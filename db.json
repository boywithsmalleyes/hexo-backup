{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/IMG_4730.JPG","path":"IMG_4730.JPG","modified":0,"renderable":0},{"_id":"source/lib/bookmark/LICENSE","path":"lib/bookmark/LICENSE","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/affix.js","path":"js/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/center-quote.js","path":"js/center-quote.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/exturl.js","path":"js/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/js.cookie.js","path":"js/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/post-details.js","path":"js/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/scroll-cookie.js","path":"js/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/scrollspy.js","path":"js/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"77a924caebd15ab533afdc7b1194aaa23ce7b1ad","modified":1611849590884},{"_id":"source/CNAME","hash":"ea1b199ca19ae7e6468fae83751b424390dd16d3","modified":1555420502071},{"_id":"themes/next/.DS_Store","hash":"53e3b3c4aab438e6821117fab26eb1ce45afa12f","modified":1611850355867},{"_id":"themes/next/.all-contributorsrc","hash":"d139a3b623b2e40bbff5c96ad44adf7dbdbc5be1","modified":1555508921344},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1555508921344},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1555508921344},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1555508921344},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1555508921344},{"_id":"themes/next/.gitignore","hash":"3558a8b174618c7a643aceb13233edd729813f9a","modified":1555508921349},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1555508921349},{"_id":"themes/next/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1555508921349},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1555508921350},{"_id":"themes/next/README.md","hash":"7958c3f70b2133b479ddaf525cc4b6d87a37e04a","modified":1555508921350},{"_id":"themes/next/_config.yml","hash":"f10f13e48b4a12b1c751109da69b87acb230e958","modified":1611997288036},{"_id":"themes/next/bower.json","hash":"8fa4f26f5205cbc64d33318d1be5d35b2667398c","modified":1555508921351},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1555508921351},{"_id":"themes/next/gulpfile.coffee","hash":"23bd9587807edc4dbecb5c5a29ab96ade24458b5","modified":1555508921358},{"_id":"themes/next/package.json","hash":"888bcacea284ec536a1428ad957a78dfb3ec255d","modified":1555508921397},{"_id":"source/IMG_4730.JPG","hash":"0226ccd67cb36f69ec5206e20e6fadefadd049fb","modified":1555422697000},{"_id":"source/_posts/.DS_Store","hash":"51b8363ba44c4e7464acc613545cfee5d10a1df2","modified":1611936875309},{"_id":"source/_posts/ASpectJ-初识.md","hash":"1d3dc014d810d1392daa6d930643b5ecb12e5666","modified":1611936177365},{"_id":"source/_posts/Android-Room.md","hash":"733b39dbb6ab906722a6529740db5afd7e49d175","modified":1611995127815},{"_id":"source/_posts/Android-Studio-Dependencies-Library-Resolve.md","hash":"15e24849b21ad4d67f5056811a0cf79508a8823a","modified":1611936215670},{"_id":"source/_posts/Jenkins-gradle-git-构建-Android-CI-构建环境.md","hash":"da49acea0c72ba34276f114d84381b9842b3577a","modified":1611936208385},{"_id":"source/_posts/Linux-下配置-Android-Studio-中文输入.md","hash":"bac8f868e3d5f1e94e6c74629f058106d1565e18","modified":1566527525000},{"_id":"source/_posts/RecyclerView.md","hash":"7ab3a86fda56c33d69f56a35554309426696ee00","modified":1611936172183},{"_id":"source/_posts/git-command.md","hash":"533ecf4766faa9855fb442c691f0f82f04696064","modified":1565623980863},{"_id":"source/_posts/多个-ssh-公钥提交代码到不同平台.md","hash":"ff5852eed5992cf0553ec571aaf2ee939bf08870","modified":1611936201222},{"_id":"source/_posts/开发一个Android-IoT-App.md","hash":"8f066cbf22cf134f0950c88992d2de5ade473809","modified":1555509259361},{"_id":"source/_posts/清香木养殖（一）.md","hash":"65ce0480d51317959b93d186761f4fa535576159","modified":1611936196497},{"_id":"source/_posts/清香木养殖（三）.md","hash":"7ed78060fbcb9ca7125eccc021e4c68df7bb5f4c","modified":1611936189154},{"_id":"source/_posts/清香木养殖（二）.md","hash":"e694ecb4cb7498b2f036bbe03ab75704de0f2bb9","modified":1611936192378},{"_id":"source/_posts/清香木养殖（四）.md","hash":"98180be90d617fc78de7e409737380ff22f8d483","modified":1582190017992},{"_id":"source/schedule/index.md","hash":"341d6005087022541cf0f3d6b36f879b59ac1bc1","modified":1556116092403},{"_id":"source/sitemap/index.md","hash":"b7ee8261c172311ffdd7d2876ad48b56db940392","modified":1556116136524},{"_id":"source/tags/index.md","hash":"e808b1592f8b5b16b41ee1a652f4aea5105522e1","modified":1556114463217},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"c149f003d03501565e7688915cd8f2e99fbf8f42","modified":1555508921345},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"285a95aca36e0ac770bcde2b35e3b572d45d1518","modified":1555508921345},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"00c25366764e6b9ccb40b877c60dc13b2916bbf7","modified":1555508921346},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"492b2c159d871e5b5d4c70d259f36e603afe192d","modified":1555508921347},{"_id":"themes/next/.github/auto_assign.yml","hash":"cb68a1dca1c4623448c2ca899614a9f21df1b036","modified":1555508921347},{"_id":"themes/next/.github/config.yml","hash":"8a5cbf5aa9529390fe0a782758aca9c3a02f9dcf","modified":1555508921347},{"_id":"themes/next/.github/eslint-disable-bot.yml","hash":"16541fb7b80f5ab90135db96285badb63c4d7d3e","modified":1555508921348},{"_id":"themes/next/.github/lock.yml","hash":"585d2c471047be320aa62f2b74dad797bf09c530","modified":1555508921348},{"_id":"themes/next/.github/mergeable.yml","hash":"8e3a6abc74b5cba57f9586fe6d98762fd4fc9b04","modified":1555508921348},{"_id":"themes/next/.github/release-drafter.yml","hash":"b4476ada5c62ee7d63ba2e59ead2ec4897086e3c","modified":1555508921348},{"_id":"themes/next/.github/stale.yml","hash":"41bf97ee86b8940a0b2e754499ec77fd2b44b717","modified":1555508921348},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1555508921348},{"_id":"themes/next/.github/topissuebot.yml","hash":"10665bf2b5aba351725715c71e94ad183a0e8f18","modified":1555508921349},{"_id":"themes/next/.github/weekly-digest.yml","hash":"404e4ccb7fcd6587bc9b0247a7a7ff256d21f2cb","modified":1555508921349},{"_id":"themes/next/docs/.DS_Store","hash":"9791ee6f9a5da1edbd11b4eda469cd83e63e6cc8","modified":1611920925177},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1555508921352},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"0d2f22ea09dd1ef63c66164e048d8239d2ccb2b8","modified":1555508921352},{"_id":"themes/next/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1555508921352},{"_id":"themes/next/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1555508921352},{"_id":"themes/next/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1555508921352},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"212a36d57495990b5f56e46ca8dce1d76c199660","modified":1555508921353},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1555508921353},{"_id":"themes/next/docs/MATH.md","hash":"e6023505dcccaef0b856102543585a13fc6af0b1","modified":1555508921353},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1555508921353},{"_id":"themes/next/languages/de.yml","hash":"9e524b2bdfb848504b93a51c5650e76bba5fa9e0","modified":1555508921358},{"_id":"themes/next/languages/default.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1555508921359},{"_id":"themes/next/languages/en.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1555508921359},{"_id":"themes/next/languages/es.yml","hash":"1752429687861b5cedd063c6ebe5dacefbe7e5a7","modified":1555508921359},{"_id":"themes/next/languages/fr.yml","hash":"7005c2b42c2c6e82bd7a1be5cc2f443b5fc79105","modified":1555508921359},{"_id":"themes/next/languages/id.yml","hash":"1c4868837f5109f1df863b04fe627352c31d404b","modified":1555508921360},{"_id":"themes/next/languages/it.yml","hash":"b30ff77ad8044e3b021a3b09187cd377dc789fd2","modified":1555508921360},{"_id":"themes/next/languages/ja.yml","hash":"1dc35e436da6214cdb3c2ff44bc4a06d0be5b9a0","modified":1555508921360},{"_id":"themes/next/languages/ko.yml","hash":"20bfaa7600d35235996c18e5c13dcef89c119626","modified":1555508921360},{"_id":"themes/next/languages/nl.yml","hash":"1c44b3cb2f817808607f3bf6ef47f58ce7599995","modified":1555508921361},{"_id":"themes/next/languages/pt-BR.yml","hash":"08b913a5cf4cc160083069cb4dfb2d66eecd1218","modified":1555508921361},{"_id":"themes/next/languages/pt.yml","hash":"8ddac820e2c17b484b56c0da8881e142b10e221b","modified":1555508921361},{"_id":"themes/next/languages/ru.yml","hash":"db0644e738d2306ac38567aa183ca3e859a3980f","modified":1555508921362},{"_id":"themes/next/languages/tr.yml","hash":"c5f0c20743b1dd52ccb256050b1397d023e6bcd9","modified":1555508921362},{"_id":"themes/next/languages/uk.yml","hash":"1eb59e581568da9a81d6e20541b4ada5fc1c55c0","modified":1555508921362},{"_id":"themes/next/languages/vi.yml","hash":"ba7aff8f88e03f69a0acf7f1b90ee03e077ee88e","modified":1555508921362},{"_id":"themes/next/languages/zh-CN.yml","hash":"fbbf3a0b664ae8e927c700b0a813692b94345156","modified":1555508921363},{"_id":"themes/next/languages/zh-HK.yml","hash":"7903b96912c605e630fb695534012501b2fad805","modified":1555508921363},{"_id":"themes/next/languages/zh-TW.yml","hash":"6e6d2cd8f4244cb1b349b94904cb4770935acefd","modified":1555508921363},{"_id":"themes/next/layout/.DS_Store","hash":"3811fc76abe906447ac6d59c9dbf9dc0a9de4719","modified":1611920925174},{"_id":"themes/next/layout/_layout.swig","hash":"74701fcf2303d59400587436ab4c244e04df7ad9","modified":1555508921365},{"_id":"themes/next/layout/archive.swig","hash":"7e8f3a41a68e912f2b2aaba905d314306ccaf794","modified":1555508921393},{"_id":"themes/next/layout/category.swig","hash":"dda0e6b2139decaf5e865d22ec9d45fdb615a703","modified":1555508921393},{"_id":"themes/next/layout/index.swig","hash":"c2a3896c64e96790edc10426ef586b6186a87f46","modified":1555508921394},{"_id":"themes/next/layout/page.swig","hash":"d8a6cbf6f611c5d68d5da430cb6dc7010ff2c7e0","modified":1555508921394},{"_id":"themes/next/layout/post.swig","hash":"f74929fd792541916eb25c2addfb35431be071ba","modified":1555508921395},{"_id":"themes/next/layout/schedule.swig","hash":"3268dd3d90d8b0e142cfa1a2ebb23355baeda148","modified":1555508921395},{"_id":"themes/next/layout/tag.swig","hash":"a6be69a90924c9d2f4d90fb4867234859bd2c2e9","modified":1555508921396},{"_id":"themes/next/scripts/.DS_Store","hash":"9ed037317a873b91db9fcee642ffe8439c873767","modified":1611920925183},{"_id":"themes/next/scripts/merge-configs.js","hash":"33afe97284d34542015d358a720823feeebef120","modified":1555508921400},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1555508921401},{"_id":"themes/next/source/.DS_Store","hash":"c6540938591164189f054dbb51eb50c98707b561","modified":1611920925172},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1555508921459},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1555508921459},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1555508921459},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1555508921437},{"_id":"source/_posts/Android 基础/.DS_Store","hash":"ad7405214f2ee22d687159ba14ece93167f3fff7","modified":1611935863728},{"_id":"source/_posts/Android 基础/Android 横竖屏的事儿.md","hash":"ac62a73985ff7e1a26d2e6b39a835369b900e593","modified":1611990295285},{"_id":"source/_posts/Android 基础/Android-中设置全屏的方法.md","hash":"655bff65b939b5f83abbe03509649e11f84e92e0","modified":1611936226744},{"_id":"source/_posts/Android 基础/Android-在一个应用中启动另外一个应用.md","hash":"25c2bee6b313225072b9d96a7d2923bc18c98ed4","modified":1611935668283},{"_id":"source/_posts/Java/.DS_Store","hash":"1299f4e251c650b4d8aca001a2f6d0c64160c37f","modified":1611935863722},{"_id":"source/_posts/Java/Java 中堆和栈的区别.md","hash":"ab31366f5d250a2f35f9671b5d2553b3427a7e95","modified":1611992576812},{"_id":"source/_posts/Java/Java 中文件 Copy 的几种方式.md","hash":"2b43d3d43fbf3b604ce16705cb57857ea88bb9a6","modified":1611992607383},{"_id":"source/_posts/Java/Java 内存管理.md","hash":"2565ce74c814a08f6c79bfb6b82cccbeb7f9f845","modified":1611992620666},{"_id":"source/_posts/Java/Java 各引用之间的区别.md","hash":"2812a848853bde2da37f59941458cf5244a5fa82","modified":1611936245903},{"_id":"source/_posts/Java/Java-判断字符串是否是数字的方法.md","hash":"03bfba51e81dc6a58b5fcd47d33ef04d06623d67","modified":1611935668308},{"_id":"source/_posts/Java/Java-异常.md","hash":"72beeb56d394a87be9b7b60c42593070aa74206d","modified":1611936236918},{"_id":"source/_posts/Java/阻塞队列.md","hash":"a2eb228dad16a212795d6dfb8b4e02d8cf18151c","modified":1611936233964},{"_id":"source/_posts/Jetpack/Android Room.md","hash":"ee523534ec2ced5a2b331128f7972c816f61549f","modified":1611936285937},{"_id":"source/_posts/Jetpack/Android架构组件.md","hash":"dbc261687f90b4e07e2e17cfeffa7ef6222facb0","modified":1611936281495},{"_id":"source/_posts/Jetpack/Data Binding.md","hash":"eeb7ce232424d7503a72c31f4b0b83971a3c8598","modified":1611936278897},{"_id":"source/_posts/Jetpack/Lifecycle 源码分析.md","hash":"c2bf74f3f3b06f86587c1045da486fd9134b1357","modified":1611936270610},{"_id":"source/_posts/Tools/Android-常用工具和插件.md","hash":"981d26f3a9b8ee2286bb4367759bfd8f1e67dac3","modified":1611936312097},{"_id":"source/_posts/Tools/Markdown 公式.md","hash":"3d2c4ced6412bd2d3738f19eae10be19db843678","modified":1611936306644},{"_id":"source/_posts/Tools/Typora 自动图床设置.md","hash":"accdf03cc641a125c9a0b8ff3440365907dee680","modified":1611936909950},{"_id":"source/_posts/Tools/adb-command.md","hash":"7c0e227ffb627044c7d8f3953ee67c1e6540e908","modified":1611936295036},{"_id":"source/_posts/Tools/git-command.md","hash":"533ecf4766faa9855fb442c691f0f82f04696064","modified":1611935668322},{"_id":"source/_posts/三方框架/Glide 源码分析.md","hash":"163a8edaa5171f7dfa9e807bbe3f66262c2c1bb7","modified":1611936128236},{"_id":"source/_posts/三方框架/OKHttp-重定向拦截器.md","hash":"7b418fa47175a74c1b2fd36f027439d9b37561be","modified":1611936319187},{"_id":"source/_posts/三方框架/OkHttp-Intercept.md","hash":"6a49c31aba69240ec0daa4cfad02a3b3edbabe81","modified":1611936315347},{"_id":"source/_posts/数据结构/数据结构.md","hash":"9ee06fcdc151f6e90b1da2580479bbce344bd47b","modified":1611995411009},{"_id":"source/_posts/数据结构/算法.md","hash":"a610fde4fcc5ef7663cf9fe7e0eebf9da96fec0a","modified":1611995062228},{"_id":"source/lib/bookmark/.eslintignore","hash":"3d3910611724b7584a29297a3f7132334a3ad091","modified":1611996550700},{"_id":"source/lib/bookmark/.eslintrc.js","hash":"76bec2314ec3477b18e357f9992cf42a9524a3f7","modified":1611996550700},{"_id":"source/lib/bookmark/.gitignore","hash":"5410a1bef9807f666cd92a0d2020f700e67e4096","modified":1611996550701},{"_id":"source/lib/bookmark/LICENSE","hash":"1440355648a72be5b7625fe6fa055b462fcc78b0","modified":1611996550702},{"_id":"source/lib/bookmark/README.md","hash":"ecfb09270cf202fb2228e9a79fa970b60be69222","modified":1611996550702},{"_id":"source/lib/bookmark/bookmark.min.js","hash":"9e525329553335c2484f6faf9e933a6bbee9ab6d","modified":1611996550702},{"_id":"source/lib/bookmark/index.js","hash":"5e5cba645a1a4531ccbb4782df2f7a075626393f","modified":1611996550703},{"_id":"source/lib/bookmark/package.json","hash":"013ff96fc03cd4ed7b17059af207e53f94953202","modified":1611996550703},{"_id":"source/lib/bookmark/renovate.json","hash":"cb29cc16e61b0b8a6dac34657d76822ae29ad5aa","modified":1611996550703},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c37a60580c901c79ccb22564b228a46e06207445","modified":1555508921346},{"_id":"themes/next/.github/ISSUE_TEMPLATE/custom-issue-template.md","hash":"57e1e06e845193e80c7df4a4454af28352526f7a","modified":1555508921346},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"07c423cce4157b8e2dbf60907ccbf3f18c4cf98a","modified":1555508921346},{"_id":"themes/next/.github/ISSUE_TEMPLATE/non-english.md","hash":"0b0727ff4d5180ae67f930fb4f8e9488e33eda9f","modified":1555508921347},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1555508921354},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1555508921354},{"_id":"themes/next/docs/ru/README.md","hash":"4d7ef717d0b57288e606996ee56c20ffd59d5a99","modified":1555508921354},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1555508921354},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"caa624092175d44e3d3a8c6ca23922718da2354c","modified":1555508921355},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"b218e30df4126b6adc87684775ac4c86ea7f7958","modified":1555508921355},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"bc43beb3af74d64fbd3920539d08861e4cadb9a0","modified":1555508921355},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1555508921356},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1555508921356},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"115ffbde2b3ce01ef1f8c2b3833e6f6794650132","modified":1555508921356},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b76ccbc658024e86639cfa5f8a3817647fc8d651","modified":1555508921357},{"_id":"themes/next/docs/zh-CN/README.md","hash":"1b5bd6ae5781137d81dc8667e912d3df6eeab260","modified":1555508921357},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"5da70d7fa0c988a66a469b9795d33d471a4a4433","modified":1555508921357},{"_id":"themes/next/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1555508921364},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1555508921364},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1555508921364},{"_id":"themes/next/layout/_macro/passage-end-tag.swig","hash":"d9105e5249b22d8a94a15c84468ae16ec3e63c56","modified":1611989422248},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"89b0a0e64637bf5b0cfea0a23642df3d95eedfa4","modified":1555508921366},{"_id":"themes/next/layout/_macro/post.swig","hash":"7753d97cd0a4f1d010692beb87b6d0f87fde3959","modified":1611990226903},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"480d93619479dcfcbec6906803bb38b2dfbeae53","modified":1555508921367},{"_id":"themes/next/layout/_partials/.DS_Store","hash":"214faa98217af8bfd1fe54b441fb03731e7ad6ba","modified":1611920925185},{"_id":"themes/next/layout/_partials/comments.swig","hash":"5352f96f4544c1520babf1cec7b44ddf2f8057b3","modified":1555508921367},{"_id":"themes/next/layout/_partials/footer.swig","hash":"589f545333e21a8c7823bce89ab45cf1eb7db6e2","modified":1555508921368},{"_id":"themes/next/layout/_partials/github-banner.swig","hash":"6357537ac0bb114aed4d61bafb39e6690a413697","modified":1555508921368},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1555508921371},{"_id":"themes/next/layout/_partials/post-edit.swig","hash":"06dac109504812b63766a80ede9ddacbd42d227d","modified":1555508921372},{"_id":"themes/next/layout/_scripts/.DS_Store","hash":"9ad92f50bd2c37d8527a4feb6d699b81ef067e58","modified":1611920925170},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"50be1762f60222379a8bef5e42ab1a0f3872b7ff","modified":1555508921375},{"_id":"themes/next/layout/_scripts/exturl.swig","hash":"61ae10d41f67ece004a025077fdb28724af05090","modified":1555508921375},{"_id":"themes/next/layout/_scripts/next-boot.swig","hash":"012e3ece672cc3b13d5e032139f328d3426d7d65","modified":1555508921376},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"edaff4766e0c05fd5c889d9dd32884d376bef9d9","modified":1555508921376},{"_id":"themes/next/layout/_scripts/scroll-cookie.swig","hash":"ccd13d73429ef91ef5e8b7d9fa43c8188facdf41","modified":1555508921378},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"83470eb401f78f4683907c48ad6760b90730daa3","modified":1555508921378},{"_id":"themes/next/layout/_third-party/.DS_Store","hash":"ffee2720f9fb4c89ad72edf150dbafc9f423953e","modified":1611920925168},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"4ccf2abbfd070874265b0436a3eff21f7c998dfb","modified":1555508921383},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"10b61a8bac671e375916a4d234c120117098a78f","modified":1555508921383},{"_id":"themes/next/layout/_third-party/chatra.swig","hash":"eefb68b69b4b0ed558ee0324ccd711990059b20d","modified":1555508921383},{"_id":"themes/next/layout/_third-party/copy-code.swig","hash":"01ded5e1bad89a6f8d64cd063e3e4e42c20d33bc","modified":1555508921386},{"_id":"themes/next/layout/_third-party/mermaid.swig","hash":"d6e6ddda836bd9e2e8d9767a910c7d3280080e81","modified":1555508921387},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"2c4a66be4677d3e4dec3f169ac8a769098dad1fe","modified":1555508921387},{"_id":"themes/next/layout/_third-party/pangu.swig","hash":"c28f9dc96ab735daeb7f599f86470aa5a83c03cf","modified":1555508921388},{"_id":"themes/next/layout/_third-party/pdf.swig","hash":"810a9b2a6059f46c4a2ddb178f1eaa4c5e23750b","modified":1555508921388},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"5db80e8d7ea3f29e998320f79508f7e14342a33c","modified":1555508921388},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"cbe40cb67dad15ade967b0f396c1a95b6871f76a","modified":1555508921389},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"2398e5cd0cb466953b6e7a42c2b2caddebf3c348","modified":1555508921389},{"_id":"themes/next/layout/_third-party/tidio.swig","hash":"912368c41de675f458b267a49a99ae3e7e420ebb","modified":1555508921392},{"_id":"themes/next/scripts/filters/exturl.js","hash":"79ad823ca803cb00e0bfc648aa6c9d59711e0519","modified":1555508921398},{"_id":"themes/next/scripts/helpers/engine.js","hash":"60eb1554456d9d0e5afc4a2d16f1580a0aa02da8","modified":1555508921399},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"799a042bbf497a4c7a2981aa2014ff28fa1bb382","modified":1555508921399},{"_id":"themes/next/scripts/tags/button.js","hash":"f3b4f7ae7e58072bbf410d950a99a0b53cbc866d","modified":1555508921401},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1555508921402},{"_id":"themes/next/scripts/tags/exturl.js","hash":"d605918cf819887e9555212dbe12da97fd887a0b","modified":1555508921402},{"_id":"themes/next/scripts/tags/full-image.js","hash":"fcb41c1c81560ed49dc4024654388a28ee7d32b0","modified":1555508921402},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"598220fa92ff3540dcab74f633ba41523daa8364","modified":1555508921402},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"5db59d56f4f4082382bf1c16722e6c383892b0c5","modified":1555508921403},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1555508921403},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1555508921403},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1555508921403},{"_id":"themes/next/scripts/tags/pdf.js","hash":"f780cc72bff91d2720626e7af69eed25e9c12a29","modified":1555508921404},{"_id":"themes/next/scripts/tags/tabs.js","hash":"00ca6340d4fe0ccdae7525373e4729117775bbfa","modified":1555508921404},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1555508921404},{"_id":"themes/next/source/css/.DS_Store","hash":"6ebb2dd7b88565263cc4d4308d53b5616ab0bbf0","modified":1611920925186},{"_id":"themes/next/source/css/main.styl","hash":"e010ec8ac73268a0f137204c89e0080ab8d59b3d","modified":1555508921437},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1555508921438},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1555508921438},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1555508921438},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1555508921438},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1555508921439},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1555508921439},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1555508921439},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1555508921440},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1555508921440},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1555508921440},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1555508921441},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1555508921441},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1555508921441},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1555508921441},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1555508921442},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1555508921442},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1555508921442},{"_id":"themes/next/source/images/searchicon.png","hash":"025d64ba0160a3a2257dd2b3032b5f7c9dd9b82b","modified":1555508921442},{"_id":"themes/next/source/js/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1555518021687},{"_id":"themes/next/source/js/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1555508921443},{"_id":"themes/next/source/js/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1555508921443},{"_id":"themes/next/source/js/center-quote.js","hash":"e4bc6f92b18fc410cfa2df6e7368055449fc75cf","modified":1555517797502},{"_id":"themes/next/source/js/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1555508921443},{"_id":"themes/next/source/js/js.cookie.js","hash":"e0afce539f1fb81d59e3c6f0a68d736e2fb45d93","modified":1555508921444},{"_id":"themes/next/source/js/motion.js","hash":"a16bc0b701646bf6653484675f4d5dc0f892d184","modified":1555508921444},{"_id":"themes/next/source/js/next-boot.js","hash":"e0615efab5f81ba0fd39c0527eac31144deac7ce","modified":1555508921444},{"_id":"themes/next/source/js/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1555508921445},{"_id":"themes/next/source/js/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1555508921446},{"_id":"themes/next/source/js/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1555508921446},{"_id":"themes/next/source/js/utils.js","hash":"3c987de7cfb944c33e9e527f1214724c7aafc796","modified":1555508921446},{"_id":"themes/next/source/lib/.DS_Store","hash":"482f73a6478997fbcfb4ebd7f1c2fe99adb75711","modified":1611920925188},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1555508921427},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1555508921428},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1555508921428},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1555508921436},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1555508921437},{"_id":"source/_posts/Android 基础/View/Android WebView.md","hash":"2b6b914a8059d8d2120311b6e791d057506329b3","modified":1611935668284},{"_id":"source/_posts/Android 基础/View/Android 自定义 View.md","hash":"b706d0d76040443e20878413657a072abf33c395","modified":1611937081765},{"_id":"source/_posts/Android 基础/View/RecyclerView 总结.md","hash":"2e429ced244963356a4b79ae3b0b21e9eb8fae4c","modified":1611937074159},{"_id":"source/_posts/Android 基础/View/自定义 ViewGroup.md","hash":"f08cce6fa5f81d290e7923cacae822dd759e9b5c","modified":1611937069560},{"_id":"source/_posts/Android 基础/原理/Handler 消息机制.md","hash":"2592cd3ce1fb31a4d16fc16d01fe687184adf833","modified":1611935668303},{"_id":"source/_posts/Android 基础/原理/Handler 线程通信基础流程.md","hash":"0cd6be963c45a7de3bd4abdca0c8cf9906929828","modified":1611935668303},{"_id":"source/_posts/Android 基础/适配/Android 屏幕适配.md","hash":"bcfe44a948bbe095f6dee4ec09d4ed26e161aae7","modified":1611935668304},{"_id":"source/_posts/Android 基础/适配/Android 版本适配.md","hash":"a59aeacd9d6bf55d6cca48ac7236415d9e202be1","modified":1611935668305},{"_id":"source/_posts/Android 基础/适配/Android-Q-文件权限适配.md","hash":"bdc61e4bf3a3e588dc8dfd44a2ed7305f2e75d43","modified":1611935668305},{"_id":"source/_posts/Java/基础知识/Java 枚举.md","hash":"7b42b4d214ba0c08c2087bce2fd64539fe5f1dbb","modified":1611937011163},{"_id":"source/_posts/Java/基础知识/Java-反射.md","hash":"ec4b8dbe3302e094405c94f1f60f0e0da2f3ab6e","modified":1611937017117},{"_id":"source/_posts/Java/基础知识/Java-泛型.md","hash":"790b940b300c95e3394dcd6f6d35ced8c8ac3a1e","modified":1611937019570},{"_id":"source/_posts/Java/基础知识/Java-注解.md","hash":"b95a56ebbe8acec526f8506cfc931d28bfab48bf","modified":1611937021851},{"_id":"source/_posts/Java/基础知识/Object 类.md","hash":"ee72e04f18a90c11efdf3b15c8c65b0445000bab","modified":1611937024099},{"_id":"source/_posts/Java/设计模式/代理模式‘.md","hash":"75694babcc86621763d6c2b52ed3a4190541e573","modified":1611937004804},{"_id":"source/_posts/Kotlin/协程/协程-入门.md","hash":"1bd385b9e9e30a2e61511d47de1f41b5c70f81cb","modified":1611936978533},{"_id":"source/_posts/Kotlin/协程/协程-取消.md","hash":"768223534dbca08760d795d2ac570173fce32a3a","modified":1611936973323},{"_id":"source/_posts/Kotlin/协程/协程-启动.md","hash":"a3498093f2761da1098d8e31a34fe6e4ecdc8a58","modified":1611936969837},{"_id":"source/_posts/Kotlin/协程/协程-异常处理.md","hash":"664ea19b99d3b8caf47e0300624d9e3b89ccb121","modified":1611936967965},{"_id":"source/_posts/Kotlin/协程/协程-挂起.md","hash":"b08a8d9383e766c2d45683ae2e883423121f6ce8","modified":1611936965224},{"_id":"source/_posts/Kotlin/协程/协程-调度器.md","hash":"82a87fd713c9d0b91710c6ee276ae4546a6be04e","modified":1611936962061},{"_id":"source/_posts/Kotlin/协程/协程.md","hash":"d0e158e069170647e7e29ae33d61ea3a1ea6f888","modified":1611936957661},{"_id":"source/_posts/Kotlin/协程/协程知识点.md","hash":"7dbd17d3fa98c385832998a1e5e22fabbf012389","modified":1611936936741},{"_id":"source/lib/bookmark/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1611996550686},{"_id":"source/lib/bookmark/.git/config","hash":"4341f663713109d9556a1123759988f6a5d696c3","modified":1611996550690},{"_id":"source/lib/bookmark/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1611996545757},{"_id":"source/lib/bookmark/.git/index","hash":"f17473af666d8f130dd8844bfd0f972075fe30f5","modified":1611996550704},{"_id":"source/lib/bookmark/.git/packed-refs","hash":"9fab9e3bb3b0936efcc88d126fa44cba250c3d8c","modified":1611996550675},{"_id":"source/lib/bookmark/.github/stale.yml","hash":"fd0856f6745db8bd0228079ccb92a662830cc4fb","modified":1611996550701},{"_id":"themes/next/layout/_macro/menu/menu-badge.swig","hash":"65c5e585982dae7ae1542cada71858b4ea1f73d6","modified":1555508921365},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"fb33f499022cd02722f834fcef1a0e193362cfde","modified":1555508921365},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"fc6bafc8c633afadc538c5afa5620ea2a1cdcb84","modified":1555508921368},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"02bb5748e8540b024e7f4008a9e640890b45280f","modified":1555508921369},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"36eae78a4d7160a1c5e59ca3f7333f00b43d359b","modified":1555508921369},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"648bf7eda66629592cb915c4004534b3913cbc22","modified":1555508921369},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"2082f5077551123e695e8afec471c9c44b436acb","modified":1555508921370},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"71af31fea5913fd30c233e555ef13cf2c9768f72","modified":1555508921370},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"5adc60100e129c1d0307bdcaa0c7b8e8375a6ea4","modified":1555508921370},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"2940df694fff28e8bf71b6546b4162f1e38227db","modified":1555508921371},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"0fa4fadb39467b01cede49f21b22e86b1a2da805","modified":1555508921371},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"3615db591dd910fb9fa96542734c7ec0ef05019c","modified":1555508921372},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"eea95b785c9c36d28e1839619793f66e89773bee","modified":1555508921372},{"_id":"themes/next/layout/_partials/post/reward.swig","hash":"d44f025eb93c99ddf90202d8293ccf80689a00c7","modified":1555508921372},{"_id":"themes/next/layout/_partials/post/wechat-subscriber.swig","hash":"ef11b5be5bfb2f0affe82cf521c002b37fef9819","modified":1555508921372},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1555508921373},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"7d1693416a5dc098f4723a53da2e2d1fc2d6e075","modified":1555508921373},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1555508921373},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a5587bd1f60d35e58618576cec45e662aa44ea1f","modified":1555508921374},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"15b542f5b06b7532234af367340b9ed9fcebb0ac","modified":1555508921374},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"6f181cc188ecbe5e607fd989756e470d4cb9765d","modified":1555508921374},{"_id":"themes/next/layout/_partials/share/likely.swig","hash":"b45e934d24d76ec6b6a790e92bdb3d56186b0e2a","modified":1555508921375},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"5b05f165547391bf231e52f56f3d925efc09bc44","modified":1555508921376},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"ffc8e8836714ea79abeb77b75859634615652877","modified":1555508921376},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"108b157fbd1ac3baaf19ae87234fa8728ab79556","modified":1555508921377},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"0097e45e7b671f8006b8b2d3c4f95cacc76a983c","modified":1555508921377},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"e42604fbb17648484e5f12afe230d826de089388","modified":1555508921377},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"a5723950c343d220270bfd27bd30050eda6c3fb3","modified":1555508921378},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"798d67e4a736613ab899eabe6529091bbcda7850","modified":1555508921379},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"591b2ccd9713ccb922b9fcf5e278b6de9c5ec30b","modified":1555508921379},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"8eadb929c9e50e58502ccad2dc2657746f8c592a","modified":1555508921379},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"08cd47ef8572121b7811342d3c9a84a338a18191","modified":1555508921380},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"050ea01f25cfe492be9bb77b409644d623fdf2dc","modified":1555508921380},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"fae69a0e1a1d42f7bb44e594a29857d94594698b","modified":1555508921380},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"d422beaf35a5d2646feaa098bc3e5adf691c7565","modified":1555508921380},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"4a966b7ffe2d80ff1b3dd0fd14b355766dc5c70f","modified":1555508921381},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"438c6f5e6665d72f4ea7ee206011d669246f6102","modified":1555508921381},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"c754f699c90f6278b9159eff1855c17bc713ee96","modified":1555508921382},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"f240a50cd9b627620d9a374a29cf95f0c5e99d7c","modified":1555508921382},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"92e04a2b9e0c3df594bc22235d1894e5ad458dfc","modified":1555508921382},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"0dd5b315d1da55dbfc10f51a1f8952f72eba2720","modified":1555508921382},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"3533167c4295637b91d90f3bae7c651cd128bb6e","modified":1555508921383},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"3cfeafefc672d9a7704650ebfb2f9d8668b38d9a","modified":1555508921384},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"c77a2e7ef5f449a445fb4d36b055721fba4a81af","modified":1555508921384},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"e8f91c571ceb4b80aafebc4d36b89fb41b1ae040","modified":1555508921384},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"388efc86af7f19c05ad0e26720cd24ee012d20b9","modified":1555508921385},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"2cbaae65a020bbb0e9265364488aff8bf84fa48d","modified":1555508921385},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"5856d5f701e51dfae1fd6fb486cefde67effd555","modified":1555508921385},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"4a908b613518878b9b69576c5dba4a5185f552ab","modified":1555508921386},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"a7e304b05a44279d3e4f611908d7faef9dc14d7c","modified":1555508921386},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"c2cb2f384bc30d31cdccf9794a729c03e687b45c","modified":1555508921387},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"601774d8672577aefbcefac82c94b01f0338da31","modified":1555508921387},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"0a13dfd2de52a96901039098c6fc7b515edfc50b","modified":1555508921390},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"ea94aa85034c6d1b6bb865aecea55c73f8a14501","modified":1555508921391},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"b3eaab6a269aa3fcbafe24fd06f0c9206dc12716","modified":1555508921391},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1555508921427},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1555508921427},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"2e8fb29aa92325df39054b5450757858c6cebc41","modified":1555508921428},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"2036bbb73afd43251982ce824f06c6e88d35a2ef","modified":1555508921428},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"a8aa41625b94cf17a7f473ed10dcbe683b1db705","modified":1555508921436},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1555508921436},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"fc15e277d1504532a09b7b1bd31f900ad95ec4b8","modified":1555508921436},{"_id":"themes/next/source/css/_variables/base.styl","hash":"640f25a63770af5566ccc9cec79c40a4f1c0b29e","modified":1555508921437},{"_id":"themes/next/source/js/schemes/muse.js","hash":"e9bfa6b343b67625f58757efce46ccdaac8f308c","modified":1555508921445},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"9eb63cba0327d3d11b6cbfcbe40b88e97a8378a3","modified":1555508921445},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1555508921447},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1555508921447},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1555508921447},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1555508921447},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1555508921448},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1555508921458},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1555508921458},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1555508921459},{"_id":"source/lib/bookmark/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1611996545758},{"_id":"source/lib/bookmark/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1611996545757},{"_id":"source/lib/bookmark/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1611996545760},{"_id":"source/lib/bookmark/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1611996545760},{"_id":"source/lib/bookmark/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1611996545758},{"_id":"source/lib/bookmark/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1611996545761},{"_id":"source/lib/bookmark/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1611996545758},{"_id":"source/lib/bookmark/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1611996545759},{"_id":"source/lib/bookmark/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1611996545760},{"_id":"source/lib/bookmark/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1611996545761},{"_id":"source/lib/bookmark/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1611996545756},{"_id":"source/lib/bookmark/.git/logs/HEAD","hash":"6f73a58f060f379d72393de6174c4d67d09fccad","modified":1611996550687},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"fe5ff961b86004a306778c7d33a85b32e5e00e48","modified":1555508921405},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"c8b3225396cb444d8baeb94bac78e5216b992a81","modified":1555508921405},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"b98c65006e2546fbf3870c16fbbcbc009dbaab15","modified":1555508921405},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1555508921406},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"9d71f34fa13a41b8c8cd2fbdf3fdea608385277c","modified":1555508921406},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"ce826aedf42b9eca424a044452f5d193866726a6","modified":1555508921411},{"_id":"themes/next/source/css/_common/components/rainbow.styl","hash":"ce2aae8f3ed8ceac3a2417e0481044cf69c788aa","modified":1555508921416},{"_id":"themes/next/source/css/_common/components/scrollbar.styl","hash":"d7b8bcf2a6031296c84bb4f4ecfb037af01d2d82","modified":1555508921417},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"7e51ea64611ab5d678c112b4688d4db4fd2737e2","modified":1555508921425},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"6d900b4159eeb869196a619602578bf4d83a117b","modified":1555508921425},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"8e0740a9ad349ce5555122325da872923135a698","modified":1555508921426},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"a5305a2fa0b03b1dc1dfd156bb1a590b4819f1f3","modified":1555508921426},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"7ffde343bdf10add1f052f3c4308a15180eb4404","modified":1555508921426},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1555508921426},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"33456264a74d1bba38264d14713544d67d003733","modified":1555508921427},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"9a2d298dbdcbfd758518fd74b63897bc80ce15a5","modified":1555508921429},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1555508921429},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"24230e46fc9fb7b8551f97bb36e9bc1f7423098e","modified":1555508921430},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1555508921430},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"75d2d92af070eb10273558b2436972d3f12b361c","modified":1555508921430},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fa33213aceed7bf4bf25437ca9c1a00f7734ae65","modified":1555508921430},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"7359880e8d85312861fe0871f58b662e627dae0c","modified":1555508921431},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a96e46a6ae86c423f932bc2bc78b9f7453e4e4e5","modified":1555508921431},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6565b4a309325596768d0d32e022c80ef23066cb","modified":1555508921432},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"fc160583f742c94316a0fee05c18468033173534","modified":1555508921432},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"1edf4e69d0ec0dc9cefed6c35d3e803e0da4093d","modified":1555508921433},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"7359880e8d85312861fe0871f58b662e627dae0c","modified":1555508921433},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1555508921433},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"57044a6d19eb418c1c3d28787e82c69efa9e0ca6","modified":1555508921434},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"75737591682a2bafa71db4c03fb79e970ac0e7aa","modified":1555508921434},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"b6dac5bbf20f090cf4b67d156f030d7170dfb39c","modified":1555508921435},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"6400c98a9fd2b9a8502269f33355bd7ab3ff793b","modified":1555508921435},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b5b936dddb7b4de4720cd1e8428b30a2f06d63fb","modified":1555508921435},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"232aedbd44243b3b80c4503c947060d3269c1afc","modified":1555508921435},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1555508921448},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1555508921449},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1555508921449},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1555508921455},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1555508921454},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1555508921457},{"_id":"source/_posts/Android 基础/View/Android 动画.xmind","hash":"03fde07cb9466c4ce13ea430df1db35c69dfb1be","modified":1611935668287},{"_id":"source/lib/bookmark/.git/objects/02/b27223487ca819cf7167dc23626af595112e25","hash":"e5bbb1906aa9a8e2696817d19d85aeedf82539ed","modified":1611996550636},{"_id":"source/lib/bookmark/.git/objects/07/4d4d38a37d506f5db482b5c27ad1143bba5aab","hash":"ee76158694b6490056328594b5d15a54faba253e","modified":1611996550619},{"_id":"source/lib/bookmark/.git/objects/0a/9e6b66e9d710a68e08fcc295fca440eabcb4bc","hash":"aa0b269640b41735ba54a9279f10ddd19ecd5887","modified":1611996549540},{"_id":"source/lib/bookmark/.git/objects/0c/dada082d621dbfdd00f7020c33dc751129167f","hash":"b490c11cdefde6b331a7d4ddb055e34ad08459d8","modified":1611996549545},{"_id":"source/lib/bookmark/.git/objects/0d/61683ea74054da2645effdd51d0a3282d6a9ff","hash":"879563c866dbe7efa0074a1ebcd206723e552f27","modified":1611996549536},{"_id":"source/lib/bookmark/.git/objects/16/75d42fcbd2aded2e9b42efe38c347ced893495","hash":"979ec745cfdc8dd979785b78c9be7645bb73d922","modified":1611996550602},{"_id":"source/lib/bookmark/.git/objects/17/ad1e81c2805cc9c5c00846c8bf9bf16524b55a","hash":"8f779f28267873af1e5c71386603042dbaff6211","modified":1611996550617},{"_id":"source/lib/bookmark/.git/objects/18/77388dd9427b36d7c8703038a215b79f1218c2","hash":"8d48c7c0d7427116dbeb32552c576cc4edbe2d38","modified":1611996550640},{"_id":"source/lib/bookmark/.git/objects/1b/db4ff581f77318e6c4783d8e1ce811c37f13bf","hash":"06b3da6e152ffd68ed4617db1c4e3912f41d8bec","modified":1611996549537},{"_id":"source/lib/bookmark/.git/objects/25/b729e9ad0151b51f50297ea35280111b953236","hash":"af4bf7f3feb175c6980ee81a84f679149f713987","modified":1611996550616},{"_id":"source/lib/bookmark/.git/objects/25/42ea91169dbe9da086918ad02160e42310e185","hash":"3c942c82f3ef7fcd9a15276c82fcf59fa141521c","modified":1611996550645},{"_id":"source/lib/bookmark/.git/objects/2b/358da01f778126b38fc4ddf5ecafa625cad38b","hash":"d4613d86e15d9679b8f1f18950b71a182af4b5c8","modified":1611996549535},{"_id":"source/lib/bookmark/.git/objects/2b/d59834388b6377fd14413f2614f550e35e35f1","hash":"654763c707c65aa3f353f8a9edb0cc0ae4bcccfa","modified":1611996549543},{"_id":"source/lib/bookmark/.git/objects/2f/425e03cfa918b2d638bbd37279a8b1e7757508","hash":"283713eda90efb64849519db267b652facfdbd63","modified":1611996550608},{"_id":"source/lib/bookmark/.git/objects/2f/9eba51ec174b1e0c719d12cafa7c3c07140471","hash":"fc994d9d8b3b21ec7c941eea7e3862970e297e9b","modified":1611996550592},{"_id":"source/lib/bookmark/.git/objects/36/6ee3e25fa36be8ea88ed1c7913a8de8fd3b820","hash":"81c45f061381dd947da576758992b64b6101fbc8","modified":1611996550600},{"_id":"source/lib/bookmark/.git/objects/3f/30e2e442e4fdc1e91d5d1b642662e3900e5d6f","hash":"358397c32831b80fa4828334de7080bdaafe1c52","modified":1611996550639},{"_id":"source/lib/bookmark/.git/objects/41/bde8ccd130442ef0b3f8b24764a6d72635a485","hash":"4a833bb669ac126a00dec7153f8c263eab47b024","modified":1611996550649},{"_id":"source/lib/bookmark/.git/objects/40/b878db5b1c97fc77049537a71bb2e249abe5dc","hash":"929471c4b27858bbdae034381982f996144f6b3d","modified":1611996550594},{"_id":"source/lib/bookmark/.git/objects/41/fcb40408cfe2e9e0d1796ce1384024f7ba2c1c","hash":"600f3ee28c5dc2f1b21f8d9043d271b9601750b1","modified":1611996549179},{"_id":"source/lib/bookmark/.git/objects/47/1dd1f3ddf970ee3418f801ae787bf98191d47e","hash":"8634518aeeffc4b8b0dbe6ca6159480264cf1916","modified":1611996549184},{"_id":"source/lib/bookmark/.git/objects/42/c32aba927940c9e92b9928dceee88eacbf4874","hash":"2c7b6bb078f2eb52eead906df3ed4fa136a1e651","modified":1611996549530},{"_id":"source/lib/bookmark/.git/objects/48/7e5a296eebd45809199d2f557e340603931bad","hash":"6cf9f9b5ae990bbb0083b37b0c29b269cd8cc735","modified":1611996550630},{"_id":"source/lib/bookmark/.git/objects/4a/16717bb5a449fab2291e6397c30c6cb34814f1","hash":"5e244da7b9b6dfc9ad924ee5259805d4ae272c2e","modified":1611996550613},{"_id":"source/lib/bookmark/.git/objects/4a/6e0d94cae4e01312054983b4e2e4007e3fd3b8","hash":"9eff6f1c82336ebdab0503e0ab0f753cd18f01ff","modified":1611996549542},{"_id":"source/lib/bookmark/.git/objects/4a/7e8d64b8956ffd9339000e62d490f18dcd3ecd","hash":"3cc8fd65b3663a750887093f67bb28696492d5e5","modified":1611996550646},{"_id":"source/lib/bookmark/.git/objects/4e/7ec652ef197de221d6576a717edf0b583a688a","hash":"e45f3b02a04d04eb3bcd6373ae79d86cbbd62798","modified":1611996550628},{"_id":"source/lib/bookmark/.git/objects/55/31419f7d03a523182be5373e246e43acdf60d7","hash":"274085edc584079218a79c199bd0c7360a700290","modified":1611996549533},{"_id":"source/lib/bookmark/.git/objects/58/b257bc636adc71871da51e615e6734c9479f3a","hash":"4e63de59c359c9bf480b47aa5e342ed78663fb58","modified":1611996550644},{"_id":"source/lib/bookmark/.git/objects/29/de98ce86c01618ebbe3352e213db74feda0dc0","hash":"046bf7ab442c095f0150c96fe06d83855c92092f","modified":1611996550605},{"_id":"source/lib/bookmark/.git/objects/5c/02525c8b55f89f0ec0304cd0d266453bdf0541","hash":"51cab03e6cbebdb421eea45818b1ff7d9ec7783f","modified":1611996550618},{"_id":"source/lib/bookmark/.git/objects/5c/ffa97fb277e628a550bc1d8f7fa7c5c776129f","hash":"8c4e4a79d14522f34280ef85c794df6f4886e040","modified":1611996550603},{"_id":"source/lib/bookmark/.git/objects/11/8348fe672067e7d9c32c73d586023804eeb565","hash":"2b73c34eb535ff7e7d91cefb5215feddd9f2c36f","modified":1611996550612},{"_id":"source/lib/bookmark/.git/objects/5e/038b5098480c14a29cefd944e3eb23109473b2","hash":"9c3aba7ff1afc70708a90e2f4f610499ee268d4a","modified":1611996550648},{"_id":"source/lib/bookmark/.git/objects/5f/1541db4b58002e45b9b5fe19426551a8239a49","hash":"9a50dcb663e39892adbfccab943fb8dc37add2d0","modified":1611996550631},{"_id":"source/lib/bookmark/.git/objects/60/438c0c99eece781f9c7b2779ab7673ab34ba62","hash":"76032e20bf2916b03d9f795982831868f42a03af","modified":1611996550601},{"_id":"source/lib/bookmark/.git/objects/61/4795cc61f429929887fde3962027254db90a62","hash":"c4e415dda2e421df728dda51f953cc2f01296378","modified":1611996550642},{"_id":"source/lib/bookmark/.git/objects/62/150c9d8f54ca62e1af3c9d666bb5e35eb3bdbd","hash":"2998eaea45a0135e879da15851a535ae2940d85e","modified":1611996549534},{"_id":"source/lib/bookmark/.git/objects/69/d5670af93cd1d3f0acc082583b1d150c5d61b5","hash":"e6c6fdb25f5fc4949594e217ae14d309b2fba4a1","modified":1611996549185},{"_id":"source/lib/bookmark/.git/objects/6d/1188177a8798893f9efe275d4d75d0f9301be9","hash":"b8652b3249ef6662a8dee7c01e5667f7e4f33cc4","modified":1611996549538},{"_id":"source/lib/bookmark/.git/objects/74/dba5056028cc4bac4f79ffec7da1e076260ffd","hash":"cd7bbf512f3c0291badb58f0679485c18a98c034","modified":1611996550611},{"_id":"source/lib/bookmark/.git/objects/75/4a45e75b8a6dc256755287312c729adc2fc6c9","hash":"e700708d93a902401e54d96d4d632ae4225cdf2c","modified":1611996550621},{"_id":"source/lib/bookmark/.git/objects/77/d7bbc93f0a411d2e50b7c67a2827dece42727f","hash":"6865e0eb54a9882e55e70669a44cdddb2da1665e","modified":1611996549539},{"_id":"source/lib/bookmark/.git/objects/79/c8a354ccacb4edc27acbcc503f26acf6119624","hash":"7a44189d1189ad7aedea595fc8a4ef387de7041d","modified":1611996550599},{"_id":"source/lib/bookmark/.git/objects/7e/58471cd13382a6bafd05015cd0a5b5a8e899eb","hash":"21ae04d7ac48092d7b07b7278bf099cfc2691e57","modified":1611996550606},{"_id":"source/lib/bookmark/.git/objects/84/08abfa6c03a2809cb160da5badc6d1050bfbb3","hash":"9d3f29a89223403d1a0292681a330cbf7616c190","modified":1611996549183},{"_id":"source/lib/bookmark/.git/objects/85/839f2b88dfaef92ae7c84c10f446e98d07b852","hash":"9662dba024cf43e039d41f4253e7aa282e2141ba","modified":1611996549181},{"_id":"source/lib/bookmark/.git/objects/8a/7f4f27cc671188881ca5cd80d941720a78be04","hash":"de24124a9660dad2ee4e1d25a3580ac87d42b3e0","modified":1611996550614},{"_id":"source/lib/bookmark/.git/objects/8d/ae3702857a081653c16320999ed63f3c6fb719","hash":"cc5ed8d3d17451c722a3ebfa3251fff27d348218","modified":1611996550632},{"_id":"source/lib/bookmark/.git/objects/8e/b07c89ff54bda39a40d6448a6a8ef4df57c8f2","hash":"fadb84b2a2c5dee0b8f67dd53b4e2b8a5b270e92","modified":1611996550597},{"_id":"source/lib/bookmark/.git/objects/92/f5900e81d1cf9e90787b7138f4285434e45c10","hash":"05c5b8557d69133fd01ebd1b85a5e009a822ca20","modified":1611996550617},{"_id":"source/lib/bookmark/.git/objects/96/353334c808a19403f7d2f0e880668bf8f0e320","hash":"dbcb9efdc52a50d5f0431394c24b35ff47f1833d","modified":1611996549190},{"_id":"source/lib/bookmark/.git/objects/97/b44840ca6d92e3e650428f433b75a501b1427c","hash":"a899d561a89c4ab798063c1df81d78015992ad15","modified":1611996549192},{"_id":"source/lib/bookmark/.git/objects/9d/a80d05852c1c5aec3e8d31b63d429bcfecc0c5","hash":"392385eddea633b0bea1194c2c66db593c6a9c0a","modified":1611996549544},{"_id":"source/lib/bookmark/.git/objects/a9/21fc59cd52b57fc3093fbdc04b446bae0a2f8a","hash":"a2e879b7fdb0cf153f8526064a6b8810b2cd8988","modified":1611996550620},{"_id":"source/lib/bookmark/.git/objects/aa/d78f9de11c827340e4695cbc1f5a73f53ee577","hash":"0f5086a5818caf093dcf60126a7d0f72bc73928b","modified":1611996550625},{"_id":"source/lib/bookmark/.git/objects/ad/b3297e18bb4d11be9f7305db144e5015f40738","hash":"b44f4417307f3dbb33d30c22700dbfb61c87f198","modified":1611996550628},{"_id":"source/lib/bookmark/.git/objects/b5/c8b8aa1a6dba7c8152b49ef103a0952f1bb9ca","hash":"d070cad9094ddcf44be0e16b3872f1fb4f05ae0d","modified":1611996549193},{"_id":"source/lib/bookmark/.git/objects/b8/e5e058b339881ced4b4b5c4d89f337ccfb67de","hash":"0d229cce5fbe7e41e4961070dd2e4d76c7b3efb6","modified":1611996549543},{"_id":"source/lib/bookmark/.git/objects/bc/0570da6c07cf361d794008e58455455a2580be","hash":"822af280dbbe78499a932faf9229f4c467d48cbe","modified":1611996550622},{"_id":"source/lib/bookmark/.git/objects/bf/05dfc0c17af4b48e94676e1e2feaba911d8c71","hash":"4d8adbebcb8ffb4bc3c61b9c97bd225f128b8e74","modified":1611996549538},{"_id":"source/lib/bookmark/.git/objects/bf/c91bf59adb7231937b98d35cb952b4bab01fff","hash":"016dc36835bb17ba3f54eebaef4d57f5498015da","modified":1611996549531},{"_id":"source/lib/bookmark/.git/objects/c1/7940ffb480f454472c9083efabce723ff53cd4","hash":"29bbded01d4399f509abd809c00957f182226432","modified":1611996550609},{"_id":"source/lib/bookmark/.git/objects/c3/75bd4420a3baa49b9a5d52f8040400491ac933","hash":"beb87437d1591c6bec51a6e85176f576092a83f2","modified":1611996550638},{"_id":"source/lib/bookmark/.git/objects/c7/631242bf4ea5781b2d173d999b41c69fdd8ace","hash":"f2d3b9fb648bed7f61dc917d9ad45550c4c70e77","modified":1611996550651},{"_id":"source/lib/bookmark/.git/objects/c6/26688a33395276a262158e171027a61c56150c","hash":"3727c122ab41e9dd1abc6490a40eb28f212c5c8e","modified":1611996549186},{"_id":"source/lib/bookmark/.git/objects/ca/799c34c37f63bd64ed9b49413e7fc6db8ab2ef","hash":"4e6ee2dffc199b5954fb34b129fe2f012099463d","modified":1611996549541},{"_id":"source/lib/bookmark/.git/objects/cd/ea049768c3f2d2b89792c19a523584590292c5","hash":"5e69fbae98becc6ed3be947a2450511294252891","modified":1611996550626},{"_id":"source/lib/bookmark/.git/objects/ce/70a57b7d6bcddae01e3434d416c27c84b24727","hash":"d8ccbf99469b51ae629347665f96354c264457b4","modified":1611996550615},{"_id":"source/lib/bookmark/.git/objects/d2/45f9acfffc2e168c17bcc4e115527f21a77521","hash":"76d31ac0c9ca563b5854fe5b6c5ab46ebb202680","modified":1611996550631},{"_id":"source/lib/bookmark/.git/objects/d4/d4c40411de7936e90c6ebbc19e182ad225cb4c","hash":"f8d44f87905d5dfbeb1fdf5519a5256d27d00120","modified":1611996550641},{"_id":"source/lib/bookmark/.git/objects/d3/a06b992cfe7d26e022b14abf5ba563e6e63c4a","hash":"6820962ea4a4da9e9de834c97c1630477c30ef20","modified":1611996550595},{"_id":"source/lib/bookmark/.git/objects/d6/31561b3edf93b81d38f81278d6574c77006e39","hash":"afaad8a2c6944b11695122cf45cedadbc3bd7605","modified":1611996550627},{"_id":"source/lib/bookmark/.git/objects/db/3b3566df6e7d89575c4150067f61087be1bedb","hash":"118afda770f93908ad97d6ad0bb6a42b21aab9cf","modified":1611996549189},{"_id":"source/lib/bookmark/.git/objects/de/52a356f671fa73a9d9910c26968d47100c655f","hash":"5bd5f521df149c8e24640151b6d83b3c6be1fd30","modified":1611996549187},{"_id":"source/lib/bookmark/.git/objects/e7/aba3f8ec35017b4dd2bc8f5ca94253a8674ce7","hash":"8fe85003f71bf38e6ae367366ae6e95a819d046d","modified":1611996549182},{"_id":"source/lib/bookmark/.git/objects/df/af7173f5d152681fb2bc7adfdebb54ad195281","hash":"7fc27717b2f7da8f6a6e40ac8d88c75485a505fa","modified":1611996550596},{"_id":"source/lib/bookmark/.git/objects/ef/090e162cd7cc22d2da95d77acac1d7a1eb9c43","hash":"a6997644fb850bedaeeb01adfc90fc404cf80074","modified":1611996550598},{"_id":"source/lib/bookmark/.git/objects/f4/5d8f110c3034162a1091dafe4b03d2e56b323e","hash":"963dad8248030a8d7b185f4726e40a65a0583c0e","modified":1611996550610},{"_id":"source/lib/bookmark/.git/objects/f6/c892849ea799eb017a3d5bf05edb602780cd38","hash":"3b568af69c7a3dc7439155fe36b64a65e8b0bb79","modified":1611996549191},{"_id":"source/lib/bookmark/.git/objects/f7/bc8429b09417e69629d9fa0c2874dd5adc30d2","hash":"d8b3844ae942e165b59b6a57c5decdeb35582539","modified":1611996550629},{"_id":"source/lib/bookmark/.git/objects/f8/efc68c4efb88e2ff0660752cfe028e78a2f7b8","hash":"4c3753e97e390be8668cb07fececcfd02be084f9","modified":1611996549177},{"_id":"source/lib/bookmark/.git/objects/fb/0a1d42d6507805651dec61ecc4df11f37dc1a6","hash":"fcef8ee1a40833b2cf5ecae90bfa22002f46b29a","modified":1611996550635},{"_id":"source/lib/bookmark/.git/objects/fc/63af0044284a5b08f20cf1444a062176d835fe","hash":"9994dd502452c757856b88aa0d1be86540dd7a82","modified":1611996550634},{"_id":"source/lib/bookmark/.git/refs/heads/master","hash":"0ff01610d23a5f9b86dfe1138ddf331d9cd008d1","modified":1611996550687},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"4cfeec9434a72d5efc6ca225d3445d084d4590f7","modified":1555508921406},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"ca97f0b6990eef947039faede80c56d9c4381ee1","modified":1555508921407},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"6c4990d375b640ee4551e62c48c1cbe4c3d62212","modified":1555508921407},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1555508921407},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"a410ed529afd46ddf4a96ecf0de6599488716887","modified":1555508921407},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"c0d9e18a9210fdcaf33e488518b3b288eb58c0a1","modified":1555508921408},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"cc6ee18f47f2e1e06df6fa0eadb37079e580fd11","modified":1555508921408},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"71d8d1cc22a2a7627a6db7240f0c4902a14f9bea","modified":1555508921408},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"e9dd8de7d98f1478ac7d351624fffd3d8738c905","modified":1555508921409},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1555508921409},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"6904fd7ea6455e008d9884558b68254608af9a3c","modified":1555508921409},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"2d142c6f39853916256ad8fc79eb6b85f4001ae8","modified":1555508921410},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1555508921410},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f1d52954b9a5d1ca8e224382349f525e598dd923","modified":1555508921410},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1555508921410},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"80addb9b725e329915c05c27b9fadaf56457a9b3","modified":1555508921411},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"61ca40856e5cacd48e0fa9728fde4605c7dd4c94","modified":1555508921411},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1555508921412},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"6a75bb1f2435f4e895cbbb5abbddf6e8f7257804","modified":1555508921412},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"2356226157e8068b0e9bbe2f7d0f74e1ab49199b","modified":1555508921413},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"c961d37190d9bec58a36306c7e716c4e72c4582f","modified":1555508921413},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"1385862a5c0bd845015d165aadbd1a6add7b72d7","modified":1555508921413},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"0bf899fab331add63f0c8ead31ca3a3db2ad74d9","modified":1555508921413},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"b082d07b13a3d55b4c032fd351dfa9a4fd74edec","modified":1555508921414},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"496f931e3a7e313ba8088fb91bb20789cace72c9","modified":1555508921414},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"5440013a081201ca791582db98159dce93ea9e75","modified":1555508921415},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"3f33bb862c2aa993f54987fbb345da067b79b112","modified":1555508921414},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1555508921415},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1555508921415},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"8e058c99dd7d41f0bd34c7c28b6ac9fbb17dcb5e","modified":1555508921415},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"d5c8ffed7f2c701052b7a53abaf5ef437374ea72","modified":1555508921416},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"a6c24393dffbdd94dd5c01cdbec5e180b0bfbbbd","modified":1555508921416},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a3170630d8e085889a4bdc20eb7f09c5a0479c47","modified":1555508921416},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"707527c9950a7459355c8abcf4751c0964de0bc1","modified":1555508921417},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"9224b566cd2632f64c1a964e2c786cee93b93286","modified":1555508921417},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"cc83816614f21c7e1d8d3f867d547ff7c658cec4","modified":1555508921417},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-button.styl","hash":"517d541a80d59ad99a3f648be74891e0c7bc72a8","modified":1555508921418},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"c2d9c3b6fbfa65544e6b5a55d3cb2149df04a8a9","modified":1555508921418},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"9a3bfc878ca797946815bed23cd6f92b24a16358","modified":1555508921418},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"8a24b56524a388fbabd408ffc8ba9b56eb9e01ce","modified":1555508921419},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"c01609176929590f8f347075a9a12b661acd661e","modified":1555508921419},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"8e5c884fb950937afa350c608545455c87aa6129","modified":1555508921419},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"967fb3a3c6c851b34ec5df2d945dc266ed63d146","modified":1555508921419},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"58ec00eebe68d0eebd2eea435c710063877447df","modified":1555508921420},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1555508921420},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"6ec8ea7b11a146777b6b8da0f71f0cc1dbd129df","modified":1555508921420},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"d7501ae01fc45fa15b00d1bc5233b9fffa20a3c9","modified":1555508921421},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"21b32840d8b3a14b10770153114778304ba6d1b0","modified":1555508921421},{"_id":"themes/next/source/css/_common/components/tags/pdf.styl","hash":"da8d34729fb6eb0fcb8ee81e67d2be3c02bc1bc4","modified":1555508921421},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"fcda60fecff1479adaf6521cf629cda2506337a8","modified":1555508921421},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"cbc0be5a3285b469858ec9ead48e2ea90bd47ae1","modified":1555508921422},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fc58498d4f5081fcf6218e9e18c5bf2328275bef","modified":1555508921422},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"ac7753d536341aa824d7bce0332735e838916995","modified":1555508921423},{"_id":"themes/next/source/css/_common/components/third-party/copy-code.styl","hash":"688ca3eccc26727d050ad098b32b40934719588a","modified":1555508921422},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"f1d9ee1f86a179741f2478f8c70ca11ab578810e","modified":1555508921423},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"7059e24235b7c57a07f3f8abaa06b0bd6a7eda2f","modified":1555508921423},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"ef66c0a08e4243a25e41408d70ca66682b8dcea1","modified":1555508921424},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"9fac89c8146eb2675721a26f528d7d0f8be7debe","modified":1555508921423},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"61466e3e5459960b5802a267751a0c8018918b0b","modified":1555508921424},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"3ae3f3c276d444862033fd3434c632ad0d2f84e6","modified":1555508921424},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"03c4fa9573fddd930552784cf484fd2ee7825323","modified":1555508921424},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1555508921431},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1555508921432},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1555508921433},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1555508921453},{"_id":"source/lib/bookmark/.git/logs/refs/heads/master","hash":"6f73a58f060f379d72393de6174c4d67d09fccad","modified":1611996550688},{"_id":"source/lib/bookmark/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1611996550686},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1555508921452},{"_id":"source/lib/bookmark/.git/logs/refs/remotes/origin/HEAD","hash":"6f73a58f060f379d72393de6174c4d67d09fccad","modified":1611996550685}],"Category":[{"name":"Jetpack","_id":"ckkjhb87h0006sz5qsto9wm7d"},{"name":"Java","_id":"ckkjhb8et001hsz5qbpeddo4x"},{"name":"基础知识","_id":"ckkjhb8fw002msz5qz7me836l"}],"Data":[],"Page":[{"title":"Schedule","date":"2019-04-24T14:28:12.000Z","_content":"","source":"schedule/index.md","raw":"---\ntitle: schedule\ndate: 2019-04-24 22:28:12\n---\n","updated":"2019-04-24T14:28:12.403Z","path":"schedule/index.html","comments":1,"layout":"page","_id":"ckkjhb8750001sz5qvnjd2fi2","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Sitemap","date":"2019-04-24T14:28:56.000Z","_content":"","source":"sitemap/index.md","raw":"---\ntitle: sitemap\ndate: 2019-04-24 22:28:56\n---\n","updated":"2019-04-24T14:28:56.524Z","path":"sitemap/index.html","comments":1,"layout":"page","_id":"ckkjhb8790003sz5q30mnwf0y","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Tags","type":"tags","date":"2019-04-24T14:00:26.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ntype: tags\ndate: 2019-04-24 22:00:26\n---\n","updated":"2019-04-24T14:01:03.217Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckkjhb87e0005sz5qevsnxdga","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"<h1 align=\"center\">Bookmark for <a href=\"https://github.com/theme-next\">NexT</a></h1>\n\n<h2 align=\"center\">Introduce</h2>\n\nBookmark is a plugin that allow the users save their reading position.\n\nThe users could just click the bookmark icon (like 🔖) in left-top of the page to save the position.\n\nAnd when they visit your blog in the next time, they can continue the last reading position by clicking the bookmark icon from the home page.\n\n<h1 align=\"center\">Installation</h1>\n\n<h2>If you want to use the CDN instead of clone this repo, please jump to the Step 3.</h2>\n\n<h2 align=\"center\">Step 1 &rarr; Go to NexT dir</h2>\n\nChange dir to **NexT** directory. There must be `layout`, `source`, `languages` and other directories:\n\n```sh\n$ cd themes/next\n$ ls\nbower.json  _config.yml  docs  gulpfile.coffee  languages  layout  LICENSE.md  package.json  README.md  scripts  source  test\n```\n\n<h2 align=\"center\">Step 2 &rarr; Get module</h2>\n\nInstall module to `source/lib` directory:\n\n```sh\n$ git clone https://github.com/theme-next/theme-next-bookmark.git source/lib/bookmark\n```\n\n<h2 align=\"center\">Step 3 &rarr; Set it up</h2>\n\nEnable module in **NexT** `_config.yml` file:\n\n```yml\nbookmark: true\n```\n\n**And, if you wants to use the CDN, then need to set:**\n\n```yml\nvendors:\n  ...\n  bookmark: https://cdn.jsdelivr.net/gh/theme-next/theme-next-bookmark@latest/bookmark.min.js\n```\n\n<h1 align=\"center\">Update</h1>\n\n```sh\n$ cd themes/next/source/lib/bookmark\n$ git pull\n```\n","source":"lib/bookmark/README.md","raw":"<h1 align=\"center\">Bookmark for <a href=\"https://github.com/theme-next\">NexT</a></h1>\n\n<h2 align=\"center\">Introduce</h2>\n\nBookmark is a plugin that allow the users save their reading position.\n\nThe users could just click the bookmark icon (like 🔖) in left-top of the page to save the position.\n\nAnd when they visit your blog in the next time, they can continue the last reading position by clicking the bookmark icon from the home page.\n\n<h1 align=\"center\">Installation</h1>\n\n<h2>If you want to use the CDN instead of clone this repo, please jump to the Step 3.</h2>\n\n<h2 align=\"center\">Step 1 &rarr; Go to NexT dir</h2>\n\nChange dir to **NexT** directory. There must be `layout`, `source`, `languages` and other directories:\n\n```sh\n$ cd themes/next\n$ ls\nbower.json  _config.yml  docs  gulpfile.coffee  languages  layout  LICENSE.md  package.json  README.md  scripts  source  test\n```\n\n<h2 align=\"center\">Step 2 &rarr; Get module</h2>\n\nInstall module to `source/lib` directory:\n\n```sh\n$ git clone https://github.com/theme-next/theme-next-bookmark.git source/lib/bookmark\n```\n\n<h2 align=\"center\">Step 3 &rarr; Set it up</h2>\n\nEnable module in **NexT** `_config.yml` file:\n\n```yml\nbookmark: true\n```\n\n**And, if you wants to use the CDN, then need to set:**\n\n```yml\nvendors:\n  ...\n  bookmark: https://cdn.jsdelivr.net/gh/theme-next/theme-next-bookmark@latest/bookmark.min.js\n```\n\n<h1 align=\"center\">Update</h1>\n\n```sh\n$ cd themes/next/source/lib/bookmark\n$ git pull\n```\n","date":"2021-01-30T08:49:10.702Z","updated":"2021-01-30T08:49:10.702Z","path":"lib/bookmark/README.html","title":"","comments":1,"layout":"page","_id":"ckkjhb8e70011sz5qulyi8i5s","content":"<h1 align=\"center\">Bookmark for <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQ=\" title=\"https://github.com/theme-next\">NexT<i class=\"fa fa-external-link\"></i></span></h1>\n\n<h2 align=\"center\">Introduce</h2>\n\n<p>Bookmark is a plugin that allow the users save their reading position.</p>\n<p>The users could just click the bookmark icon (like 🔖) in left-top of the page to save the position.</p>\n<p>And when they visit your blog in the next time, they can continue the last reading position by clicking the bookmark icon from the home page.</p>\n<h1 align=\"center\">Installation</h1>\n\n<h2>If you want to use the CDN instead of clone this repo, please jump to the Step 3.</h2>\n\n<h2 align=\"center\">Step 1 &rarr; Go to NexT dir</h2>\n\n<p>Change dir to <strong>NexT</strong> directory. There must be <code>layout</code>, <code>source</code>, <code>languages</code> and other directories:</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">$ cd themes/next\n$ ls\nbower.json  _config.yml  docs  gulpfile.coffee  languages  layout  LICENSE.md  package.json  README.md  scripts  source  test\n</code></pre>\n<h2 align=\"center\">Step 2 &rarr; Get module</h2>\n\n<p>Install module to <code>source/lib</code> directory:</p>\n<pre class=\" language-sh\"><code class=\"language-sh\">$ git clone https://github.com/theme-next/theme-next-bookmark.git source/lib/bookmark\n</code></pre>\n<h2 align=\"center\">Step 3 &rarr; Set it up</h2>\n\n<p>Enable module in <strong>NexT</strong> <code>_config.yml</code> file:</p>\n<pre class=\" language-yml\"><code class=\"language-yml\">bookmark: true\n</code></pre>\n<p><strong>And, if you wants to use the CDN, then need to set:</strong></p>\n<pre class=\" language-yml\"><code class=\"language-yml\">vendors:\n  ...\n  bookmark: https://cdn.jsdelivr.net/gh/theme-next/theme-next-bookmark@latest/bookmark.min.js\n</code></pre>\n<h1 align=\"center\">Update</h1>\n\n<pre class=\" language-sh\"><code class=\"language-sh\">$ cd themes/next/source/lib/bookmark\n$ git pull\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 align=\"center\">Bookmark for <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQ=\" title=\"https://github.com/theme-next\">NexT<i class=\"fa fa-external-link\"></i></span></h1>\n\n<h2 align=\"center\">Introduce</h2>\n\n<p>Bookmark is a plugin that allow the users save their reading position.</p>\n<p>The users could just click the bookmark icon (like 🔖) in left-top of the page to save the position.</p>\n<p>And when they visit your blog in the next time, they can continue the last reading position by clicking the bookmark icon from the home page.</p>\n<h1 align=\"center\">Installation</h1>\n\n<h2>If you want to use the CDN instead of clone this repo, please jump to the Step 3.</h2>\n\n<h2 align=\"center\">Step 1 &rarr; Go to NexT dir</h2>\n\n<p>Change dir to <strong>NexT</strong> directory. There must be <code>layout</code>, <code>source</code>, <code>languages</code> and other directories:</p>\n<pre><code class=\"sh\">$ cd themes/next\n$ ls\nbower.json  _config.yml  docs  gulpfile.coffee  languages  layout  LICENSE.md  package.json  README.md  scripts  source  test\n</code></pre>\n<h2 align=\"center\">Step 2 &rarr; Get module</h2>\n\n<p>Install module to <code>source/lib</code> directory:</p>\n<pre><code class=\"sh\">$ git clone https://github.com/theme-next/theme-next-bookmark.git source/lib/bookmark\n</code></pre>\n<h2 align=\"center\">Step 3 &rarr; Set it up</h2>\n\n<p>Enable module in <strong>NexT</strong> <code>_config.yml</code> file:</p>\n<pre><code class=\"yml\">bookmark: true\n</code></pre>\n<p><strong>And, if you wants to use the CDN, then need to set:</strong></p>\n<pre><code class=\"yml\">vendors:\n  ...\n  bookmark: https://cdn.jsdelivr.net/gh/theme-next/theme-next-bookmark@latest/bookmark.min.js\n</code></pre>\n<h1 align=\"center\">Update</h1>\n\n<pre><code class=\"sh\">$ cd themes/next/source/lib/bookmark\n$ git pull\n</code></pre>\n"},{"_content":"!function(o){\"use strict\";var n=o.localStorage;null==n&&(n={getItem:function(){return null},setItem:function(){},removeItem:function(){},clear:function(){}});var t,e=function(){var o=n.getItem(\"bookmark\");if(null==o)return null;try{return JSON.parse(o)}catch(o){return null}},a=function(){var n=o.document.createElement(\"style\");n.type=\"text/css\";var e=\".book-mark-link{border-bottom:none;display:block;position:fixed;color:#222;font-size:26px !important;top:-10px;left:20px;transition:.3s;}.book-mark-link:hover,.book-mark-link-fixed{top:-2px}@media(max-width:1090px){.book-mark-link{display:none}}\";e=o.document.createTextNode(e),n.appendChild(e),o.document.head.appendChild(n),t=$('<a class=\"book-mark-link book-mark-link-fixed fa fa-bookmark\" href=\"#\"></a>'),$(o.document.body).append(t);var a=0;$(o).on(\"scroll.bookmark\",function(){var n=o.document.documentElement.scrollTop;n>0?0===a&&(t.removeClass(\"book-mark-link-fixed\"),a=n):a>0&&(!t.hasClass(\"book-mark-link-fixed\")&&t.addClass(\"book-mark-link-fixed\"),a=0)})},r=function(e,a){null==a&&(a={});var r=o.document.documentElement.scrollTop;return a.lastUri=e,a[e]=r,n.setItem(\"bookmark\",JSON.stringify(a)),t.animate({top:-26},\"fast\",function(){setTimeout(function(){t.css(\"top\",\"\")},400)}),a};o.bookmark={loadBookmark:function(){var o=e();null!=o&&$(function(){a(),t.attr(\"href\",o.lastUri+\"#book:mark\")})},scrollToMark:function(n,l){var i=o.location.pathname,c=e();$(function(){var e;a(),t.click(function(){return c=r(i,c),!1}),\"auto\"===n&&o.addEventListener(\"beforeunload\",function(){r(i,c)}),null!=c&&([l,\"#comments\"].filter(function(n){return n===o.location.hash}).length>0||(e=c[i],isNaN(e)||$(function(){$(o.document.documentElement).animate({scrollTop:e},\"fast\")})))})}}}(window);","source":"lib/bookmark/bookmark.min.js","raw":"!function(o){\"use strict\";var n=o.localStorage;null==n&&(n={getItem:function(){return null},setItem:function(){},removeItem:function(){},clear:function(){}});var t,e=function(){var o=n.getItem(\"bookmark\");if(null==o)return null;try{return JSON.parse(o)}catch(o){return null}},a=function(){var n=o.document.createElement(\"style\");n.type=\"text/css\";var e=\".book-mark-link{border-bottom:none;display:block;position:fixed;color:#222;font-size:26px !important;top:-10px;left:20px;transition:.3s;}.book-mark-link:hover,.book-mark-link-fixed{top:-2px}@media(max-width:1090px){.book-mark-link{display:none}}\";e=o.document.createTextNode(e),n.appendChild(e),o.document.head.appendChild(n),t=$('<a class=\"book-mark-link book-mark-link-fixed fa fa-bookmark\" href=\"#\"></a>'),$(o.document.body).append(t);var a=0;$(o).on(\"scroll.bookmark\",function(){var n=o.document.documentElement.scrollTop;n>0?0===a&&(t.removeClass(\"book-mark-link-fixed\"),a=n):a>0&&(!t.hasClass(\"book-mark-link-fixed\")&&t.addClass(\"book-mark-link-fixed\"),a=0)})},r=function(e,a){null==a&&(a={});var r=o.document.documentElement.scrollTop;return a.lastUri=e,a[e]=r,n.setItem(\"bookmark\",JSON.stringify(a)),t.animate({top:-26},\"fast\",function(){setTimeout(function(){t.css(\"top\",\"\")},400)}),a};o.bookmark={loadBookmark:function(){var o=e();null!=o&&$(function(){a(),t.attr(\"href\",o.lastUri+\"#book:mark\")})},scrollToMark:function(n,l){var i=o.location.pathname,c=e();$(function(){var e;a(),t.click(function(){return c=r(i,c),!1}),\"auto\"===n&&o.addEventListener(\"beforeunload\",function(){r(i,c)}),null!=c&&([l,\"#comments\"].filter(function(n){return n===o.location.hash}).length>0||(e=c[i],isNaN(e)||$(function(){$(o.document.documentElement).animate({scrollTop:e},\"fast\")})))})}}}(window);","date":"2021-01-30T08:49:10.702Z","updated":"2021-01-30T08:49:10.702Z","path":"lib/bookmark/bookmark.min.js","layout":"false","title":"","comments":1,"_id":"ckkjhb8e90013sz5qf7du6s55","content":"!function(o){\"use strict\";var n=o.localStorage;null==n&&(n={getItem:function(){return null},setItem:function(){},removeItem:function(){},clear:function(){}});var t,e=function(){var o=n.getItem(\"bookmark\");if(null==o)return null;try{return JSON.parse(o)}catch(o){return null}},a=function(){var n=o.document.createElement(\"style\");n.type=\"text/css\";var e=\".book-mark-link{border-bottom:none;display:block;position:fixed;color:#222;font-size:26px !important;top:-10px;left:20px;transition:.3s;}.book-mark-link:hover,.book-mark-link-fixed{top:-2px}@media(max-width:1090px){.book-mark-link{display:none}}\";e=o.document.createTextNode(e),n.appendChild(e),o.document.head.appendChild(n),t=$('<a class=\"book-mark-link book-mark-link-fixed fa fa-bookmark\" href=\"#\"></a>'),$(o.document.body).append(t);var a=0;$(o).on(\"scroll.bookmark\",function(){var n=o.document.documentElement.scrollTop;n>0?0===a&&(t.removeClass(\"book-mark-link-fixed\"),a=n):a>0&&(!t.hasClass(\"book-mark-link-fixed\")&&t.addClass(\"book-mark-link-fixed\"),a=0)})},r=function(e,a){null==a&&(a={});var r=o.document.documentElement.scrollTop;return a.lastUri=e,a[e]=r,n.setItem(\"bookmark\",JSON.stringify(a)),t.animate({top:-26},\"fast\",function(){setTimeout(function(){t.css(\"top\",\"\")},400)}),a};o.bookmark={loadBookmark:function(){var o=e();null!=o&&$(function(){a(),t.attr(\"href\",o.lastUri+\"#book:mark\")})},scrollToMark:function(n,l){var i=o.location.pathname,c=e();$(function(){var e;a(),t.click(function(){return c=r(i,c),!1}),\"auto\"===n&&o.addEventListener(\"beforeunload\",function(){r(i,c)}),null!=c&&([l,\"#comments\"].filter(function(n){return n===o.location.hash}).length>0||(e=c[i],isNaN(e)||$(function(){$(o.document.documentElement).animate({scrollTop:e},\"fast\")})))})}}}(window);","site":{"data":{}},"excerpt":"","more":"!function(o){\"use strict\";var n=o.localStorage;null==n&&(n={getItem:function(){return null},setItem:function(){},removeItem:function(){},clear:function(){}});var t,e=function(){var o=n.getItem(\"bookmark\");if(null==o)return null;try{return JSON.parse(o)}catch(o){return null}},a=function(){var n=o.document.createElement(\"style\");n.type=\"text/css\";var e=\".book-mark-link{border-bottom:none;display:block;position:fixed;color:#222;font-size:26px !important;top:-10px;left:20px;transition:.3s;}.book-mark-link:hover,.book-mark-link-fixed{top:-2px}@media(max-width:1090px){.book-mark-link{display:none}}\";e=o.document.createTextNode(e),n.appendChild(e),o.document.head.appendChild(n),t=$('<a class=\"book-mark-link book-mark-link-fixed fa fa-bookmark\" href=\"#\"></a>'),$(o.document.body).append(t);var a=0;$(o).on(\"scroll.bookmark\",function(){var n=o.document.documentElement.scrollTop;n>0?0===a&&(t.removeClass(\"book-mark-link-fixed\"),a=n):a>0&&(!t.hasClass(\"book-mark-link-fixed\")&&t.addClass(\"book-mark-link-fixed\"),a=0)})},r=function(e,a){null==a&&(a={});var r=o.document.documentElement.scrollTop;return a.lastUri=e,a[e]=r,n.setItem(\"bookmark\",JSON.stringify(a)),t.animate({top:-26},\"fast\",function(){setTimeout(function(){t.css(\"top\",\"\")},400)}),a};o.bookmark={loadBookmark:function(){var o=e();null!=o&&$(function(){a(),t.attr(\"href\",o.lastUri+\"#book:mark\")})},scrollToMark:function(n,l){var i=o.location.pathname,c=e();$(function(){var e;a(),t.click(function(){return c=r(i,c),!1}),\"auto\"===n&&o.addEventListener(\"beforeunload\",function(){r(i,c)}),null!=c&&([l,\"#comments\"].filter(function(n){return n===o.location.hash}).length>0||(e=c[i],isNaN(e)||$(function(){$(o.document.documentElement).animate({scrollTop:e},\"fast\")})))})}}}(window);"},{"_content":"(function (global) {\n  'use strict';\n\n  var storage = global.localStorage;\n  if (storage == null) {\n    // if the localStorage is not exists\n    storage = {\n      // eslint-disable-next-line\n      getItem: function () { return null },\n      setItem: function () { },\n      removeItem: function () { },\n      clear: function () { },\n    };\n  }\n\n  // get the saved bookmark object\n  var getBookmark = function () {\n    var mark = storage.getItem('bookmark');\n    if (mark == null) {\n      return null;\n    }\n    try {\n      return JSON.parse(mark);\n    } catch (e) {\n      // invalid object saved in the storage\n      // console.warn('Invalid bookmark object.');\n      return null;\n    }\n  };\n\n  var link;\n  // register everything\n  var init = function () {\n    // bookmark-link style\n    var style = global.document.createElement('style');\n    style.type = 'text/css';\n    var text = '.book-mark-link{'\n      + 'border-bottom:none;'\n      + 'display:block;'\n      + 'position:fixed;'\n      + 'color:#222;'\n      + 'font-size:26px !important;'\n      + 'top:-10px;left:20px;'\n      + 'transition:.3s;'\n      + '}'\n      + '.book-mark-link:hover,.book-mark-link-fixed{top:-2px}'\n      // do not show when the width is not enough\n      + '@media(max-width:1090px){.book-mark-link{display:none}}';\n    text = global.document.createTextNode(text);\n    style.appendChild(text);\n    global.document.head.appendChild(style);\n\n    // create a link element\n    // eslint-disable-next-line max-len\n    link = $('<a class=\"book-mark-link book-mark-link-fixed fa fa-bookmark\" href=\"#\"></a>');\n    $(global.document.body).append(link);\n\n    var currentTop = 0;\n    // scroll event\n    $(global).on('scroll.bookmark', function () {\n      var top = global.document.documentElement.scrollTop;\n      if (top > 0) {\n        if (currentTop === 0) {\n          link.removeClass('book-mark-link-fixed');\n          currentTop = top;\n        }\n      } else {\n        if (currentTop > 0) {\n          !link.hasClass('book-mark-link-fixed') &&\n            link.addClass('book-mark-link-fixed');\n          currentTop = 0;\n        }\n      }\n    });\n  };\n\n  var loadBookmark = function () {\n    var mark = getBookmark();\n    if (mark == null) {\n      return;\n    }\n    // found the bookmark\n    $(function () {\n      init();\n      link.attr('href', mark.lastUri + '#book:mark');\n    });\n  };\n\n  var doScroll = function (top) {\n    if (!isNaN(top)) {\n      $(function () {\n        // eslint-disable-next-line max-len\n        $(global.document.documentElement).animate({ 'scrollTop': top }, 'fast');\n      });\n    }\n  };\n\n  var doSaveScroll = function (path, mark) {\n    if (mark == null) {\n      mark = {};\n    }\n    var top = global.document.documentElement.scrollTop;\n    mark.lastUri = path;\n    mark[path] = top;\n    storage.setItem('bookmark', JSON.stringify(mark));\n    link.animate({ top: -26 }, 'fast', function () {\n      setTimeout(function () {\n        link.css('top', '');\n      }, 400);\n    });\n    return mark;\n  };\n\n  var scrollToMark = function (trigger, hash) {\n    var path = global.location.pathname;\n    var mark = getBookmark();\n    $(function () {\n      init();\n      // save the position by clicking the icon\n      link.click(function () {\n        mark = doSaveScroll(path, mark);\n        return false;\n      });\n\n      // register beforeunload event when the trigger is auto\n      if (trigger === 'auto') {\n        // register beforeunload event\n        global.addEventListener('beforeunload', function () {\n          doSaveScroll(path, mark);\n        });\n      }\n      // auto scroll to the position\n      if (mark == null) {\n        return;\n      }\n      // and if the page opens with a specific hash, just jump out\n      var skips = [hash, '#comments'];\n      // eslint-disable-next-line\n      if (skips.filter(function (h) { return h === global.location.hash }).length > 0) {\n        return;\n      }\n      doScroll(mark[path]);\n    });\n  };\n\n  global.bookmark = {\n    loadBookmark: loadBookmark,\n    scrollToMark: scrollToMark,\n  };\n})(window);\n","source":"lib/bookmark/index.js","raw":"(function (global) {\n  'use strict';\n\n  var storage = global.localStorage;\n  if (storage == null) {\n    // if the localStorage is not exists\n    storage = {\n      // eslint-disable-next-line\n      getItem: function () { return null },\n      setItem: function () { },\n      removeItem: function () { },\n      clear: function () { },\n    };\n  }\n\n  // get the saved bookmark object\n  var getBookmark = function () {\n    var mark = storage.getItem('bookmark');\n    if (mark == null) {\n      return null;\n    }\n    try {\n      return JSON.parse(mark);\n    } catch (e) {\n      // invalid object saved in the storage\n      // console.warn('Invalid bookmark object.');\n      return null;\n    }\n  };\n\n  var link;\n  // register everything\n  var init = function () {\n    // bookmark-link style\n    var style = global.document.createElement('style');\n    style.type = 'text/css';\n    var text = '.book-mark-link{'\n      + 'border-bottom:none;'\n      + 'display:block;'\n      + 'position:fixed;'\n      + 'color:#222;'\n      + 'font-size:26px !important;'\n      + 'top:-10px;left:20px;'\n      + 'transition:.3s;'\n      + '}'\n      + '.book-mark-link:hover,.book-mark-link-fixed{top:-2px}'\n      // do not show when the width is not enough\n      + '@media(max-width:1090px){.book-mark-link{display:none}}';\n    text = global.document.createTextNode(text);\n    style.appendChild(text);\n    global.document.head.appendChild(style);\n\n    // create a link element\n    // eslint-disable-next-line max-len\n    link = $('<a class=\"book-mark-link book-mark-link-fixed fa fa-bookmark\" href=\"#\"></a>');\n    $(global.document.body).append(link);\n\n    var currentTop = 0;\n    // scroll event\n    $(global).on('scroll.bookmark', function () {\n      var top = global.document.documentElement.scrollTop;\n      if (top > 0) {\n        if (currentTop === 0) {\n          link.removeClass('book-mark-link-fixed');\n          currentTop = top;\n        }\n      } else {\n        if (currentTop > 0) {\n          !link.hasClass('book-mark-link-fixed') &&\n            link.addClass('book-mark-link-fixed');\n          currentTop = 0;\n        }\n      }\n    });\n  };\n\n  var loadBookmark = function () {\n    var mark = getBookmark();\n    if (mark == null) {\n      return;\n    }\n    // found the bookmark\n    $(function () {\n      init();\n      link.attr('href', mark.lastUri + '#book:mark');\n    });\n  };\n\n  var doScroll = function (top) {\n    if (!isNaN(top)) {\n      $(function () {\n        // eslint-disable-next-line max-len\n        $(global.document.documentElement).animate({ 'scrollTop': top }, 'fast');\n      });\n    }\n  };\n\n  var doSaveScroll = function (path, mark) {\n    if (mark == null) {\n      mark = {};\n    }\n    var top = global.document.documentElement.scrollTop;\n    mark.lastUri = path;\n    mark[path] = top;\n    storage.setItem('bookmark', JSON.stringify(mark));\n    link.animate({ top: -26 }, 'fast', function () {\n      setTimeout(function () {\n        link.css('top', '');\n      }, 400);\n    });\n    return mark;\n  };\n\n  var scrollToMark = function (trigger, hash) {\n    var path = global.location.pathname;\n    var mark = getBookmark();\n    $(function () {\n      init();\n      // save the position by clicking the icon\n      link.click(function () {\n        mark = doSaveScroll(path, mark);\n        return false;\n      });\n\n      // register beforeunload event when the trigger is auto\n      if (trigger === 'auto') {\n        // register beforeunload event\n        global.addEventListener('beforeunload', function () {\n          doSaveScroll(path, mark);\n        });\n      }\n      // auto scroll to the position\n      if (mark == null) {\n        return;\n      }\n      // and if the page opens with a specific hash, just jump out\n      var skips = [hash, '#comments'];\n      // eslint-disable-next-line\n      if (skips.filter(function (h) { return h === global.location.hash }).length > 0) {\n        return;\n      }\n      doScroll(mark[path]);\n    });\n  };\n\n  global.bookmark = {\n    loadBookmark: loadBookmark,\n    scrollToMark: scrollToMark,\n  };\n})(window);\n","date":"2021-01-30T08:49:10.703Z","updated":"2021-01-30T08:49:10.703Z","path":"lib/bookmark/index.js","layout":"false","title":"","comments":1,"_id":"ckkjhb8ek0016sz5q0cnb1366","content":"(function (global) {\n  'use strict';\n\n  var storage = global.localStorage;\n  if (storage == null) {\n    // if the localStorage is not exists\n    storage = {\n      // eslint-disable-next-line\n      getItem: function () { return null },\n      setItem: function () { },\n      removeItem: function () { },\n      clear: function () { },\n    };\n  }\n\n  // get the saved bookmark object\n  var getBookmark = function () {\n    var mark = storage.getItem('bookmark');\n    if (mark == null) {\n      return null;\n    }\n    try {\n      return JSON.parse(mark);\n    } catch (e) {\n      // invalid object saved in the storage\n      // console.warn('Invalid bookmark object.');\n      return null;\n    }\n  };\n\n  var link;\n  // register everything\n  var init = function () {\n    // bookmark-link style\n    var style = global.document.createElement('style');\n    style.type = 'text/css';\n    var text = '.book-mark-link{'\n      + 'border-bottom:none;'\n      + 'display:block;'\n      + 'position:fixed;'\n      + 'color:#222;'\n      + 'font-size:26px !important;'\n      + 'top:-10px;left:20px;'\n      + 'transition:.3s;'\n      + '}'\n      + '.book-mark-link:hover,.book-mark-link-fixed{top:-2px}'\n      // do not show when the width is not enough\n      + '@media(max-width:1090px){.book-mark-link{display:none}}';\n    text = global.document.createTextNode(text);\n    style.appendChild(text);\n    global.document.head.appendChild(style);\n\n    // create a link element\n    // eslint-disable-next-line max-len\n    link = $('<a class=\"book-mark-link book-mark-link-fixed fa fa-bookmark\" href=\"#\"></a>');\n    $(global.document.body).append(link);\n\n    var currentTop = 0;\n    // scroll event\n    $(global).on('scroll.bookmark', function () {\n      var top = global.document.documentElement.scrollTop;\n      if (top > 0) {\n        if (currentTop === 0) {\n          link.removeClass('book-mark-link-fixed');\n          currentTop = top;\n        }\n      } else {\n        if (currentTop > 0) {\n          !link.hasClass('book-mark-link-fixed') &&\n            link.addClass('book-mark-link-fixed');\n          currentTop = 0;\n        }\n      }\n    });\n  };\n\n  var loadBookmark = function () {\n    var mark = getBookmark();\n    if (mark == null) {\n      return;\n    }\n    // found the bookmark\n    $(function () {\n      init();\n      link.attr('href', mark.lastUri + '#book:mark');\n    });\n  };\n\n  var doScroll = function (top) {\n    if (!isNaN(top)) {\n      $(function () {\n        // eslint-disable-next-line max-len\n        $(global.document.documentElement).animate({ 'scrollTop': top }, 'fast');\n      });\n    }\n  };\n\n  var doSaveScroll = function (path, mark) {\n    if (mark == null) {\n      mark = {};\n    }\n    var top = global.document.documentElement.scrollTop;\n    mark.lastUri = path;\n    mark[path] = top;\n    storage.setItem('bookmark', JSON.stringify(mark));\n    link.animate({ top: -26 }, 'fast', function () {\n      setTimeout(function () {\n        link.css('top', '');\n      }, 400);\n    });\n    return mark;\n  };\n\n  var scrollToMark = function (trigger, hash) {\n    var path = global.location.pathname;\n    var mark = getBookmark();\n    $(function () {\n      init();\n      // save the position by clicking the icon\n      link.click(function () {\n        mark = doSaveScroll(path, mark);\n        return false;\n      });\n\n      // register beforeunload event when the trigger is auto\n      if (trigger === 'auto') {\n        // register beforeunload event\n        global.addEventListener('beforeunload', function () {\n          doSaveScroll(path, mark);\n        });\n      }\n      // auto scroll to the position\n      if (mark == null) {\n        return;\n      }\n      // and if the page opens with a specific hash, just jump out\n      var skips = [hash, '#comments'];\n      // eslint-disable-next-line\n      if (skips.filter(function (h) { return h === global.location.hash }).length > 0) {\n        return;\n      }\n      doScroll(mark[path]);\n    });\n  };\n\n  global.bookmark = {\n    loadBookmark: loadBookmark,\n    scrollToMark: scrollToMark,\n  };\n})(window);\n","site":{"data":{}},"excerpt":"","more":"(function (global) {\n  'use strict';\n\n  var storage = global.localStorage;\n  if (storage == null) {\n    // if the localStorage is not exists\n    storage = {\n      // eslint-disable-next-line\n      getItem: function () { return null },\n      setItem: function () { },\n      removeItem: function () { },\n      clear: function () { },\n    };\n  }\n\n  // get the saved bookmark object\n  var getBookmark = function () {\n    var mark = storage.getItem('bookmark');\n    if (mark == null) {\n      return null;\n    }\n    try {\n      return JSON.parse(mark);\n    } catch (e) {\n      // invalid object saved in the storage\n      // console.warn('Invalid bookmark object.');\n      return null;\n    }\n  };\n\n  var link;\n  // register everything\n  var init = function () {\n    // bookmark-link style\n    var style = global.document.createElement('style');\n    style.type = 'text/css';\n    var text = '.book-mark-link{'\n      + 'border-bottom:none;'\n      + 'display:block;'\n      + 'position:fixed;'\n      + 'color:#222;'\n      + 'font-size:26px !important;'\n      + 'top:-10px;left:20px;'\n      + 'transition:.3s;'\n      + '}'\n      + '.book-mark-link:hover,.book-mark-link-fixed{top:-2px}'\n      // do not show when the width is not enough\n      + '@media(max-width:1090px){.book-mark-link{display:none}}';\n    text = global.document.createTextNode(text);\n    style.appendChild(text);\n    global.document.head.appendChild(style);\n\n    // create a link element\n    // eslint-disable-next-line max-len\n    link = $('<a class=\"book-mark-link book-mark-link-fixed fa fa-bookmark\" href=\"#\"></a>');\n    $(global.document.body).append(link);\n\n    var currentTop = 0;\n    // scroll event\n    $(global).on('scroll.bookmark', function () {\n      var top = global.document.documentElement.scrollTop;\n      if (top > 0) {\n        if (currentTop === 0) {\n          link.removeClass('book-mark-link-fixed');\n          currentTop = top;\n        }\n      } else {\n        if (currentTop > 0) {\n          !link.hasClass('book-mark-link-fixed') &&\n            link.addClass('book-mark-link-fixed');\n          currentTop = 0;\n        }\n      }\n    });\n  };\n\n  var loadBookmark = function () {\n    var mark = getBookmark();\n    if (mark == null) {\n      return;\n    }\n    // found the bookmark\n    $(function () {\n      init();\n      link.attr('href', mark.lastUri + '#book:mark');\n    });\n  };\n\n  var doScroll = function (top) {\n    if (!isNaN(top)) {\n      $(function () {\n        // eslint-disable-next-line max-len\n        $(global.document.documentElement).animate({ 'scrollTop': top }, 'fast');\n      });\n    }\n  };\n\n  var doSaveScroll = function (path, mark) {\n    if (mark == null) {\n      mark = {};\n    }\n    var top = global.document.documentElement.scrollTop;\n    mark.lastUri = path;\n    mark[path] = top;\n    storage.setItem('bookmark', JSON.stringify(mark));\n    link.animate({ top: -26 }, 'fast', function () {\n      setTimeout(function () {\n        link.css('top', '');\n      }, 400);\n    });\n    return mark;\n  };\n\n  var scrollToMark = function (trigger, hash) {\n    var path = global.location.pathname;\n    var mark = getBookmark();\n    $(function () {\n      init();\n      // save the position by clicking the icon\n      link.click(function () {\n        mark = doSaveScroll(path, mark);\n        return false;\n      });\n\n      // register beforeunload event when the trigger is auto\n      if (trigger === 'auto') {\n        // register beforeunload event\n        global.addEventListener('beforeunload', function () {\n          doSaveScroll(path, mark);\n        });\n      }\n      // auto scroll to the position\n      if (mark == null) {\n        return;\n      }\n      // and if the page opens with a specific hash, just jump out\n      var skips = [hash, '#comments'];\n      // eslint-disable-next-line\n      if (skips.filter(function (h) { return h === global.location.hash }).length > 0) {\n        return;\n      }\n      doScroll(mark[path]);\n    });\n  };\n\n  global.bookmark = {\n    loadBookmark: loadBookmark,\n    scrollToMark: scrollToMark,\n  };\n})(window);\n"},{"_content":"{\n  \"name\": \"theme-next-bookmark\",\n  \"version\": \"1.0.2\",\n  \"description\": \"A plugin of local-bookmarks for NexT theme.\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"eslint index.js\",\n    \"dist\": \"eslint index.js && uglifyjs --compress --mangle -o bookmark.min.js -- index.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/theme-next/theme-next-bookmark.git\"\n  },\n  \"keywords\": [\n    \"hexo\",\n    \"theme-next\",\n    \"plugin\",\n    \"bookmark\"\n  ],\n  \"author\": \"Tsanie Lily\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/theme-next/theme-next-bookmark/issues\"\n  },\n  \"homepage\": \"https://github.com/theme-next/theme-next-bookmark#readme\",\n  \"devDependencies\": {\n    \"eslint\": \"^4.17.0\",\n    \"eslint-config-google\": \"^0.9.1\",\n    \"uglify-js\": \"^3.3.10\"\n  }\n}\n","source":"lib/bookmark/package.json","raw":"{\n  \"name\": \"theme-next-bookmark\",\n  \"version\": \"1.0.2\",\n  \"description\": \"A plugin of local-bookmarks for NexT theme.\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"eslint index.js\",\n    \"dist\": \"eslint index.js && uglifyjs --compress --mangle -o bookmark.min.js -- index.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/theme-next/theme-next-bookmark.git\"\n  },\n  \"keywords\": [\n    \"hexo\",\n    \"theme-next\",\n    \"plugin\",\n    \"bookmark\"\n  ],\n  \"author\": \"Tsanie Lily\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/theme-next/theme-next-bookmark/issues\"\n  },\n  \"homepage\": \"https://github.com/theme-next/theme-next-bookmark#readme\",\n  \"devDependencies\": {\n    \"eslint\": \"^4.17.0\",\n    \"eslint-config-google\": \"^0.9.1\",\n    \"uglify-js\": \"^3.3.10\"\n  }\n}\n","date":"2021-01-30T08:49:10.703Z","updated":"2021-01-30T08:49:10.703Z","path":"lib/bookmark/package.json","layout":"false","title":"","comments":1,"_id":"ckkjhb8em0019sz5q7vz2z9ze","content":"{\"name\":\"theme-next-bookmark\",\"version\":\"1.0.2\",\"description\":\"A plugin of local-bookmarks for NexT theme.\",\"main\":\"index.js\",\"scripts\":{\"test\":\"eslint index.js\",\"dist\":\"eslint index.js && uglifyjs --compress --mangle -o bookmark.min.js -- index.js\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/theme-next/theme-next-bookmark.git\"},\"keywords\":[\"hexo\",\"theme-next\",\"plugin\",\"bookmark\"],\"author\":\"Tsanie Lily\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/theme-next/theme-next-bookmark/issues\"},\"homepage\":\"https://github.com/theme-next/theme-next-bookmark#readme\",\"devDependencies\":{\"eslint\":\"^4.17.0\",\"eslint-config-google\":\"^0.9.1\",\"uglify-js\":\"^3.3.10\"}}","site":{"data":{}},"excerpt":"","more":"{\"name\":\"theme-next-bookmark\",\"version\":\"1.0.2\",\"description\":\"A plugin of local-bookmarks for NexT theme.\",\"main\":\"index.js\",\"scripts\":{\"test\":\"eslint index.js\",\"dist\":\"eslint index.js && uglifyjs --compress --mangle -o bookmark.min.js -- index.js\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/theme-next/theme-next-bookmark.git\"},\"keywords\":[\"hexo\",\"theme-next\",\"plugin\",\"bookmark\"],\"author\":\"Tsanie Lily\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/theme-next/theme-next-bookmark/issues\"},\"homepage\":\"https://github.com/theme-next/theme-next-bookmark#readme\",\"devDependencies\":{\"eslint\":\"^4.17.0\",\"eslint-config-google\":\"^0.9.1\",\"uglify-js\":\"^3.3.10\"}}"},{"_content":"{\n  \"extends\": [\n    \"config:base\"\n  ]\n}\n","source":"lib/bookmark/renovate.json","raw":"{\n  \"extends\": [\n    \"config:base\"\n  ]\n}\n","date":"2021-01-30T08:49:10.703Z","updated":"2021-01-30T08:49:10.703Z","path":"lib/bookmark/renovate.json","layout":"false","title":"","comments":1,"_id":"ckkjhb8ep001csz5q6fgwbn4j","content":"{\"extends\":[\"config:base\"]}","site":{"data":{}},"excerpt":"","more":"{\"extends\":[\"config:base\"]}"}],"Post":[{"title":"ASpectJ 初识","date":"2020-03-06T02:41:22.000Z","_content":"\n## 首先我们先来了解一下 AOP\n\n> AOP(面向切面编程) 被认为是 OOP（面向对象编程） 的一个强大补充，有了 AOP ，我们可以把分散在应用各处的行为放在可重用的模块中，有效减少冗余代码，并让我们的类只关注自身的主要功能\n\n面向切面编程 AOP（aspect oriented programming），是一种将横切关注点与业务逻辑分离的编程方式。每个横切关注点都集中在一个地方，儿不是分散在很多处代码中。这样我们的服务模块更加简洁，因为他们只包含了主要关注点的代码，而次要的功能或者说是辅助的功能被转移到切面中。\n<!-- more-->\n\n## AOP 术语\n\n\n| key | 别名 | 描述 |\n| :---: | :---: | ---|\n| Advice | 通知 | 切面的具体行为，要执行的代码 |\n| PointCut | 切点 | 通知被应用的具体位置 |\n| Join Point | 连接点 | 程序运行时，能够应用通知的所有点 | \n| Aspect | 切面 | 什么时候在什么地方做什么事情，是切点和通知的结合 |\n| Target | 目标对象| 被切入功能的目标对象 | \n| Introduction | 引入| 将新的方法或属性引入到现有的类中| \n| Weaving | 织入 | 将切面应用到目标对象并创建新的代理对象的过程| \n\n\nAOP 底层通过使用动态代理实现，包含两种方式：\n1. 使用 JDK 动态代理实现\n2. 使用 cglib 实现\n\n**通知类型**\n1. 前置通知(Befor)：在方法之前执行\n2. 后置通知(After)：在方法之后执行\n3. 异常通知(AfterThrowing)：方法出现异常执行\n4. 最终通知(AfterReturning)：在后置之后执行\n5. 环绕通知(Around)：在方法之前和之后执行\n\n## AspectJ\n\nAspectJ 实际是对 AOP 编程思想的一个实践，目前用的比较火，它是一种集合和 Java 完全一样的语言，而且完全兼容 Java。\n\n\n先写到这里！\n\n","source":"_posts/ASpectJ-初识.md","raw":"---\ntitle: ASpectJ 初识\ndate: 2020-03-06 10:41:22\ntags:\n---\n\n## 首先我们先来了解一下 AOP\n\n> AOP(面向切面编程) 被认为是 OOP（面向对象编程） 的一个强大补充，有了 AOP ，我们可以把分散在应用各处的行为放在可重用的模块中，有效减少冗余代码，并让我们的类只关注自身的主要功能\n\n面向切面编程 AOP（aspect oriented programming），是一种将横切关注点与业务逻辑分离的编程方式。每个横切关注点都集中在一个地方，儿不是分散在很多处代码中。这样我们的服务模块更加简洁，因为他们只包含了主要关注点的代码，而次要的功能或者说是辅助的功能被转移到切面中。\n<!-- more-->\n\n## AOP 术语\n\n\n| key | 别名 | 描述 |\n| :---: | :---: | ---|\n| Advice | 通知 | 切面的具体行为，要执行的代码 |\n| PointCut | 切点 | 通知被应用的具体位置 |\n| Join Point | 连接点 | 程序运行时，能够应用通知的所有点 | \n| Aspect | 切面 | 什么时候在什么地方做什么事情，是切点和通知的结合 |\n| Target | 目标对象| 被切入功能的目标对象 | \n| Introduction | 引入| 将新的方法或属性引入到现有的类中| \n| Weaving | 织入 | 将切面应用到目标对象并创建新的代理对象的过程| \n\n\nAOP 底层通过使用动态代理实现，包含两种方式：\n1. 使用 JDK 动态代理实现\n2. 使用 cglib 实现\n\n**通知类型**\n1. 前置通知(Befor)：在方法之前执行\n2. 后置通知(After)：在方法之后执行\n3. 异常通知(AfterThrowing)：方法出现异常执行\n4. 最终通知(AfterReturning)：在后置之后执行\n5. 环绕通知(Around)：在方法之前和之后执行\n\n## AspectJ\n\nAspectJ 实际是对 AOP 编程思想的一个实践，目前用的比较火，它是一种集合和 Java 完全一样的语言，而且完全兼容 Java。\n\n\n先写到这里！\n\n","slug":"ASpectJ-初识","published":1,"updated":"2021-01-29T16:02:57.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb86v0000sz5qlvkzdz2b","content":"<h2 id=\"首先我们先来了解一下-AOP\"><a href=\"#首先我们先来了解一下-AOP\" class=\"headerlink\" title=\"首先我们先来了解一下 AOP\"></a>首先我们先来了解一下 AOP</h2><blockquote>\n<p>AOP(面向切面编程) 被认为是 OOP（面向对象编程） 的一个强大补充，有了 AOP ，我们可以把分散在应用各处的行为放在可重用的模块中，有效减少冗余代码，并让我们的类只关注自身的主要功能</p>\n</blockquote>\n<p>面向切面编程 AOP（aspect oriented programming），是一种将横切关注点与业务逻辑分离的编程方式。每个横切关注点都集中在一个地方，儿不是分散在很多处代码中。这样我们的服务模块更加简洁，因为他们只包含了主要关注点的代码，而次要的功能或者说是辅助的功能被转移到切面中。<br><a id=\"more\"></a></p>\n<h2 id=\"AOP-术语\"><a href=\"#AOP-术语\" class=\"headerlink\" title=\"AOP 术语\"></a>AOP 术语</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">key</th>\n<th style=\"text-align:center\">别名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Advice</td>\n<td style=\"text-align:center\">通知</td>\n<td>切面的具体行为，要执行的代码</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PointCut</td>\n<td style=\"text-align:center\">切点</td>\n<td>通知被应用的具体位置</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Join Point</td>\n<td style=\"text-align:center\">连接点</td>\n<td>程序运行时，能够应用通知的所有点</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Aspect</td>\n<td style=\"text-align:center\">切面</td>\n<td>什么时候在什么地方做什么事情，是切点和通知的结合</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Target</td>\n<td style=\"text-align:center\">目标对象</td>\n<td>被切入功能的目标对象</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Introduction</td>\n<td style=\"text-align:center\">引入</td>\n<td>将新的方法或属性引入到现有的类中</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Weaving</td>\n<td style=\"text-align:center\">织入</td>\n<td>将切面应用到目标对象并创建新的代理对象的过程</td>\n</tr>\n</tbody>\n</table>\n<p>AOP 底层通过使用动态代理实现，包含两种方式：</p>\n<ol>\n<li>使用 JDK 动态代理实现</li>\n<li>使用 cglib 实现</li>\n</ol>\n<p><strong>通知类型</strong></p>\n<ol>\n<li>前置通知(Befor)：在方法之前执行</li>\n<li>后置通知(After)：在方法之后执行</li>\n<li>异常通知(AfterThrowing)：方法出现异常执行</li>\n<li>最终通知(AfterReturning)：在后置之后执行</li>\n<li>环绕通知(Around)：在方法之前和之后执行</li>\n</ol>\n<h2 id=\"AspectJ\"><a href=\"#AspectJ\" class=\"headerlink\" title=\"AspectJ\"></a>AspectJ</h2><p>AspectJ 实际是对 AOP 编程思想的一个实践，目前用的比较火，它是一种集合和 Java 完全一样的语言，而且完全兼容 Java。</p>\n<p>先写到这里！</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"首先我们先来了解一下-AOP\"><a href=\"#首先我们先来了解一下-AOP\" class=\"headerlink\" title=\"首先我们先来了解一下 AOP\"></a>首先我们先来了解一下 AOP</h2><blockquote>\n<p>AOP(面向切面编程) 被认为是 OOP（面向对象编程） 的一个强大补充，有了 AOP ，我们可以把分散在应用各处的行为放在可重用的模块中，有效减少冗余代码，并让我们的类只关注自身的主要功能</p>\n</blockquote>\n<p>面向切面编程 AOP（aspect oriented programming），是一种将横切关注点与业务逻辑分离的编程方式。每个横切关注点都集中在一个地方，儿不是分散在很多处代码中。这样我们的服务模块更加简洁，因为他们只包含了主要关注点的代码，而次要的功能或者说是辅助的功能被转移到切面中。<br>","more":"</p>\n<h2 id=\"AOP-术语\"><a href=\"#AOP-术语\" class=\"headerlink\" title=\"AOP 术语\"></a>AOP 术语</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">key</th>\n<th style=\"text-align:center\">别名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Advice</td>\n<td style=\"text-align:center\">通知</td>\n<td>切面的具体行为，要执行的代码</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PointCut</td>\n<td style=\"text-align:center\">切点</td>\n<td>通知被应用的具体位置</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Join Point</td>\n<td style=\"text-align:center\">连接点</td>\n<td>程序运行时，能够应用通知的所有点</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Aspect</td>\n<td style=\"text-align:center\">切面</td>\n<td>什么时候在什么地方做什么事情，是切点和通知的结合</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Target</td>\n<td style=\"text-align:center\">目标对象</td>\n<td>被切入功能的目标对象</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Introduction</td>\n<td style=\"text-align:center\">引入</td>\n<td>将新的方法或属性引入到现有的类中</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Weaving</td>\n<td style=\"text-align:center\">织入</td>\n<td>将切面应用到目标对象并创建新的代理对象的过程</td>\n</tr>\n</tbody>\n</table>\n<p>AOP 底层通过使用动态代理实现，包含两种方式：</p>\n<ol>\n<li>使用 JDK 动态代理实现</li>\n<li>使用 cglib 实现</li>\n</ol>\n<p><strong>通知类型</strong></p>\n<ol>\n<li>前置通知(Befor)：在方法之前执行</li>\n<li>后置通知(After)：在方法之后执行</li>\n<li>异常通知(AfterThrowing)：方法出现异常执行</li>\n<li>最终通知(AfterReturning)：在后置之后执行</li>\n<li>环绕通知(Around)：在方法之前和之后执行</li>\n</ol>\n<h2 id=\"AspectJ\"><a href=\"#AspectJ\" class=\"headerlink\" title=\"AspectJ\"></a>AspectJ</h2><p>AspectJ 实际是对 AOP 编程思想的一个实践，目前用的比较火，它是一种集合和 Java 完全一样的语言，而且完全兼容 Java。</p>\n<p>先写到这里！</p>"},{"title":"Android Room","date":"2021-01-04T11:44:57.000Z","_content":"# Android Room\n\n[翻译自官网文档](https://developer.android.com/reference/android/arch/persistence/room/package-summary?hl=zh-cn)\n\n\n\nRoom 是一个关系映射对象库，可以使我们很方便的访问 App 数据库\n<!-- more-->\n* **Database:** 注解用来标记问数据库，该类须继承 RoomDatabase,运行时，可以通过 Room.databaseBuilder 或者获取他的实例 Room.inMemoryDatabasebuilder\n* **Entity:** 将 Model 或 pojo 类，标记为数据库行，每个 Entity 都会创建一个数据库表来保存项目。实体类必须在 Database#entities  数组中引用。除非另有说明，否则 Entity 的每个字段（及其父类）都将 Entity 保留在数据库中\n* **Dao:** 将类或接口标记为数据访问对象。数据访问对象负责定义访问数据库的方法。带有注释的类 Database 必须具有一个带有 0 个参数的抽象方法，并返回带有 Dao 注释的类。\n\n\n\n``` java\n// File: User.java\n@Entity\npublic class User {\n    @PrimaryKey\n    private int uid;\n    private String name;\n    @ColumnInfo(name = \"last_name\")\n    private String lastName;\n    // Room 请求 set 和 get 方法去访问数据\n}\n\n// File: UserDao.java\n@Dao\npublic interface UserDao {\n    @Query(\"select * from user\") \n    List<User> loadAll();\n    \n    @Query(\"select * from user where uid in (:userIds)\")\n    List<User> loadAllByUserId(int... userIds);\n    \n    @Query(\"select * from user where name like :first and last_name like :last limit 1\")\n    User loadOneByNameAndLastName(String first, String last);\n    \n    @Insert\n    void insertAll(User... users);\n    \n    @Delete\n    void delete(User user);\n}\n\n// File: AppDatabse.java\n@Database(entities = {User.java})\npublic abstract class AppDatabase extends RoomDatabase {\n    public abstract UserDao userDao();\n}\n\n// 创建 AppDatabase 实例\nAppDatabse db = Room.databaseBuilder(getApplicationContext(), AppDatabase.class, \"database_name\").build();\n```\n\n一旦 Room 在编译期，就开始检测注解，扫描所有可以访问的表/\n\n可以通过使用 `InvalidtaionTracker` 类来观察一个数据表的变化。\n\nRoom 允许通过 `Query`  方法返回一个 `LiveData` 类型的数据。它会自动观察相关数据表，一旦发生数据改变，就会触发 `LiveData` 的观察者\n\n\n\n```java\n// LiveData 会自动分发数据表的改变\n@Query(\"Select * from user order by name limit 5\") \npublic LiveData<List<User>> loadFirstFiveUsers();\n```\n\n","source":"_posts/Android-Room.md","raw":"---\ntitle: Android Room\ndate: 2021-01-04 19:44:57\ntag: Jetpack\ncategory: Jetpack\n---\n# Android Room\n\n[翻译自官网文档](https://developer.android.com/reference/android/arch/persistence/room/package-summary?hl=zh-cn)\n\n\n\nRoom 是一个关系映射对象库，可以使我们很方便的访问 App 数据库\n<!-- more-->\n* **Database:** 注解用来标记问数据库，该类须继承 RoomDatabase,运行时，可以通过 Room.databaseBuilder 或者获取他的实例 Room.inMemoryDatabasebuilder\n* **Entity:** 将 Model 或 pojo 类，标记为数据库行，每个 Entity 都会创建一个数据库表来保存项目。实体类必须在 Database#entities  数组中引用。除非另有说明，否则 Entity 的每个字段（及其父类）都将 Entity 保留在数据库中\n* **Dao:** 将类或接口标记为数据访问对象。数据访问对象负责定义访问数据库的方法。带有注释的类 Database 必须具有一个带有 0 个参数的抽象方法，并返回带有 Dao 注释的类。\n\n\n\n``` java\n// File: User.java\n@Entity\npublic class User {\n    @PrimaryKey\n    private int uid;\n    private String name;\n    @ColumnInfo(name = \"last_name\")\n    private String lastName;\n    // Room 请求 set 和 get 方法去访问数据\n}\n\n// File: UserDao.java\n@Dao\npublic interface UserDao {\n    @Query(\"select * from user\") \n    List<User> loadAll();\n    \n    @Query(\"select * from user where uid in (:userIds)\")\n    List<User> loadAllByUserId(int... userIds);\n    \n    @Query(\"select * from user where name like :first and last_name like :last limit 1\")\n    User loadOneByNameAndLastName(String first, String last);\n    \n    @Insert\n    void insertAll(User... users);\n    \n    @Delete\n    void delete(User user);\n}\n\n// File: AppDatabse.java\n@Database(entities = {User.java})\npublic abstract class AppDatabase extends RoomDatabase {\n    public abstract UserDao userDao();\n}\n\n// 创建 AppDatabase 实例\nAppDatabse db = Room.databaseBuilder(getApplicationContext(), AppDatabase.class, \"database_name\").build();\n```\n\n一旦 Room 在编译期，就开始检测注解，扫描所有可以访问的表/\n\n可以通过使用 `InvalidtaionTracker` 类来观察一个数据表的变化。\n\nRoom 允许通过 `Query`  方法返回一个 `LiveData` 类型的数据。它会自动观察相关数据表，一旦发生数据改变，就会触发 `LiveData` 的观察者\n\n\n\n```java\n// LiveData 会自动分发数据表的改变\n@Query(\"Select * from user order by name limit 5\") \npublic LiveData<List<User>> loadFirstFiveUsers();\n```\n\n","slug":"Android-Room","published":1,"updated":"2021-01-30T08:25:27.815Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8760002sz5qzefgcfhz","content":"<h1 id=\"Android-Room\"><a href=\"#Android-Room\" class=\"headerlink\" title=\"Android Room\"></a>Android Room</h1><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvYXJjaC9wZXJzaXN0ZW5jZS9yb29tL3BhY2thZ2Utc3VtbWFyeT9obD16aC1jbg==\" title=\"https://developer.android.com/reference/android/arch/persistence/room/package-summary?hl=zh-cn\">翻译自官网文档<i class=\"fa fa-external-link\"></i></span></p>\n<p>Room 是一个关系映射对象库，可以使我们很方便的访问 App 数据库<br><a id=\"more\"></a></p>\n<ul>\n<li><strong>Database:</strong> 注解用来标记问数据库，该类须继承 RoomDatabase,运行时，可以通过 Room.databaseBuilder 或者获取他的实例 Room.inMemoryDatabasebuilder</li>\n<li><strong>Entity:</strong> 将 Model 或 pojo 类，标记为数据库行，每个 Entity 都会创建一个数据库表来保存项目。实体类必须在 Database#entities  数组中引用。除非另有说明，否则 Entity 的每个字段（及其父类）都将 Entity 保留在数据库中</li>\n<li><strong>Dao:</strong> 将类或接口标记为数据访问对象。数据访问对象负责定义访问数据库的方法。带有注释的类 Database 必须具有一个带有 0 个参数的抽象方法，并返回带有 Dao 注释的类。</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// File: User.java</span>\n<span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">User</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@PrimaryKey</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> uid<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> String name<span class=\"token punctuation\">;</span>\n    <span class=\"token annotation punctuation\">@ColumnInfo</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"last_name\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> String lastName<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Room 请求 set 和 get 方法去访问数据</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// File: UserDao.java</span>\n<span class=\"token annotation punctuation\">@Dao</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">UserDao</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Query</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"select * from user\"</span><span class=\"token punctuation\">)</span> \n    List<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span> <span class=\"token function\">loadAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@Query</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"select * from user where uid in (:userIds)\"</span><span class=\"token punctuation\">)</span>\n    List<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span> <span class=\"token function\">loadAllByUserId</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> userIds<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@Query</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"select * from user where name like :first and last_name like :last limit 1\"</span><span class=\"token punctuation\">)</span>\n    User <span class=\"token function\">loadOneByNameAndLastName</span><span class=\"token punctuation\">(</span>String first<span class=\"token punctuation\">,</span> String last<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@Insert</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">insertAll</span><span class=\"token punctuation\">(</span>User<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> users<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@Delete</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">delete</span><span class=\"token punctuation\">(</span>User user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// File: AppDatabse.java</span>\n<span class=\"token annotation punctuation\">@Database</span><span class=\"token punctuation\">(</span>entities <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>User<span class=\"token punctuation\">.</span>java<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AppDatabase</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">RoomDatabase</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> UserDao <span class=\"token function\">userDao</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 创建 AppDatabase 实例</span>\nAppDatabse db <span class=\"token operator\">=</span> Room<span class=\"token punctuation\">.</span><span class=\"token function\">databaseBuilder</span><span class=\"token punctuation\">(</span><span class=\"token function\">getApplicationContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> AppDatabase<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"database_name\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>一旦 Room 在编译期，就开始检测注解，扫描所有可以访问的表/</p>\n<p>可以通过使用 <code>InvalidtaionTracker</code> 类来观察一个数据表的变化。</p>\n<p>Room 允许通过 <code>Query</code>  方法返回一个 <code>LiveData</code> 类型的数据。它会自动观察相关数据表，一旦发生数据改变，就会触发 <code>LiveData</code> 的观察者</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// LiveData 会自动分发数据表的改变</span>\n<span class=\"token annotation punctuation\">@Query</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Select * from user order by name limit 5\"</span><span class=\"token punctuation\">)</span> \n<span class=\"token keyword\">public</span> LiveData<span class=\"token operator\">&lt;</span>List<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">>></span> <span class=\"token function\">loadFirstFiveUsers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n","site":{"data":{}},"excerpt":"<h1 id=\"Android-Room\"><a href=\"#Android-Room\" class=\"headerlink\" title=\"Android Room\"></a>Android Room</h1><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvYXJjaC9wZXJzaXN0ZW5jZS9yb29tL3BhY2thZ2Utc3VtbWFyeT9obD16aC1jbg==\" title=\"https://developer.android.com/reference/android/arch/persistence/room/package-summary?hl=zh-cn\">翻译自官网文档<i class=\"fa fa-external-link\"></i></span></p>\n<p>Room 是一个关系映射对象库，可以使我们很方便的访问 App 数据库<br>","more":"</p>\n<ul>\n<li><strong>Database:</strong> 注解用来标记问数据库，该类须继承 RoomDatabase,运行时，可以通过 Room.databaseBuilder 或者获取他的实例 Room.inMemoryDatabasebuilder</li>\n<li><strong>Entity:</strong> 将 Model 或 pojo 类，标记为数据库行，每个 Entity 都会创建一个数据库表来保存项目。实体类必须在 Database#entities  数组中引用。除非另有说明，否则 Entity 的每个字段（及其父类）都将 Entity 保留在数据库中</li>\n<li><strong>Dao:</strong> 将类或接口标记为数据访问对象。数据访问对象负责定义访问数据库的方法。带有注释的类 Database 必须具有一个带有 0 个参数的抽象方法，并返回带有 Dao 注释的类。</li>\n</ul>\n<pre><code class=\"java\">// File: User.java\n@Entity\npublic class User {\n    @PrimaryKey\n    private int uid;\n    private String name;\n    @ColumnInfo(name = &quot;last_name&quot;)\n    private String lastName;\n    // Room 请求 set 和 get 方法去访问数据\n}\n\n// File: UserDao.java\n@Dao\npublic interface UserDao {\n    @Query(&quot;select * from user&quot;) \n    List&lt;User&gt; loadAll();\n\n    @Query(&quot;select * from user where uid in (:userIds)&quot;)\n    List&lt;User&gt; loadAllByUserId(int... userIds);\n\n    @Query(&quot;select * from user where name like :first and last_name like :last limit 1&quot;)\n    User loadOneByNameAndLastName(String first, String last);\n\n    @Insert\n    void insertAll(User... users);\n\n    @Delete\n    void delete(User user);\n}\n\n// File: AppDatabse.java\n@Database(entities = {User.java})\npublic abstract class AppDatabase extends RoomDatabase {\n    public abstract UserDao userDao();\n}\n\n// 创建 AppDatabase 实例\nAppDatabse db = Room.databaseBuilder(getApplicationContext(), AppDatabase.class, &quot;database_name&quot;).build();\n</code></pre>\n<p>一旦 Room 在编译期，就开始检测注解，扫描所有可以访问的表/</p>\n<p>可以通过使用 <code>InvalidtaionTracker</code> 类来观察一个数据表的变化。</p>\n<p>Room 允许通过 <code>Query</code>  方法返回一个 <code>LiveData</code> 类型的数据。它会自动观察相关数据表，一旦发生数据改变，就会触发 <code>LiveData</code> 的观察者</p>\n<pre><code class=\"java\">// LiveData 会自动分发数据表的改变\n@Query(&quot;Select * from user order by name limit 5&quot;) \npublic LiveData&lt;List&lt;User&gt;&gt; loadFirstFiveUsers();\n</code></pre>"},{"title":"Android Studio Dependencies Library Resolve","date":"2019-04-16T09:44:39.000Z","_content":"\n在使用 Android Studio 开发时,使用 Gradle 脚本构建项目, 同 Maven 一样,所引用的包之间也存在着相互依赖的关系, 当你使用某个包之后,发现有包版本冲突, 那么解决方案就来了.\n<!-- more-->\n\n先说点不正经的:\n1.  你可以把你自己引入的包去掉,使用依赖包\n2.  放弃治疗\n\n\n哈哈,言归正传:\n\n当我们引入的包之间存在冲突(不是同一个)的关系时, 也就是说,我们需要保留一个项目依赖包使用,那么我们需要在 `build.gradle` 中将我们不需要的包删除掉.\n\n## 举个栗子:\n\n当我使用 `com.squareup.retrofit2:adapter-rxjava:2.1.0` 时, 它默认依赖使用 `RxJava 1.5.0` 版本. 当我使用 `io.reactivex.rxjava2:rxjava:2.0.6` 时, 就会引起包冲突.\n\n## 解决方案:\n\nbuild.gradle\n\n```\n\n...\ndependencies {\n    compile fileTree(include: ['*.jar'], dir: 'libs')\n\n    compile ('com.squareup.retrofit2:adapter-rxjava:2.1.0'){\n        exclude group: 'io.reactivex'\n    }\n    compile 'io.reactivex.rxjava2:rxjava:2.0.6'\n    compile 'io.reactivex.rxjava2:rxandroid:2.0.1'\n}\n```\n\n","source":"_posts/Android-Studio-Dependencies-Library-Resolve.md","raw":"---\ntitle: Android Studio Dependencies Library Resolve\ndate: 2019-04-16 17:44:39\ntags: Android\n---\n\n在使用 Android Studio 开发时,使用 Gradle 脚本构建项目, 同 Maven 一样,所引用的包之间也存在着相互依赖的关系, 当你使用某个包之后,发现有包版本冲突, 那么解决方案就来了.\n<!-- more-->\n\n先说点不正经的:\n1.  你可以把你自己引入的包去掉,使用依赖包\n2.  放弃治疗\n\n\n哈哈,言归正传:\n\n当我们引入的包之间存在冲突(不是同一个)的关系时, 也就是说,我们需要保留一个项目依赖包使用,那么我们需要在 `build.gradle` 中将我们不需要的包删除掉.\n\n## 举个栗子:\n\n当我使用 `com.squareup.retrofit2:adapter-rxjava:2.1.0` 时, 它默认依赖使用 `RxJava 1.5.0` 版本. 当我使用 `io.reactivex.rxjava2:rxjava:2.0.6` 时, 就会引起包冲突.\n\n## 解决方案:\n\nbuild.gradle\n\n```\n\n...\ndependencies {\n    compile fileTree(include: ['*.jar'], dir: 'libs')\n\n    compile ('com.squareup.retrofit2:adapter-rxjava:2.1.0'){\n        exclude group: 'io.reactivex'\n    }\n    compile 'io.reactivex.rxjava2:rxjava:2.0.6'\n    compile 'io.reactivex.rxjava2:rxandroid:2.0.1'\n}\n```\n\n","slug":"Android-Studio-Dependencies-Library-Resolve","published":1,"updated":"2021-01-29T16:03:35.670Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb87d0004sz5qqrrm8sug","content":"<p>在使用 Android Studio 开发时,使用 Gradle 脚本构建项目, 同 Maven 一样,所引用的包之间也存在着相互依赖的关系, 当你使用某个包之后,发现有包版本冲突, 那么解决方案就来了.<br><a id=\"more\"></a></p>\n<p>先说点不正经的:</p>\n<ol>\n<li>你可以把你自己引入的包去掉,使用依赖包</li>\n<li>放弃治疗</li>\n</ol>\n<p>哈哈,言归正传:</p>\n<p>当我们引入的包之间存在冲突(不是同一个)的关系时, 也就是说,我们需要保留一个项目依赖包使用,那么我们需要在 <code>build.gradle</code> 中将我们不需要的包删除掉.</p>\n<h2 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子:\"></a>举个栗子:</h2><p>当我使用 <code>com.squareup.retrofit2:adapter-rxjava:2.1.0</code> 时, 它默认依赖使用 <code>RxJava 1.5.0</code> 版本. 当我使用 <code>io.reactivex.rxjava2:rxjava:2.0.6</code> 时, 就会引起包冲突.</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案:\"></a>解决方案:</h2><p>build.gradle</p>\n<pre><code>\n...\ndependencies {\n    compile fileTree(include: [&#39;*.jar&#39;], dir: &#39;libs&#39;)\n\n    compile (&#39;com.squareup.retrofit2:adapter-rxjava:2.1.0&#39;){\n        exclude group: &#39;io.reactivex&#39;\n    }\n    compile &#39;io.reactivex.rxjava2:rxjava:2.0.6&#39;\n    compile &#39;io.reactivex.rxjava2:rxandroid:2.0.1&#39;\n}\n</code></pre>","site":{"data":{}},"excerpt":"<p>在使用 Android Studio 开发时,使用 Gradle 脚本构建项目, 同 Maven 一样,所引用的包之间也存在着相互依赖的关系, 当你使用某个包之后,发现有包版本冲突, 那么解决方案就来了.<br>","more":"</p>\n<p>先说点不正经的:</p>\n<ol>\n<li>你可以把你自己引入的包去掉,使用依赖包</li>\n<li>放弃治疗</li>\n</ol>\n<p>哈哈,言归正传:</p>\n<p>当我们引入的包之间存在冲突(不是同一个)的关系时, 也就是说,我们需要保留一个项目依赖包使用,那么我们需要在 <code>build.gradle</code> 中将我们不需要的包删除掉.</p>\n<h2 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子:\"></a>举个栗子:</h2><p>当我使用 <code>com.squareup.retrofit2:adapter-rxjava:2.1.0</code> 时, 它默认依赖使用 <code>RxJava 1.5.0</code> 版本. 当我使用 <code>io.reactivex.rxjava2:rxjava:2.0.6</code> 时, 就会引起包冲突.</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案:\"></a>解决方案:</h2><p>build.gradle</p>\n<pre><code>\n...\ndependencies {\n    compile fileTree(include: [&#39;*.jar&#39;], dir: &#39;libs&#39;)\n\n    compile (&#39;com.squareup.retrofit2:adapter-rxjava:2.1.0&#39;){\n        exclude group: &#39;io.reactivex&#39;\n    }\n    compile &#39;io.reactivex.rxjava2:rxjava:2.0.6&#39;\n    compile &#39;io.reactivex.rxjava2:rxandroid:2.0.1&#39;\n}\n</code></pre>"},{"title":"Jenkins + Gradle + Git 构建 Android CI 构建环境","date":"2019-04-16T09:42:05.000Z","_content":"\n# 前言\n\n在项目开发中，我们需要将最新的代码更新，提供给测试人员进行测试，以及发布。\n\n目前 Android 工作中都在使用很强大的开发、构建以及打包工具，例如： android-studio、Gradle、Git等。\n<!-- more-->\n然，在企业组织并不是很完善的公司里，开发打包发布等工作，时常会由开发人员进行操作，难免在一些地方疏忽掉。\n\n因此，CI 构建的出现，使得这些繁琐的工作变得轻松起来。\n\n对于开发工程师，只负责向版本库提交代码，不用关心打包，发布之类的流程。\n\n对于产品和测试，只需要从发布页面下载 APK 安装文件，不需要每一次都去工程师哪里索取最新的安装文件。\n\nCI 的基本工作流程如下：\n![图1](http://upload-images.jianshu.io/upload_images/1550996-5101eac8d87352a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们每一次提交代码（通过git/svn作为版本库）到主干上，根据 CI 的定时任务，检测到版本更新，通过 CI ，将进行打包发布等流程操作。\n\n<!--more-->\n# 准备工作\n\n本文使用 Linux Ubuntu 系统为大家介绍环境的搭建\n\n## 环境工具\n    1. PC 机(mac/linux)\n    2. Java JDK\n    3. Android SDK\n    4. Gradle\n    5. Git\n    6. Tomcat\n    7. Jenkins\n\n## 环境搭建\n\n###  Java 环境 安装\nJava JDK, Android SDK, Gradle 可从[AndroidDevTools](http://androiddevtools.cn)处下载获取。\n\n### git 安装\ngit 可通过终端进行安装\n```\nsudo add-apt-repository ppa:git-core/ppa\nsudo apt-get update\nsudo apt-get install git\n```\n\n安装完成之后通过`git --version` 检查是否成功\n\n安装后 git 存储在 `/usr/bin/git`下\n\n### Jenkins \n\n通过 Jenkins [官方网站](https://jenkins.io/index.html)下载最新Jenkins.war包\n\n![Jenkins 下载](http://upload-images.jianshu.io/upload_images/1550996-d2654c0a1383423a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 环境变量\n\n打开 `vi /etc/profile`\n\n将下列语句添加在文件的末尾后， 执行 esc->:wq\n\n其中环境位置根据自己的所在位置进行相应的更改\n\n![环境变量](http://upload-images.jianshu.io/upload_images/1550996-ffd5f1b87d0e5bbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### 启动\n\n激动的你，是不是已经被这些繁琐的东西搞的不耐烦了呢，下面我们开始启动 Jenkins\n\n将下载好的 Jenkins.war 包， 放入 Tomcat 的 webapps 目录下，进入 bin 目录执行 ./startup.sh 启动 Tomcat。\n\n启动后，在浏览器中输入： `localhost:8080/jenkins`\n\n\n![jenkinsmain.png](http://upload-images.jianshu.io/upload_images/1550996-cbdb39d4f2f4a85f.png?\nimageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 插件安装\n\n系统管理-> 插件管理->可选插件：\n\n在搜索框中搜索以下插件，并进行安装\n\ngit plugin\ngitlab plugin\ngrade plugin\nAndroid Lint Plugin\nBuild Pipeline plugin\nbuild timeout plugin\nbuild name plugin\nchange assembly-version plugin\ncredentials binding plugin\ndescription setter plugin\nDynamic parameter plugin\nEmail Extension plugin\nFindBugs plugin\nJaCoco plugin\nUnit attachments plugin\nProject Description plugin\nTimestamper\nWorkspace cleanup plugin\n\n安装完成后，重启。\n\n### 系统设置\n\n系统管理->系统设置：\n\n配置Android 环境，将地址指向本机的 SDK 目录\n![Android environment](http://upload-images.jianshu.io/upload_images/1550996-5987aabcffb290c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n系统管理->全局工具配置\n\n配置 Java， Git ， Gradle 目录等\n\nJDK：\n\n![Java JDK](http://upload-images.jianshu.io/upload_images/1550996-b9e29a1ec2b746e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nGit：\n\n![git](http://upload-images.jianshu.io/upload_images/1550996-9c4e88d64fcc2ab9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nGradle：\n\n\n![gradle](http://upload-images.jianshu.io/upload_images/1550996-9fbabc7d5c7ca319.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n到此，环境配置，已基本完成。\n\n下面我们开始进行项目够将操作\n\n## 项目构建\n\n### 创建Job\n\n新建->构建一个自由风格的软件项目:\n\n![创建CI工程](http://upload-images.jianshu.io/upload_images/1550996-2390d86256678c54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 参数化构建\n\n通常我们在使用 Android-studio 进行打包时以及签名时，都会用到build.gradle并在其中配置相关属性。再此，我们可以用Jenkins，配置我们的项目参数，例如发布的版本号，构建时间， 上传路径，发布地址，签名打包等等。\n\n在这里我们先看看 build.gradle 中的构建信息:\n\n在项目的 moudle 下 build.gradle 文件\n```\ndef getDate () {\n    def date = new Date()\n    def formattedDate = date.format(\"yyyyMMddHHmm\")\n    return formattedDate\n}\n\ndef verName = APP_VERSION\ndef verCode = 14\n\nandroid {\n    ....\n    signingConfigs {\n        release {\n          keyAlias ''\n          keyPassword ''\n          storeFile file ('')\n          storePassword ''\n       }   \n   }\n\n  defaultConfig {\n      applicationId \"cn.zhuangbudong.example\"\n      minSdkVersion 18\n      targetSdkVersion 25\n      multiDexEnabled true\n      versionCode verCode\n      versionName verName\n\n      resValues(\"string\", 'app_version', verName)\n  }\n  buildTypes {\n    release {\n      signingConfig signingConfigs.release\n      minifyEnabled false\n      proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n    }\n\n   lintOptions {\n    abortOnError false\n   }\n\n   dexOptions {\n      javaMaxHeapSize '2g'\n   }\n\napplicationVariants.all { variant ->\n    variant.outputs.each { output ->\n        def newName\n        def timeNow\n        def oldFile = output.outputFile\n        def outDirectory = oldFile.parent\n        if (\"true\".equals(IS_JENKINS)) { \n            timeNow = JENKINS_TIME\n            outDirectory = \"/media/nexd/work/android/package/release/\"\n            newName = 'zhuangbudong_example_' + verName + \"_\" + timeNow + \"_\" + variant.buildType.name + \".apk\" \n       } else {\n            timeNow = getDate()\n            if (variant.buildType.name.equals('debug')) { \n               newName = 'zhuangbudong_example_' + verName + \"_debug.apk\"  \n          } else { \n               newName = 'zhuangbudong_example_' + verName + \"_\" + timeNow + \"_\" + variant.buildType.name + \".apk\" \n           } \n       } \n       output.outputFile = new File(outDirectory, newName)\n    }}\n\n  }\n}\n```\n\ngradle.properties:\n\n```\nAPP_VERSION=2.0.2\nIS_JENKINS=false\nJENKINS_TIME=''\n```\n\n在工程中添加以上代码，并在Jenkins中为这些参数赋值。\n\n下面介绍 Jenkins 参数配置\n\n勾选参数化构建过程，如下图：\n![参数化构建](http://upload-images.jianshu.io/upload_images/1550996-20f69e63a527814c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n按照下图，添加相关类型的参数，此处注意，Jenkins 配置的参数名要和在android-studio中配置的参数名保持一致\n\n![JENKINS_TIME](http://upload-images.jianshu.io/upload_images/1550996-e0f4ceb7015ac0da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![APP_VERSION](http://upload-images.jianshu.io/upload_images/1550996-6e3f8d0311399d74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![IS_JENKINS](http://upload-images.jianshu.io/upload_images/1550996-673c2465bcdc9a89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![ENVIRONMENT](http://upload-images.jianshu.io/upload_images/1550996-a82221191b980ad7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 源码管理\n\n此处负责从版本库中拉去最新的代码\n\n\n![git 仓库](http://upload-images.jianshu.io/upload_images/1550996-6dcbd8dd2dd9456c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n此处如果需要验证，点击 Add， 选择： Username with password\n\n在对应窗口输入用户名和密码信息\n![用户身份验证](http://upload-images.jianshu.io/upload_images/1550996-8af978712a010864.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n点击添加。\n\n使用 gitlab 进行源码库管理。\n\n### 触发器\n\n触发器负责拉取代码，编译，打包，发布等操作。通过触发器，执行Jenkins。\n\n\n![触发器构建](http://upload-images.jianshu.io/upload_images/1550996-beb6ff8faa9843f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 构建环境\n\n此处只是在Jenkins在打包时，配置任务名称即可。如下图：\n\n![构建环境](http://upload-images.jianshu.io/upload_images/1550996-45b210c5df916dbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 构建\n\n这里是最重要滴，配置以下命令，才能进行打包签名等等。\n\n如下配置，这里需要注意下，构建文件，根目录。在你的目录结构比较复杂的时候，即你的根目录没有 build.gradle 文件时，需要指定一下 build.gradle 目录的位置。\n\n同时，也是最重要的，勾选上pass job parameters as gradle properties ，不然之前配置的参数无法传递给项目中的 gradle.properties。\n\n![构建](http://upload-images.jianshu.io/upload_images/1550996-4e4e6e139fc1e856.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 构建后操作\n\n当项目构建完成后，我们可以通过邮件的方式将产生的Apk文件，以及测试报告，构建日志等信息，发送出来 如下图：\n\n\n![邮件发送](http://upload-images.jianshu.io/upload_images/1550996-63b6bcb7b2dfd551.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\n<hr/>\n(本邮件是程序自动下发的，请勿回复！)<br/><hr/>\n项目名称：${PROJECT_NAME}<br/><hr/>\n构建编号：${BUILD_NUMBER}<br/><hr/>\n构建状态：${BUILD_STATUS}<br/><hr/>\n触发原因：${CAUSE}<br/><hr/>\n测试报告：<a href=\"${PROJECT_URL}ws/${PROJECT_NAME}app/build/reports/tests/release/index.html\">${PROJECT_URL}ws/${PROJECT_NAME}app/build/reports/tests/release/index.html</a><br/><hr/>\n构建日志地址：<a href=\"${BUILD_URL}console\">${BUILD_URL}console/</a><br/><hr/>\n构建地址：<a href=\"${PROJECT_URL}\">${PROJECT_URL}</a><br/><hr/>\n构建报告：<a href=\"${BUILD_URL}testReport\">${BUILD_URL}testReport</a><br/><hr/>\n变更集:${JELLY_SCRIPT,template=\"html\"}<br/>\n\n<hr/>\n```\n\n## 开始构建\n\n回到 Jenkins 首页，点击创建的项目，点击 build with parameters:\n\n\n![Build with Parameters](http://upload-images.jianshu.io/upload_images/1550996-58ecc4965ab845ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n点击开始构建，启动 Jenkins 构建任务。\n\n构建成功时，显示为蓝色， 失败为红色，如下图：\n\n\n![构建结果](http://upload-images.jianshu.io/upload_images/1550996-4b2fc4b1190ddcd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n构建后生成的 Apk 文件，存在 build.gradle 文件中配置的目录。同时也可以使用蒲公英或fir.im 进行发布管理。\n\n谢谢~\n\n","source":"_posts/Jenkins-gradle-git-构建-Android-CI-构建环境.md","raw":"---\ntitle: Jenkins + gradle + git 构建 Android CI 构建环境\ndate: 2019-04-16 17:42:05\ntags: Android\n---\n\n# 前言\n\n在项目开发中，我们需要将最新的代码更新，提供给测试人员进行测试，以及发布。\n\n目前 Android 工作中都在使用很强大的开发、构建以及打包工具，例如： android-studio、Gradle、Git等。\n<!-- more-->\n然，在企业组织并不是很完善的公司里，开发打包发布等工作，时常会由开发人员进行操作，难免在一些地方疏忽掉。\n\n因此，CI 构建的出现，使得这些繁琐的工作变得轻松起来。\n\n对于开发工程师，只负责向版本库提交代码，不用关心打包，发布之类的流程。\n\n对于产品和测试，只需要从发布页面下载 APK 安装文件，不需要每一次都去工程师哪里索取最新的安装文件。\n\nCI 的基本工作流程如下：\n![图1](http://upload-images.jianshu.io/upload_images/1550996-5101eac8d87352a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们每一次提交代码（通过git/svn作为版本库）到主干上，根据 CI 的定时任务，检测到版本更新，通过 CI ，将进行打包发布等流程操作。\n\n<!--more-->\n# 准备工作\n\n本文使用 Linux Ubuntu 系统为大家介绍环境的搭建\n\n## 环境工具\n    1. PC 机(mac/linux)\n    2. Java JDK\n    3. Android SDK\n    4. Gradle\n    5. Git\n    6. Tomcat\n    7. Jenkins\n\n## 环境搭建\n\n###  Java 环境 安装\nJava JDK, Android SDK, Gradle 可从[AndroidDevTools](http://androiddevtools.cn)处下载获取。\n\n### git 安装\ngit 可通过终端进行安装\n```\nsudo add-apt-repository ppa:git-core/ppa\nsudo apt-get update\nsudo apt-get install git\n```\n\n安装完成之后通过`git --version` 检查是否成功\n\n安装后 git 存储在 `/usr/bin/git`下\n\n### Jenkins \n\n通过 Jenkins [官方网站](https://jenkins.io/index.html)下载最新Jenkins.war包\n\n![Jenkins 下载](http://upload-images.jianshu.io/upload_images/1550996-d2654c0a1383423a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 环境变量\n\n打开 `vi /etc/profile`\n\n将下列语句添加在文件的末尾后， 执行 esc->:wq\n\n其中环境位置根据自己的所在位置进行相应的更改\n\n![环境变量](http://upload-images.jianshu.io/upload_images/1550996-ffd5f1b87d0e5bbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### 启动\n\n激动的你，是不是已经被这些繁琐的东西搞的不耐烦了呢，下面我们开始启动 Jenkins\n\n将下载好的 Jenkins.war 包， 放入 Tomcat 的 webapps 目录下，进入 bin 目录执行 ./startup.sh 启动 Tomcat。\n\n启动后，在浏览器中输入： `localhost:8080/jenkins`\n\n\n![jenkinsmain.png](http://upload-images.jianshu.io/upload_images/1550996-cbdb39d4f2f4a85f.png?\nimageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 插件安装\n\n系统管理-> 插件管理->可选插件：\n\n在搜索框中搜索以下插件，并进行安装\n\ngit plugin\ngitlab plugin\ngrade plugin\nAndroid Lint Plugin\nBuild Pipeline plugin\nbuild timeout plugin\nbuild name plugin\nchange assembly-version plugin\ncredentials binding plugin\ndescription setter plugin\nDynamic parameter plugin\nEmail Extension plugin\nFindBugs plugin\nJaCoco plugin\nUnit attachments plugin\nProject Description plugin\nTimestamper\nWorkspace cleanup plugin\n\n安装完成后，重启。\n\n### 系统设置\n\n系统管理->系统设置：\n\n配置Android 环境，将地址指向本机的 SDK 目录\n![Android environment](http://upload-images.jianshu.io/upload_images/1550996-5987aabcffb290c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n系统管理->全局工具配置\n\n配置 Java， Git ， Gradle 目录等\n\nJDK：\n\n![Java JDK](http://upload-images.jianshu.io/upload_images/1550996-b9e29a1ec2b746e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nGit：\n\n![git](http://upload-images.jianshu.io/upload_images/1550996-9c4e88d64fcc2ab9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nGradle：\n\n\n![gradle](http://upload-images.jianshu.io/upload_images/1550996-9fbabc7d5c7ca319.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n到此，环境配置，已基本完成。\n\n下面我们开始进行项目够将操作\n\n## 项目构建\n\n### 创建Job\n\n新建->构建一个自由风格的软件项目:\n\n![创建CI工程](http://upload-images.jianshu.io/upload_images/1550996-2390d86256678c54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 参数化构建\n\n通常我们在使用 Android-studio 进行打包时以及签名时，都会用到build.gradle并在其中配置相关属性。再此，我们可以用Jenkins，配置我们的项目参数，例如发布的版本号，构建时间， 上传路径，发布地址，签名打包等等。\n\n在这里我们先看看 build.gradle 中的构建信息:\n\n在项目的 moudle 下 build.gradle 文件\n```\ndef getDate () {\n    def date = new Date()\n    def formattedDate = date.format(\"yyyyMMddHHmm\")\n    return formattedDate\n}\n\ndef verName = APP_VERSION\ndef verCode = 14\n\nandroid {\n    ....\n    signingConfigs {\n        release {\n          keyAlias ''\n          keyPassword ''\n          storeFile file ('')\n          storePassword ''\n       }   \n   }\n\n  defaultConfig {\n      applicationId \"cn.zhuangbudong.example\"\n      minSdkVersion 18\n      targetSdkVersion 25\n      multiDexEnabled true\n      versionCode verCode\n      versionName verName\n\n      resValues(\"string\", 'app_version', verName)\n  }\n  buildTypes {\n    release {\n      signingConfig signingConfigs.release\n      minifyEnabled false\n      proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n    }\n\n   lintOptions {\n    abortOnError false\n   }\n\n   dexOptions {\n      javaMaxHeapSize '2g'\n   }\n\napplicationVariants.all { variant ->\n    variant.outputs.each { output ->\n        def newName\n        def timeNow\n        def oldFile = output.outputFile\n        def outDirectory = oldFile.parent\n        if (\"true\".equals(IS_JENKINS)) { \n            timeNow = JENKINS_TIME\n            outDirectory = \"/media/nexd/work/android/package/release/\"\n            newName = 'zhuangbudong_example_' + verName + \"_\" + timeNow + \"_\" + variant.buildType.name + \".apk\" \n       } else {\n            timeNow = getDate()\n            if (variant.buildType.name.equals('debug')) { \n               newName = 'zhuangbudong_example_' + verName + \"_debug.apk\"  \n          } else { \n               newName = 'zhuangbudong_example_' + verName + \"_\" + timeNow + \"_\" + variant.buildType.name + \".apk\" \n           } \n       } \n       output.outputFile = new File(outDirectory, newName)\n    }}\n\n  }\n}\n```\n\ngradle.properties:\n\n```\nAPP_VERSION=2.0.2\nIS_JENKINS=false\nJENKINS_TIME=''\n```\n\n在工程中添加以上代码，并在Jenkins中为这些参数赋值。\n\n下面介绍 Jenkins 参数配置\n\n勾选参数化构建过程，如下图：\n![参数化构建](http://upload-images.jianshu.io/upload_images/1550996-20f69e63a527814c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n按照下图，添加相关类型的参数，此处注意，Jenkins 配置的参数名要和在android-studio中配置的参数名保持一致\n\n![JENKINS_TIME](http://upload-images.jianshu.io/upload_images/1550996-e0f4ceb7015ac0da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![APP_VERSION](http://upload-images.jianshu.io/upload_images/1550996-6e3f8d0311399d74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![IS_JENKINS](http://upload-images.jianshu.io/upload_images/1550996-673c2465bcdc9a89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![ENVIRONMENT](http://upload-images.jianshu.io/upload_images/1550996-a82221191b980ad7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 源码管理\n\n此处负责从版本库中拉去最新的代码\n\n\n![git 仓库](http://upload-images.jianshu.io/upload_images/1550996-6dcbd8dd2dd9456c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n此处如果需要验证，点击 Add， 选择： Username with password\n\n在对应窗口输入用户名和密码信息\n![用户身份验证](http://upload-images.jianshu.io/upload_images/1550996-8af978712a010864.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n点击添加。\n\n使用 gitlab 进行源码库管理。\n\n### 触发器\n\n触发器负责拉取代码，编译，打包，发布等操作。通过触发器，执行Jenkins。\n\n\n![触发器构建](http://upload-images.jianshu.io/upload_images/1550996-beb6ff8faa9843f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 构建环境\n\n此处只是在Jenkins在打包时，配置任务名称即可。如下图：\n\n![构建环境](http://upload-images.jianshu.io/upload_images/1550996-45b210c5df916dbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 构建\n\n这里是最重要滴，配置以下命令，才能进行打包签名等等。\n\n如下配置，这里需要注意下，构建文件，根目录。在你的目录结构比较复杂的时候，即你的根目录没有 build.gradle 文件时，需要指定一下 build.gradle 目录的位置。\n\n同时，也是最重要的，勾选上pass job parameters as gradle properties ，不然之前配置的参数无法传递给项目中的 gradle.properties。\n\n![构建](http://upload-images.jianshu.io/upload_images/1550996-4e4e6e139fc1e856.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 构建后操作\n\n当项目构建完成后，我们可以通过邮件的方式将产生的Apk文件，以及测试报告，构建日志等信息，发送出来 如下图：\n\n\n![邮件发送](http://upload-images.jianshu.io/upload_images/1550996-63b6bcb7b2dfd551.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\n<hr/>\n(本邮件是程序自动下发的，请勿回复！)<br/><hr/>\n项目名称：${PROJECT_NAME}<br/><hr/>\n构建编号：${BUILD_NUMBER}<br/><hr/>\n构建状态：${BUILD_STATUS}<br/><hr/>\n触发原因：${CAUSE}<br/><hr/>\n测试报告：<a href=\"${PROJECT_URL}ws/${PROJECT_NAME}app/build/reports/tests/release/index.html\">${PROJECT_URL}ws/${PROJECT_NAME}app/build/reports/tests/release/index.html</a><br/><hr/>\n构建日志地址：<a href=\"${BUILD_URL}console\">${BUILD_URL}console/</a><br/><hr/>\n构建地址：<a href=\"${PROJECT_URL}\">${PROJECT_URL}</a><br/><hr/>\n构建报告：<a href=\"${BUILD_URL}testReport\">${BUILD_URL}testReport</a><br/><hr/>\n变更集:${JELLY_SCRIPT,template=\"html\"}<br/>\n\n<hr/>\n```\n\n## 开始构建\n\n回到 Jenkins 首页，点击创建的项目，点击 build with parameters:\n\n\n![Build with Parameters](http://upload-images.jianshu.io/upload_images/1550996-58ecc4965ab845ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n点击开始构建，启动 Jenkins 构建任务。\n\n构建成功时，显示为蓝色， 失败为红色，如下图：\n\n\n![构建结果](http://upload-images.jianshu.io/upload_images/1550996-4b2fc4b1190ddcd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n构建后生成的 Apk 文件，存在 build.gradle 文件中配置的目录。同时也可以使用蒲公英或fir.im 进行发布管理。\n\n谢谢~\n\n","slug":"Jenkins-gradle-git-构建-Android-CI-构建环境","published":1,"updated":"2021-01-29T16:03:28.385Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb87j0008sz5q7mhg41dy","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在项目开发中，我们需要将最新的代码更新，提供给测试人员进行测试，以及发布。</p>\n<p>目前 Android 工作中都在使用很强大的开发、构建以及打包工具，例如： android-studio、Gradle、Git等。<br><a id=\"more\"></a><br>然，在企业组织并不是很完善的公司里，开发打包发布等工作，时常会由开发人员进行操作，难免在一些地方疏忽掉。</p>\n<p>因此，CI 构建的出现，使得这些繁琐的工作变得轻松起来。</p>\n<p>对于开发工程师，只负责向版本库提交代码，不用关心打包，发布之类的流程。</p>\n<p>对于产品和测试，只需要从发布页面下载 APK 安装文件，不需要每一次都去工程师哪里索取最新的安装文件。</p>\n<p>CI 的基本工作流程如下：<br><img src=\"http://upload-images.jianshu.io/upload_images/1550996-5101eac8d87352a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图1\"></p>\n<p>我们每一次提交代码（通过git/svn作为版本库）到主干上，根据 CI 的定时任务，检测到版本更新，通过 CI ，将进行打包发布等流程操作。</p>\n<!--more-->\n<h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><p>本文使用 Linux Ubuntu 系统为大家介绍环境的搭建</p>\n<h2 id=\"环境工具\"><a href=\"#环境工具\" class=\"headerlink\" title=\"环境工具\"></a>环境工具</h2><pre><code>1. PC 机(mac/linux)\n2. Java JDK\n3. Android SDK\n4. Gradle\n5. Git\n6. Tomcat\n7. Jenkins\n</code></pre><h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><h3 id=\"Java-环境-安装\"><a href=\"#Java-环境-安装\" class=\"headerlink\" title=\"Java 环境 安装\"></a>Java 环境 安装</h3><p>Java JDK, Android SDK, Gradle 可从<span class=\"exturl\" data-url=\"aHR0cDovL2FuZHJvaWRkZXZ0b29scy5jbg==\" title=\"http://androiddevtools.cn\">AndroidDevTools<i class=\"fa fa-external-link\"></i></span>处下载获取。</p>\n<h3 id=\"git-安装\"><a href=\"#git-安装\" class=\"headerlink\" title=\"git 安装\"></a>git 安装</h3><p>git 可通过终端进行安装</p>\n<pre><code>sudo add-apt-repository ppa:git-core/ppa\nsudo apt-get update\nsudo apt-get install git\n</code></pre><p>安装完成之后通过<code>git --version</code> 检查是否成功</p>\n<p>安装后 git 存储在 <code>/usr/bin/git</code>下</p>\n<h3 id=\"Jenkins\"><a href=\"#Jenkins\" class=\"headerlink\" title=\"Jenkins\"></a>Jenkins</h3><p>通过 Jenkins <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qZW5raW5zLmlvL2luZGV4Lmh0bWw=\" title=\"https://jenkins.io/index.html\">官方网站<i class=\"fa fa-external-link\"></i></span>下载最新Jenkins.war包</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-d2654c0a1383423a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Jenkins 下载\"></p>\n<h3 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h3><p>打开 <code>vi /etc/profile</code></p>\n<p>将下列语句添加在文件的末尾后， 执行 esc-&gt;:wq</p>\n<p>其中环境位置根据自己的所在位置进行相应的更改</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-ffd5f1b87d0e5bbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"环境变量\"></p>\n<h3 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h3><p>激动的你，是不是已经被这些繁琐的东西搞的不耐烦了呢，下面我们开始启动 Jenkins</p>\n<p>将下载好的 Jenkins.war 包， 放入 Tomcat 的 webapps 目录下，进入 bin 目录执行 ./startup.sh 启动 Tomcat。</p>\n<p>启动后，在浏览器中输入： <code>localhost:8080/jenkins</code></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-cbdb39d4f2f4a85f.png?\nimageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"jenkinsmain.png\"></p>\n<h3 id=\"插件安装\"><a href=\"#插件安装\" class=\"headerlink\" title=\"插件安装\"></a>插件安装</h3><p>系统管理-&gt; 插件管理-&gt;可选插件：</p>\n<p>在搜索框中搜索以下插件，并进行安装</p>\n<p>git plugin<br>gitlab plugin<br>grade plugin<br>Android Lint Plugin<br>Build Pipeline plugin<br>build timeout plugin<br>build name plugin<br>change assembly-version plugin<br>credentials binding plugin<br>description setter plugin<br>Dynamic parameter plugin<br>Email Extension plugin<br>FindBugs plugin<br>JaCoco plugin<br>Unit attachments plugin<br>Project Description plugin<br>Timestamper<br>Workspace cleanup plugin</p>\n<p>安装完成后，重启。</p>\n<h3 id=\"系统设置\"><a href=\"#系统设置\" class=\"headerlink\" title=\"系统设置\"></a>系统设置</h3><p>系统管理-&gt;系统设置：</p>\n<p>配置Android 环境，将地址指向本机的 SDK 目录<br><img src=\"http://upload-images.jianshu.io/upload_images/1550996-5987aabcffb290c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Android environment\"></p>\n<p>系统管理-&gt;全局工具配置</p>\n<p>配置 Java， Git ， Gradle 目录等</p>\n<p>JDK：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-b9e29a1ec2b746e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Java JDK\"></p>\n<p>Git：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-9c4e88d64fcc2ab9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"git\"></p>\n<p>Gradle：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-9fbabc7d5c7ca319.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"gradle\"></p>\n<p>到此，环境配置，已基本完成。</p>\n<p>下面我们开始进行项目够将操作</p>\n<h2 id=\"项目构建\"><a href=\"#项目构建\" class=\"headerlink\" title=\"项目构建\"></a>项目构建</h2><h3 id=\"创建Job\"><a href=\"#创建Job\" class=\"headerlink\" title=\"创建Job\"></a>创建Job</h3><p>新建-&gt;构建一个自由风格的软件项目:</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-2390d86256678c54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"创建CI工程\"></p>\n<h3 id=\"参数化构建\"><a href=\"#参数化构建\" class=\"headerlink\" title=\"参数化构建\"></a>参数化构建</h3><p>通常我们在使用 Android-studio 进行打包时以及签名时，都会用到build.gradle并在其中配置相关属性。再此，我们可以用Jenkins，配置我们的项目参数，例如发布的版本号，构建时间， 上传路径，发布地址，签名打包等等。</p>\n<p>在这里我们先看看 build.gradle 中的构建信息:</p>\n<p>在项目的 moudle 下 build.gradle 文件</p>\n<pre><code>def getDate () {\n    def date = new Date()\n    def formattedDate = date.format(&quot;yyyyMMddHHmm&quot;)\n    return formattedDate\n}\n\ndef verName = APP_VERSION\ndef verCode = 14\n\nandroid {\n    ....\n    signingConfigs {\n        release {\n          keyAlias &#39;&#39;\n          keyPassword &#39;&#39;\n          storeFile file (&#39;&#39;)\n          storePassword &#39;&#39;\n       }   \n   }\n\n  defaultConfig {\n      applicationId &quot;cn.zhuangbudong.example&quot;\n      minSdkVersion 18\n      targetSdkVersion 25\n      multiDexEnabled true\n      versionCode verCode\n      versionName verName\n\n      resValues(&quot;string&quot;, &#39;app_version&#39;, verName)\n  }\n  buildTypes {\n    release {\n      signingConfig signingConfigs.release\n      minifyEnabled false\n      proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;\n    }\n\n   lintOptions {\n    abortOnError false\n   }\n\n   dexOptions {\n      javaMaxHeapSize &#39;2g&#39;\n   }\n\napplicationVariants.all { variant -&gt;\n    variant.outputs.each { output -&gt;\n        def newName\n        def timeNow\n        def oldFile = output.outputFile\n        def outDirectory = oldFile.parent\n        if (&quot;true&quot;.equals(IS_JENKINS)) { \n            timeNow = JENKINS_TIME\n            outDirectory = &quot;/media/nexd/work/android/package/release/&quot;\n            newName = &#39;zhuangbudong_example_&#39; + verName + &quot;_&quot; + timeNow + &quot;_&quot; + variant.buildType.name + &quot;.apk&quot; \n       } else {\n            timeNow = getDate()\n            if (variant.buildType.name.equals(&#39;debug&#39;)) { \n               newName = &#39;zhuangbudong_example_&#39; + verName + &quot;_debug.apk&quot;  \n          } else { \n               newName = &#39;zhuangbudong_example_&#39; + verName + &quot;_&quot; + timeNow + &quot;_&quot; + variant.buildType.name + &quot;.apk&quot; \n           } \n       } \n       output.outputFile = new File(outDirectory, newName)\n    }}\n\n  }\n}\n</code></pre><p>gradle.properties:</p>\n<pre><code>APP_VERSION=2.0.2\nIS_JENKINS=false\nJENKINS_TIME=&#39;&#39;\n</code></pre><p>在工程中添加以上代码，并在Jenkins中为这些参数赋值。</p>\n<p>下面介绍 Jenkins 参数配置</p>\n<p>勾选参数化构建过程，如下图：<br><img src=\"http://upload-images.jianshu.io/upload_images/1550996-20f69e63a527814c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"参数化构建\"></p>\n<p>按照下图，添加相关类型的参数，此处注意，Jenkins 配置的参数名要和在android-studio中配置的参数名保持一致</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-e0f4ceb7015ac0da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"JENKINS_TIME\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1550996-6e3f8d0311399d74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"APP_VERSION\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1550996-673c2465bcdc9a89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"IS_JENKINS\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1550996-a82221191b980ad7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"ENVIRONMENT\"></p>\n<h3 id=\"源码管理\"><a href=\"#源码管理\" class=\"headerlink\" title=\"源码管理\"></a>源码管理</h3><p>此处负责从版本库中拉去最新的代码</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-6dcbd8dd2dd9456c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"git 仓库\"></p>\n<p>此处如果需要验证，点击 Add， 选择： Username with password</p>\n<p>在对应窗口输入用户名和密码信息<br><img src=\"http://upload-images.jianshu.io/upload_images/1550996-8af978712a010864.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"用户身份验证\"></p>\n<p>点击添加。</p>\n<p>使用 gitlab 进行源码库管理。</p>\n<h3 id=\"触发器\"><a href=\"#触发器\" class=\"headerlink\" title=\"触发器\"></a>触发器</h3><p>触发器负责拉取代码，编译，打包，发布等操作。通过触发器，执行Jenkins。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-beb6ff8faa9843f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"触发器构建\"></p>\n<h3 id=\"构建环境\"><a href=\"#构建环境\" class=\"headerlink\" title=\"构建环境\"></a>构建环境</h3><p>此处只是在Jenkins在打包时，配置任务名称即可。如下图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-45b210c5df916dbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"构建环境\"></p>\n<h3 id=\"构建\"><a href=\"#构建\" class=\"headerlink\" title=\"构建\"></a>构建</h3><p>这里是最重要滴，配置以下命令，才能进行打包签名等等。</p>\n<p>如下配置，这里需要注意下，构建文件，根目录。在你的目录结构比较复杂的时候，即你的根目录没有 build.gradle 文件时，需要指定一下 build.gradle 目录的位置。</p>\n<p>同时，也是最重要的，勾选上pass job parameters as gradle properties ，不然之前配置的参数无法传递给项目中的 gradle.properties。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-4e4e6e139fc1e856.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"构建\"></p>\n<h3 id=\"构建后操作\"><a href=\"#构建后操作\" class=\"headerlink\" title=\"构建后操作\"></a>构建后操作</h3><p>当项目构建完成后，我们可以通过邮件的方式将产生的Apk文件，以及测试报告，构建日志等信息，发送出来 如下图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-63b6bcb7b2dfd551.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"邮件发送\"></p>\n<pre><code>&lt;hr/&gt;\n(本邮件是程序自动下发的，请勿回复！)&lt;br/&gt;&lt;hr/&gt;\n项目名称：${PROJECT_NAME}&lt;br/&gt;&lt;hr/&gt;\n构建编号：${BUILD_NUMBER}&lt;br/&gt;&lt;hr/&gt;\n构建状态：${BUILD_STATUS}&lt;br/&gt;&lt;hr/&gt;\n触发原因：${CAUSE}&lt;br/&gt;&lt;hr/&gt;\n测试报告：&lt;a href=&quot;${PROJECT_URL}ws/${PROJECT_NAME}app/build/reports/tests/release/index.html&quot;&gt;${PROJECT_URL}ws/${PROJECT_NAME}app/build/reports/tests/release/index.html&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;\n构建日志地址：&lt;a href=&quot;${BUILD_URL}console&quot;&gt;${BUILD_URL}console/&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;\n构建地址：&lt;a href=&quot;${PROJECT_URL}&quot;&gt;${PROJECT_URL}&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;\n构建报告：&lt;a href=&quot;${BUILD_URL}testReport&quot;&gt;${BUILD_URL}testReport&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;\n变更集:${JELLY_SCRIPT,template=&quot;html&quot;}&lt;br/&gt;\n\n&lt;hr/&gt;\n</code></pre><h2 id=\"开始构建\"><a href=\"#开始构建\" class=\"headerlink\" title=\"开始构建\"></a>开始构建</h2><p>回到 Jenkins 首页，点击创建的项目，点击 build with parameters:</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-58ecc4965ab845ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Build with Parameters\"></p>\n<p>点击开始构建，启动 Jenkins 构建任务。</p>\n<p>构建成功时，显示为蓝色， 失败为红色，如下图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-4b2fc4b1190ddcd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"构建结果\"></p>\n<p>构建后生成的 Apk 文件，存在 build.gradle 文件中配置的目录。同时也可以使用蒲公英或fir.im 进行发布管理。</p>\n<p>谢谢~</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在项目开发中，我们需要将最新的代码更新，提供给测试人员进行测试，以及发布。</p>\n<p>目前 Android 工作中都在使用很强大的开发、构建以及打包工具，例如： android-studio、Gradle、Git等。<br>","more":"<br>然，在企业组织并不是很完善的公司里，开发打包发布等工作，时常会由开发人员进行操作，难免在一些地方疏忽掉。</p>\n<p>因此，CI 构建的出现，使得这些繁琐的工作变得轻松起来。</p>\n<p>对于开发工程师，只负责向版本库提交代码，不用关心打包，发布之类的流程。</p>\n<p>对于产品和测试，只需要从发布页面下载 APK 安装文件，不需要每一次都去工程师哪里索取最新的安装文件。</p>\n<p>CI 的基本工作流程如下：<br><img src=\"http://upload-images.jianshu.io/upload_images/1550996-5101eac8d87352a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图1\"></p>\n<p>我们每一次提交代码（通过git/svn作为版本库）到主干上，根据 CI 的定时任务，检测到版本更新，通过 CI ，将进行打包发布等流程操作。</p>\n<!--more-->\n<h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><p>本文使用 Linux Ubuntu 系统为大家介绍环境的搭建</p>\n<h2 id=\"环境工具\"><a href=\"#环境工具\" class=\"headerlink\" title=\"环境工具\"></a>环境工具</h2><pre><code>1. PC 机(mac/linux)\n2. Java JDK\n3. Android SDK\n4. Gradle\n5. Git\n6. Tomcat\n7. Jenkins\n</code></pre><h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><h3 id=\"Java-环境-安装\"><a href=\"#Java-环境-安装\" class=\"headerlink\" title=\"Java 环境 安装\"></a>Java 环境 安装</h3><p>Java JDK, Android SDK, Gradle 可从<span class=\"exturl\" data-url=\"aHR0cDovL2FuZHJvaWRkZXZ0b29scy5jbg==\" title=\"http://androiddevtools.cn\">AndroidDevTools<i class=\"fa fa-external-link\"></i></span>处下载获取。</p>\n<h3 id=\"git-安装\"><a href=\"#git-安装\" class=\"headerlink\" title=\"git 安装\"></a>git 安装</h3><p>git 可通过终端进行安装</p>\n<pre><code>sudo add-apt-repository ppa:git-core/ppa\nsudo apt-get update\nsudo apt-get install git\n</code></pre><p>安装完成之后通过<code>git --version</code> 检查是否成功</p>\n<p>安装后 git 存储在 <code>/usr/bin/git</code>下</p>\n<h3 id=\"Jenkins\"><a href=\"#Jenkins\" class=\"headerlink\" title=\"Jenkins\"></a>Jenkins</h3><p>通过 Jenkins <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qZW5raW5zLmlvL2luZGV4Lmh0bWw=\" title=\"https://jenkins.io/index.html\">官方网站<i class=\"fa fa-external-link\"></i></span>下载最新Jenkins.war包</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-d2654c0a1383423a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Jenkins 下载\"></p>\n<h3 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h3><p>打开 <code>vi /etc/profile</code></p>\n<p>将下列语句添加在文件的末尾后， 执行 esc-&gt;:wq</p>\n<p>其中环境位置根据自己的所在位置进行相应的更改</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-ffd5f1b87d0e5bbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"环境变量\"></p>\n<h3 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h3><p>激动的你，是不是已经被这些繁琐的东西搞的不耐烦了呢，下面我们开始启动 Jenkins</p>\n<p>将下载好的 Jenkins.war 包， 放入 Tomcat 的 webapps 目录下，进入 bin 目录执行 ./startup.sh 启动 Tomcat。</p>\n<p>启动后，在浏览器中输入： <code>localhost:8080/jenkins</code></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-cbdb39d4f2f4a85f.png?\nimageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"jenkinsmain.png\"></p>\n<h3 id=\"插件安装\"><a href=\"#插件安装\" class=\"headerlink\" title=\"插件安装\"></a>插件安装</h3><p>系统管理-&gt; 插件管理-&gt;可选插件：</p>\n<p>在搜索框中搜索以下插件，并进行安装</p>\n<p>git plugin<br>gitlab plugin<br>grade plugin<br>Android Lint Plugin<br>Build Pipeline plugin<br>build timeout plugin<br>build name plugin<br>change assembly-version plugin<br>credentials binding plugin<br>description setter plugin<br>Dynamic parameter plugin<br>Email Extension plugin<br>FindBugs plugin<br>JaCoco plugin<br>Unit attachments plugin<br>Project Description plugin<br>Timestamper<br>Workspace cleanup plugin</p>\n<p>安装完成后，重启。</p>\n<h3 id=\"系统设置\"><a href=\"#系统设置\" class=\"headerlink\" title=\"系统设置\"></a>系统设置</h3><p>系统管理-&gt;系统设置：</p>\n<p>配置Android 环境，将地址指向本机的 SDK 目录<br><img src=\"http://upload-images.jianshu.io/upload_images/1550996-5987aabcffb290c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Android environment\"></p>\n<p>系统管理-&gt;全局工具配置</p>\n<p>配置 Java， Git ， Gradle 目录等</p>\n<p>JDK：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-b9e29a1ec2b746e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Java JDK\"></p>\n<p>Git：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-9c4e88d64fcc2ab9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"git\"></p>\n<p>Gradle：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-9fbabc7d5c7ca319.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"gradle\"></p>\n<p>到此，环境配置，已基本完成。</p>\n<p>下面我们开始进行项目够将操作</p>\n<h2 id=\"项目构建\"><a href=\"#项目构建\" class=\"headerlink\" title=\"项目构建\"></a>项目构建</h2><h3 id=\"创建Job\"><a href=\"#创建Job\" class=\"headerlink\" title=\"创建Job\"></a>创建Job</h3><p>新建-&gt;构建一个自由风格的软件项目:</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-2390d86256678c54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"创建CI工程\"></p>\n<h3 id=\"参数化构建\"><a href=\"#参数化构建\" class=\"headerlink\" title=\"参数化构建\"></a>参数化构建</h3><p>通常我们在使用 Android-studio 进行打包时以及签名时，都会用到build.gradle并在其中配置相关属性。再此，我们可以用Jenkins，配置我们的项目参数，例如发布的版本号，构建时间， 上传路径，发布地址，签名打包等等。</p>\n<p>在这里我们先看看 build.gradle 中的构建信息:</p>\n<p>在项目的 moudle 下 build.gradle 文件</p>\n<pre><code>def getDate () {\n    def date = new Date()\n    def formattedDate = date.format(&quot;yyyyMMddHHmm&quot;)\n    return formattedDate\n}\n\ndef verName = APP_VERSION\ndef verCode = 14\n\nandroid {\n    ....\n    signingConfigs {\n        release {\n          keyAlias &#39;&#39;\n          keyPassword &#39;&#39;\n          storeFile file (&#39;&#39;)\n          storePassword &#39;&#39;\n       }   \n   }\n\n  defaultConfig {\n      applicationId &quot;cn.zhuangbudong.example&quot;\n      minSdkVersion 18\n      targetSdkVersion 25\n      multiDexEnabled true\n      versionCode verCode\n      versionName verName\n\n      resValues(&quot;string&quot;, &#39;app_version&#39;, verName)\n  }\n  buildTypes {\n    release {\n      signingConfig signingConfigs.release\n      minifyEnabled false\n      proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;\n    }\n\n   lintOptions {\n    abortOnError false\n   }\n\n   dexOptions {\n      javaMaxHeapSize &#39;2g&#39;\n   }\n\napplicationVariants.all { variant -&gt;\n    variant.outputs.each { output -&gt;\n        def newName\n        def timeNow\n        def oldFile = output.outputFile\n        def outDirectory = oldFile.parent\n        if (&quot;true&quot;.equals(IS_JENKINS)) { \n            timeNow = JENKINS_TIME\n            outDirectory = &quot;/media/nexd/work/android/package/release/&quot;\n            newName = &#39;zhuangbudong_example_&#39; + verName + &quot;_&quot; + timeNow + &quot;_&quot; + variant.buildType.name + &quot;.apk&quot; \n       } else {\n            timeNow = getDate()\n            if (variant.buildType.name.equals(&#39;debug&#39;)) { \n               newName = &#39;zhuangbudong_example_&#39; + verName + &quot;_debug.apk&quot;  \n          } else { \n               newName = &#39;zhuangbudong_example_&#39; + verName + &quot;_&quot; + timeNow + &quot;_&quot; + variant.buildType.name + &quot;.apk&quot; \n           } \n       } \n       output.outputFile = new File(outDirectory, newName)\n    }}\n\n  }\n}\n</code></pre><p>gradle.properties:</p>\n<pre><code>APP_VERSION=2.0.2\nIS_JENKINS=false\nJENKINS_TIME=&#39;&#39;\n</code></pre><p>在工程中添加以上代码，并在Jenkins中为这些参数赋值。</p>\n<p>下面介绍 Jenkins 参数配置</p>\n<p>勾选参数化构建过程，如下图：<br><img src=\"http://upload-images.jianshu.io/upload_images/1550996-20f69e63a527814c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"参数化构建\"></p>\n<p>按照下图，添加相关类型的参数，此处注意，Jenkins 配置的参数名要和在android-studio中配置的参数名保持一致</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-e0f4ceb7015ac0da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"JENKINS_TIME\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1550996-6e3f8d0311399d74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"APP_VERSION\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1550996-673c2465bcdc9a89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"IS_JENKINS\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1550996-a82221191b980ad7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"ENVIRONMENT\"></p>\n<h3 id=\"源码管理\"><a href=\"#源码管理\" class=\"headerlink\" title=\"源码管理\"></a>源码管理</h3><p>此处负责从版本库中拉去最新的代码</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-6dcbd8dd2dd9456c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"git 仓库\"></p>\n<p>此处如果需要验证，点击 Add， 选择： Username with password</p>\n<p>在对应窗口输入用户名和密码信息<br><img src=\"http://upload-images.jianshu.io/upload_images/1550996-8af978712a010864.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"用户身份验证\"></p>\n<p>点击添加。</p>\n<p>使用 gitlab 进行源码库管理。</p>\n<h3 id=\"触发器\"><a href=\"#触发器\" class=\"headerlink\" title=\"触发器\"></a>触发器</h3><p>触发器负责拉取代码，编译，打包，发布等操作。通过触发器，执行Jenkins。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-beb6ff8faa9843f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"触发器构建\"></p>\n<h3 id=\"构建环境\"><a href=\"#构建环境\" class=\"headerlink\" title=\"构建环境\"></a>构建环境</h3><p>此处只是在Jenkins在打包时，配置任务名称即可。如下图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-45b210c5df916dbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"构建环境\"></p>\n<h3 id=\"构建\"><a href=\"#构建\" class=\"headerlink\" title=\"构建\"></a>构建</h3><p>这里是最重要滴，配置以下命令，才能进行打包签名等等。</p>\n<p>如下配置，这里需要注意下，构建文件，根目录。在你的目录结构比较复杂的时候，即你的根目录没有 build.gradle 文件时，需要指定一下 build.gradle 目录的位置。</p>\n<p>同时，也是最重要的，勾选上pass job parameters as gradle properties ，不然之前配置的参数无法传递给项目中的 gradle.properties。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-4e4e6e139fc1e856.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"构建\"></p>\n<h3 id=\"构建后操作\"><a href=\"#构建后操作\" class=\"headerlink\" title=\"构建后操作\"></a>构建后操作</h3><p>当项目构建完成后，我们可以通过邮件的方式将产生的Apk文件，以及测试报告，构建日志等信息，发送出来 如下图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-63b6bcb7b2dfd551.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"邮件发送\"></p>\n<pre><code>&lt;hr/&gt;\n(本邮件是程序自动下发的，请勿回复！)&lt;br/&gt;&lt;hr/&gt;\n项目名称：${PROJECT_NAME}&lt;br/&gt;&lt;hr/&gt;\n构建编号：${BUILD_NUMBER}&lt;br/&gt;&lt;hr/&gt;\n构建状态：${BUILD_STATUS}&lt;br/&gt;&lt;hr/&gt;\n触发原因：${CAUSE}&lt;br/&gt;&lt;hr/&gt;\n测试报告：&lt;a href=&quot;${PROJECT_URL}ws/${PROJECT_NAME}app/build/reports/tests/release/index.html&quot;&gt;${PROJECT_URL}ws/${PROJECT_NAME}app/build/reports/tests/release/index.html&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;\n构建日志地址：&lt;a href=&quot;${BUILD_URL}console&quot;&gt;${BUILD_URL}console/&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;\n构建地址：&lt;a href=&quot;${PROJECT_URL}&quot;&gt;${PROJECT_URL}&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;\n构建报告：&lt;a href=&quot;${BUILD_URL}testReport&quot;&gt;${BUILD_URL}testReport&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;\n变更集:${JELLY_SCRIPT,template=&quot;html&quot;}&lt;br/&gt;\n\n&lt;hr/&gt;\n</code></pre><h2 id=\"开始构建\"><a href=\"#开始构建\" class=\"headerlink\" title=\"开始构建\"></a>开始构建</h2><p>回到 Jenkins 首页，点击创建的项目，点击 build with parameters:</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-58ecc4965ab845ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Build with Parameters\"></p>\n<p>点击开始构建，启动 Jenkins 构建任务。</p>\n<p>构建成功时，显示为蓝色， 失败为红色，如下图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-4b2fc4b1190ddcd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"构建结果\"></p>\n<p>构建后生成的 Apk 文件，存在 build.gradle 文件中配置的目录。同时也可以使用蒲公英或fir.im 进行发布管理。</p>\n<p>谢谢~</p>"},{"title":"Linux 下配置 Android Studio 中文输入","date":"2019-08-23T02:26:28.000Z","_content":"\n我的电脑是深度 Ubuntu， 效果和 Windows 很像，个人不喜欢 Windows 的原因很简单，盗版太多。\n\n虽然 Ubuntu 下很多软件都会受到限制，但我是一个软件工程师，常用的开发工具可以使用，就可以了。\n\n最近一直困扰我的一个问题就是， 每当我给 Android Studio 升级时，就会遇到无法输入中文的情况，每次上网查询，总是磕磕绊绊，今儿将方法记录下来，以备以后需要是好找。\n\n首先，打开 Android Studio 的文件目录 `/android-stdio/bin/` ，使用 Vi 命令打开文件 `studio.sh`，\n\n在文件的开头，输入下面这一串\n\n```\nexport XMODIFIERS=@im=fcitx\nexport QT_IM_MODULE=fcitx\nexport GTK_IM_MODULE=\"fcitx\"\n```\n然后 :wq 保存退出。\n\n接着重启 Android Studio 就可以了。\n","source":"_posts/Linux-下配置-Android-Studio-中文输入.md","raw":"---\ntitle: Linux 下配置 Android Studio 中文输入\ndate: 2019-08-23 10:26:28\ntags:\n---\n\n我的电脑是深度 Ubuntu， 效果和 Windows 很像，个人不喜欢 Windows 的原因很简单，盗版太多。\n\n虽然 Ubuntu 下很多软件都会受到限制，但我是一个软件工程师，常用的开发工具可以使用，就可以了。\n\n最近一直困扰我的一个问题就是， 每当我给 Android Studio 升级时，就会遇到无法输入中文的情况，每次上网查询，总是磕磕绊绊，今儿将方法记录下来，以备以后需要是好找。\n\n首先，打开 Android Studio 的文件目录 `/android-stdio/bin/` ，使用 Vi 命令打开文件 `studio.sh`，\n\n在文件的开头，输入下面这一串\n\n```\nexport XMODIFIERS=@im=fcitx\nexport QT_IM_MODULE=fcitx\nexport GTK_IM_MODULE=\"fcitx\"\n```\n然后 :wq 保存退出。\n\n接着重启 Android Studio 就可以了。\n","slug":"Linux-下配置-Android-Studio-中文输入","published":1,"updated":"2019-08-23T02:32:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8880009sz5qn4g5pgbp","content":"<p>我的电脑是深度 Ubuntu， 效果和 Windows 很像，个人不喜欢 Windows 的原因很简单，盗版太多。</p>\n<p>虽然 Ubuntu 下很多软件都会受到限制，但我是一个软件工程师，常用的开发工具可以使用，就可以了。</p>\n<p>最近一直困扰我的一个问题就是， 每当我给 Android Studio 升级时，就会遇到无法输入中文的情况，每次上网查询，总是磕磕绊绊，今儿将方法记录下来，以备以后需要是好找。</p>\n<p>首先，打开 Android Studio 的文件目录 <code>/android-stdio/bin/</code> ，使用 Vi 命令打开文件 <code>studio.sh</code>，</p>\n<p>在文件的开头，输入下面这一串</p>\n<pre><code>export XMODIFIERS=@im=fcitx\nexport QT_IM_MODULE=fcitx\nexport GTK_IM_MODULE=&quot;fcitx&quot;\n</code></pre><p>然后 :wq 保存退出。</p>\n<p>接着重启 Android Studio 就可以了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>我的电脑是深度 Ubuntu， 效果和 Windows 很像，个人不喜欢 Windows 的原因很简单，盗版太多。</p>\n<p>虽然 Ubuntu 下很多软件都会受到限制，但我是一个软件工程师，常用的开发工具可以使用，就可以了。</p>\n<p>最近一直困扰我的一个问题就是， 每当我给 Android Studio 升级时，就会遇到无法输入中文的情况，每次上网查询，总是磕磕绊绊，今儿将方法记录下来，以备以后需要是好找。</p>\n<p>首先，打开 Android Studio 的文件目录 <code>/android-stdio/bin/</code> ，使用 Vi 命令打开文件 <code>studio.sh</code>，</p>\n<p>在文件的开头，输入下面这一串</p>\n<pre><code>export XMODIFIERS=@im=fcitx\nexport QT_IM_MODULE=fcitx\nexport GTK_IM_MODULE=&quot;fcitx&quot;\n</code></pre><p>然后 :wq 保存退出。</p>\n<p>接着重启 Android Studio 就可以了。</p>\n"},{"title":"RecyclerView","date":"2020-07-09T12:33:30.000Z","_content":"# RechclerView 总结\n\n\n\n\n\n![image-20200709164241306](https://github.com/xiaomanwong/static_file/blob/master/images/image-20200709164241306.png?raw=true)\n\n<!-- more-->\n\nRecycler View： 负责将 Datas 展示在自己身上，其本身是一个 ViewGroup，只认识 View，因此需要一个 Adapter 来将 Datas 的内容转换为 View\n\nAdapter： 负责翻译，将 Datas 内容，转换为 View，方便 RecyclerView 展示\n\nViewHolder： RecyclerView 只会与 ViewHolder 进行交互，因此 ViewHolder 充当中间件，来将 Datas 的内容传递给  RecyclerView\n\nLayoutManager：负责布局，RecyclerView 将其子 View 的布局管理，交给它来完成\n\nRecycler：负责管理 View 的生命周期，LayoutManager 只管负责 View 的布局任务，对其回收交给了 Recycler 来处理，避免造成不必要的错误\n\nItemAnimator： 负责动画，当 RecyclerView 中的数据发生变化（增、删等）都会通过它来完成平滑的过渡\n\n<!--more-->\n\n## RecyclerView 的绘制\n\nRecyclerView 无疑也是一个 View ，View 的绘制同样逃离不了三大步骤 `onMeasure()` `onLayout()` `onDraw()` \n\n\n\n### onMeasure\n\nLayoutManager 负责 RecyclerView 的绘制，其有一个 `mAutoMeasure` 属性，用来控制是否开启自动测量，开启情况下，布局交由 `RecyclerView` 使用一套默认的测量机制；否则，自定义的 LayoutManager 需要重写 `onMeasure` 来处理自身的测量工作。\n\n\n\n* 自动测量原理：\n\n  当 RecyclerView 的宽高都为 `EXACTLY` 时， 可以直接设置对应的宽高，然后返回，结束测量\n\n  如果宽高都不时 `EXACTLY` 则会在 `onMeasure` 中开始布局的处理。\n\n  RecyclerView.State 这个类封装了当前 RecyclerView 的信息。State 中的一个变量 `mLayoutStep` 记录了 RecyclerView  当前的布局状态\n\n  * STEP_START\n  * STEP_LAYOUT\n  * STEP_ANIMATIONS\n\n  对应的， RecyclerView 的布局过程也分为三步，STEP_START 表示开始布局，对应需要调用 `dispatchLayoutStep1()` 来执行第一步布局，结束后， `mLayoutStep` 变为 STEP_LAYOUT ，表示接下来需要调用 `dispatchLayoutStep2()` 进行布局，结束后 `mLayoutStep` 变为 STEP_ANIMATIONS, 继续执行第三步 `dispatchLayoutStep3()`\n\n  * dispatchLayoutStep1:  负责记录状态\n  * dispatchLayoutStep2：负责布局\n  * dispatchLayoutStep3：与 step1 比较，根据变化来触发动画\n\n  ### onLayout\n\n  \n\n  ```java\n  protected void onLayout(boolean changed, int l int t, int r, int b) {\n      TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);\n      dispatchLayout();\n      TraceCompat.endSection();\n      mFirstLayoutComplete = true;\n  }\n  \n  void dispatchLayout() {\n      mState.mIsMeasuring = false;\n      if(mState.mLayoutStep == State.STEP_START) {\n          dispatchLayoutStep1();\n          mLayout.setExactMeasureSpecsFrom(this);\n          dispatchLayoutStep2();\n      } else if(mAdapterHelper.hasUpdates() \n                || mLayout.getWidth() != getWidth() \n                || mLayout.getHeight() != getHeight()) {\n          // first 2 steps are done in onMeasure but looks like we have to run again due to changed size\n          mLayout.setExactMeasureSpecsFrom(this);\n          dispatchLayoutStep2();\n      } else {\n          // always make sure we sync them (to ensure mode is exact)\n          mLayout.setExactMeasureSpecsFrom(this);\n      }\n      \n      dispatchLayoutStep3();\n  }\n  ```\n\n  通过 `dispatchLayout` 可以验证RecyclerView 的 layout三步走原则，如果在 `onMeasure` 中已经完成了 step1 和 step2 ，则只会执行 step3，否则，会在 `onLayout` 中依次触发三步走。\n\n  #### dispatchLayoutStep1\n\n  ```java\n  private void dispatchLayoutStep1(){\n  \tif(mState.mRunSimpleAnimations) {\n          int count = mChildHelper.getChildCount();\n          for(int i = 0; i < count; i++) {\n              final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));\n              final ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(mState, holder, ItemAnimator.buildAdapterChangeFlagsForAnimations(holder), holder.getUnmodifiedPayloads());\n              mViewInfoStore.addToPreLayout(holder, animationInfo);\n          }\n      }\n      mState.mLayoutStep = State.STEP_LAYOUT\n  }\n  ```\n\n  step 的第一步目的就是记录 View 的状态，先遍历当前所有 View，一次进行处理，mItemAnimator 会根据每个 View 的信息，封装一个 ItemHolderInfo, 这个 ItemHolderInfo 中主要包含的就是 View 的位置状态等。然后将 ItemHodlerInfo 存入 mViewInfoStore 中。在进入第二步后， View 的信息就将被改变\n\n  #### dispatchLayoutStep2\n\n  ```java\n  private void dispatchLayoutStep2(){\n      mLayout.onLayoutChildren(mRecycler, mState);\n      \n      mState.mLayoutStep = State.STATE_ANIMATIONS;\n  }\n  ```\n\n  layout 的第二步就是真正的布局 View。RecyclerView 的真正布局是由 LayoutManger 来负责的，其主要工作也在 LayoutManager 中。\n\n  ```java\n  public  void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {\n      \n      if(!mAnchorInfo.mValid \n        || mPendingScrollPosition != NO_POSITION \n        || mPendingSavedState != null) {\n          updateAnchorInfoForLayout(recycler, state, mAnchorInfo);\n      }\n      \n      if(mAnchorInfo.mLayoutFromEnd) {\n          firstLayoutDirection = mShouldReverseLayout \n              ? LayoutState.ITEM_DIRECTIONTAIL\n              : LayoutState.ITEM_DIRECTION_HEAD;\n      } else {\n          firstLayoutDirection = mShouldReverseLayout \n              ? LayoutState.ITEM_DIRECTION_HEAD\n              : LayoutState.ITEM_DIRECTION_TAIL;\n      }\n      \n      onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);\n      \n      if(mAnchorInfo.mLayoutFromEnd) {\n          \n      } else {\n          // fill towards end\n          updateLayouStateToFillEnd(mAnchorInfo);\n          fill(recycler, mLayoutState, state, false);\n          \n          // fill towards start\n          updateLayoutStateToFillStart(mAnchorInfo);\n          fill(recycler, mLayoutState, state, false);\n      }\n  }\n  ```\n\n  流程很负责，大致流程如下\n\n  * 找到 anchor点\n  * 根据 anchor 一直向前布局，直到填充满 anchor 点前面的所有区域\n  * 根据 anchor 一直向后布局，直到填充满 anchor 点后面的所有区域\n\n  anchor 点的寻找是由 `updateAnchorInfoForLayout` 函数负责。向下追踪会看到 `updateAnchorFromChildren`  方法，其内容为，先寻找被 focus 的 child， 找到以此 child 作为 anchor ，否则根据布局方向寻找最合适的 child 来作为 anchor，如果找到则将 child 的信息复制给 anchorInfo 。 `anchorInfo` 主要记录的信息就是 View 的物理位置与 Adapter 中的位置。找到后返回 true，否则返回 false，交给上一步函数做处理。\n\n  继续当找到 anchor 后，会根据 anchor 来布局，通过 fill 方法来完成\n\n  ```java\n  int fill(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.state state, boolean stopOnFocusable) {\n      final int start = layoutState.mAvailable;\n      if(layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {\n          recycleByLayoutState(recycler, layoutState);\n      }\n      \n      int remainingSpace = layoutState.mAvailable + layoutState.mExtra;\n      LayoutChunkResult layoutChunkResult = mLayoutChunkResult;\n      while((layoutState.mInfinite || remainingSpace > 0)\n           && layoutState.hasMore(state)) {\n          layoutChunk(recycler, state, layoutState, layoutChunkResult);\n      }\n      return start-layoutState.mAvailable;\n  }\n  ```\n\n  **recycleByLayoutState** 这个函数，会根据当前信息对不需要的 View 进行回收:\n\n  ```java\n  private void recycleByLayoutState(RecyclerView.Recycler recycler, LayoutState layoutState) {\n      if(layoutState.mLayoutDirection == LayoutState.LAYOUT_START) {\n          \n      } else {\n          recycleViewsFromStart(recycler, layoutState.mScrollingOffset);\n      }\n  }\n  ```\n\n  继续看 `recycleViewsFromStart`\n\n  ```java\n  private void recycleViewsFromStart(RecyclerView.Recycler recycler, int dt){\n      final int limit = dt;\n      final int childCount = getChildCount();\n      if(mShouldReverseLayout) {\n          \n      } else {\n          for(int i = 0; i < childCount; i++){\n              View child = getChildAt(i);\n              if(mOrientationHelper.getDecoratedEnd(child) > limit\n                || mOrientationHelper.getTransformedEndWithDecoration(child) > limit) {\n          recycleChildren(recycler, 0, i);\n                  return;\n              }\n          }\n      }\n  }\n  ```\n\n  该函数的作用时遍历所有的子 View ,找出逃离边界的 View 进行回收，回收函数在 `recycleChildren` 里，而这函数又调用了 `removeAndRecycleViewAt` \n\n  ```java\n  public void removeAndRecycleViewAt(int index, Recycler recycler) {\n      final View view = getChildAt(index);\n      removeViewAt(index);\n      recycler.recycleView(view);\n  }\n  ```\n\n  该函数先调用 `removeViewAt` ，将 View 从 RecyclerView 中移除，紧接着是 recycler 执行了 View 的回收逻辑。在 fill 函数的一开始会去回收逃离出屏幕的 view。\n\n  ```java\n  while((layoutState.mInfinite || remainningSpace > 0) \n       && layoutState.hasMore(state)) {\n      layoutChunk(recycler, state, layoutState, layoutChunkResult);\n  }\n  ```\n\n  只要又剩余空间，就会执行 layoutChunk 方法\n\n  ```java\n  void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State stat, LayoutState layoutState, LayoutCHunkResult result){\n      View view = layoutState.next(recycler);\n      \n      LayoutParams params = (LayoutParams) view.getLayoutParams();\n      if(layoutState.mScrapList == null) {\n          if(mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) {\n              addView(view);\n          } else {\n              addView(view, 0);\n          }\n      } else {\n          \n      }\n      \n      layoutDecoratedWithMargins(view, left, top, right, bottom);\n  }\n  ```\n\n  在 layoutState 的 next 方法返回了一个 view， 凭空变出一个 View， 很神奇\n\n  ```java\n  View next(RecyclerView.Recycler recycler ) {\n      final View view = recycler.getViewForPosition(mCurrentPosition);\n      return view;\n  }\n  ```\n\n  可见 view 的获取逻辑也是由 recycler 来负责， 所以我们只需要清楚 recycler 可以根据位置返回一个 View 即可。\n\n  我们在看 layoutChunk 对刚刚生成的 View 的处理\n\n  ```java\n  if(mShouldReverseLayout == (layoutState.mLayoutDirectoin == LayoutState.LAYOUT_STATE)) {\n      addView(view);\n  } else {\n      addView(view, 0);\n  }\n  ```\n\n  明显的调用了 addView 方法，虽然这个方法是 LayoutManager 的，但是这个方法最终会多次辗转调用到 Recycler View 的 addView 方法，将 view 添加到 RecyclerView 中。\n\n  dispatchLayoutStep2 整个布局过程，完成了对 子 View 的测量与布局\n\n  #### dispatchLayoutStep3\n\n  最后一步\n\n  ```java\n  private void dispatchLayoutStep3(){\n      mState.mLayoutStep = State.STEP_START;\n      if(mState.mRunSimpleAnimations) {\n          for(int i = mChildHelper.getChildCount() - 1; i >= 0; i--) {\n              final ItemHolderInfo animationInfo = mItemAnimator.recordPostLayoutInformation(mState, holder);\n              mViewInfoStore.addToPostLayout(holder, animationInfo);\n          }\n          \n          mViewInfoStore.process(mViewInfoProcessCallback);\n      }\n  }\n  ```\n\n  这里是与第一步呼应的，此时子 View 都已布局完成，所以子 View 的信息都发生了变化。第一步出现的 mViewInfoStore 和 mItemAnimator 再次登场，这次 mItemAnimator 调用的是 recordPostLayoutInformation 方法，而 mViewInfoStore 调用的是 addToPostLayout 方法，\n\n  ```java\n  void addToPostLayout(ViewHolder holder, ItemHolderInfo info) {\n      InfoRecord record = mLayoutHolderMap.get(holder);\n      if(record == null ) {\n          record = InfoRecord.obtain();\n          mLayoutHolderMap.put(holder, record);\n      }\n      record.postInfo = info;record.flags |= FLAT_POST;\n  }\n  ```\n\n  最后 mViewInfoStore 调用了 process 方法，根据 mViewInfoStore 中的 View 信息，来执行动画逻辑。\n\n  \n\n  ### 缓存逻辑\n\n  RecyclerView 的缓存时分为多级的，但其实真个逻辑很好理解，\n\n  ```java\n  View getViewForPosition(int position, boolean dryRun) {\n      boolean fromScrap = false;\n      ViewHolder holder = null;\n      if(mState.isPreLayout()) {\n          holder = getChangedScrapViewForPosition(position);\n  \t\tfromScrap = holder != null\n      }\n      \n      if(hoder == null) {\n          hodler = getScrapViewForPosition(position, INVALID_TYPE, dryRun);\n      }\n      \n      if(holder == null ){\n          final int offsetPosition = mAdapterHelper.findPositionOffset(position);\n          final int type = mAdapter.getItemViewType(offsetPosition);\n          if(mAdapter.hasStableIds()){\n              holder = getScrapViewForId(mAdapter.getItemId(offsetPosition), type, dryRun);\n          }\n          \n          if(holder == null && mViewCacheExtension != null) {\n              final View view = mViewCacheExtension.getViewForPositionAndType(this, position, type);\n          }\n          \n          if(holder == null) {\n              // fallback to recycler\n              holder = getRecyclerViewPool().getRecyclerView(type);\n              if(holder != null){\n                  holder.resetInternal();\n                  if(FORCE_INVALIDATE_DISPLAY_LIST){\n                      invalidateDisplayListInt(holder);\n                  }\n              }\n          } \n          \n          if(holder == null ){\n              holder = mAdapter.createViewHolder(RecyclerView.this, type);\n          }\n      }\n      \n      \n      // 生成 LayoutParams 的代码\n      return holder.itemView;\n  }\n  ```\n\n获取 View 的逻辑可以整理为\n\n* 搜索 mChangedScrap， 如果找到则返回相应的 holder\n* 搜索 mAttachedScrap与 mCachedViews， 如果找到且 holder 有效则返回相应的 holder\n* 如果设置了 mViewCacheExtension, 对其调用 getViewForPositionAndType 方法进行获取，若返回结果则生成对应的 holder\n* 搜索 mRecyclerPool, 如果找到则返回 Holder\n* 如果上述过程都没有找到对饮的 holder, 则执行 Adapter.createViewHolder(); 创建新的 ViewHolder 实例\n\n对于 View 的回收\n\n```java\nvoid recycleViewHolderInternal(ViewHolder holder ) {\n    \n    if(holder.isRecyclable()) {\n        if(!holder.hasAnyOfTheFlags(VieHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED) | ViewHolder.FLAG_UPDATE) {\n            int cachedViewSize = mCachedViews.size();\n            if(cachedViewSize >= mViewCacheMax && cachedViewSize > 0) {\n                recycleCachedViewAt(0);\n                cachedViewSize--;\n            }\n            \n            if(cachedViewSize < mViewCacheMax) {\n                mCachedViews.add(holder);\n                cached = true;\n            }\n        }\n        \n        if(!cached) {\n            addViewHolderToRecycledViewPool(holder);\n            recycled = true;\n        }\n    }\n}\n```\n\n回收没有创建复杂，只涉及到两次缓存， mCachedViews 和 mRecyclerPool , mCachedViews 相当于一个先进先出的数据结构，当有信的 View 需要缓存时，都会将新的 View 存入到 mCachedViews， 而 mCachedView  则会移除头部元素，并将头部元素存储在 mRecyclerPool 中， 即 mCachedViews 相当于一级缓存， mRecyclerPool 相当于二级缓存，。并且 mRecyclerPool  时可以多个 RecyclerView 共享的。\n\n\n\n## 与 AdapterView 比较\n\n| index |      AdapterView      |                 RecyclerView                 |\n| :---: | :-------------------: | :------------------------------------------: |\n|   1   | Simple click listener |             OnItemTouchListener              |\n|   2   |    Simple Divider     |                ItemDecoration                |\n|   3   | ListView and GridView | LinearLayoutManager<br />GridLayoutManager.. |\n|   4   |      RecyclerBin      |                   Recycler                   |\n|   5   |   Header and Footer   |               Partial refresh                |\n\n* 点击事件\n\n  ListView 原生提供了Item 点击、长安的事件，而 RecyclerView  则需要使用 onTouchListener 相对比较复杂\n\n* 分割线\n\n  ListView  可以很轻松设施 Divider 属性来显示 item 之间的分割线，\n\n  RecyclerView 需要自己实现 ItemDecoration ，两者比较，前者使用更简单，后者定制性更强\n\n* 布局类型\n\n  AdapterView 提供了 ListView 和 GridView 两种， RecyclerView 提供了 LinearLayoutManger 和 GirdLayoutManager。相比较 RecyclerView 更换布局方式更轻松，AdapterView 则需要更换一个 View。\n  \n* 缓存方式\n\n  ListView 使用了 RecyclerBin 类负责视图的缓存，RecyclerView 使用 Recycler 进行缓存，原理基本一致\n\n**不同点**\n\n* 局部刷新\n\n  ListView 中想局部刷新某个 item 需要自己来编写刷新逻辑， 而 RecyclerView 中可以通过 `notifyItemChanged(position)` 来完成，甚至可以通过 `notifyItemChanged(position, payload)` 传入一个 payload 信息来刷新单个 item 中的特定内容。\n\n* 动画\n\n  RecyclerView 内部通过 ItemAnimation 类完成了动画操作，而 ListView 做动画比较困难\n\n* 嵌套布局\n\n  RecyclerView 实现了 `NestedScrollingChild` 接口，可以和一切嵌套组件很好的工作\n\n**ListView 原生特点**\n\n* 头部与尾部支持\n\n  ListView 原生支持头部和尾部的添加，虽然 RecyclerView 可以通过定义不同的 Type 来坐支持，但实际应用中，封装不好会造成问题。因为 Adapter 中的数据位置与物理数据位置发生了偏移、\n\n* 多选\n\n  支持多选和单选的 ListView 更方便\n\n* 多数据源支持\n\n  ListView 提供了 Cursor Adapter， ArrayAdapter 可以很方便从数据库或者数组中获取数据。\n\n**总结**\n\nRecyclerView 的最大特点就是灵活，正是因为灵活，也牺牲了很多便利性，而 AdapterView 比较刻板，原生方法给与开发很多便利。\n\n\n\n","source":"_posts/RecyclerView.md","raw":"---\ntitle: RecyclerView\ndate: 2020-07-09 20:33:30\ntags:\n---\n# RechclerView 总结\n\n\n\n\n\n![image-20200709164241306](https://github.com/xiaomanwong/static_file/blob/master/images/image-20200709164241306.png?raw=true)\n\n<!-- more-->\n\nRecycler View： 负责将 Datas 展示在自己身上，其本身是一个 ViewGroup，只认识 View，因此需要一个 Adapter 来将 Datas 的内容转换为 View\n\nAdapter： 负责翻译，将 Datas 内容，转换为 View，方便 RecyclerView 展示\n\nViewHolder： RecyclerView 只会与 ViewHolder 进行交互，因此 ViewHolder 充当中间件，来将 Datas 的内容传递给  RecyclerView\n\nLayoutManager：负责布局，RecyclerView 将其子 View 的布局管理，交给它来完成\n\nRecycler：负责管理 View 的生命周期，LayoutManager 只管负责 View 的布局任务，对其回收交给了 Recycler 来处理，避免造成不必要的错误\n\nItemAnimator： 负责动画，当 RecyclerView 中的数据发生变化（增、删等）都会通过它来完成平滑的过渡\n\n<!--more-->\n\n## RecyclerView 的绘制\n\nRecyclerView 无疑也是一个 View ，View 的绘制同样逃离不了三大步骤 `onMeasure()` `onLayout()` `onDraw()` \n\n\n\n### onMeasure\n\nLayoutManager 负责 RecyclerView 的绘制，其有一个 `mAutoMeasure` 属性，用来控制是否开启自动测量，开启情况下，布局交由 `RecyclerView` 使用一套默认的测量机制；否则，自定义的 LayoutManager 需要重写 `onMeasure` 来处理自身的测量工作。\n\n\n\n* 自动测量原理：\n\n  当 RecyclerView 的宽高都为 `EXACTLY` 时， 可以直接设置对应的宽高，然后返回，结束测量\n\n  如果宽高都不时 `EXACTLY` 则会在 `onMeasure` 中开始布局的处理。\n\n  RecyclerView.State 这个类封装了当前 RecyclerView 的信息。State 中的一个变量 `mLayoutStep` 记录了 RecyclerView  当前的布局状态\n\n  * STEP_START\n  * STEP_LAYOUT\n  * STEP_ANIMATIONS\n\n  对应的， RecyclerView 的布局过程也分为三步，STEP_START 表示开始布局，对应需要调用 `dispatchLayoutStep1()` 来执行第一步布局，结束后， `mLayoutStep` 变为 STEP_LAYOUT ，表示接下来需要调用 `dispatchLayoutStep2()` 进行布局，结束后 `mLayoutStep` 变为 STEP_ANIMATIONS, 继续执行第三步 `dispatchLayoutStep3()`\n\n  * dispatchLayoutStep1:  负责记录状态\n  * dispatchLayoutStep2：负责布局\n  * dispatchLayoutStep3：与 step1 比较，根据变化来触发动画\n\n  ### onLayout\n\n  \n\n  ```java\n  protected void onLayout(boolean changed, int l int t, int r, int b) {\n      TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);\n      dispatchLayout();\n      TraceCompat.endSection();\n      mFirstLayoutComplete = true;\n  }\n  \n  void dispatchLayout() {\n      mState.mIsMeasuring = false;\n      if(mState.mLayoutStep == State.STEP_START) {\n          dispatchLayoutStep1();\n          mLayout.setExactMeasureSpecsFrom(this);\n          dispatchLayoutStep2();\n      } else if(mAdapterHelper.hasUpdates() \n                || mLayout.getWidth() != getWidth() \n                || mLayout.getHeight() != getHeight()) {\n          // first 2 steps are done in onMeasure but looks like we have to run again due to changed size\n          mLayout.setExactMeasureSpecsFrom(this);\n          dispatchLayoutStep2();\n      } else {\n          // always make sure we sync them (to ensure mode is exact)\n          mLayout.setExactMeasureSpecsFrom(this);\n      }\n      \n      dispatchLayoutStep3();\n  }\n  ```\n\n  通过 `dispatchLayout` 可以验证RecyclerView 的 layout三步走原则，如果在 `onMeasure` 中已经完成了 step1 和 step2 ，则只会执行 step3，否则，会在 `onLayout` 中依次触发三步走。\n\n  #### dispatchLayoutStep1\n\n  ```java\n  private void dispatchLayoutStep1(){\n  \tif(mState.mRunSimpleAnimations) {\n          int count = mChildHelper.getChildCount();\n          for(int i = 0; i < count; i++) {\n              final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));\n              final ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(mState, holder, ItemAnimator.buildAdapterChangeFlagsForAnimations(holder), holder.getUnmodifiedPayloads());\n              mViewInfoStore.addToPreLayout(holder, animationInfo);\n          }\n      }\n      mState.mLayoutStep = State.STEP_LAYOUT\n  }\n  ```\n\n  step 的第一步目的就是记录 View 的状态，先遍历当前所有 View，一次进行处理，mItemAnimator 会根据每个 View 的信息，封装一个 ItemHolderInfo, 这个 ItemHolderInfo 中主要包含的就是 View 的位置状态等。然后将 ItemHodlerInfo 存入 mViewInfoStore 中。在进入第二步后， View 的信息就将被改变\n\n  #### dispatchLayoutStep2\n\n  ```java\n  private void dispatchLayoutStep2(){\n      mLayout.onLayoutChildren(mRecycler, mState);\n      \n      mState.mLayoutStep = State.STATE_ANIMATIONS;\n  }\n  ```\n\n  layout 的第二步就是真正的布局 View。RecyclerView 的真正布局是由 LayoutManger 来负责的，其主要工作也在 LayoutManager 中。\n\n  ```java\n  public  void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {\n      \n      if(!mAnchorInfo.mValid \n        || mPendingScrollPosition != NO_POSITION \n        || mPendingSavedState != null) {\n          updateAnchorInfoForLayout(recycler, state, mAnchorInfo);\n      }\n      \n      if(mAnchorInfo.mLayoutFromEnd) {\n          firstLayoutDirection = mShouldReverseLayout \n              ? LayoutState.ITEM_DIRECTIONTAIL\n              : LayoutState.ITEM_DIRECTION_HEAD;\n      } else {\n          firstLayoutDirection = mShouldReverseLayout \n              ? LayoutState.ITEM_DIRECTION_HEAD\n              : LayoutState.ITEM_DIRECTION_TAIL;\n      }\n      \n      onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);\n      \n      if(mAnchorInfo.mLayoutFromEnd) {\n          \n      } else {\n          // fill towards end\n          updateLayouStateToFillEnd(mAnchorInfo);\n          fill(recycler, mLayoutState, state, false);\n          \n          // fill towards start\n          updateLayoutStateToFillStart(mAnchorInfo);\n          fill(recycler, mLayoutState, state, false);\n      }\n  }\n  ```\n\n  流程很负责，大致流程如下\n\n  * 找到 anchor点\n  * 根据 anchor 一直向前布局，直到填充满 anchor 点前面的所有区域\n  * 根据 anchor 一直向后布局，直到填充满 anchor 点后面的所有区域\n\n  anchor 点的寻找是由 `updateAnchorInfoForLayout` 函数负责。向下追踪会看到 `updateAnchorFromChildren`  方法，其内容为，先寻找被 focus 的 child， 找到以此 child 作为 anchor ，否则根据布局方向寻找最合适的 child 来作为 anchor，如果找到则将 child 的信息复制给 anchorInfo 。 `anchorInfo` 主要记录的信息就是 View 的物理位置与 Adapter 中的位置。找到后返回 true，否则返回 false，交给上一步函数做处理。\n\n  继续当找到 anchor 后，会根据 anchor 来布局，通过 fill 方法来完成\n\n  ```java\n  int fill(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.state state, boolean stopOnFocusable) {\n      final int start = layoutState.mAvailable;\n      if(layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {\n          recycleByLayoutState(recycler, layoutState);\n      }\n      \n      int remainingSpace = layoutState.mAvailable + layoutState.mExtra;\n      LayoutChunkResult layoutChunkResult = mLayoutChunkResult;\n      while((layoutState.mInfinite || remainingSpace > 0)\n           && layoutState.hasMore(state)) {\n          layoutChunk(recycler, state, layoutState, layoutChunkResult);\n      }\n      return start-layoutState.mAvailable;\n  }\n  ```\n\n  **recycleByLayoutState** 这个函数，会根据当前信息对不需要的 View 进行回收:\n\n  ```java\n  private void recycleByLayoutState(RecyclerView.Recycler recycler, LayoutState layoutState) {\n      if(layoutState.mLayoutDirection == LayoutState.LAYOUT_START) {\n          \n      } else {\n          recycleViewsFromStart(recycler, layoutState.mScrollingOffset);\n      }\n  }\n  ```\n\n  继续看 `recycleViewsFromStart`\n\n  ```java\n  private void recycleViewsFromStart(RecyclerView.Recycler recycler, int dt){\n      final int limit = dt;\n      final int childCount = getChildCount();\n      if(mShouldReverseLayout) {\n          \n      } else {\n          for(int i = 0; i < childCount; i++){\n              View child = getChildAt(i);\n              if(mOrientationHelper.getDecoratedEnd(child) > limit\n                || mOrientationHelper.getTransformedEndWithDecoration(child) > limit) {\n          recycleChildren(recycler, 0, i);\n                  return;\n              }\n          }\n      }\n  }\n  ```\n\n  该函数的作用时遍历所有的子 View ,找出逃离边界的 View 进行回收，回收函数在 `recycleChildren` 里，而这函数又调用了 `removeAndRecycleViewAt` \n\n  ```java\n  public void removeAndRecycleViewAt(int index, Recycler recycler) {\n      final View view = getChildAt(index);\n      removeViewAt(index);\n      recycler.recycleView(view);\n  }\n  ```\n\n  该函数先调用 `removeViewAt` ，将 View 从 RecyclerView 中移除，紧接着是 recycler 执行了 View 的回收逻辑。在 fill 函数的一开始会去回收逃离出屏幕的 view。\n\n  ```java\n  while((layoutState.mInfinite || remainningSpace > 0) \n       && layoutState.hasMore(state)) {\n      layoutChunk(recycler, state, layoutState, layoutChunkResult);\n  }\n  ```\n\n  只要又剩余空间，就会执行 layoutChunk 方法\n\n  ```java\n  void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State stat, LayoutState layoutState, LayoutCHunkResult result){\n      View view = layoutState.next(recycler);\n      \n      LayoutParams params = (LayoutParams) view.getLayoutParams();\n      if(layoutState.mScrapList == null) {\n          if(mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) {\n              addView(view);\n          } else {\n              addView(view, 0);\n          }\n      } else {\n          \n      }\n      \n      layoutDecoratedWithMargins(view, left, top, right, bottom);\n  }\n  ```\n\n  在 layoutState 的 next 方法返回了一个 view， 凭空变出一个 View， 很神奇\n\n  ```java\n  View next(RecyclerView.Recycler recycler ) {\n      final View view = recycler.getViewForPosition(mCurrentPosition);\n      return view;\n  }\n  ```\n\n  可见 view 的获取逻辑也是由 recycler 来负责， 所以我们只需要清楚 recycler 可以根据位置返回一个 View 即可。\n\n  我们在看 layoutChunk 对刚刚生成的 View 的处理\n\n  ```java\n  if(mShouldReverseLayout == (layoutState.mLayoutDirectoin == LayoutState.LAYOUT_STATE)) {\n      addView(view);\n  } else {\n      addView(view, 0);\n  }\n  ```\n\n  明显的调用了 addView 方法，虽然这个方法是 LayoutManager 的，但是这个方法最终会多次辗转调用到 Recycler View 的 addView 方法，将 view 添加到 RecyclerView 中。\n\n  dispatchLayoutStep2 整个布局过程，完成了对 子 View 的测量与布局\n\n  #### dispatchLayoutStep3\n\n  最后一步\n\n  ```java\n  private void dispatchLayoutStep3(){\n      mState.mLayoutStep = State.STEP_START;\n      if(mState.mRunSimpleAnimations) {\n          for(int i = mChildHelper.getChildCount() - 1; i >= 0; i--) {\n              final ItemHolderInfo animationInfo = mItemAnimator.recordPostLayoutInformation(mState, holder);\n              mViewInfoStore.addToPostLayout(holder, animationInfo);\n          }\n          \n          mViewInfoStore.process(mViewInfoProcessCallback);\n      }\n  }\n  ```\n\n  这里是与第一步呼应的，此时子 View 都已布局完成，所以子 View 的信息都发生了变化。第一步出现的 mViewInfoStore 和 mItemAnimator 再次登场，这次 mItemAnimator 调用的是 recordPostLayoutInformation 方法，而 mViewInfoStore 调用的是 addToPostLayout 方法，\n\n  ```java\n  void addToPostLayout(ViewHolder holder, ItemHolderInfo info) {\n      InfoRecord record = mLayoutHolderMap.get(holder);\n      if(record == null ) {\n          record = InfoRecord.obtain();\n          mLayoutHolderMap.put(holder, record);\n      }\n      record.postInfo = info;record.flags |= FLAT_POST;\n  }\n  ```\n\n  最后 mViewInfoStore 调用了 process 方法，根据 mViewInfoStore 中的 View 信息，来执行动画逻辑。\n\n  \n\n  ### 缓存逻辑\n\n  RecyclerView 的缓存时分为多级的，但其实真个逻辑很好理解，\n\n  ```java\n  View getViewForPosition(int position, boolean dryRun) {\n      boolean fromScrap = false;\n      ViewHolder holder = null;\n      if(mState.isPreLayout()) {\n          holder = getChangedScrapViewForPosition(position);\n  \t\tfromScrap = holder != null\n      }\n      \n      if(hoder == null) {\n          hodler = getScrapViewForPosition(position, INVALID_TYPE, dryRun);\n      }\n      \n      if(holder == null ){\n          final int offsetPosition = mAdapterHelper.findPositionOffset(position);\n          final int type = mAdapter.getItemViewType(offsetPosition);\n          if(mAdapter.hasStableIds()){\n              holder = getScrapViewForId(mAdapter.getItemId(offsetPosition), type, dryRun);\n          }\n          \n          if(holder == null && mViewCacheExtension != null) {\n              final View view = mViewCacheExtension.getViewForPositionAndType(this, position, type);\n          }\n          \n          if(holder == null) {\n              // fallback to recycler\n              holder = getRecyclerViewPool().getRecyclerView(type);\n              if(holder != null){\n                  holder.resetInternal();\n                  if(FORCE_INVALIDATE_DISPLAY_LIST){\n                      invalidateDisplayListInt(holder);\n                  }\n              }\n          } \n          \n          if(holder == null ){\n              holder = mAdapter.createViewHolder(RecyclerView.this, type);\n          }\n      }\n      \n      \n      // 生成 LayoutParams 的代码\n      return holder.itemView;\n  }\n  ```\n\n获取 View 的逻辑可以整理为\n\n* 搜索 mChangedScrap， 如果找到则返回相应的 holder\n* 搜索 mAttachedScrap与 mCachedViews， 如果找到且 holder 有效则返回相应的 holder\n* 如果设置了 mViewCacheExtension, 对其调用 getViewForPositionAndType 方法进行获取，若返回结果则生成对应的 holder\n* 搜索 mRecyclerPool, 如果找到则返回 Holder\n* 如果上述过程都没有找到对饮的 holder, 则执行 Adapter.createViewHolder(); 创建新的 ViewHolder 实例\n\n对于 View 的回收\n\n```java\nvoid recycleViewHolderInternal(ViewHolder holder ) {\n    \n    if(holder.isRecyclable()) {\n        if(!holder.hasAnyOfTheFlags(VieHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED) | ViewHolder.FLAG_UPDATE) {\n            int cachedViewSize = mCachedViews.size();\n            if(cachedViewSize >= mViewCacheMax && cachedViewSize > 0) {\n                recycleCachedViewAt(0);\n                cachedViewSize--;\n            }\n            \n            if(cachedViewSize < mViewCacheMax) {\n                mCachedViews.add(holder);\n                cached = true;\n            }\n        }\n        \n        if(!cached) {\n            addViewHolderToRecycledViewPool(holder);\n            recycled = true;\n        }\n    }\n}\n```\n\n回收没有创建复杂，只涉及到两次缓存， mCachedViews 和 mRecyclerPool , mCachedViews 相当于一个先进先出的数据结构，当有信的 View 需要缓存时，都会将新的 View 存入到 mCachedViews， 而 mCachedView  则会移除头部元素，并将头部元素存储在 mRecyclerPool 中， 即 mCachedViews 相当于一级缓存， mRecyclerPool 相当于二级缓存，。并且 mRecyclerPool  时可以多个 RecyclerView 共享的。\n\n\n\n## 与 AdapterView 比较\n\n| index |      AdapterView      |                 RecyclerView                 |\n| :---: | :-------------------: | :------------------------------------------: |\n|   1   | Simple click listener |             OnItemTouchListener              |\n|   2   |    Simple Divider     |                ItemDecoration                |\n|   3   | ListView and GridView | LinearLayoutManager<br />GridLayoutManager.. |\n|   4   |      RecyclerBin      |                   Recycler                   |\n|   5   |   Header and Footer   |               Partial refresh                |\n\n* 点击事件\n\n  ListView 原生提供了Item 点击、长安的事件，而 RecyclerView  则需要使用 onTouchListener 相对比较复杂\n\n* 分割线\n\n  ListView  可以很轻松设施 Divider 属性来显示 item 之间的分割线，\n\n  RecyclerView 需要自己实现 ItemDecoration ，两者比较，前者使用更简单，后者定制性更强\n\n* 布局类型\n\n  AdapterView 提供了 ListView 和 GridView 两种， RecyclerView 提供了 LinearLayoutManger 和 GirdLayoutManager。相比较 RecyclerView 更换布局方式更轻松，AdapterView 则需要更换一个 View。\n  \n* 缓存方式\n\n  ListView 使用了 RecyclerBin 类负责视图的缓存，RecyclerView 使用 Recycler 进行缓存，原理基本一致\n\n**不同点**\n\n* 局部刷新\n\n  ListView 中想局部刷新某个 item 需要自己来编写刷新逻辑， 而 RecyclerView 中可以通过 `notifyItemChanged(position)` 来完成，甚至可以通过 `notifyItemChanged(position, payload)` 传入一个 payload 信息来刷新单个 item 中的特定内容。\n\n* 动画\n\n  RecyclerView 内部通过 ItemAnimation 类完成了动画操作，而 ListView 做动画比较困难\n\n* 嵌套布局\n\n  RecyclerView 实现了 `NestedScrollingChild` 接口，可以和一切嵌套组件很好的工作\n\n**ListView 原生特点**\n\n* 头部与尾部支持\n\n  ListView 原生支持头部和尾部的添加，虽然 RecyclerView 可以通过定义不同的 Type 来坐支持，但实际应用中，封装不好会造成问题。因为 Adapter 中的数据位置与物理数据位置发生了偏移、\n\n* 多选\n\n  支持多选和单选的 ListView 更方便\n\n* 多数据源支持\n\n  ListView 提供了 Cursor Adapter， ArrayAdapter 可以很方便从数据库或者数组中获取数据。\n\n**总结**\n\nRecyclerView 的最大特点就是灵活，正是因为灵活，也牺牲了很多便利性，而 AdapterView 比较刻板，原生方法给与开发很多便利。\n\n\n\n","slug":"RecyclerView","published":1,"updated":"2021-01-29T16:02:52.183Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb88b000asz5qgx3xpy5g","content":"<h1 id=\"RechclerView-总结\"><a href=\"#RechclerView-总结\" class=\"headerlink\" title=\"RechclerView 总结\"></a>RechclerView 总结</h1><p><img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/image-20200709164241306.png?raw=true\" alt=\"image-20200709164241306\"></p>\n<a id=\"more\"></a>\n<p>Recycler View： 负责将 Datas 展示在自己身上，其本身是一个 ViewGroup，只认识 View，因此需要一个 Adapter 来将 Datas 的内容转换为 View</p>\n<p>Adapter： 负责翻译，将 Datas 内容，转换为 View，方便 RecyclerView 展示</p>\n<p>ViewHolder： RecyclerView 只会与 ViewHolder 进行交互，因此 ViewHolder 充当中间件，来将 Datas 的内容传递给  RecyclerView</p>\n<p>LayoutManager：负责布局，RecyclerView 将其子 View 的布局管理，交给它来完成</p>\n<p>Recycler：负责管理 View 的生命周期，LayoutManager 只管负责 View 的布局任务，对其回收交给了 Recycler 来处理，避免造成不必要的错误</p>\n<p>ItemAnimator： 负责动画，当 RecyclerView 中的数据发生变化（增、删等）都会通过它来完成平滑的过渡</p>\n<!--more-->\n<h2 id=\"RecyclerView-的绘制\"><a href=\"#RecyclerView-的绘制\" class=\"headerlink\" title=\"RecyclerView 的绘制\"></a>RecyclerView 的绘制</h2><p>RecyclerView 无疑也是一个 View ，View 的绘制同样逃离不了三大步骤 <code>onMeasure()</code> <code>onLayout()</code> <code>onDraw()</code> </p>\n<h3 id=\"onMeasure\"><a href=\"#onMeasure\" class=\"headerlink\" title=\"onMeasure\"></a>onMeasure</h3><p>LayoutManager 负责 RecyclerView 的绘制，其有一个 <code>mAutoMeasure</code> 属性，用来控制是否开启自动测量，开启情况下，布局交由 <code>RecyclerView</code> 使用一套默认的测量机制；否则，自定义的 LayoutManager 需要重写 <code>onMeasure</code> 来处理自身的测量工作。</p>\n<ul>\n<li><p>自动测量原理：</p>\n<p>当 RecyclerView 的宽高都为 <code>EXACTLY</code> 时， 可以直接设置对应的宽高，然后返回，结束测量</p>\n<p>如果宽高都不时 <code>EXACTLY</code> 则会在 <code>onMeasure</code> 中开始布局的处理。</p>\n<p>RecyclerView.State 这个类封装了当前 RecyclerView 的信息。State 中的一个变量 <code>mLayoutStep</code> 记录了 RecyclerView  当前的布局状态</p>\n<ul>\n<li>STEP_START</li>\n<li>STEP_LAYOUT</li>\n<li>STEP_ANIMATIONS</li>\n</ul>\n<p>对应的， RecyclerView 的布局过程也分为三步，STEP_START 表示开始布局，对应需要调用 <code>dispatchLayoutStep1()</code> 来执行第一步布局，结束后， <code>mLayoutStep</code> 变为 STEP_LAYOUT ，表示接下来需要调用 <code>dispatchLayoutStep2()</code> 进行布局，结束后 <code>mLayoutStep</code> 变为 STEP_ANIMATIONS, 继续执行第三步 <code>dispatchLayoutStep3()</code></p>\n<ul>\n<li>dispatchLayoutStep1:  负责记录状态</li>\n<li>dispatchLayoutStep2：负责布局</li>\n<li>dispatchLayoutStep3：与 step1 比较，根据变化来触发动画</li>\n</ul>\n<h3 id=\"onLayout\"><a href=\"#onLayout\" class=\"headerlink\" title=\"onLayout\"></a>onLayout</h3></li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\">  <span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onLayout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span> changed<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> l <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> r<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      TraceCompat<span class=\"token punctuation\">.</span><span class=\"token function\">beginSection</span><span class=\"token punctuation\">(</span>TRACE_ON_LAYOUT_TAG<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token function\">dispatchLayout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      TraceCompat<span class=\"token punctuation\">.</span><span class=\"token function\">endSection</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      mFirstLayoutComplete <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">void</span> <span class=\"token function\">dispatchLayout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      mState<span class=\"token punctuation\">.</span>mIsMeasuring <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mState<span class=\"token punctuation\">.</span>mLayoutStep <span class=\"token operator\">==</span> State<span class=\"token punctuation\">.</span>STEP_START<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">dispatchLayoutStep1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          mLayout<span class=\"token punctuation\">.</span><span class=\"token function\">setExactMeasureSpecsFrom</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token function\">dispatchLayoutStep2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mAdapterHelper<span class=\"token punctuation\">.</span><span class=\"token function\">hasUpdates</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> \n                <span class=\"token operator\">||</span> mLayout<span class=\"token punctuation\">.</span><span class=\"token function\">getWidth</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token function\">getWidth</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> \n                <span class=\"token operator\">||</span> mLayout<span class=\"token punctuation\">.</span><span class=\"token function\">getHeight</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token function\">getHeight</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\" spellcheck=\"true\">// first 2 steps are done in onMeasure but looks like we have to run again due to changed size</span>\n          mLayout<span class=\"token punctuation\">.</span><span class=\"token function\">setExactMeasureSpecsFrom</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token function\">dispatchLayoutStep2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\" spellcheck=\"true\">// always make sure we sync them (to ensure mode is exact)</span>\n          mLayout<span class=\"token punctuation\">.</span><span class=\"token function\">setExactMeasureSpecsFrom</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token function\">dispatchLayoutStep3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>  通过 <code>dispatchLayout</code> 可以验证RecyclerView 的 layout三步走原则，如果在 <code>onMeasure</code> 中已经完成了 step1 和 step2 ，则只会执行 step3，否则，会在 <code>onLayout</code> 中依次触发三步走。</p>\n<h4 id=\"dispatchLayoutStep1\"><a href=\"#dispatchLayoutStep1\" class=\"headerlink\" title=\"dispatchLayoutStep1\"></a>dispatchLayoutStep1</h4><pre class=\" language-java\"><code class=\"language-java\">  <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">dispatchLayoutStep1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mState<span class=\"token punctuation\">.</span>mRunSimpleAnimations<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> mChildHelper<span class=\"token punctuation\">.</span><span class=\"token function\">getChildCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> count<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token keyword\">final</span> ViewHolder holder <span class=\"token operator\">=</span> <span class=\"token function\">getChildViewHolderInt</span><span class=\"token punctuation\">(</span>mChildHelper<span class=\"token punctuation\">.</span><span class=\"token function\">getChildAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              <span class=\"token keyword\">final</span> ItemHolderInfo animationInfo <span class=\"token operator\">=</span> mItemAnimator<span class=\"token punctuation\">.</span><span class=\"token function\">recordPreLayoutInformation</span><span class=\"token punctuation\">(</span>mState<span class=\"token punctuation\">,</span> holder<span class=\"token punctuation\">,</span> ItemAnimator<span class=\"token punctuation\">.</span><span class=\"token function\">buildAdapterChangeFlagsForAnimations</span><span class=\"token punctuation\">(</span>holder<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> holder<span class=\"token punctuation\">.</span><span class=\"token function\">getUnmodifiedPayloads</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              mViewInfoStore<span class=\"token punctuation\">.</span><span class=\"token function\">addToPreLayout</span><span class=\"token punctuation\">(</span>holder<span class=\"token punctuation\">,</span> animationInfo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n      mState<span class=\"token punctuation\">.</span>mLayoutStep <span class=\"token operator\">=</span> State<span class=\"token punctuation\">.</span>STEP_LAYOUT\n  <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>  step 的第一步目的就是记录 View 的状态，先遍历当前所有 View，一次进行处理，mItemAnimator 会根据每个 View 的信息，封装一个 ItemHolderInfo, 这个 ItemHolderInfo 中主要包含的就是 View 的位置状态等。然后将 ItemHodlerInfo 存入 mViewInfoStore 中。在进入第二步后， View 的信息就将被改变</p>\n<h4 id=\"dispatchLayoutStep2\"><a href=\"#dispatchLayoutStep2\" class=\"headerlink\" title=\"dispatchLayoutStep2\"></a>dispatchLayoutStep2</h4><pre class=\" language-java\"><code class=\"language-java\">  <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">dispatchLayoutStep2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      mLayout<span class=\"token punctuation\">.</span><span class=\"token function\">onLayoutChildren</span><span class=\"token punctuation\">(</span>mRecycler<span class=\"token punctuation\">,</span> mState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      mState<span class=\"token punctuation\">.</span>mLayoutStep <span class=\"token operator\">=</span> State<span class=\"token punctuation\">.</span>STATE_ANIMATIONS<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>  layout 的第二步就是真正的布局 View。RecyclerView 的真正布局是由 LayoutManger 来负责的，其主要工作也在 LayoutManager 中。</p>\n<pre class=\" language-java\"><code class=\"language-java\">  <span class=\"token keyword\">public</span>  <span class=\"token keyword\">void</span> <span class=\"token function\">onLayoutChildren</span><span class=\"token punctuation\">(</span>RecyclerView<span class=\"token punctuation\">.</span>Recycler recycler<span class=\"token punctuation\">,</span> RecyclerView<span class=\"token punctuation\">.</span>State state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>mAnchorInfo<span class=\"token punctuation\">.</span>mValid \n        <span class=\"token operator\">||</span> mPendingScrollPosition <span class=\"token operator\">!=</span> NO_POSITION \n        <span class=\"token operator\">||</span> mPendingSavedState <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">updateAnchorInfoForLayout</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">,</span> mAnchorInfo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mAnchorInfo<span class=\"token punctuation\">.</span>mLayoutFromEnd<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          firstLayoutDirection <span class=\"token operator\">=</span> mShouldReverseLayout \n              <span class=\"token operator\">?</span> LayoutState<span class=\"token punctuation\">.</span>ITEM_DIRECTIONTAIL\n              <span class=\"token operator\">:</span> LayoutState<span class=\"token punctuation\">.</span>ITEM_DIRECTION_HEAD<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n          firstLayoutDirection <span class=\"token operator\">=</span> mShouldReverseLayout \n              <span class=\"token operator\">?</span> LayoutState<span class=\"token punctuation\">.</span>ITEM_DIRECTION_HEAD\n              <span class=\"token operator\">:</span> LayoutState<span class=\"token punctuation\">.</span>ITEM_DIRECTION_TAIL<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token function\">onAnchorReady</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">,</span> mAnchorInfo<span class=\"token punctuation\">,</span> firstLayoutDirection<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mAnchorInfo<span class=\"token punctuation\">.</span>mLayoutFromEnd<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\" spellcheck=\"true\">// fill towards end</span>\n          <span class=\"token function\">updateLayouStateToFillEnd</span><span class=\"token punctuation\">(</span>mAnchorInfo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token function\">fill</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">,</span> mLayoutState<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n          <span class=\"token comment\" spellcheck=\"true\">// fill towards start</span>\n          <span class=\"token function\">updateLayoutStateToFillStart</span><span class=\"token punctuation\">(</span>mAnchorInfo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token function\">fill</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">,</span> mLayoutState<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>  流程很负责，大致流程如下</p>\n<ul>\n<li>找到 anchor点</li>\n<li>根据 anchor 一直向前布局，直到填充满 anchor 点前面的所有区域</li>\n<li><p>根据 anchor 一直向后布局，直到填充满 anchor 点后面的所有区域</p>\n<p>anchor 点的寻找是由 <code>updateAnchorInfoForLayout</code> 函数负责。向下追踪会看到 <code>updateAnchorFromChildren</code>  方法，其内容为，先寻找被 focus 的 child， 找到以此 child 作为 anchor ，否则根据布局方向寻找最合适的 child 来作为 anchor，如果找到则将 child 的信息复制给 anchorInfo 。 <code>anchorInfo</code> 主要记录的信息就是 View 的物理位置与 Adapter 中的位置。找到后返回 true，否则返回 false，交给上一步函数做处理。</p>\n<p>继续当找到 anchor 后，会根据 anchor 来布局，通过 fill 方法来完成</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> <span class=\"token function\">fill</span><span class=\"token punctuation\">(</span>RecyclerView<span class=\"token punctuation\">.</span>Recycler recycler<span class=\"token punctuation\">,</span> LayoutState layoutState<span class=\"token punctuation\">,</span> RecyclerView<span class=\"token punctuation\">.</span>state state<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> stopOnFocusable<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> start <span class=\"token operator\">=</span> layoutState<span class=\"token punctuation\">.</span>mAvailable<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>layoutState<span class=\"token punctuation\">.</span>mScrollingOffset <span class=\"token operator\">!=</span> LayoutState<span class=\"token punctuation\">.</span>SCROLLING_OFFSET_NaN<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">recycleByLayoutState</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">,</span> layoutState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">int</span> remainingSpace <span class=\"token operator\">=</span> layoutState<span class=\"token punctuation\">.</span>mAvailable <span class=\"token operator\">+</span> layoutState<span class=\"token punctuation\">.</span>mExtra<span class=\"token punctuation\">;</span>\n  LayoutChunkResult layoutChunkResult <span class=\"token operator\">=</span> mLayoutChunkResult<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>layoutState<span class=\"token punctuation\">.</span>mInfinite <span class=\"token operator\">||</span> remainingSpace <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n       <span class=\"token operator\">&amp;&amp;</span> layoutState<span class=\"token punctuation\">.</span><span class=\"token function\">hasMore</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">layoutChunk</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">,</span> layoutState<span class=\"token punctuation\">,</span> layoutChunkResult<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> start<span class=\"token operator\">-</span>layoutState<span class=\"token punctuation\">.</span>mAvailable<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>recycleByLayoutState</strong> 这个函数，会根据当前信息对不需要的 View 进行回收:</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">recycleByLayoutState</span><span class=\"token punctuation\">(</span>RecyclerView<span class=\"token punctuation\">.</span>Recycler recycler<span class=\"token punctuation\">,</span> LayoutState layoutState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>layoutState<span class=\"token punctuation\">.</span>mLayoutDirection <span class=\"token operator\">==</span> LayoutState<span class=\"token punctuation\">.</span>LAYOUT_START<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">recycleViewsFromStart</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">,</span> layoutState<span class=\"token punctuation\">.</span>mScrollingOffset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>继续看 <code>recycleViewsFromStart</code></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">recycleViewsFromStart</span><span class=\"token punctuation\">(</span>RecyclerView<span class=\"token punctuation\">.</span>Recycler recycler<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> dt<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> limit <span class=\"token operator\">=</span> dt<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> childCount <span class=\"token operator\">=</span> <span class=\"token function\">getChildCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mShouldReverseLayout<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> childCount<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n          View child <span class=\"token operator\">=</span> <span class=\"token function\">getChildAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mOrientationHelper<span class=\"token punctuation\">.</span><span class=\"token function\">getDecoratedEnd</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> limit\n            <span class=\"token operator\">||</span> mOrientationHelper<span class=\"token punctuation\">.</span><span class=\"token function\">getTransformedEndWithDecoration</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> limit<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">recycleChildren</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>该函数的作用时遍历所有的子 View ,找出逃离边界的 View 进行回收，回收函数在 <code>recycleChildren</code> 里，而这函数又调用了 <code>removeAndRecycleViewAt</code> </p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">removeAndRecycleViewAt</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> index<span class=\"token punctuation\">,</span> Recycler recycler<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">final</span> View view <span class=\"token operator\">=</span> <span class=\"token function\">getChildAt</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">removeViewAt</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  recycler<span class=\"token punctuation\">.</span><span class=\"token function\">recycleView</span><span class=\"token punctuation\">(</span>view<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>该函数先调用 <code>removeViewAt</code> ，将 View 从 RecyclerView 中移除，紧接着是 recycler 执行了 View 的回收逻辑。在 fill 函数的一开始会去回收逃离出屏幕的 view。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>layoutState<span class=\"token punctuation\">.</span>mInfinite <span class=\"token operator\">||</span> remainningSpace <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> \n   <span class=\"token operator\">&amp;&amp;</span> layoutState<span class=\"token punctuation\">.</span><span class=\"token function\">hasMore</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">layoutChunk</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">,</span> layoutState<span class=\"token punctuation\">,</span> layoutChunkResult<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>只要又剩余空间，就会执行 layoutChunk 方法</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">void</span> <span class=\"token function\">layoutChunk</span><span class=\"token punctuation\">(</span>RecyclerView<span class=\"token punctuation\">.</span>Recycler recycler<span class=\"token punctuation\">,</span> RecyclerView<span class=\"token punctuation\">.</span>State stat<span class=\"token punctuation\">,</span> LayoutState layoutState<span class=\"token punctuation\">,</span> LayoutCHunkResult result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  View view <span class=\"token operator\">=</span> layoutState<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  LayoutParams params <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>LayoutParams<span class=\"token punctuation\">)</span> view<span class=\"token punctuation\">.</span><span class=\"token function\">getLayoutParams</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>layoutState<span class=\"token punctuation\">.</span>mScrapList <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mShouldReverseLayout <span class=\"token operator\">==</span> <span class=\"token punctuation\">(</span>layoutState<span class=\"token punctuation\">.</span>mLayoutDirection <span class=\"token operator\">==</span> LayoutState<span class=\"token punctuation\">.</span>LAYOUT_START<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">addView</span><span class=\"token punctuation\">(</span>view<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">addView</span><span class=\"token punctuation\">(</span>view<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">layoutDecoratedWithMargins</span><span class=\"token punctuation\">(</span>view<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> top<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">,</span> bottom<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>在 layoutState 的 next 方法返回了一个 view， 凭空变出一个 View， 很神奇</p>\n<pre class=\" language-java\"><code class=\"language-java\">View <span class=\"token function\">next</span><span class=\"token punctuation\">(</span>RecyclerView<span class=\"token punctuation\">.</span>Recycler recycler <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">final</span> View view <span class=\"token operator\">=</span> recycler<span class=\"token punctuation\">.</span><span class=\"token function\">getViewForPosition</span><span class=\"token punctuation\">(</span>mCurrentPosition<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> view<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>可见 view 的获取逻辑也是由 recycler 来负责， 所以我们只需要清楚 recycler 可以根据位置返回一个 View 即可。</p>\n<p>我们在看 layoutChunk 对刚刚生成的 View 的处理</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mShouldReverseLayout <span class=\"token operator\">==</span> <span class=\"token punctuation\">(</span>layoutState<span class=\"token punctuation\">.</span>mLayoutDirectoin <span class=\"token operator\">==</span> LayoutState<span class=\"token punctuation\">.</span>LAYOUT_STATE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">addView</span><span class=\"token punctuation\">(</span>view<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">addView</span><span class=\"token punctuation\">(</span>view<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>明显的调用了 addView 方法，虽然这个方法是 LayoutManager 的，但是这个方法最终会多次辗转调用到 Recycler View 的 addView 方法，将 view 添加到 RecyclerView 中。</p>\n<p>dispatchLayoutStep2 整个布局过程，完成了对 子 View 的测量与布局</p>\n<h4 id=\"dispatchLayoutStep3\"><a href=\"#dispatchLayoutStep3\" class=\"headerlink\" title=\"dispatchLayoutStep3\"></a>dispatchLayoutStep3</h4><p>最后一步</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">dispatchLayoutStep3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  mState<span class=\"token punctuation\">.</span>mLayoutStep <span class=\"token operator\">=</span> State<span class=\"token punctuation\">.</span>STEP_START<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mState<span class=\"token punctuation\">.</span>mRunSimpleAnimations<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> mChildHelper<span class=\"token punctuation\">.</span><span class=\"token function\">getChildCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">final</span> ItemHolderInfo animationInfo <span class=\"token operator\">=</span> mItemAnimator<span class=\"token punctuation\">.</span><span class=\"token function\">recordPostLayoutInformation</span><span class=\"token punctuation\">(</span>mState<span class=\"token punctuation\">,</span> holder<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          mViewInfoStore<span class=\"token punctuation\">.</span><span class=\"token function\">addToPostLayout</span><span class=\"token punctuation\">(</span>holder<span class=\"token punctuation\">,</span> animationInfo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      mViewInfoStore<span class=\"token punctuation\">.</span><span class=\"token function\">process</span><span class=\"token punctuation\">(</span>mViewInfoProcessCallback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>这里是与第一步呼应的，此时子 View 都已布局完成，所以子 View 的信息都发生了变化。第一步出现的 mViewInfoStore 和 mItemAnimator 再次登场，这次 mItemAnimator 调用的是 recordPostLayoutInformation 方法，而 mViewInfoStore 调用的是 addToPostLayout 方法，</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">void</span> <span class=\"token function\">addToPostLayout</span><span class=\"token punctuation\">(</span>ViewHolder holder<span class=\"token punctuation\">,</span> ItemHolderInfo info<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  InfoRecord record <span class=\"token operator\">=</span> mLayoutHolderMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>holder<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>record <span class=\"token operator\">==</span> null <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      record <span class=\"token operator\">=</span> InfoRecord<span class=\"token punctuation\">.</span><span class=\"token function\">obtain</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      mLayoutHolderMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>holder<span class=\"token punctuation\">,</span> record<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  record<span class=\"token punctuation\">.</span>postInfo <span class=\"token operator\">=</span> info<span class=\"token punctuation\">;</span>record<span class=\"token punctuation\">.</span>flags <span class=\"token operator\">|=</span> FLAT_POST<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>最后 mViewInfoStore 调用了 process 方法，根据 mViewInfoStore 中的 View 信息，来执行动画逻辑。</p>\n</li>\n</ul>\n<h3 id=\"缓存逻辑\"><a href=\"#缓存逻辑\" class=\"headerlink\" title=\"缓存逻辑\"></a>缓存逻辑</h3><p>  RecyclerView 的缓存时分为多级的，但其实真个逻辑很好理解，</p>\n<pre class=\" language-java\"><code class=\"language-java\">  View <span class=\"token function\">getViewForPosition</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> position<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> dryRun<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">boolean</span> fromScrap <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n      ViewHolder holder <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mState<span class=\"token punctuation\">.</span><span class=\"token function\">isPreLayout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          holder <span class=\"token operator\">=</span> <span class=\"token function\">getChangedScrapViewForPosition</span><span class=\"token punctuation\">(</span>position<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          fromScrap <span class=\"token operator\">=</span> holder <span class=\"token operator\">!=</span> null\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>hoder <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          hodler <span class=\"token operator\">=</span> <span class=\"token function\">getScrapViewForPosition</span><span class=\"token punctuation\">(</span>position<span class=\"token punctuation\">,</span> INVALID_TYPE<span class=\"token punctuation\">,</span> dryRun<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>holder <span class=\"token operator\">==</span> null <span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> offsetPosition <span class=\"token operator\">=</span> mAdapterHelper<span class=\"token punctuation\">.</span><span class=\"token function\">findPositionOffset</span><span class=\"token punctuation\">(</span>position<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> type <span class=\"token operator\">=</span> mAdapter<span class=\"token punctuation\">.</span><span class=\"token function\">getItemViewType</span><span class=\"token punctuation\">(</span>offsetPosition<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mAdapter<span class=\"token punctuation\">.</span><span class=\"token function\">hasStableIds</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n              holder <span class=\"token operator\">=</span> <span class=\"token function\">getScrapViewForId</span><span class=\"token punctuation\">(</span>mAdapter<span class=\"token punctuation\">.</span><span class=\"token function\">getItemId</span><span class=\"token punctuation\">(</span>offsetPosition<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">,</span> dryRun<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n\n          <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>holder <span class=\"token operator\">==</span> null <span class=\"token operator\">&amp;&amp;</span> mViewCacheExtension <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token keyword\">final</span> View view <span class=\"token operator\">=</span> mViewCacheExtension<span class=\"token punctuation\">.</span><span class=\"token function\">getViewForPositionAndType</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> position<span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n\n          <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>holder <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token comment\" spellcheck=\"true\">// fallback to recycler</span>\n              holder <span class=\"token operator\">=</span> <span class=\"token function\">getRecyclerViewPool</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getRecyclerView</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>holder <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                  holder<span class=\"token punctuation\">.</span><span class=\"token function\">resetInternal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>FORCE_INVALIDATE_DISPLAY_LIST<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                      <span class=\"token function\">invalidateDisplayListInt</span><span class=\"token punctuation\">(</span>holder<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                  <span class=\"token punctuation\">}</span>\n              <span class=\"token punctuation\">}</span>\n          <span class=\"token punctuation\">}</span> \n\n          <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>holder <span class=\"token operator\">==</span> null <span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n              holder <span class=\"token operator\">=</span> mAdapter<span class=\"token punctuation\">.</span><span class=\"token function\">createViewHolder</span><span class=\"token punctuation\">(</span>RecyclerView<span class=\"token punctuation\">.</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n\n\n      <span class=\"token comment\" spellcheck=\"true\">// 生成 LayoutParams 的代码</span>\n      <span class=\"token keyword\">return</span> holder<span class=\"token punctuation\">.</span>itemView<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>获取 View 的逻辑可以整理为</p>\n<ul>\n<li>搜索 mChangedScrap， 如果找到则返回相应的 holder</li>\n<li>搜索 mAttachedScrap与 mCachedViews， 如果找到且 holder 有效则返回相应的 holder</li>\n<li>如果设置了 mViewCacheExtension, 对其调用 getViewForPositionAndType 方法进行获取，若返回结果则生成对应的 holder</li>\n<li>搜索 mRecyclerPool, 如果找到则返回 Holder</li>\n<li>如果上述过程都没有找到对饮的 holder, 则执行 Adapter.createViewHolder(); 创建新的 ViewHolder 实例</li>\n</ul>\n<p>对于 View 的回收</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">void</span> <span class=\"token function\">recycleViewHolderInternal</span><span class=\"token punctuation\">(</span>ViewHolder holder <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>holder<span class=\"token punctuation\">.</span><span class=\"token function\">isRecyclable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>holder<span class=\"token punctuation\">.</span><span class=\"token function\">hasAnyOfTheFlags</span><span class=\"token punctuation\">(</span>VieHolder<span class=\"token punctuation\">.</span>FLAG_INVALID <span class=\"token operator\">|</span> ViewHolder<span class=\"token punctuation\">.</span>FLAG_REMOVED<span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span> ViewHolder<span class=\"token punctuation\">.</span>FLAG_UPDATE<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> cachedViewSize <span class=\"token operator\">=</span> mCachedViews<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>cachedViewSize <span class=\"token operator\">>=</span> mViewCacheMax <span class=\"token operator\">&amp;&amp;</span> cachedViewSize <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">recycleCachedViewAt</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                cachedViewSize<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>cachedViewSize <span class=\"token operator\">&lt;</span> mViewCacheMax<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                mCachedViews<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>holder<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                cached <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>cached<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">addViewHolderToRecycledViewPool</span><span class=\"token punctuation\">(</span>holder<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            recycled <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>回收没有创建复杂，只涉及到两次缓存， mCachedViews 和 mRecyclerPool , mCachedViews 相当于一个先进先出的数据结构，当有信的 View 需要缓存时，都会将新的 View 存入到 mCachedViews， 而 mCachedView  则会移除头部元素，并将头部元素存储在 mRecyclerPool 中， 即 mCachedViews 相当于一级缓存， mRecyclerPool 相当于二级缓存，。并且 mRecyclerPool  时可以多个 RecyclerView 共享的。</p>\n<h2 id=\"与-AdapterView-比较\"><a href=\"#与-AdapterView-比较\" class=\"headerlink\" title=\"与 AdapterView 比较\"></a>与 AdapterView 比较</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">index</th>\n<th style=\"text-align:center\">AdapterView</th>\n<th style=\"text-align:center\">RecyclerView</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">Simple click listener</td>\n<td style=\"text-align:center\">OnItemTouchListener</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">Simple Divider</td>\n<td style=\"text-align:center\">ItemDecoration</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">ListView and GridView</td>\n<td style=\"text-align:center\">LinearLayoutManager<br>GridLayoutManager..</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">RecyclerBin</td>\n<td style=\"text-align:center\">Recycler</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">Header and Footer</td>\n<td style=\"text-align:center\">Partial refresh</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>点击事件</p>\n<p>ListView 原生提供了Item 点击、长安的事件，而 RecyclerView  则需要使用 onTouchListener 相对比较复杂</p>\n</li>\n<li><p>分割线</p>\n<p>ListView  可以很轻松设施 Divider 属性来显示 item 之间的分割线，</p>\n<p>RecyclerView 需要自己实现 ItemDecoration ，两者比较，前者使用更简单，后者定制性更强</p>\n</li>\n<li><p>布局类型</p>\n<p>AdapterView 提供了 ListView 和 GridView 两种， RecyclerView 提供了 LinearLayoutManger 和 GirdLayoutManager。相比较 RecyclerView 更换布局方式更轻松，AdapterView 则需要更换一个 View。</p>\n</li>\n<li><p>缓存方式</p>\n<p>ListView 使用了 RecyclerBin 类负责视图的缓存，RecyclerView 使用 Recycler 进行缓存，原理基本一致</p>\n</li>\n</ul>\n<p><strong>不同点</strong></p>\n<ul>\n<li><p>局部刷新</p>\n<p>ListView 中想局部刷新某个 item 需要自己来编写刷新逻辑， 而 RecyclerView 中可以通过 <code>notifyItemChanged(position)</code> 来完成，甚至可以通过 <code>notifyItemChanged(position, payload)</code> 传入一个 payload 信息来刷新单个 item 中的特定内容。</p>\n</li>\n<li><p>动画</p>\n<p>RecyclerView 内部通过 ItemAnimation 类完成了动画操作，而 ListView 做动画比较困难</p>\n</li>\n<li><p>嵌套布局</p>\n<p>RecyclerView 实现了 <code>NestedScrollingChild</code> 接口，可以和一切嵌套组件很好的工作</p>\n</li>\n</ul>\n<p><strong>ListView 原生特点</strong></p>\n<ul>\n<li><p>头部与尾部支持</p>\n<p>ListView 原生支持头部和尾部的添加，虽然 RecyclerView 可以通过定义不同的 Type 来坐支持，但实际应用中，封装不好会造成问题。因为 Adapter 中的数据位置与物理数据位置发生了偏移、</p>\n</li>\n<li><p>多选</p>\n<p>支持多选和单选的 ListView 更方便</p>\n</li>\n<li><p>多数据源支持</p>\n<p>ListView 提供了 Cursor Adapter， ArrayAdapter 可以很方便从数据库或者数组中获取数据。</p>\n</li>\n</ul>\n<p><strong>总结</strong></p>\n<p>RecyclerView 的最大特点就是灵活，正是因为灵活，也牺牲了很多便利性，而 AdapterView 比较刻板，原生方法给与开发很多便利。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"RechclerView-总结\"><a href=\"#RechclerView-总结\" class=\"headerlink\" title=\"RechclerView 总结\"></a>RechclerView 总结</h1><p><img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/image-20200709164241306.png?raw=true\" alt=\"image-20200709164241306\"></p>","more":"<p>Recycler View： 负责将 Datas 展示在自己身上，其本身是一个 ViewGroup，只认识 View，因此需要一个 Adapter 来将 Datas 的内容转换为 View</p>\n<p>Adapter： 负责翻译，将 Datas 内容，转换为 View，方便 RecyclerView 展示</p>\n<p>ViewHolder： RecyclerView 只会与 ViewHolder 进行交互，因此 ViewHolder 充当中间件，来将 Datas 的内容传递给  RecyclerView</p>\n<p>LayoutManager：负责布局，RecyclerView 将其子 View 的布局管理，交给它来完成</p>\n<p>Recycler：负责管理 View 的生命周期，LayoutManager 只管负责 View 的布局任务，对其回收交给了 Recycler 来处理，避免造成不必要的错误</p>\n<p>ItemAnimator： 负责动画，当 RecyclerView 中的数据发生变化（增、删等）都会通过它来完成平滑的过渡</p>\n<!--more-->\n<h2 id=\"RecyclerView-的绘制\"><a href=\"#RecyclerView-的绘制\" class=\"headerlink\" title=\"RecyclerView 的绘制\"></a>RecyclerView 的绘制</h2><p>RecyclerView 无疑也是一个 View ，View 的绘制同样逃离不了三大步骤 <code>onMeasure()</code> <code>onLayout()</code> <code>onDraw()</code> </p>\n<h3 id=\"onMeasure\"><a href=\"#onMeasure\" class=\"headerlink\" title=\"onMeasure\"></a>onMeasure</h3><p>LayoutManager 负责 RecyclerView 的绘制，其有一个 <code>mAutoMeasure</code> 属性，用来控制是否开启自动测量，开启情况下，布局交由 <code>RecyclerView</code> 使用一套默认的测量机制；否则，自定义的 LayoutManager 需要重写 <code>onMeasure</code> 来处理自身的测量工作。</p>\n<ul>\n<li><p>自动测量原理：</p>\n<p>当 RecyclerView 的宽高都为 <code>EXACTLY</code> 时， 可以直接设置对应的宽高，然后返回，结束测量</p>\n<p>如果宽高都不时 <code>EXACTLY</code> 则会在 <code>onMeasure</code> 中开始布局的处理。</p>\n<p>RecyclerView.State 这个类封装了当前 RecyclerView 的信息。State 中的一个变量 <code>mLayoutStep</code> 记录了 RecyclerView  当前的布局状态</p>\n<ul>\n<li>STEP_START</li>\n<li>STEP_LAYOUT</li>\n<li>STEP_ANIMATIONS</li>\n</ul>\n<p>对应的， RecyclerView 的布局过程也分为三步，STEP_START 表示开始布局，对应需要调用 <code>dispatchLayoutStep1()</code> 来执行第一步布局，结束后， <code>mLayoutStep</code> 变为 STEP_LAYOUT ，表示接下来需要调用 <code>dispatchLayoutStep2()</code> 进行布局，结束后 <code>mLayoutStep</code> 变为 STEP_ANIMATIONS, 继续执行第三步 <code>dispatchLayoutStep3()</code></p>\n<ul>\n<li>dispatchLayoutStep1:  负责记录状态</li>\n<li>dispatchLayoutStep2：负责布局</li>\n<li>dispatchLayoutStep3：与 step1 比较，根据变化来触发动画</li>\n</ul>\n<h3 id=\"onLayout\"><a href=\"#onLayout\" class=\"headerlink\" title=\"onLayout\"></a>onLayout</h3></li>\n</ul>\n<pre><code class=\"java\">  protected void onLayout(boolean changed, int l int t, int r, int b) {\n      TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);\n      dispatchLayout();\n      TraceCompat.endSection();\n      mFirstLayoutComplete = true;\n  }\n\n  void dispatchLayout() {\n      mState.mIsMeasuring = false;\n      if(mState.mLayoutStep == State.STEP_START) {\n          dispatchLayoutStep1();\n          mLayout.setExactMeasureSpecsFrom(this);\n          dispatchLayoutStep2();\n      } else if(mAdapterHelper.hasUpdates() \n                || mLayout.getWidth() != getWidth() \n                || mLayout.getHeight() != getHeight()) {\n          // first 2 steps are done in onMeasure but looks like we have to run again due to changed size\n          mLayout.setExactMeasureSpecsFrom(this);\n          dispatchLayoutStep2();\n      } else {\n          // always make sure we sync them (to ensure mode is exact)\n          mLayout.setExactMeasureSpecsFrom(this);\n      }\n\n      dispatchLayoutStep3();\n  }\n</code></pre>\n<p>  通过 <code>dispatchLayout</code> 可以验证RecyclerView 的 layout三步走原则，如果在 <code>onMeasure</code> 中已经完成了 step1 和 step2 ，则只会执行 step3，否则，会在 <code>onLayout</code> 中依次触发三步走。</p>\n<h4 id=\"dispatchLayoutStep1\"><a href=\"#dispatchLayoutStep1\" class=\"headerlink\" title=\"dispatchLayoutStep1\"></a>dispatchLayoutStep1</h4><pre><code class=\"java\">  private void dispatchLayoutStep1(){\n      if(mState.mRunSimpleAnimations) {\n          int count = mChildHelper.getChildCount();\n          for(int i = 0; i &lt; count; i++) {\n              final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));\n              final ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(mState, holder, ItemAnimator.buildAdapterChangeFlagsForAnimations(holder), holder.getUnmodifiedPayloads());\n              mViewInfoStore.addToPreLayout(holder, animationInfo);\n          }\n      }\n      mState.mLayoutStep = State.STEP_LAYOUT\n  }\n</code></pre>\n<p>  step 的第一步目的就是记录 View 的状态，先遍历当前所有 View，一次进行处理，mItemAnimator 会根据每个 View 的信息，封装一个 ItemHolderInfo, 这个 ItemHolderInfo 中主要包含的就是 View 的位置状态等。然后将 ItemHodlerInfo 存入 mViewInfoStore 中。在进入第二步后， View 的信息就将被改变</p>\n<h4 id=\"dispatchLayoutStep2\"><a href=\"#dispatchLayoutStep2\" class=\"headerlink\" title=\"dispatchLayoutStep2\"></a>dispatchLayoutStep2</h4><pre><code class=\"java\">  private void dispatchLayoutStep2(){\n      mLayout.onLayoutChildren(mRecycler, mState);\n\n      mState.mLayoutStep = State.STATE_ANIMATIONS;\n  }\n</code></pre>\n<p>  layout 的第二步就是真正的布局 View。RecyclerView 的真正布局是由 LayoutManger 来负责的，其主要工作也在 LayoutManager 中。</p>\n<pre><code class=\"java\">  public  void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {\n\n      if(!mAnchorInfo.mValid \n        || mPendingScrollPosition != NO_POSITION \n        || mPendingSavedState != null) {\n          updateAnchorInfoForLayout(recycler, state, mAnchorInfo);\n      }\n\n      if(mAnchorInfo.mLayoutFromEnd) {\n          firstLayoutDirection = mShouldReverseLayout \n              ? LayoutState.ITEM_DIRECTIONTAIL\n              : LayoutState.ITEM_DIRECTION_HEAD;\n      } else {\n          firstLayoutDirection = mShouldReverseLayout \n              ? LayoutState.ITEM_DIRECTION_HEAD\n              : LayoutState.ITEM_DIRECTION_TAIL;\n      }\n\n      onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);\n\n      if(mAnchorInfo.mLayoutFromEnd) {\n\n      } else {\n          // fill towards end\n          updateLayouStateToFillEnd(mAnchorInfo);\n          fill(recycler, mLayoutState, state, false);\n\n          // fill towards start\n          updateLayoutStateToFillStart(mAnchorInfo);\n          fill(recycler, mLayoutState, state, false);\n      }\n  }\n</code></pre>\n<p>  流程很负责，大致流程如下</p>\n<ul>\n<li>找到 anchor点</li>\n<li>根据 anchor 一直向前布局，直到填充满 anchor 点前面的所有区域</li>\n<li><p>根据 anchor 一直向后布局，直到填充满 anchor 点后面的所有区域</p>\n<p>anchor 点的寻找是由 <code>updateAnchorInfoForLayout</code> 函数负责。向下追踪会看到 <code>updateAnchorFromChildren</code>  方法，其内容为，先寻找被 focus 的 child， 找到以此 child 作为 anchor ，否则根据布局方向寻找最合适的 child 来作为 anchor，如果找到则将 child 的信息复制给 anchorInfo 。 <code>anchorInfo</code> 主要记录的信息就是 View 的物理位置与 Adapter 中的位置。找到后返回 true，否则返回 false，交给上一步函数做处理。</p>\n<p>继续当找到 anchor 后，会根据 anchor 来布局，通过 fill 方法来完成</p>\n<pre><code class=\"java\">int fill(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.state state, boolean stopOnFocusable) {\n  final int start = layoutState.mAvailable;\n  if(layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {\n      recycleByLayoutState(recycler, layoutState);\n  }\n\n  int remainingSpace = layoutState.mAvailable + layoutState.mExtra;\n  LayoutChunkResult layoutChunkResult = mLayoutChunkResult;\n  while((layoutState.mInfinite || remainingSpace &gt; 0)\n       &amp;&amp; layoutState.hasMore(state)) {\n      layoutChunk(recycler, state, layoutState, layoutChunkResult);\n  }\n  return start-layoutState.mAvailable;\n}\n</code></pre>\n<p><strong>recycleByLayoutState</strong> 这个函数，会根据当前信息对不需要的 View 进行回收:</p>\n<pre><code class=\"java\">private void recycleByLayoutState(RecyclerView.Recycler recycler, LayoutState layoutState) {\n  if(layoutState.mLayoutDirection == LayoutState.LAYOUT_START) {\n\n  } else {\n      recycleViewsFromStart(recycler, layoutState.mScrollingOffset);\n  }\n}\n</code></pre>\n<p>继续看 <code>recycleViewsFromStart</code></p>\n<pre><code class=\"java\">private void recycleViewsFromStart(RecyclerView.Recycler recycler, int dt){\n  final int limit = dt;\n  final int childCount = getChildCount();\n  if(mShouldReverseLayout) {\n\n  } else {\n      for(int i = 0; i &lt; childCount; i++){\n          View child = getChildAt(i);\n          if(mOrientationHelper.getDecoratedEnd(child) &gt; limit\n            || mOrientationHelper.getTransformedEndWithDecoration(child) &gt; limit) {\n      recycleChildren(recycler, 0, i);\n              return;\n          }\n      }\n  }\n}\n</code></pre>\n<p>该函数的作用时遍历所有的子 View ,找出逃离边界的 View 进行回收，回收函数在 <code>recycleChildren</code> 里，而这函数又调用了 <code>removeAndRecycleViewAt</code> </p>\n<pre><code class=\"java\">public void removeAndRecycleViewAt(int index, Recycler recycler) {\n  final View view = getChildAt(index);\n  removeViewAt(index);\n  recycler.recycleView(view);\n}\n</code></pre>\n<p>该函数先调用 <code>removeViewAt</code> ，将 View 从 RecyclerView 中移除，紧接着是 recycler 执行了 View 的回收逻辑。在 fill 函数的一开始会去回收逃离出屏幕的 view。</p>\n<pre><code class=\"java\">while((layoutState.mInfinite || remainningSpace &gt; 0) \n   &amp;&amp; layoutState.hasMore(state)) {\n  layoutChunk(recycler, state, layoutState, layoutChunkResult);\n}\n</code></pre>\n<p>只要又剩余空间，就会执行 layoutChunk 方法</p>\n<pre><code class=\"java\">void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State stat, LayoutState layoutState, LayoutCHunkResult result){\n  View view = layoutState.next(recycler);\n\n  LayoutParams params = (LayoutParams) view.getLayoutParams();\n  if(layoutState.mScrapList == null) {\n      if(mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) {\n          addView(view);\n      } else {\n          addView(view, 0);\n      }\n  } else {\n\n  }\n\n  layoutDecoratedWithMargins(view, left, top, right, bottom);\n}\n</code></pre>\n<p>在 layoutState 的 next 方法返回了一个 view， 凭空变出一个 View， 很神奇</p>\n<pre><code class=\"java\">View next(RecyclerView.Recycler recycler ) {\n  final View view = recycler.getViewForPosition(mCurrentPosition);\n  return view;\n}\n</code></pre>\n<p>可见 view 的获取逻辑也是由 recycler 来负责， 所以我们只需要清楚 recycler 可以根据位置返回一个 View 即可。</p>\n<p>我们在看 layoutChunk 对刚刚生成的 View 的处理</p>\n<pre><code class=\"java\">if(mShouldReverseLayout == (layoutState.mLayoutDirectoin == LayoutState.LAYOUT_STATE)) {\n  addView(view);\n} else {\n  addView(view, 0);\n}\n</code></pre>\n<p>明显的调用了 addView 方法，虽然这个方法是 LayoutManager 的，但是这个方法最终会多次辗转调用到 Recycler View 的 addView 方法，将 view 添加到 RecyclerView 中。</p>\n<p>dispatchLayoutStep2 整个布局过程，完成了对 子 View 的测量与布局</p>\n<h4 id=\"dispatchLayoutStep3\"><a href=\"#dispatchLayoutStep3\" class=\"headerlink\" title=\"dispatchLayoutStep3\"></a>dispatchLayoutStep3</h4><p>最后一步</p>\n<pre><code class=\"java\">private void dispatchLayoutStep3(){\n  mState.mLayoutStep = State.STEP_START;\n  if(mState.mRunSimpleAnimations) {\n      for(int i = mChildHelper.getChildCount() - 1; i &gt;= 0; i--) {\n          final ItemHolderInfo animationInfo = mItemAnimator.recordPostLayoutInformation(mState, holder);\n          mViewInfoStore.addToPostLayout(holder, animationInfo);\n      }\n\n      mViewInfoStore.process(mViewInfoProcessCallback);\n  }\n}\n</code></pre>\n<p>这里是与第一步呼应的，此时子 View 都已布局完成，所以子 View 的信息都发生了变化。第一步出现的 mViewInfoStore 和 mItemAnimator 再次登场，这次 mItemAnimator 调用的是 recordPostLayoutInformation 方法，而 mViewInfoStore 调用的是 addToPostLayout 方法，</p>\n<pre><code class=\"java\">void addToPostLayout(ViewHolder holder, ItemHolderInfo info) {\n  InfoRecord record = mLayoutHolderMap.get(holder);\n  if(record == null ) {\n      record = InfoRecord.obtain();\n      mLayoutHolderMap.put(holder, record);\n  }\n  record.postInfo = info;record.flags |= FLAT_POST;\n}\n</code></pre>\n<p>最后 mViewInfoStore 调用了 process 方法，根据 mViewInfoStore 中的 View 信息，来执行动画逻辑。</p>\n</li>\n</ul>\n<h3 id=\"缓存逻辑\"><a href=\"#缓存逻辑\" class=\"headerlink\" title=\"缓存逻辑\"></a>缓存逻辑</h3><p>  RecyclerView 的缓存时分为多级的，但其实真个逻辑很好理解，</p>\n<pre><code class=\"java\">  View getViewForPosition(int position, boolean dryRun) {\n      boolean fromScrap = false;\n      ViewHolder holder = null;\n      if(mState.isPreLayout()) {\n          holder = getChangedScrapViewForPosition(position);\n          fromScrap = holder != null\n      }\n\n      if(hoder == null) {\n          hodler = getScrapViewForPosition(position, INVALID_TYPE, dryRun);\n      }\n\n      if(holder == null ){\n          final int offsetPosition = mAdapterHelper.findPositionOffset(position);\n          final int type = mAdapter.getItemViewType(offsetPosition);\n          if(mAdapter.hasStableIds()){\n              holder = getScrapViewForId(mAdapter.getItemId(offsetPosition), type, dryRun);\n          }\n\n          if(holder == null &amp;&amp; mViewCacheExtension != null) {\n              final View view = mViewCacheExtension.getViewForPositionAndType(this, position, type);\n          }\n\n          if(holder == null) {\n              // fallback to recycler\n              holder = getRecyclerViewPool().getRecyclerView(type);\n              if(holder != null){\n                  holder.resetInternal();\n                  if(FORCE_INVALIDATE_DISPLAY_LIST){\n                      invalidateDisplayListInt(holder);\n                  }\n              }\n          } \n\n          if(holder == null ){\n              holder = mAdapter.createViewHolder(RecyclerView.this, type);\n          }\n      }\n\n\n      // 生成 LayoutParams 的代码\n      return holder.itemView;\n  }\n</code></pre>\n<p>获取 View 的逻辑可以整理为</p>\n<ul>\n<li>搜索 mChangedScrap， 如果找到则返回相应的 holder</li>\n<li>搜索 mAttachedScrap与 mCachedViews， 如果找到且 holder 有效则返回相应的 holder</li>\n<li>如果设置了 mViewCacheExtension, 对其调用 getViewForPositionAndType 方法进行获取，若返回结果则生成对应的 holder</li>\n<li>搜索 mRecyclerPool, 如果找到则返回 Holder</li>\n<li>如果上述过程都没有找到对饮的 holder, 则执行 Adapter.createViewHolder(); 创建新的 ViewHolder 实例</li>\n</ul>\n<p>对于 View 的回收</p>\n<pre><code class=\"java\">void recycleViewHolderInternal(ViewHolder holder ) {\n\n    if(holder.isRecyclable()) {\n        if(!holder.hasAnyOfTheFlags(VieHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED) | ViewHolder.FLAG_UPDATE) {\n            int cachedViewSize = mCachedViews.size();\n            if(cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; 0) {\n                recycleCachedViewAt(0);\n                cachedViewSize--;\n            }\n\n            if(cachedViewSize &lt; mViewCacheMax) {\n                mCachedViews.add(holder);\n                cached = true;\n            }\n        }\n\n        if(!cached) {\n            addViewHolderToRecycledViewPool(holder);\n            recycled = true;\n        }\n    }\n}\n</code></pre>\n<p>回收没有创建复杂，只涉及到两次缓存， mCachedViews 和 mRecyclerPool , mCachedViews 相当于一个先进先出的数据结构，当有信的 View 需要缓存时，都会将新的 View 存入到 mCachedViews， 而 mCachedView  则会移除头部元素，并将头部元素存储在 mRecyclerPool 中， 即 mCachedViews 相当于一级缓存， mRecyclerPool 相当于二级缓存，。并且 mRecyclerPool  时可以多个 RecyclerView 共享的。</p>\n<h2 id=\"与-AdapterView-比较\"><a href=\"#与-AdapterView-比较\" class=\"headerlink\" title=\"与 AdapterView 比较\"></a>与 AdapterView 比较</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">index</th>\n<th style=\"text-align:center\">AdapterView</th>\n<th style=\"text-align:center\">RecyclerView</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">Simple click listener</td>\n<td style=\"text-align:center\">OnItemTouchListener</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">Simple Divider</td>\n<td style=\"text-align:center\">ItemDecoration</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">ListView and GridView</td>\n<td style=\"text-align:center\">LinearLayoutManager<br>GridLayoutManager..</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">RecyclerBin</td>\n<td style=\"text-align:center\">Recycler</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">Header and Footer</td>\n<td style=\"text-align:center\">Partial refresh</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>点击事件</p>\n<p>ListView 原生提供了Item 点击、长安的事件，而 RecyclerView  则需要使用 onTouchListener 相对比较复杂</p>\n</li>\n<li><p>分割线</p>\n<p>ListView  可以很轻松设施 Divider 属性来显示 item 之间的分割线，</p>\n<p>RecyclerView 需要自己实现 ItemDecoration ，两者比较，前者使用更简单，后者定制性更强</p>\n</li>\n<li><p>布局类型</p>\n<p>AdapterView 提供了 ListView 和 GridView 两种， RecyclerView 提供了 LinearLayoutManger 和 GirdLayoutManager。相比较 RecyclerView 更换布局方式更轻松，AdapterView 则需要更换一个 View。</p>\n</li>\n<li><p>缓存方式</p>\n<p>ListView 使用了 RecyclerBin 类负责视图的缓存，RecyclerView 使用 Recycler 进行缓存，原理基本一致</p>\n</li>\n</ul>\n<p><strong>不同点</strong></p>\n<ul>\n<li><p>局部刷新</p>\n<p>ListView 中想局部刷新某个 item 需要自己来编写刷新逻辑， 而 RecyclerView 中可以通过 <code>notifyItemChanged(position)</code> 来完成，甚至可以通过 <code>notifyItemChanged(position, payload)</code> 传入一个 payload 信息来刷新单个 item 中的特定内容。</p>\n</li>\n<li><p>动画</p>\n<p>RecyclerView 内部通过 ItemAnimation 类完成了动画操作，而 ListView 做动画比较困难</p>\n</li>\n<li><p>嵌套布局</p>\n<p>RecyclerView 实现了 <code>NestedScrollingChild</code> 接口，可以和一切嵌套组件很好的工作</p>\n</li>\n</ul>\n<p><strong>ListView 原生特点</strong></p>\n<ul>\n<li><p>头部与尾部支持</p>\n<p>ListView 原生支持头部和尾部的添加，虽然 RecyclerView 可以通过定义不同的 Type 来坐支持，但实际应用中，封装不好会造成问题。因为 Adapter 中的数据位置与物理数据位置发生了偏移、</p>\n</li>\n<li><p>多选</p>\n<p>支持多选和单选的 ListView 更方便</p>\n</li>\n<li><p>多数据源支持</p>\n<p>ListView 提供了 Cursor Adapter， ArrayAdapter 可以很方便从数据库或者数组中获取数据。</p>\n</li>\n</ul>\n<p><strong>总结</strong></p>\n<p>RecyclerView 的最大特点就是灵活，正是因为灵活，也牺牲了很多便利性，而 AdapterView 比较刻板，原生方法给与开发很多便利。</p>"},{"title":"Git Command","date":"2019-04-16T09:43:58.000Z","_content":"\n# Git 命令\n\n|     修改记录     |        修改时间        |                  备注                  |\n| :--------------: | :--------------------: | :------------------------------------: |\n| 添加删除远程分支 | 2018年07月26日13:59:22 |            删除远程分支命令            |\n|   更新fork仓库   | 2018年08月10日14:16:08 | 添加fork的仓库，从主仓库更新代码的命令 |\n\n\n整理的还不够完善，以后工作中遇到了会不断补进，如有大神，有可以留言，我们一起来完善。欢迎各位留言^_^\n\n<!--more-->\n\n## Git 文件的三种状态\n\n1. 已提交：表示该文件已经被安全地保存在本地版本库中，执行过git commit。\n2. 已修改：表示修改了某个文件，但还没有提交保存\n3. 已暂存：表示把已修改的文件房子啊下次提交时要保存的清单中，也就是执行了 git add 命令。\n\n## 远程仓库与本地代码的配置\n\n将本地已经有的项目上传到远程空仓库中\n\n``` git\ncd <project path>\ngit init\ngit remote add origin <远程仓库地址>\ngit add .\ngit commit -m '提交日志'\ngit push -u origin master\n```\n\n## Git 基本配置\n\n1. 配置个人的用户名称和电子邮件地址，每次提交时，都会引用这两条信息，以用来说明是谁提交的更新。\n\n\n使用 `--global` 选项，更改的未用户主目录下的配置，如果想在某个特定的项目中使用其他的名称和邮件，只需要去掉 `--global` 选项重新配置，新的配置位于当前项目的 `.git/config` 文件中。\n\n```git\n git config --global user.name ''yourname''\n git config --global user.email  yourname@gmail.com\n```\n\n2. 基础命令\n\n> git init\n\n通过此命令会在当前目录创建一个`.git`的隐藏目录，这是`git`的第一步。\n\n> git status\n\n`git status`是最为常用的命令之一，用于检查本地项目的状态.仔细阅读红色/绿色部分，可以获得相关文件的操作信息，根据提示，判断是执行`git commit` 还是执行`git add` 操作。\n\n\n> git add\n\n将一个或多个文件添加到 `git`仓库中，只有通过 `git add` 添加的文件才会被版本控制管理。\n\n添加单个文件 `git add HelloWorld2.java`\n\n添加多个文件 `git add --a`\n\n添加当前目录所有文件 `git add .`\n\n\n> git rm --cached <file>\n\n将文件从`git`追踪列表中移除，只是逻辑删除（从版本库中移除），并不会将本地文件删除\n\n> git commit\n\n执行过 `git add` 命令后，需要将暂存的文件提交到本地仓库中，此时是真正的提交\n\n带 log 的提交： `git commit -m 'first commit'`\n\n通过编辑器提交: `git commit `\n\n带log 的提交比较方便，但当你的提交信息有一定格式或者需要提交的文字内容较多时，使用编辑器效果会更好.\n\n\n> git log\n\n查看历史提交记录， 包括**提交人**、**时间**、**信息**、**信息指纹**等.\n\n查看提交记录： `git log`\n\n单行展示记录： `git log --pretty=oneline`\n\n展示全部信息： `git log --pretty=fuller`\n\n\n> git clone <远程仓库地址>\n\n拉取远程仓库代码,此项目并不一定是你所创建\n\n例如： `git clone git@github.com:bboyfeiyu/AndroidEventBus.git`\n\n执行完成后，会在本地当前目录创建一个AndroidEventBus的目录来存放仓库代码\n\n> git remote\n\n将本地已经`init`过的工程链接到远程的空仓库中，以此来完成远程版本库的创建\n\n链接远程版本库： `git remote add origin <远程地址>`\n\n\n> git remote set-url <仓库地址>\n\nSSH 和 HTTPS 方式切换\n\n\n```git\n# ssh to https\n$ git remote set-url origin https://github.com/USERNAME/repository.git\n# https to ssh\n$ git remote set-url origin git@github.com:USERNAME/repository.git\n```\n\n可以使用 `git remote -v` 来检查当前仓库地址\n\n```\n> origin git@github.com:username/repository.git (fetch)\n> origin git@github.com:username/repository.git (push)\n```\n\nSSH 和 HTTPS 的区别：\n\n使用 SSH 方式需要在本地配置一个密钥，具体可参见[多个 SSH 公钥提交代码到不同平台](https://xiaoman.ren/2019/04/17/%E5%A4%9A%E4%B8%AA-ssh-%E5%85%AC%E9%92%A5%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%88%B0%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0/)中介绍；\n而使用 HTTPS 的方式操作简单，弊端是需要经常输入密码。\n\n\n> git branch\n\n分支是用来管理代码版本、类型的有效工具，可根据不同的服务对象、不同的上线版本等等，来做代码分离，版本管理操作\n\n查看分支： `git branch`\n\n查看带提交信息的分支信息： `git branch -v`\n\n创建分支： `git branch <分支名称>`\n\n创建并切换分支： `git branch -b <分支名称>`\n\n切换分支： `git checkout <分支名称>`\n\n推送分支： `git push origin <分支名称>`\n\n删除分支： `git branch -d <分支名称>`\n\n删除远程分支： `git push origin :<分支名称>`\n\n合并分支： `git merge <分支名称>`\n\n\n\n> git push\n\n推送本地修改到远端服务器\n\n`git push origin master`\n\n有时因两个独立的历史，会导致推送无法达成， 通常在 `git pull` 时会提示 `fatal: refusing to merge unrelated histories  // 拒绝合并无关历史`\n\n这时可是使用 `git pull origin master --allow-unrelated-histories ` 来解决。\n\n\n\n> git tag \n\n会列出所有的 `tag` 标签信息\n\n在完成了所有功能、并且经过测试之后，可以封板上线的版本，通常会打一个标签，***这是一个很重要的功能*** \n\n建议每次上线都要做一次，便于后续的版本检索与维护，通常一个标签就代表了一个正式版本。\n\n查看本地/远程 tag 标签：`git tag`\n\n查看模糊 tag 标签： `git tag -l 'v1.4.2.*'`\n\n查看备注 tag 标签： `git tag -ln`\n\n\n查看标签信息： `git show <标签名>`\n\n\n创建本地 tag 标签： `git tag -a <标签名> -m \"<标签备注信息>\"`\n\n删除本地 tag 标签： `git tag -d <标签名>`\n\n\n推送远程 tag 标签： `git push origin <标签名>`\n\n推送全部 tag 标签： `git push origin -tags`\n\n删除远程 tag 标签： `git push origin :refs/tags/<标签名>`\n\n\n**查看远程机状态**\n> git remote 用来管理， fork 的项目，与主项目的更新操作\n\n```\ngit remote -v\ngit remote add upstream git@github.com:XXX/XXX.git\ngit fetch upstream\ngit merge upstream/master\ngit push\n```\n\n## 使用中的一些技巧\n\n**命名别名**\n复杂并超长的命令，可以通过起别名的方式方便在终端中书协\n\n```\ngit config --global alias.ci commit\ngit config --global alias.ck checkout\ngit config --global alias.st status\n```\n\n然后就可以很愉快的使用git命令了。\n```\ngit st\n```\n\n","source":"_posts/git-command.md","raw":"---\ntitle: git command\ndate: 2019-04-16 17:43:58\ntags: Git\n---\n\n# Git 命令\n\n|     修改记录     |        修改时间        |                  备注                  |\n| :--------------: | :--------------------: | :------------------------------------: |\n| 添加删除远程分支 | 2018年07月26日13:59:22 |            删除远程分支命令            |\n|   更新fork仓库   | 2018年08月10日14:16:08 | 添加fork的仓库，从主仓库更新代码的命令 |\n\n\n整理的还不够完善，以后工作中遇到了会不断补进，如有大神，有可以留言，我们一起来完善。欢迎各位留言^_^\n\n<!--more-->\n\n## Git 文件的三种状态\n\n1. 已提交：表示该文件已经被安全地保存在本地版本库中，执行过git commit。\n2. 已修改：表示修改了某个文件，但还没有提交保存\n3. 已暂存：表示把已修改的文件房子啊下次提交时要保存的清单中，也就是执行了 git add 命令。\n\n## 远程仓库与本地代码的配置\n\n将本地已经有的项目上传到远程空仓库中\n\n``` git\ncd <project path>\ngit init\ngit remote add origin <远程仓库地址>\ngit add .\ngit commit -m '提交日志'\ngit push -u origin master\n```\n\n## Git 基本配置\n\n1. 配置个人的用户名称和电子邮件地址，每次提交时，都会引用这两条信息，以用来说明是谁提交的更新。\n\n\n使用 `--global` 选项，更改的未用户主目录下的配置，如果想在某个特定的项目中使用其他的名称和邮件，只需要去掉 `--global` 选项重新配置，新的配置位于当前项目的 `.git/config` 文件中。\n\n```git\n git config --global user.name ''yourname''\n git config --global user.email  yourname@gmail.com\n```\n\n2. 基础命令\n\n> git init\n\n通过此命令会在当前目录创建一个`.git`的隐藏目录，这是`git`的第一步。\n\n> git status\n\n`git status`是最为常用的命令之一，用于检查本地项目的状态.仔细阅读红色/绿色部分，可以获得相关文件的操作信息，根据提示，判断是执行`git commit` 还是执行`git add` 操作。\n\n\n> git add\n\n将一个或多个文件添加到 `git`仓库中，只有通过 `git add` 添加的文件才会被版本控制管理。\n\n添加单个文件 `git add HelloWorld2.java`\n\n添加多个文件 `git add --a`\n\n添加当前目录所有文件 `git add .`\n\n\n> git rm --cached <file>\n\n将文件从`git`追踪列表中移除，只是逻辑删除（从版本库中移除），并不会将本地文件删除\n\n> git commit\n\n执行过 `git add` 命令后，需要将暂存的文件提交到本地仓库中，此时是真正的提交\n\n带 log 的提交： `git commit -m 'first commit'`\n\n通过编辑器提交: `git commit `\n\n带log 的提交比较方便，但当你的提交信息有一定格式或者需要提交的文字内容较多时，使用编辑器效果会更好.\n\n\n> git log\n\n查看历史提交记录， 包括**提交人**、**时间**、**信息**、**信息指纹**等.\n\n查看提交记录： `git log`\n\n单行展示记录： `git log --pretty=oneline`\n\n展示全部信息： `git log --pretty=fuller`\n\n\n> git clone <远程仓库地址>\n\n拉取远程仓库代码,此项目并不一定是你所创建\n\n例如： `git clone git@github.com:bboyfeiyu/AndroidEventBus.git`\n\n执行完成后，会在本地当前目录创建一个AndroidEventBus的目录来存放仓库代码\n\n> git remote\n\n将本地已经`init`过的工程链接到远程的空仓库中，以此来完成远程版本库的创建\n\n链接远程版本库： `git remote add origin <远程地址>`\n\n\n> git remote set-url <仓库地址>\n\nSSH 和 HTTPS 方式切换\n\n\n```git\n# ssh to https\n$ git remote set-url origin https://github.com/USERNAME/repository.git\n# https to ssh\n$ git remote set-url origin git@github.com:USERNAME/repository.git\n```\n\n可以使用 `git remote -v` 来检查当前仓库地址\n\n```\n> origin git@github.com:username/repository.git (fetch)\n> origin git@github.com:username/repository.git (push)\n```\n\nSSH 和 HTTPS 的区别：\n\n使用 SSH 方式需要在本地配置一个密钥，具体可参见[多个 SSH 公钥提交代码到不同平台](https://xiaoman.ren/2019/04/17/%E5%A4%9A%E4%B8%AA-ssh-%E5%85%AC%E9%92%A5%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%88%B0%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0/)中介绍；\n而使用 HTTPS 的方式操作简单，弊端是需要经常输入密码。\n\n\n> git branch\n\n分支是用来管理代码版本、类型的有效工具，可根据不同的服务对象、不同的上线版本等等，来做代码分离，版本管理操作\n\n查看分支： `git branch`\n\n查看带提交信息的分支信息： `git branch -v`\n\n创建分支： `git branch <分支名称>`\n\n创建并切换分支： `git branch -b <分支名称>`\n\n切换分支： `git checkout <分支名称>`\n\n推送分支： `git push origin <分支名称>`\n\n删除分支： `git branch -d <分支名称>`\n\n删除远程分支： `git push origin :<分支名称>`\n\n合并分支： `git merge <分支名称>`\n\n\n\n> git push\n\n推送本地修改到远端服务器\n\n`git push origin master`\n\n有时因两个独立的历史，会导致推送无法达成， 通常在 `git pull` 时会提示 `fatal: refusing to merge unrelated histories  // 拒绝合并无关历史`\n\n这时可是使用 `git pull origin master --allow-unrelated-histories ` 来解决。\n\n\n\n> git tag \n\n会列出所有的 `tag` 标签信息\n\n在完成了所有功能、并且经过测试之后，可以封板上线的版本，通常会打一个标签，***这是一个很重要的功能*** \n\n建议每次上线都要做一次，便于后续的版本检索与维护，通常一个标签就代表了一个正式版本。\n\n查看本地/远程 tag 标签：`git tag`\n\n查看模糊 tag 标签： `git tag -l 'v1.4.2.*'`\n\n查看备注 tag 标签： `git tag -ln`\n\n\n查看标签信息： `git show <标签名>`\n\n\n创建本地 tag 标签： `git tag -a <标签名> -m \"<标签备注信息>\"`\n\n删除本地 tag 标签： `git tag -d <标签名>`\n\n\n推送远程 tag 标签： `git push origin <标签名>`\n\n推送全部 tag 标签： `git push origin -tags`\n\n删除远程 tag 标签： `git push origin :refs/tags/<标签名>`\n\n\n**查看远程机状态**\n> git remote 用来管理， fork 的项目，与主项目的更新操作\n\n```\ngit remote -v\ngit remote add upstream git@github.com:XXX/XXX.git\ngit fetch upstream\ngit merge upstream/master\ngit push\n```\n\n## 使用中的一些技巧\n\n**命名别名**\n复杂并超长的命令，可以通过起别名的方式方便在终端中书协\n\n```\ngit config --global alias.ci commit\ngit config --global alias.ck checkout\ngit config --global alias.st status\n```\n\n然后就可以很愉快的使用git命令了。\n```\ngit st\n```\n\n","slug":"git-command","published":1,"updated":"2019-08-12T15:33:00.863Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb88d000dsz5qwolvxf2k","content":"<h1 id=\"Git-命令\"><a href=\"#Git-命令\" class=\"headerlink\" title=\"Git 命令\"></a>Git 命令</h1><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">修改记录</th>\n<th style=\"text-align:center\">修改时间</th>\n<th style=\"text-align:center\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">添加删除远程分支</td>\n<td style=\"text-align:center\">2018年07月26日13:59:22</td>\n<td style=\"text-align:center\">删除远程分支命令</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">更新fork仓库</td>\n<td style=\"text-align:center\">2018年08月10日14:16:08</td>\n<td style=\"text-align:center\">添加fork的仓库，从主仓库更新代码的命令</td>\n</tr>\n</tbody>\n</table>\n<p>整理的还不够完善，以后工作中遇到了会不断补进，如有大神，有可以留言，我们一起来完善。欢迎各位留言^_^</p>\n<a id=\"more\"></a>\n<h2 id=\"Git-文件的三种状态\"><a href=\"#Git-文件的三种状态\" class=\"headerlink\" title=\"Git 文件的三种状态\"></a>Git 文件的三种状态</h2><ol>\n<li>已提交：表示该文件已经被安全地保存在本地版本库中，执行过git commit。</li>\n<li>已修改：表示修改了某个文件，但还没有提交保存</li>\n<li>已暂存：表示把已修改的文件房子啊下次提交时要保存的清单中，也就是执行了 git add 命令。</li>\n</ol>\n<h2 id=\"远程仓库与本地代码的配置\"><a href=\"#远程仓库与本地代码的配置\" class=\"headerlink\" title=\"远程仓库与本地代码的配置\"></a>远程仓库与本地代码的配置</h2><p>将本地已经有的项目上传到远程空仓库中</p>\n<pre class=\" language-git\"><code class=\"language-git\">cd &lt;project path>\ngit init\ngit remote add origin &lt;远程仓库地址>\ngit add .\ngit commit -m <span class=\"token string\">'提交日志'</span>\ngit push -u origin master\n</code></pre>\n<h2 id=\"Git-基本配置\"><a href=\"#Git-基本配置\" class=\"headerlink\" title=\"Git 基本配置\"></a>Git 基本配置</h2><ol>\n<li>配置个人的用户名称和电子邮件地址，每次提交时，都会引用这两条信息，以用来说明是谁提交的更新。</li>\n</ol>\n<p>使用 <code>--global</code> 选项，更改的未用户主目录下的配置，如果想在某个特定的项目中使用其他的名称和邮件，只需要去掉 <code>--global</code> 选项重新配置，新的配置位于当前项目的 <code>.git/config</code> 文件中。</p>\n<pre class=\" language-git\"><code class=\"language-git\"> git config --global user.name <span class=\"token string\">''</span>yourname<span class=\"token string\">''</span>\n git config --global user.email  yourname@gmail.com\n</code></pre>\n<ol start=\"2\">\n<li>基础命令</li>\n</ol>\n<blockquote>\n<p>git init</p>\n</blockquote>\n<p>通过此命令会在当前目录创建一个<code>.git</code>的隐藏目录，这是<code>git</code>的第一步。</p>\n<blockquote>\n<p>git status</p>\n</blockquote>\n<p><code>git status</code>是最为常用的命令之一，用于检查本地项目的状态.仔细阅读红色/绿色部分，可以获得相关文件的操作信息，根据提示，判断是执行<code>git commit</code> 还是执行<code>git add</code> 操作。</p>\n<blockquote>\n<p>git add</p>\n</blockquote>\n<p>将一个或多个文件添加到 <code>git</code>仓库中，只有通过 <code>git add</code> 添加的文件才会被版本控制管理。</p>\n<p>添加单个文件 <code>git add HelloWorld2.java</code></p>\n<p>添加多个文件 <code>git add --a</code></p>\n<p>添加当前目录所有文件 <code>git add .</code></p>\n<blockquote>\n<p>git rm –cached <file></file></p>\n</blockquote>\n<p>将文件从<code>git</code>追踪列表中移除，只是逻辑删除（从版本库中移除），并不会将本地文件删除</p>\n<blockquote>\n<p>git commit</p>\n</blockquote>\n<p>执行过 <code>git add</code> 命令后，需要将暂存的文件提交到本地仓库中，此时是真正的提交</p>\n<p>带 log 的提交： <code>git commit -m &#39;first commit&#39;</code></p>\n<p>通过编辑器提交: <code>git commit</code></p>\n<p>带log 的提交比较方便，但当你的提交信息有一定格式或者需要提交的文字内容较多时，使用编辑器效果会更好.</p>\n<blockquote>\n<p>git log</p>\n</blockquote>\n<p>查看历史提交记录， 包括<strong>提交人</strong>、<strong>时间</strong>、<strong>信息</strong>、<strong>信息指纹</strong>等.</p>\n<p>查看提交记录： <code>git log</code></p>\n<p>单行展示记录： <code>git log --pretty=oneline</code></p>\n<p>展示全部信息： <code>git log --pretty=fuller</code></p>\n<blockquote>\n<p>git clone &lt;远程仓库地址&gt;</p>\n</blockquote>\n<p>拉取远程仓库代码,此项目并不一定是你所创建</p>\n<p>例如： <code>git clone git@github.com:bboyfeiyu/AndroidEventBus.git</code></p>\n<p>执行完成后，会在本地当前目录创建一个AndroidEventBus的目录来存放仓库代码</p>\n<blockquote>\n<p>git remote</p>\n</blockquote>\n<p>将本地已经<code>init</code>过的工程链接到远程的空仓库中，以此来完成远程版本库的创建</p>\n<p>链接远程版本库： <code>git remote add origin &lt;远程地址&gt;</code></p>\n<blockquote>\n<p>git remote set-url &lt;仓库地址&gt;</p>\n</blockquote>\n<p>SSH 和 HTTPS 方式切换</p>\n<pre class=\" language-git\"><code class=\"language-git\"><span class=\"token comment\" spellcheck=\"true\"># ssh to https</span>\n<span class=\"token command\">$ git remote set-url origin https://github.com/USERNAME/repository.git</span>\n<span class=\"token comment\" spellcheck=\"true\"># https to ssh</span>\n<span class=\"token command\">$ git remote set-url origin git@github.com:USERNAME/repository.git</span>\n</code></pre>\n<p>可以使用 <code>git remote -v</code> 来检查当前仓库地址</p>\n<pre><code>&gt; origin git@github.com:username/repository.git (fetch)\n&gt; origin git@github.com:username/repository.git (push)\n</code></pre><p>SSH 和 HTTPS 的区别：</p>\n<p>使用 SSH 方式需要在本地配置一个密钥，具体可参见<a href=\"https://xiaoman.ren/2019/04/17/%E5%A4%9A%E4%B8%AA-ssh-%E5%85%AC%E9%92%A5%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%88%B0%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0/\">多个 SSH 公钥提交代码到不同平台</a>中介绍；<br>而使用 HTTPS 的方式操作简单，弊端是需要经常输入密码。</p>\n<blockquote>\n<p>git branch</p>\n</blockquote>\n<p>分支是用来管理代码版本、类型的有效工具，可根据不同的服务对象、不同的上线版本等等，来做代码分离，版本管理操作</p>\n<p>查看分支： <code>git branch</code></p>\n<p>查看带提交信息的分支信息： <code>git branch -v</code></p>\n<p>创建分支： <code>git branch &lt;分支名称&gt;</code></p>\n<p>创建并切换分支： <code>git branch -b &lt;分支名称&gt;</code></p>\n<p>切换分支： <code>git checkout &lt;分支名称&gt;</code></p>\n<p>推送分支： <code>git push origin &lt;分支名称&gt;</code></p>\n<p>删除分支： <code>git branch -d &lt;分支名称&gt;</code></p>\n<p>删除远程分支： <code>git push origin :&lt;分支名称&gt;</code></p>\n<p>合并分支： <code>git merge &lt;分支名称&gt;</code></p>\n<blockquote>\n<p>git push</p>\n</blockquote>\n<p>推送本地修改到远端服务器</p>\n<p><code>git push origin master</code></p>\n<p>有时因两个独立的历史，会导致推送无法达成， 通常在 <code>git pull</code> 时会提示 <code>fatal: refusing to merge unrelated histories  // 拒绝合并无关历史</code></p>\n<p>这时可是使用 <code>git pull origin master --allow-unrelated-histories</code> 来解决。</p>\n<blockquote>\n<p>git tag </p>\n</blockquote>\n<p>会列出所有的 <code>tag</code> 标签信息</p>\n<p>在完成了所有功能、并且经过测试之后，可以封板上线的版本，通常会打一个标签，<strong><em>这是一个很重要的功能</em></strong> </p>\n<p>建议每次上线都要做一次，便于后续的版本检索与维护，通常一个标签就代表了一个正式版本。</p>\n<p>查看本地/远程 tag 标签：<code>git tag</code></p>\n<p>查看模糊 tag 标签： <code>git tag -l &#39;v1.4.2.*&#39;</code></p>\n<p>查看备注 tag 标签： <code>git tag -ln</code></p>\n<p>查看标签信息： <code>git show &lt;标签名&gt;</code></p>\n<p>创建本地 tag 标签： <code>git tag -a &lt;标签名&gt; -m &quot;&lt;标签备注信息&gt;&quot;</code></p>\n<p>删除本地 tag 标签： <code>git tag -d &lt;标签名&gt;</code></p>\n<p>推送远程 tag 标签： <code>git push origin &lt;标签名&gt;</code></p>\n<p>推送全部 tag 标签： <code>git push origin -tags</code></p>\n<p>删除远程 tag 标签： <code>git push origin :refs/tags/&lt;标签名&gt;</code></p>\n<p><strong>查看远程机状态</strong></p>\n<blockquote>\n<p>git remote 用来管理， fork 的项目，与主项目的更新操作</p>\n</blockquote>\n<pre><code>git remote -v\ngit remote add upstream git@github.com:XXX/XXX.git\ngit fetch upstream\ngit merge upstream/master\ngit push\n</code></pre><h2 id=\"使用中的一些技巧\"><a href=\"#使用中的一些技巧\" class=\"headerlink\" title=\"使用中的一些技巧\"></a>使用中的一些技巧</h2><p><strong>命名别名</strong><br>复杂并超长的命令，可以通过起别名的方式方便在终端中书协</p>\n<pre><code>git config --global alias.ci commit\ngit config --global alias.ck checkout\ngit config --global alias.st status\n</code></pre><p>然后就可以很愉快的使用git命令了。</p>\n<pre><code>git st\n</code></pre>","site":{"data":{}},"excerpt":"<h1 id=\"Git-命令\"><a href=\"#Git-命令\" class=\"headerlink\" title=\"Git 命令\"></a>Git 命令</h1><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">修改记录</th>\n<th style=\"text-align:center\">修改时间</th>\n<th style=\"text-align:center\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">添加删除远程分支</td>\n<td style=\"text-align:center\">2018年07月26日13:59:22</td>\n<td style=\"text-align:center\">删除远程分支命令</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">更新fork仓库</td>\n<td style=\"text-align:center\">2018年08月10日14:16:08</td>\n<td style=\"text-align:center\">添加fork的仓库，从主仓库更新代码的命令</td>\n</tr>\n</tbody>\n</table>\n<p>整理的还不够完善，以后工作中遇到了会不断补进，如有大神，有可以留言，我们一起来完善。欢迎各位留言^_^</p>","more":"<h2 id=\"Git-文件的三种状态\"><a href=\"#Git-文件的三种状态\" class=\"headerlink\" title=\"Git 文件的三种状态\"></a>Git 文件的三种状态</h2><ol>\n<li>已提交：表示该文件已经被安全地保存在本地版本库中，执行过git commit。</li>\n<li>已修改：表示修改了某个文件，但还没有提交保存</li>\n<li>已暂存：表示把已修改的文件房子啊下次提交时要保存的清单中，也就是执行了 git add 命令。</li>\n</ol>\n<h2 id=\"远程仓库与本地代码的配置\"><a href=\"#远程仓库与本地代码的配置\" class=\"headerlink\" title=\"远程仓库与本地代码的配置\"></a>远程仓库与本地代码的配置</h2><p>将本地已经有的项目上传到远程空仓库中</p>\n<pre><code class=\"git\">cd &lt;project path&gt;\ngit init\ngit remote add origin &lt;远程仓库地址&gt;\ngit add .\ngit commit -m &#39;提交日志&#39;\ngit push -u origin master\n</code></pre>\n<h2 id=\"Git-基本配置\"><a href=\"#Git-基本配置\" class=\"headerlink\" title=\"Git 基本配置\"></a>Git 基本配置</h2><ol>\n<li>配置个人的用户名称和电子邮件地址，每次提交时，都会引用这两条信息，以用来说明是谁提交的更新。</li>\n</ol>\n<p>使用 <code>--global</code> 选项，更改的未用户主目录下的配置，如果想在某个特定的项目中使用其他的名称和邮件，只需要去掉 <code>--global</code> 选项重新配置，新的配置位于当前项目的 <code>.git/config</code> 文件中。</p>\n<pre><code class=\"git\"> git config --global user.name &#39;&#39;yourname&#39;&#39;\n git config --global user.email  yourname@gmail.com\n</code></pre>\n<ol start=\"2\">\n<li>基础命令</li>\n</ol>\n<blockquote>\n<p>git init</p>\n</blockquote>\n<p>通过此命令会在当前目录创建一个<code>.git</code>的隐藏目录，这是<code>git</code>的第一步。</p>\n<blockquote>\n<p>git status</p>\n</blockquote>\n<p><code>git status</code>是最为常用的命令之一，用于检查本地项目的状态.仔细阅读红色/绿色部分，可以获得相关文件的操作信息，根据提示，判断是执行<code>git commit</code> 还是执行<code>git add</code> 操作。</p>\n<blockquote>\n<p>git add</p>\n</blockquote>\n<p>将一个或多个文件添加到 <code>git</code>仓库中，只有通过 <code>git add</code> 添加的文件才会被版本控制管理。</p>\n<p>添加单个文件 <code>git add HelloWorld2.java</code></p>\n<p>添加多个文件 <code>git add --a</code></p>\n<p>添加当前目录所有文件 <code>git add .</code></p>\n<blockquote>\n<p>git rm –cached <file></file></p>\n</blockquote>\n<p>将文件从<code>git</code>追踪列表中移除，只是逻辑删除（从版本库中移除），并不会将本地文件删除</p>\n<blockquote>\n<p>git commit</p>\n</blockquote>\n<p>执行过 <code>git add</code> 命令后，需要将暂存的文件提交到本地仓库中，此时是真正的提交</p>\n<p>带 log 的提交： <code>git commit -m &#39;first commit&#39;</code></p>\n<p>通过编辑器提交: <code>git commit</code></p>\n<p>带log 的提交比较方便，但当你的提交信息有一定格式或者需要提交的文字内容较多时，使用编辑器效果会更好.</p>\n<blockquote>\n<p>git log</p>\n</blockquote>\n<p>查看历史提交记录， 包括<strong>提交人</strong>、<strong>时间</strong>、<strong>信息</strong>、<strong>信息指纹</strong>等.</p>\n<p>查看提交记录： <code>git log</code></p>\n<p>单行展示记录： <code>git log --pretty=oneline</code></p>\n<p>展示全部信息： <code>git log --pretty=fuller</code></p>\n<blockquote>\n<p>git clone &lt;远程仓库地址&gt;</p>\n</blockquote>\n<p>拉取远程仓库代码,此项目并不一定是你所创建</p>\n<p>例如： <code>git clone git@github.com:bboyfeiyu/AndroidEventBus.git</code></p>\n<p>执行完成后，会在本地当前目录创建一个AndroidEventBus的目录来存放仓库代码</p>\n<blockquote>\n<p>git remote</p>\n</blockquote>\n<p>将本地已经<code>init</code>过的工程链接到远程的空仓库中，以此来完成远程版本库的创建</p>\n<p>链接远程版本库： <code>git remote add origin &lt;远程地址&gt;</code></p>\n<blockquote>\n<p>git remote set-url &lt;仓库地址&gt;</p>\n</blockquote>\n<p>SSH 和 HTTPS 方式切换</p>\n<pre><code class=\"git\"># ssh to https\n$ git remote set-url origin https://github.com/USERNAME/repository.git\n# https to ssh\n$ git remote set-url origin git@github.com:USERNAME/repository.git\n</code></pre>\n<p>可以使用 <code>git remote -v</code> 来检查当前仓库地址</p>\n<pre><code>&gt; origin git@github.com:username/repository.git (fetch)\n&gt; origin git@github.com:username/repository.git (push)\n</code></pre><p>SSH 和 HTTPS 的区别：</p>\n<p>使用 SSH 方式需要在本地配置一个密钥，具体可参见<a href=\"https://xiaoman.ren/2019/04/17/%E5%A4%9A%E4%B8%AA-ssh-%E5%85%AC%E9%92%A5%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%88%B0%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0/\">多个 SSH 公钥提交代码到不同平台</a>中介绍；<br>而使用 HTTPS 的方式操作简单，弊端是需要经常输入密码。</p>\n<blockquote>\n<p>git branch</p>\n</blockquote>\n<p>分支是用来管理代码版本、类型的有效工具，可根据不同的服务对象、不同的上线版本等等，来做代码分离，版本管理操作</p>\n<p>查看分支： <code>git branch</code></p>\n<p>查看带提交信息的分支信息： <code>git branch -v</code></p>\n<p>创建分支： <code>git branch &lt;分支名称&gt;</code></p>\n<p>创建并切换分支： <code>git branch -b &lt;分支名称&gt;</code></p>\n<p>切换分支： <code>git checkout &lt;分支名称&gt;</code></p>\n<p>推送分支： <code>git push origin &lt;分支名称&gt;</code></p>\n<p>删除分支： <code>git branch -d &lt;分支名称&gt;</code></p>\n<p>删除远程分支： <code>git push origin :&lt;分支名称&gt;</code></p>\n<p>合并分支： <code>git merge &lt;分支名称&gt;</code></p>\n<blockquote>\n<p>git push</p>\n</blockquote>\n<p>推送本地修改到远端服务器</p>\n<p><code>git push origin master</code></p>\n<p>有时因两个独立的历史，会导致推送无法达成， 通常在 <code>git pull</code> 时会提示 <code>fatal: refusing to merge unrelated histories  // 拒绝合并无关历史</code></p>\n<p>这时可是使用 <code>git pull origin master --allow-unrelated-histories</code> 来解决。</p>\n<blockquote>\n<p>git tag </p>\n</blockquote>\n<p>会列出所有的 <code>tag</code> 标签信息</p>\n<p>在完成了所有功能、并且经过测试之后，可以封板上线的版本，通常会打一个标签，<strong><em>这是一个很重要的功能</em></strong> </p>\n<p>建议每次上线都要做一次，便于后续的版本检索与维护，通常一个标签就代表了一个正式版本。</p>\n<p>查看本地/远程 tag 标签：<code>git tag</code></p>\n<p>查看模糊 tag 标签： <code>git tag -l &#39;v1.4.2.*&#39;</code></p>\n<p>查看备注 tag 标签： <code>git tag -ln</code></p>\n<p>查看标签信息： <code>git show &lt;标签名&gt;</code></p>\n<p>创建本地 tag 标签： <code>git tag -a &lt;标签名&gt; -m &quot;&lt;标签备注信息&gt;&quot;</code></p>\n<p>删除本地 tag 标签： <code>git tag -d &lt;标签名&gt;</code></p>\n<p>推送远程 tag 标签： <code>git push origin &lt;标签名&gt;</code></p>\n<p>推送全部 tag 标签： <code>git push origin -tags</code></p>\n<p>删除远程 tag 标签： <code>git push origin :refs/tags/&lt;标签名&gt;</code></p>\n<p><strong>查看远程机状态</strong></p>\n<blockquote>\n<p>git remote 用来管理， fork 的项目，与主项目的更新操作</p>\n</blockquote>\n<pre><code>git remote -v\ngit remote add upstream git@github.com:XXX/XXX.git\ngit fetch upstream\ngit merge upstream/master\ngit push\n</code></pre><h2 id=\"使用中的一些技巧\"><a href=\"#使用中的一些技巧\" class=\"headerlink\" title=\"使用中的一些技巧\"></a>使用中的一些技巧</h2><p><strong>命名别名</strong><br>复杂并超长的命令，可以通过起别名的方式方便在终端中书协</p>\n<pre><code>git config --global alias.ci commit\ngit config --global alias.ck checkout\ngit config --global alias.st status\n</code></pre><p>然后就可以很愉快的使用git命令了。</p>\n<pre><code>git st\n</code></pre>"},{"title":"多个 Ssh 公钥提交代码到不同平台","date":"2019-04-17T14:09:21.000Z","_content":"\n作为一个技术开发人员，免不了在 `github` 以及 `gitlab` 以及其他 `git` 平台上进行代码管理；\n工作中您可能使用 `svn` （这不在我们的讨论范围）,也有可能使用 `git`, 生活中，您可能会将一些内容分享到你的 `github` 上， 供大家参阅。\n<!-- more-->\n`git` 创建版本库很容易， `clone` 代码也仅仅是简单的一句 `git clone https://github.com/xxxx.git`，异或是 `git clone git@github.com:xxxxx.git`；当然，使用 `https` 的方式简单易操作（本人认为是一个傻瓜相机），但是通过使用 `https` 的方式，经常会遇到需要输入账号和密码的情况，这大大的加大了安全问题，虽然某 dear 的图形化工具，会帮助我们 remeber 账号和密码，避免了重复输入，但这不在我们的讨论范围（个人很鄙视使用图形化界面的），接下来要说的就是使用 `SSH` 的方式来处理 `git` 的版本管理。\n\n<!--more-->\n\n## 生成 SSH 密钥\n\n使用 `SSH` 创建一套公密钥，将公钥添加到你要使用的 `Git` 平台账户下\n\n```\nssh-keygen -t rsa -C \"your email addr\" -f ~/.ssh/github\n```\n\n注意：\n1. `-f` 后面的参数是用来自定义 SSH KEY 的存放路径，如果不需要也可以自 -f 开始省略\n2. 命令输入完成后，连击3下回车就可以，不需要处理操作（除非你很想处理）\n\n## 添加生成的 SSH 公钥\n\n添加 ssh 公钥到 `github` **\n    \n1. 打开 `https://github.com/settings/profile` ，选择 `SSH and GPG keys`\n\n    ![](https://raw.githubusercontent.com/boywithsmalleyes/static_file/master/images/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190425135335.png)\n2. 点击 `New SSH key`\n\n    1. title 可以随便写，建议见名知意，能知道是哪台设备\n    2. key 通过刚刚通过 `SSH` 命令生成的 `.pub` 文件中复制即可。文件路径 `.ssh/id_rsa.pub` 异或是存在您 `-f` 之后指定的目录。\n    3. 点击 `add SSH key`\n\n\n## 配置多个 ssh\n\n配置多个 `ssh` 时，需要注意的是：\n\n1. 如果你未指定公钥的存储路径，那么你需要一个一个的手动去创建，并配置 `ssh` 公钥到对应平台，否则，后续的 `ssh` 创建过程， 会覆盖掉之前创建的。\n2. `ssh-keygen` 会同时创建 `id_rsa` 和 `id_rsa.pub` 两个文件， `.pub` 是公钥， 不带后缀的是你的私钥。\n3. 同时配置多个 `ssh` 时，需要您保留私钥在 `.ssh` 目录下，为保证多平台都可以使用，您需要手动修改一下 `id_rsa` 文件的名称，`.pub` 就随便了，配置完，就没用了。\n4. 将密钥添加到 `ssh-agent` 中\n\n    ```\n    ssh-add ~.ssh/id_rsa\n    ```\n    \n    ```\n    # 查看 agent 中的密钥\n    ssh-add -l\n    # 查看 agent 中的公钥\n    ssh-add -L\n    # 删除 agent 中的密钥\n    ssh-add -d .ssh/id_xxx.pub\n    ```\n\n\n## 修改配置文件\n\n说了半天，终于到重点了\n\n1. 在 `~/.ssh` 目录下新建一个 `config` 文件\n\n    对，没有错，就是一个连后缀都没有的文件，这个文件用来存储您的所有平台信息，以及平台对应使用的 `ssh` 密钥。\n    `touch config`\n\n2. 添加以下配置信息\n\n    ```\n    # github\n    Host github.com # 也可以是数字 ip 地址，加不加 http/https 都无所谓\n    HostName github.com # 同上\n    PreferredAuthentications publickey # 这里不要修改\n    IdentityFile ~/.ssh/id_rsa_github # 这里的文件名修改为该平台对应的密钥\n    \n    # gitlab\n    Host 公司 gitlab 地址\n    HostName 公司 gitlab 地址\n    PreferredAuthentications publickey\n    IdentityFile ~/.ssh/id_rsa_gitlab\n    \n    ...\n    ```\n\n## 测试\n\n命令为：\n\n```\nssh -T git@github.com\n```\n\n结果\n\n```\nHi boywithsmalleyes! You've successfully authenticated, but GitHub does not provide shell access.\n```\n\n只需要替换后面的 `git`仓库地址, 其他版本库都可以进行测试。\n\n\n\n## 结语\n\n说了半天， 还是要记住一点，既然要使用 `ssh` 的方式进行版本管理，那么在 `clone` 代码时，也要使用 `ssh` 方式， 不然我说了这么半天，都是白扯。\n\n\n\n\n\n\n\n> 文章内容有瑕疵，请给予指正批评\n\n","source":"_posts/多个-ssh-公钥提交代码到不同平台.md","raw":"---\ntitle: 多个 ssh 公钥提交代码到不同平台\ndate: 2019-04-17 22:09:21\ntags: Git\n---\n\n作为一个技术开发人员，免不了在 `github` 以及 `gitlab` 以及其他 `git` 平台上进行代码管理；\n工作中您可能使用 `svn` （这不在我们的讨论范围）,也有可能使用 `git`, 生活中，您可能会将一些内容分享到你的 `github` 上， 供大家参阅。\n<!-- more-->\n`git` 创建版本库很容易， `clone` 代码也仅仅是简单的一句 `git clone https://github.com/xxxx.git`，异或是 `git clone git@github.com:xxxxx.git`；当然，使用 `https` 的方式简单易操作（本人认为是一个傻瓜相机），但是通过使用 `https` 的方式，经常会遇到需要输入账号和密码的情况，这大大的加大了安全问题，虽然某 dear 的图形化工具，会帮助我们 remeber 账号和密码，避免了重复输入，但这不在我们的讨论范围（个人很鄙视使用图形化界面的），接下来要说的就是使用 `SSH` 的方式来处理 `git` 的版本管理。\n\n<!--more-->\n\n## 生成 SSH 密钥\n\n使用 `SSH` 创建一套公密钥，将公钥添加到你要使用的 `Git` 平台账户下\n\n```\nssh-keygen -t rsa -C \"your email addr\" -f ~/.ssh/github\n```\n\n注意：\n1. `-f` 后面的参数是用来自定义 SSH KEY 的存放路径，如果不需要也可以自 -f 开始省略\n2. 命令输入完成后，连击3下回车就可以，不需要处理操作（除非你很想处理）\n\n## 添加生成的 SSH 公钥\n\n添加 ssh 公钥到 `github` **\n    \n1. 打开 `https://github.com/settings/profile` ，选择 `SSH and GPG keys`\n\n    ![](https://raw.githubusercontent.com/boywithsmalleyes/static_file/master/images/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190425135335.png)\n2. 点击 `New SSH key`\n\n    1. title 可以随便写，建议见名知意，能知道是哪台设备\n    2. key 通过刚刚通过 `SSH` 命令生成的 `.pub` 文件中复制即可。文件路径 `.ssh/id_rsa.pub` 异或是存在您 `-f` 之后指定的目录。\n    3. 点击 `add SSH key`\n\n\n## 配置多个 ssh\n\n配置多个 `ssh` 时，需要注意的是：\n\n1. 如果你未指定公钥的存储路径，那么你需要一个一个的手动去创建，并配置 `ssh` 公钥到对应平台，否则，后续的 `ssh` 创建过程， 会覆盖掉之前创建的。\n2. `ssh-keygen` 会同时创建 `id_rsa` 和 `id_rsa.pub` 两个文件， `.pub` 是公钥， 不带后缀的是你的私钥。\n3. 同时配置多个 `ssh` 时，需要您保留私钥在 `.ssh` 目录下，为保证多平台都可以使用，您需要手动修改一下 `id_rsa` 文件的名称，`.pub` 就随便了，配置完，就没用了。\n4. 将密钥添加到 `ssh-agent` 中\n\n    ```\n    ssh-add ~.ssh/id_rsa\n    ```\n    \n    ```\n    # 查看 agent 中的密钥\n    ssh-add -l\n    # 查看 agent 中的公钥\n    ssh-add -L\n    # 删除 agent 中的密钥\n    ssh-add -d .ssh/id_xxx.pub\n    ```\n\n\n## 修改配置文件\n\n说了半天，终于到重点了\n\n1. 在 `~/.ssh` 目录下新建一个 `config` 文件\n\n    对，没有错，就是一个连后缀都没有的文件，这个文件用来存储您的所有平台信息，以及平台对应使用的 `ssh` 密钥。\n    `touch config`\n\n2. 添加以下配置信息\n\n    ```\n    # github\n    Host github.com # 也可以是数字 ip 地址，加不加 http/https 都无所谓\n    HostName github.com # 同上\n    PreferredAuthentications publickey # 这里不要修改\n    IdentityFile ~/.ssh/id_rsa_github # 这里的文件名修改为该平台对应的密钥\n    \n    # gitlab\n    Host 公司 gitlab 地址\n    HostName 公司 gitlab 地址\n    PreferredAuthentications publickey\n    IdentityFile ~/.ssh/id_rsa_gitlab\n    \n    ...\n    ```\n\n## 测试\n\n命令为：\n\n```\nssh -T git@github.com\n```\n\n结果\n\n```\nHi boywithsmalleyes! You've successfully authenticated, but GitHub does not provide shell access.\n```\n\n只需要替换后面的 `git`仓库地址, 其他版本库都可以进行测试。\n\n\n\n## 结语\n\n说了半天， 还是要记住一点，既然要使用 `ssh` 的方式进行版本管理，那么在 `clone` 代码时，也要使用 `ssh` 方式， 不然我说了这么半天，都是白扯。\n\n\n\n\n\n\n\n> 文章内容有瑕疵，请给予指正批评\n\n","slug":"多个-ssh-公钥提交代码到不同平台","published":1,"updated":"2021-01-29T16:03:21.222Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb88f000esz5qgij9tkel","content":"<p>作为一个技术开发人员，免不了在 <code>github</code> 以及 <code>gitlab</code> 以及其他 <code>git</code> 平台上进行代码管理；<br>工作中您可能使用 <code>svn</code> （这不在我们的讨论范围）,也有可能使用 <code>git</code>, 生活中，您可能会将一些内容分享到你的 <code>github</code> 上， 供大家参阅。<br><a id=\"more\"></a><br><code>git</code> 创建版本库很容易， <code>clone</code> 代码也仅仅是简单的一句 <code>git clone https://github.com/xxxx.git</code>，异或是 <code>git clone git@github.com:xxxxx.git</code>；当然，使用 <code>https</code> 的方式简单易操作（本人认为是一个傻瓜相机），但是通过使用 <code>https</code> 的方式，经常会遇到需要输入账号和密码的情况，这大大的加大了安全问题，虽然某 dear 的图形化工具，会帮助我们 remeber 账号和密码，避免了重复输入，但这不在我们的讨论范围（个人很鄙视使用图形化界面的），接下来要说的就是使用 <code>SSH</code> 的方式来处理 <code>git</code> 的版本管理。</p>\n<!--more-->\n<h2 id=\"生成-SSH-密钥\"><a href=\"#生成-SSH-密钥\" class=\"headerlink\" title=\"生成 SSH 密钥\"></a>生成 SSH 密钥</h2><p>使用 <code>SSH</code> 创建一套公密钥，将公钥添加到你要使用的 <code>Git</code> 平台账户下</p>\n<pre><code>ssh-keygen -t rsa -C &quot;your email addr&quot; -f ~/.ssh/github\n</code></pre><p>注意：</p>\n<ol>\n<li><code>-f</code> 后面的参数是用来自定义 SSH KEY 的存放路径，如果不需要也可以自 -f 开始省略</li>\n<li>命令输入完成后，连击3下回车就可以，不需要处理操作（除非你很想处理）</li>\n</ol>\n<h2 id=\"添加生成的-SSH-公钥\"><a href=\"#添加生成的-SSH-公钥\" class=\"headerlink\" title=\"添加生成的 SSH 公钥\"></a>添加生成的 SSH 公钥</h2><p>添加 ssh 公钥到 <code>github</code> **</p>\n<ol>\n<li><p>打开 <code>https://github.com/settings/profile</code> ，选择 <code>SSH and GPG keys</code></p>\n<p> <img src=\"https://raw.githubusercontent.com/boywithsmalleyes/static_file/master/images/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190425135335.png\" alt></p>\n</li>\n<li><p>点击 <code>New SSH key</code></p>\n<ol>\n<li>title 可以随便写，建议见名知意，能知道是哪台设备</li>\n<li>key 通过刚刚通过 <code>SSH</code> 命令生成的 <code>.pub</code> 文件中复制即可。文件路径 <code>.ssh/id_rsa.pub</code> 异或是存在您 <code>-f</code> 之后指定的目录。</li>\n<li>点击 <code>add SSH key</code></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"配置多个-ssh\"><a href=\"#配置多个-ssh\" class=\"headerlink\" title=\"配置多个 ssh\"></a>配置多个 ssh</h2><p>配置多个 <code>ssh</code> 时，需要注意的是：</p>\n<ol>\n<li>如果你未指定公钥的存储路径，那么你需要一个一个的手动去创建，并配置 <code>ssh</code> 公钥到对应平台，否则，后续的 <code>ssh</code> 创建过程， 会覆盖掉之前创建的。</li>\n<li><code>ssh-keygen</code> 会同时创建 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 两个文件， <code>.pub</code> 是公钥， 不带后缀的是你的私钥。</li>\n<li>同时配置多个 <code>ssh</code> 时，需要您保留私钥在 <code>.ssh</code> 目录下，为保证多平台都可以使用，您需要手动修改一下 <code>id_rsa</code> 文件的名称，<code>.pub</code> 就随便了，配置完，就没用了。</li>\n<li><p>将密钥添加到 <code>ssh-agent</code> 中</p>\n<pre><code> ssh-add ~.ssh/id_rsa\n</code></pre><pre><code> # 查看 agent 中的密钥\n ssh-add -l\n # 查看 agent 中的公钥\n ssh-add -L\n # 删除 agent 中的密钥\n ssh-add -d .ssh/id_xxx.pub\n</code></pre></li>\n</ol>\n<h2 id=\"修改配置文件\"><a href=\"#修改配置文件\" class=\"headerlink\" title=\"修改配置文件\"></a>修改配置文件</h2><p>说了半天，终于到重点了</p>\n<ol>\n<li><p>在 <code>~/.ssh</code> 目录下新建一个 <code>config</code> 文件</p>\n<p> 对，没有错，就是一个连后缀都没有的文件，这个文件用来存储您的所有平台信息，以及平台对应使用的 <code>ssh</code> 密钥。<br> <code>touch config</code></p>\n</li>\n<li><p>添加以下配置信息</p>\n<pre><code> # github\n Host github.com # 也可以是数字 ip 地址，加不加 http/https 都无所谓\n HostName github.com # 同上\n PreferredAuthentications publickey # 这里不要修改\n IdentityFile ~/.ssh/id_rsa_github # 这里的文件名修改为该平台对应的密钥\n\n # gitlab\n Host 公司 gitlab 地址\n HostName 公司 gitlab 地址\n PreferredAuthentications publickey\n IdentityFile ~/.ssh/id_rsa_gitlab\n\n ...\n</code></pre></li>\n</ol>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>命令为：</p>\n<pre><code>ssh -T git@github.com\n</code></pre><p>结果</p>\n<pre><code>Hi boywithsmalleyes! You&#39;ve successfully authenticated, but GitHub does not provide shell access.\n</code></pre><p>只需要替换后面的 <code>git</code>仓库地址, 其他版本库都可以进行测试。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>说了半天， 还是要记住一点，既然要使用 <code>ssh</code> 的方式进行版本管理，那么在 <code>clone</code> 代码时，也要使用 <code>ssh</code> 方式， 不然我说了这么半天，都是白扯。</p>\n<blockquote>\n<p>文章内容有瑕疵，请给予指正批评</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>作为一个技术开发人员，免不了在 <code>github</code> 以及 <code>gitlab</code> 以及其他 <code>git</code> 平台上进行代码管理；<br>工作中您可能使用 <code>svn</code> （这不在我们的讨论范围）,也有可能使用 <code>git</code>, 生活中，您可能会将一些内容分享到你的 <code>github</code> 上， 供大家参阅。<br>","more":"<br><code>git</code> 创建版本库很容易， <code>clone</code> 代码也仅仅是简单的一句 <code>git clone https://github.com/xxxx.git</code>，异或是 <code>git clone git@github.com:xxxxx.git</code>；当然，使用 <code>https</code> 的方式简单易操作（本人认为是一个傻瓜相机），但是通过使用 <code>https</code> 的方式，经常会遇到需要输入账号和密码的情况，这大大的加大了安全问题，虽然某 dear 的图形化工具，会帮助我们 remeber 账号和密码，避免了重复输入，但这不在我们的讨论范围（个人很鄙视使用图形化界面的），接下来要说的就是使用 <code>SSH</code> 的方式来处理 <code>git</code> 的版本管理。</p>\n<!--more-->\n<h2 id=\"生成-SSH-密钥\"><a href=\"#生成-SSH-密钥\" class=\"headerlink\" title=\"生成 SSH 密钥\"></a>生成 SSH 密钥</h2><p>使用 <code>SSH</code> 创建一套公密钥，将公钥添加到你要使用的 <code>Git</code> 平台账户下</p>\n<pre><code>ssh-keygen -t rsa -C &quot;your email addr&quot; -f ~/.ssh/github\n</code></pre><p>注意：</p>\n<ol>\n<li><code>-f</code> 后面的参数是用来自定义 SSH KEY 的存放路径，如果不需要也可以自 -f 开始省略</li>\n<li>命令输入完成后，连击3下回车就可以，不需要处理操作（除非你很想处理）</li>\n</ol>\n<h2 id=\"添加生成的-SSH-公钥\"><a href=\"#添加生成的-SSH-公钥\" class=\"headerlink\" title=\"添加生成的 SSH 公钥\"></a>添加生成的 SSH 公钥</h2><p>添加 ssh 公钥到 <code>github</code> **</p>\n<ol>\n<li><p>打开 <code>https://github.com/settings/profile</code> ，选择 <code>SSH and GPG keys</code></p>\n<p> <img src=\"https://raw.githubusercontent.com/boywithsmalleyes/static_file/master/images/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190425135335.png\" alt></p>\n</li>\n<li><p>点击 <code>New SSH key</code></p>\n<ol>\n<li>title 可以随便写，建议见名知意，能知道是哪台设备</li>\n<li>key 通过刚刚通过 <code>SSH</code> 命令生成的 <code>.pub</code> 文件中复制即可。文件路径 <code>.ssh/id_rsa.pub</code> 异或是存在您 <code>-f</code> 之后指定的目录。</li>\n<li>点击 <code>add SSH key</code></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"配置多个-ssh\"><a href=\"#配置多个-ssh\" class=\"headerlink\" title=\"配置多个 ssh\"></a>配置多个 ssh</h2><p>配置多个 <code>ssh</code> 时，需要注意的是：</p>\n<ol>\n<li>如果你未指定公钥的存储路径，那么你需要一个一个的手动去创建，并配置 <code>ssh</code> 公钥到对应平台，否则，后续的 <code>ssh</code> 创建过程， 会覆盖掉之前创建的。</li>\n<li><code>ssh-keygen</code> 会同时创建 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 两个文件， <code>.pub</code> 是公钥， 不带后缀的是你的私钥。</li>\n<li>同时配置多个 <code>ssh</code> 时，需要您保留私钥在 <code>.ssh</code> 目录下，为保证多平台都可以使用，您需要手动修改一下 <code>id_rsa</code> 文件的名称，<code>.pub</code> 就随便了，配置完，就没用了。</li>\n<li><p>将密钥添加到 <code>ssh-agent</code> 中</p>\n<pre><code> ssh-add ~.ssh/id_rsa\n</code></pre><pre><code> # 查看 agent 中的密钥\n ssh-add -l\n # 查看 agent 中的公钥\n ssh-add -L\n # 删除 agent 中的密钥\n ssh-add -d .ssh/id_xxx.pub\n</code></pre></li>\n</ol>\n<h2 id=\"修改配置文件\"><a href=\"#修改配置文件\" class=\"headerlink\" title=\"修改配置文件\"></a>修改配置文件</h2><p>说了半天，终于到重点了</p>\n<ol>\n<li><p>在 <code>~/.ssh</code> 目录下新建一个 <code>config</code> 文件</p>\n<p> 对，没有错，就是一个连后缀都没有的文件，这个文件用来存储您的所有平台信息，以及平台对应使用的 <code>ssh</code> 密钥。<br> <code>touch config</code></p>\n</li>\n<li><p>添加以下配置信息</p>\n<pre><code> # github\n Host github.com # 也可以是数字 ip 地址，加不加 http/https 都无所谓\n HostName github.com # 同上\n PreferredAuthentications publickey # 这里不要修改\n IdentityFile ~/.ssh/id_rsa_github # 这里的文件名修改为该平台对应的密钥\n\n # gitlab\n Host 公司 gitlab 地址\n HostName 公司 gitlab 地址\n PreferredAuthentications publickey\n IdentityFile ~/.ssh/id_rsa_gitlab\n\n ...\n</code></pre></li>\n</ol>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>命令为：</p>\n<pre><code>ssh -T git@github.com\n</code></pre><p>结果</p>\n<pre><code>Hi boywithsmalleyes! You&#39;ve successfully authenticated, but GitHub does not provide shell access.\n</code></pre><p>只需要替换后面的 <code>git</code>仓库地址, 其他版本库都可以进行测试。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>说了半天， 还是要记住一点，既然要使用 <code>ssh</code> 的方式进行版本管理，那么在 <code>clone</code> 代码时，也要使用 <code>ssh</code> 方式， 不然我说了这么半天，都是白扯。</p>\n<blockquote>\n<p>文章内容有瑕疵，请给予指正批评</p>\n</blockquote>"},{"title":"开发一个Android IoT App","date":"2019-04-16T09:43:18.000Z","_content":"\n# 构建 Android IoT App\n\n本文翻译自[Building IoT APP for Android Things in 3 step](http://www.survivingwithandroid.com/2017/01/building-iot-app-android-things-android-iot-appplication-development.html)\n\n<!--more-->\n## 前言\n\n这篇文章主要描述了，如何为 Android Things 构建 Android IoT App。 也许你早已经知道了，最近 Google 发布了一个新的 IoT 操作系统-- Android Things。Android Things 系统，是由 Android 系统衍生出来的，更有意思的是，我们可以使用我们的 Android 知识来开发 Android IoT 应用程序。在开始之前，了解 [Android Things and how it works](http://www.survivingwithandroid.com/2017/01/android-things-android-internet-of-things.html) 是很有必要的。\n\n\n## 名词索引\n\nAndroid IoT App ： 安卓物联网应用\n\nRaspberry Pi 3 ： 树莓派 3\n\n\n\n## 目标\n\n这篇文章的目标是：\n\n1. 使用 Android Things 构建一个简单的 RGB Led 控制器\n2. 使用 Android API 构建 Android IoT UI 开发\n\n我们会使用 `Raspberry Pi 3 ` 作为 [IoT 开发板](http://www.survivingwithandroid.com/2016/08/iot-rapid-prototyping-board.html),你也可以使用其他的开发板去开发 Android Things。\n\n此Android IoT应用可帮助您熟悉新的Android Things API。 此外，这个物联网应用程序对于开发Android IoT 应用 UI 的概述很有用。\n\n## 步骤一\n\n通常情况下，一个 IoT 工程有两部分， 电气/电子部分和软件部分。让事情变得简单，使我们可以集中精力在Android IoT App, 这个 IoT 应用控制着一个简单的 RGB LED （共阳极）灯。RGB Led 灯使用220Ω电阻链接到 `Raspberry`， 每个颜色一个，原理图如下：\n\n![引脚原理图](http://upload-images.jianshu.io/upload_images/1550996-ce68329a358d9cb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n共阳极 RGB LED 灯非常常见，因此 `Raspberry Pi 3` 为引脚阳极供电。控制 LED 颜色的 RGB 引脚连接到 `Raspberry` 引脚：\n\n* Pin 29\n* Pin 31\n* Pin 33\n\n这些引脚索引是非常重要的，因为我们会在 Android IoT App 上使用它。 上电前，请仔细检查 Raspberry 链接是否有异常。\n\n现在，我们使用  `Android Studio` 创建一个 IoT 应用，第一步，配置 Android IoT 工程， build.gradle :\n\n```\ndependencies {\n    provided 'com.google.android.things:androidthings:0.1-devpreview'\n}\n```\n\nAndroid Things 使用 Activity ，就像我们在 Android 中使用一样。因此，让我们创建一个 `RGBThingsActivity` 类，并在 `onCreate` 方法中处理 `Pin` 通信。\n\n## 步骤二\n\n使用 `GPIO` 引脚与 RGB LED 传递信息。 `GPIO` 引脚使用可编程的接口去获取设备的状态或者设置输出值（高电平/低电平），使用 Respberry GPIO 音及哦啊，我们开启或关闭三个颜色的组件（红绿蓝）。\n\nAndroid Things SDK 提供了一个 `PeripheralManagerService` 的服务，去抽象 GPIO 通信接口。每当我们想读写数据时都必须使用它。一开始， Android IoT App 初始化服务，并设置引脚值：\n\n```\ntry {\n   PeripheralManagerService manager = new PeripheralManagerService();\n   blueIO = manager.openGpio(\"BCM5\");\n   blueIO.setDirection(Gpio.DIRECTION_OUT_INITIALLY_LOW);\n   greenIO = manager.openGpio(\"BCM6\");\n   greenIO.setDirection(Gpio.DIRECTION_OUT_INITIALLY_HIGH);\n   redIO = manager.openGpio(\"BCM13\");\n   redIO.setDirection(Gpio.DIRECTION_OUT_INITIALLY_LOW);\n   redIO.setValue(false);\n   blueIO.setValue(false);\n   greenIO.setValue(false);\n} catch (IOException e) {\n   Log.w(TAG, \"Unable to access GPIO\", e);\n}\n```\n\n这段代码介绍了一些新的重要的新方面。首先,我们必须选对引脚。如果使用的是 Respberry ，我们需要知道每一个引脚都有对应的序号。同样的方式，Android Things 使用相同的寻址模型，不管怎样，引脚的命名都是用不同的方式。通过 [Respberry Pin reference](https://developer.android.com/things/hardware/raspberrypi-io.html) ,下图：\n\n![树莓派引脚图](http://upload-images.jianshu.io/upload_images/1550996-0957d79bc802bd94?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以了解到 `Respberry Pi 3` 的引脚地址。这些地址名称在上面的代码中使用。 例如，要使用引脚BCM5（或引脚29），代码为：\n\n```\nblueIO = manager.openGpio(\"BCM5\");\n```\n\n开始， 我们设置所有的引脚为低电平状态（低电平即为关闭状态），此时 Led 灯为关闭状态。改变引脚的状态值，由低电平调整到高电平，或者有高电平调整为低电平，我们可以看到灯的颜色变化。\n\n## 步骤三\n\nAndroid Things 另外一个有趣的功能是，为我们提供了 UI Interface。 我们开发一个 UI Interface 给 Android IoT App 和开发 Android UI 一样。就像 Android app 一样， Android Things UI 同样是使用 xml 格式开发。 下面例子，我们去配置控制 RGB Led 显示的 3 个开关：\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n  <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n            android:orientation=\"vertical\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\">\n \n <Switch android:text=\"Red\"\n         android:layout_width=\"wrap_content\"\n         android:layout_height=\"wrap_content\"\n         android:id=\"@+id/switchRed\"\n         android:layout_marginTop=\"20dp\"/>\n \n <Switch android:text=\"Green\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:id=\"@+id/switchGreen\"\n        android:layout_marginTop=\"20dp\"/>\n \n <Switch android:text=\"Blue\"\n         android:layout_width=\"wrap_content\"\n         android:layout_height=\"wrap_content\"\n         android:id=\"@+id/switchBlue\"\n         android:layout_marginTop=\"20dp\"/>\n \n</LinearLayout>\n```\n\n在 `onCreate` 方法中，我们设置 layout 布局：\n\n```\n@Override\npublic void onCreate (Bundle savedInstanceState) {\n    super.onCreate(saveInstanceState);\n    setContentView(R.layout.activity_main);\n    ...\n}\n```\n\n处理用户开关：\n\n```\nSwitch switchRed = (Switch)findViewById(R.id.switchRed);\nswitch.setOnCheckedChangedListener(new CompoundButton.OnCheckedChangedListener(){\n    @Override\n    public void onCheckedChanged (CompoundButton buttonView, boolean isChecked){\n        try {\n            redIO.setValue(!isChecked);\n        } catch (IOException e) {\n            Log.w(TAG,\"Red GPIO Error\", e);\n        }\n    }\n});\n```\n\n我们必须为其他引脚重复同一段代码。最终结果如下：\n\n因 MarkDown 模式下， 简书不支持视频播放，请点击一下链接观看。\n\n[最终结果展示--需要翻墙 youtube 上观看](https://www.youtube.com/embed/KT_FAqMbbNQ)\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/KT_FAqMbbNQ\" frameborder=\"0\" allowfullscreen></iframe>\n\n最后，要使用我们的应用程序，我们必须在 `Manifest.xml` 文件中条件：\n\n```\n<uses-library android:name=\"com.google.android.things\"/>\n```\n\n并且声明我的 `Activity` 是一个 IoT Activity， 启动脚本为：\n\n```\n<intent-filter>\n    <category android:name=\"android.intent.category.IOT_LAUNCHER\"/>\n    <category android:name=\"android.intent.category.DEFAULT”/>\n</intent-filter>\n```\n\n## 总结\n\n文章最后，你已经知道了如何更好的使用 Android Things。 有趣的是，使用一些新的 API Android 开发人员可以准备下一次技术革命成为物联网。此外，开发过程与 Android 应用程序相同。\n\n使用简单的几行代码，一个 Android 开发者就可以构建 Android IoT App.\n\n","source":"_posts/开发一个Android-IoT-App.md","raw":"---\ntitle: 开发一个Android IoT App\ndate: 2019-04-16 17:43:18\ntags: Android Things\n---\n\n# 构建 Android IoT App\n\n本文翻译自[Building IoT APP for Android Things in 3 step](http://www.survivingwithandroid.com/2017/01/building-iot-app-android-things-android-iot-appplication-development.html)\n\n<!--more-->\n## 前言\n\n这篇文章主要描述了，如何为 Android Things 构建 Android IoT App。 也许你早已经知道了，最近 Google 发布了一个新的 IoT 操作系统-- Android Things。Android Things 系统，是由 Android 系统衍生出来的，更有意思的是，我们可以使用我们的 Android 知识来开发 Android IoT 应用程序。在开始之前，了解 [Android Things and how it works](http://www.survivingwithandroid.com/2017/01/android-things-android-internet-of-things.html) 是很有必要的。\n\n\n## 名词索引\n\nAndroid IoT App ： 安卓物联网应用\n\nRaspberry Pi 3 ： 树莓派 3\n\n\n\n## 目标\n\n这篇文章的目标是：\n\n1. 使用 Android Things 构建一个简单的 RGB Led 控制器\n2. 使用 Android API 构建 Android IoT UI 开发\n\n我们会使用 `Raspberry Pi 3 ` 作为 [IoT 开发板](http://www.survivingwithandroid.com/2016/08/iot-rapid-prototyping-board.html),你也可以使用其他的开发板去开发 Android Things。\n\n此Android IoT应用可帮助您熟悉新的Android Things API。 此外，这个物联网应用程序对于开发Android IoT 应用 UI 的概述很有用。\n\n## 步骤一\n\n通常情况下，一个 IoT 工程有两部分， 电气/电子部分和软件部分。让事情变得简单，使我们可以集中精力在Android IoT App, 这个 IoT 应用控制着一个简单的 RGB LED （共阳极）灯。RGB Led 灯使用220Ω电阻链接到 `Raspberry`， 每个颜色一个，原理图如下：\n\n![引脚原理图](http://upload-images.jianshu.io/upload_images/1550996-ce68329a358d9cb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\n共阳极 RGB LED 灯非常常见，因此 `Raspberry Pi 3` 为引脚阳极供电。控制 LED 颜色的 RGB 引脚连接到 `Raspberry` 引脚：\n\n* Pin 29\n* Pin 31\n* Pin 33\n\n这些引脚索引是非常重要的，因为我们会在 Android IoT App 上使用它。 上电前，请仔细检查 Raspberry 链接是否有异常。\n\n现在，我们使用  `Android Studio` 创建一个 IoT 应用，第一步，配置 Android IoT 工程， build.gradle :\n\n```\ndependencies {\n    provided 'com.google.android.things:androidthings:0.1-devpreview'\n}\n```\n\nAndroid Things 使用 Activity ，就像我们在 Android 中使用一样。因此，让我们创建一个 `RGBThingsActivity` 类，并在 `onCreate` 方法中处理 `Pin` 通信。\n\n## 步骤二\n\n使用 `GPIO` 引脚与 RGB LED 传递信息。 `GPIO` 引脚使用可编程的接口去获取设备的状态或者设置输出值（高电平/低电平），使用 Respberry GPIO 音及哦啊，我们开启或关闭三个颜色的组件（红绿蓝）。\n\nAndroid Things SDK 提供了一个 `PeripheralManagerService` 的服务，去抽象 GPIO 通信接口。每当我们想读写数据时都必须使用它。一开始， Android IoT App 初始化服务，并设置引脚值：\n\n```\ntry {\n   PeripheralManagerService manager = new PeripheralManagerService();\n   blueIO = manager.openGpio(\"BCM5\");\n   blueIO.setDirection(Gpio.DIRECTION_OUT_INITIALLY_LOW);\n   greenIO = manager.openGpio(\"BCM6\");\n   greenIO.setDirection(Gpio.DIRECTION_OUT_INITIALLY_HIGH);\n   redIO = manager.openGpio(\"BCM13\");\n   redIO.setDirection(Gpio.DIRECTION_OUT_INITIALLY_LOW);\n   redIO.setValue(false);\n   blueIO.setValue(false);\n   greenIO.setValue(false);\n} catch (IOException e) {\n   Log.w(TAG, \"Unable to access GPIO\", e);\n}\n```\n\n这段代码介绍了一些新的重要的新方面。首先,我们必须选对引脚。如果使用的是 Respberry ，我们需要知道每一个引脚都有对应的序号。同样的方式，Android Things 使用相同的寻址模型，不管怎样，引脚的命名都是用不同的方式。通过 [Respberry Pin reference](https://developer.android.com/things/hardware/raspberrypi-io.html) ,下图：\n\n![树莓派引脚图](http://upload-images.jianshu.io/upload_images/1550996-0957d79bc802bd94?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以了解到 `Respberry Pi 3` 的引脚地址。这些地址名称在上面的代码中使用。 例如，要使用引脚BCM5（或引脚29），代码为：\n\n```\nblueIO = manager.openGpio(\"BCM5\");\n```\n\n开始， 我们设置所有的引脚为低电平状态（低电平即为关闭状态），此时 Led 灯为关闭状态。改变引脚的状态值，由低电平调整到高电平，或者有高电平调整为低电平，我们可以看到灯的颜色变化。\n\n## 步骤三\n\nAndroid Things 另外一个有趣的功能是，为我们提供了 UI Interface。 我们开发一个 UI Interface 给 Android IoT App 和开发 Android UI 一样。就像 Android app 一样， Android Things UI 同样是使用 xml 格式开发。 下面例子，我们去配置控制 RGB Led 显示的 3 个开关：\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n  <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n            android:orientation=\"vertical\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\">\n \n <Switch android:text=\"Red\"\n         android:layout_width=\"wrap_content\"\n         android:layout_height=\"wrap_content\"\n         android:id=\"@+id/switchRed\"\n         android:layout_marginTop=\"20dp\"/>\n \n <Switch android:text=\"Green\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:id=\"@+id/switchGreen\"\n        android:layout_marginTop=\"20dp\"/>\n \n <Switch android:text=\"Blue\"\n         android:layout_width=\"wrap_content\"\n         android:layout_height=\"wrap_content\"\n         android:id=\"@+id/switchBlue\"\n         android:layout_marginTop=\"20dp\"/>\n \n</LinearLayout>\n```\n\n在 `onCreate` 方法中，我们设置 layout 布局：\n\n```\n@Override\npublic void onCreate (Bundle savedInstanceState) {\n    super.onCreate(saveInstanceState);\n    setContentView(R.layout.activity_main);\n    ...\n}\n```\n\n处理用户开关：\n\n```\nSwitch switchRed = (Switch)findViewById(R.id.switchRed);\nswitch.setOnCheckedChangedListener(new CompoundButton.OnCheckedChangedListener(){\n    @Override\n    public void onCheckedChanged (CompoundButton buttonView, boolean isChecked){\n        try {\n            redIO.setValue(!isChecked);\n        } catch (IOException e) {\n            Log.w(TAG,\"Red GPIO Error\", e);\n        }\n    }\n});\n```\n\n我们必须为其他引脚重复同一段代码。最终结果如下：\n\n因 MarkDown 模式下， 简书不支持视频播放，请点击一下链接观看。\n\n[最终结果展示--需要翻墙 youtube 上观看](https://www.youtube.com/embed/KT_FAqMbbNQ)\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/KT_FAqMbbNQ\" frameborder=\"0\" allowfullscreen></iframe>\n\n最后，要使用我们的应用程序，我们必须在 `Manifest.xml` 文件中条件：\n\n```\n<uses-library android:name=\"com.google.android.things\"/>\n```\n\n并且声明我的 `Activity` 是一个 IoT Activity， 启动脚本为：\n\n```\n<intent-filter>\n    <category android:name=\"android.intent.category.IOT_LAUNCHER\"/>\n    <category android:name=\"android.intent.category.DEFAULT”/>\n</intent-filter>\n```\n\n## 总结\n\n文章最后，你已经知道了如何更好的使用 Android Things。 有趣的是，使用一些新的 API Android 开发人员可以准备下一次技术革命成为物联网。此外，开发过程与 Android 应用程序相同。\n\n使用简单的几行代码，一个 Android 开发者就可以构建 Android IoT App.\n\n","slug":"开发一个Android-IoT-App","published":1,"updated":"2019-04-17T13:54:19.361Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb88k000hsz5qtdw7y9a9","content":"<h1 id=\"构建-Android-IoT-App\"><a href=\"#构建-Android-IoT-App\" class=\"headerlink\" title=\"构建 Android IoT App\"></a>构建 Android IoT App</h1><p>本文翻译自<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdXJ2aXZpbmd3aXRoYW5kcm9pZC5jb20vMjAxNy8wMS9idWlsZGluZy1pb3QtYXBwLWFuZHJvaWQtdGhpbmdzLWFuZHJvaWQtaW90LWFwcHBsaWNhdGlvbi1kZXZlbG9wbWVudC5odG1s\" title=\"http://www.survivingwithandroid.com/2017/01/building-iot-app-android-things-android-iot-appplication-development.html\">Building IoT APP for Android Things in 3 step<i class=\"fa fa-external-link\"></i></span></p>\n<a id=\"more\"></a>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>这篇文章主要描述了，如何为 Android Things 构建 Android IoT App。 也许你早已经知道了，最近 Google 发布了一个新的 IoT 操作系统– Android Things。Android Things 系统，是由 Android 系统衍生出来的，更有意思的是，我们可以使用我们的 Android 知识来开发 Android IoT 应用程序。在开始之前，了解 <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdXJ2aXZpbmd3aXRoYW5kcm9pZC5jb20vMjAxNy8wMS9hbmRyb2lkLXRoaW5ncy1hbmRyb2lkLWludGVybmV0LW9mLXRoaW5ncy5odG1s\" title=\"http://www.survivingwithandroid.com/2017/01/android-things-android-internet-of-things.html\">Android Things and how it works<i class=\"fa fa-external-link\"></i></span> 是很有必要的。</p>\n<h2 id=\"名词索引\"><a href=\"#名词索引\" class=\"headerlink\" title=\"名词索引\"></a>名词索引</h2><p>Android IoT App ： 安卓物联网应用</p>\n<p>Raspberry Pi 3 ： 树莓派 3</p>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p>这篇文章的目标是：</p>\n<ol>\n<li>使用 Android Things 构建一个简单的 RGB Led 控制器</li>\n<li>使用 Android API 构建 Android IoT UI 开发</li>\n</ol>\n<p>我们会使用 <code>Raspberry Pi 3</code> 作为 <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdXJ2aXZpbmd3aXRoYW5kcm9pZC5jb20vMjAxNi8wOC9pb3QtcmFwaWQtcHJvdG90eXBpbmctYm9hcmQuaHRtbA==\" title=\"http://www.survivingwithandroid.com/2016/08/iot-rapid-prototyping-board.html\">IoT 开发板<i class=\"fa fa-external-link\"></i></span>,你也可以使用其他的开发板去开发 Android Things。</p>\n<p>此Android IoT应用可帮助您熟悉新的Android Things API。 此外，这个物联网应用程序对于开发Android IoT 应用 UI 的概述很有用。</p>\n<h2 id=\"步骤一\"><a href=\"#步骤一\" class=\"headerlink\" title=\"步骤一\"></a>步骤一</h2><p>通常情况下，一个 IoT 工程有两部分， 电气/电子部分和软件部分。让事情变得简单，使我们可以集中精力在Android IoT App, 这个 IoT 应用控制着一个简单的 RGB LED （共阳极）灯。RGB Led 灯使用220Ω电阻链接到 <code>Raspberry</code>， 每个颜色一个，原理图如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-ce68329a358d9cb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"引脚原理图\"> </p>\n<p>共阳极 RGB LED 灯非常常见，因此 <code>Raspberry Pi 3</code> 为引脚阳极供电。控制 LED 颜色的 RGB 引脚连接到 <code>Raspberry</code> 引脚：</p>\n<ul>\n<li>Pin 29</li>\n<li>Pin 31</li>\n<li>Pin 33</li>\n</ul>\n<p>这些引脚索引是非常重要的，因为我们会在 Android IoT App 上使用它。 上电前，请仔细检查 Raspberry 链接是否有异常。</p>\n<p>现在，我们使用  <code>Android Studio</code> 创建一个 IoT 应用，第一步，配置 Android IoT 工程， build.gradle :</p>\n<pre><code>dependencies {\n    provided &#39;com.google.android.things:androidthings:0.1-devpreview&#39;\n}\n</code></pre><p>Android Things 使用 Activity ，就像我们在 Android 中使用一样。因此，让我们创建一个 <code>RGBThingsActivity</code> 类，并在 <code>onCreate</code> 方法中处理 <code>Pin</code> 通信。</p>\n<h2 id=\"步骤二\"><a href=\"#步骤二\" class=\"headerlink\" title=\"步骤二\"></a>步骤二</h2><p>使用 <code>GPIO</code> 引脚与 RGB LED 传递信息。 <code>GPIO</code> 引脚使用可编程的接口去获取设备的状态或者设置输出值（高电平/低电平），使用 Respberry GPIO 音及哦啊，我们开启或关闭三个颜色的组件（红绿蓝）。</p>\n<p>Android Things SDK 提供了一个 <code>PeripheralManagerService</code> 的服务，去抽象 GPIO 通信接口。每当我们想读写数据时都必须使用它。一开始， Android IoT App 初始化服务，并设置引脚值：</p>\n<pre><code>try {\n   PeripheralManagerService manager = new PeripheralManagerService();\n   blueIO = manager.openGpio(&quot;BCM5&quot;);\n   blueIO.setDirection(Gpio.DIRECTION_OUT_INITIALLY_LOW);\n   greenIO = manager.openGpio(&quot;BCM6&quot;);\n   greenIO.setDirection(Gpio.DIRECTION_OUT_INITIALLY_HIGH);\n   redIO = manager.openGpio(&quot;BCM13&quot;);\n   redIO.setDirection(Gpio.DIRECTION_OUT_INITIALLY_LOW);\n   redIO.setValue(false);\n   blueIO.setValue(false);\n   greenIO.setValue(false);\n} catch (IOException e) {\n   Log.w(TAG, &quot;Unable to access GPIO&quot;, e);\n}\n</code></pre><p>这段代码介绍了一些新的重要的新方面。首先,我们必须选对引脚。如果使用的是 Respberry ，我们需要知道每一个引脚都有对应的序号。同样的方式，Android Things 使用相同的寻址模型，不管怎样，引脚的命名都是用不同的方式。通过 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdGhpbmdzL2hhcmR3YXJlL3Jhc3BiZXJyeXBpLWlvLmh0bWw=\" title=\"https://developer.android.com/things/hardware/raspberrypi-io.html\">Respberry Pin reference<i class=\"fa fa-external-link\"></i></span> ,下图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-0957d79bc802bd94?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"树莓派引脚图\"></p>\n<p>可以了解到 <code>Respberry Pi 3</code> 的引脚地址。这些地址名称在上面的代码中使用。 例如，要使用引脚BCM5（或引脚29），代码为：</p>\n<pre><code>blueIO = manager.openGpio(&quot;BCM5&quot;);\n</code></pre><p>开始， 我们设置所有的引脚为低电平状态（低电平即为关闭状态），此时 Led 灯为关闭状态。改变引脚的状态值，由低电平调整到高电平，或者有高电平调整为低电平，我们可以看到灯的颜色变化。</p>\n<h2 id=\"步骤三\"><a href=\"#步骤三\" class=\"headerlink\" title=\"步骤三\"></a>步骤三</h2><p>Android Things 另外一个有趣的功能是，为我们提供了 UI Interface。 我们开发一个 UI Interface 给 Android IoT App 和开发 Android UI 一样。就像 Android app 一样， Android Things UI 同样是使用 xml 格式开发。 下面例子，我们去配置控制 RGB Led 显示的 3 个开关：</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n  &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n            android:orientation=&quot;vertical&quot;\n            android:layout_width=&quot;match_parent&quot;\n            android:layout_height=&quot;match_parent&quot;&gt;\n\n &lt;Switch android:text=&quot;Red&quot;\n         android:layout_width=&quot;wrap_content&quot;\n         android:layout_height=&quot;wrap_content&quot;\n         android:id=&quot;@+id/switchRed&quot;\n         android:layout_marginTop=&quot;20dp&quot;/&gt;\n\n &lt;Switch android:text=&quot;Green&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:id=&quot;@+id/switchGreen&quot;\n        android:layout_marginTop=&quot;20dp&quot;/&gt;\n\n &lt;Switch android:text=&quot;Blue&quot;\n         android:layout_width=&quot;wrap_content&quot;\n         android:layout_height=&quot;wrap_content&quot;\n         android:id=&quot;@+id/switchBlue&quot;\n         android:layout_marginTop=&quot;20dp&quot;/&gt;\n\n&lt;/LinearLayout&gt;\n</code></pre><p>在 <code>onCreate</code> 方法中，我们设置 layout 布局：</p>\n<pre><code>@Override\npublic void onCreate (Bundle savedInstanceState) {\n    super.onCreate(saveInstanceState);\n    setContentView(R.layout.activity_main);\n    ...\n}\n</code></pre><p>处理用户开关：</p>\n<pre><code>Switch switchRed = (Switch)findViewById(R.id.switchRed);\nswitch.setOnCheckedChangedListener(new CompoundButton.OnCheckedChangedListener(){\n    @Override\n    public void onCheckedChanged (CompoundButton buttonView, boolean isChecked){\n        try {\n            redIO.setValue(!isChecked);\n        } catch (IOException e) {\n            Log.w(TAG,&quot;Red GPIO Error&quot;, e);\n        }\n    }\n});\n</code></pre><p>我们必须为其他引脚重复同一段代码。最终结果如下：</p>\n<p>因 MarkDown 模式下， 简书不支持视频播放，请点击一下链接观看。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vZW1iZWQvS1RfRkFxTWJiTlE=\" title=\"https://www.youtube.com/embed/KT_FAqMbbNQ\">最终结果展示–需要翻墙 youtube 上观看<i class=\"fa fa-external-link\"></i></span></p>\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/KT_FAqMbbNQ\" frameborder=\"0\" allowfullscreen></iframe>\n\n<p>最后，要使用我们的应用程序，我们必须在 <code>Manifest.xml</code> 文件中条件：</p>\n<pre><code>&lt;uses-library android:name=&quot;com.google.android.things&quot;/&gt;\n</code></pre><p>并且声明我的 <code>Activity</code> 是一个 IoT Activity， 启动脚本为：</p>\n<pre><code>&lt;intent-filter&gt;\n    &lt;category android:name=&quot;android.intent.category.IOT_LAUNCHER&quot;/&gt;\n    &lt;category android:name=&quot;android.intent.category.DEFAULT”/&gt;\n&lt;/intent-filter&gt;\n</code></pre><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>文章最后，你已经知道了如何更好的使用 Android Things。 有趣的是，使用一些新的 API Android 开发人员可以准备下一次技术革命成为物联网。此外，开发过程与 Android 应用程序相同。</p>\n<p>使用简单的几行代码，一个 Android 开发者就可以构建 Android IoT App.</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"构建-Android-IoT-App\"><a href=\"#构建-Android-IoT-App\" class=\"headerlink\" title=\"构建 Android IoT App\"></a>构建 Android IoT App</h1><p>本文翻译自<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdXJ2aXZpbmd3aXRoYW5kcm9pZC5jb20vMjAxNy8wMS9idWlsZGluZy1pb3QtYXBwLWFuZHJvaWQtdGhpbmdzLWFuZHJvaWQtaW90LWFwcHBsaWNhdGlvbi1kZXZlbG9wbWVudC5odG1s\" title=\"http://www.survivingwithandroid.com/2017/01/building-iot-app-android-things-android-iot-appplication-development.html\">Building IoT APP for Android Things in 3 step<i class=\"fa fa-external-link\"></i></span></p>","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>这篇文章主要描述了，如何为 Android Things 构建 Android IoT App。 也许你早已经知道了，最近 Google 发布了一个新的 IoT 操作系统– Android Things。Android Things 系统，是由 Android 系统衍生出来的，更有意思的是，我们可以使用我们的 Android 知识来开发 Android IoT 应用程序。在开始之前，了解 <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdXJ2aXZpbmd3aXRoYW5kcm9pZC5jb20vMjAxNy8wMS9hbmRyb2lkLXRoaW5ncy1hbmRyb2lkLWludGVybmV0LW9mLXRoaW5ncy5odG1s\" title=\"http://www.survivingwithandroid.com/2017/01/android-things-android-internet-of-things.html\">Android Things and how it works<i class=\"fa fa-external-link\"></i></span> 是很有必要的。</p>\n<h2 id=\"名词索引\"><a href=\"#名词索引\" class=\"headerlink\" title=\"名词索引\"></a>名词索引</h2><p>Android IoT App ： 安卓物联网应用</p>\n<p>Raspberry Pi 3 ： 树莓派 3</p>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p>这篇文章的目标是：</p>\n<ol>\n<li>使用 Android Things 构建一个简单的 RGB Led 控制器</li>\n<li>使用 Android API 构建 Android IoT UI 开发</li>\n</ol>\n<p>我们会使用 <code>Raspberry Pi 3</code> 作为 <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdXJ2aXZpbmd3aXRoYW5kcm9pZC5jb20vMjAxNi8wOC9pb3QtcmFwaWQtcHJvdG90eXBpbmctYm9hcmQuaHRtbA==\" title=\"http://www.survivingwithandroid.com/2016/08/iot-rapid-prototyping-board.html\">IoT 开发板<i class=\"fa fa-external-link\"></i></span>,你也可以使用其他的开发板去开发 Android Things。</p>\n<p>此Android IoT应用可帮助您熟悉新的Android Things API。 此外，这个物联网应用程序对于开发Android IoT 应用 UI 的概述很有用。</p>\n<h2 id=\"步骤一\"><a href=\"#步骤一\" class=\"headerlink\" title=\"步骤一\"></a>步骤一</h2><p>通常情况下，一个 IoT 工程有两部分， 电气/电子部分和软件部分。让事情变得简单，使我们可以集中精力在Android IoT App, 这个 IoT 应用控制着一个简单的 RGB LED （共阳极）灯。RGB Led 灯使用220Ω电阻链接到 <code>Raspberry</code>， 每个颜色一个，原理图如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-ce68329a358d9cb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"引脚原理图\"> </p>\n<p>共阳极 RGB LED 灯非常常见，因此 <code>Raspberry Pi 3</code> 为引脚阳极供电。控制 LED 颜色的 RGB 引脚连接到 <code>Raspberry</code> 引脚：</p>\n<ul>\n<li>Pin 29</li>\n<li>Pin 31</li>\n<li>Pin 33</li>\n</ul>\n<p>这些引脚索引是非常重要的，因为我们会在 Android IoT App 上使用它。 上电前，请仔细检查 Raspberry 链接是否有异常。</p>\n<p>现在，我们使用  <code>Android Studio</code> 创建一个 IoT 应用，第一步，配置 Android IoT 工程， build.gradle :</p>\n<pre><code>dependencies {\n    provided &#39;com.google.android.things:androidthings:0.1-devpreview&#39;\n}\n</code></pre><p>Android Things 使用 Activity ，就像我们在 Android 中使用一样。因此，让我们创建一个 <code>RGBThingsActivity</code> 类，并在 <code>onCreate</code> 方法中处理 <code>Pin</code> 通信。</p>\n<h2 id=\"步骤二\"><a href=\"#步骤二\" class=\"headerlink\" title=\"步骤二\"></a>步骤二</h2><p>使用 <code>GPIO</code> 引脚与 RGB LED 传递信息。 <code>GPIO</code> 引脚使用可编程的接口去获取设备的状态或者设置输出值（高电平/低电平），使用 Respberry GPIO 音及哦啊，我们开启或关闭三个颜色的组件（红绿蓝）。</p>\n<p>Android Things SDK 提供了一个 <code>PeripheralManagerService</code> 的服务，去抽象 GPIO 通信接口。每当我们想读写数据时都必须使用它。一开始， Android IoT App 初始化服务，并设置引脚值：</p>\n<pre><code>try {\n   PeripheralManagerService manager = new PeripheralManagerService();\n   blueIO = manager.openGpio(&quot;BCM5&quot;);\n   blueIO.setDirection(Gpio.DIRECTION_OUT_INITIALLY_LOW);\n   greenIO = manager.openGpio(&quot;BCM6&quot;);\n   greenIO.setDirection(Gpio.DIRECTION_OUT_INITIALLY_HIGH);\n   redIO = manager.openGpio(&quot;BCM13&quot;);\n   redIO.setDirection(Gpio.DIRECTION_OUT_INITIALLY_LOW);\n   redIO.setValue(false);\n   blueIO.setValue(false);\n   greenIO.setValue(false);\n} catch (IOException e) {\n   Log.w(TAG, &quot;Unable to access GPIO&quot;, e);\n}\n</code></pre><p>这段代码介绍了一些新的重要的新方面。首先,我们必须选对引脚。如果使用的是 Respberry ，我们需要知道每一个引脚都有对应的序号。同样的方式，Android Things 使用相同的寻址模型，不管怎样，引脚的命名都是用不同的方式。通过 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdGhpbmdzL2hhcmR3YXJlL3Jhc3BiZXJyeXBpLWlvLmh0bWw=\" title=\"https://developer.android.com/things/hardware/raspberrypi-io.html\">Respberry Pin reference<i class=\"fa fa-external-link\"></i></span> ,下图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1550996-0957d79bc802bd94?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"树莓派引脚图\"></p>\n<p>可以了解到 <code>Respberry Pi 3</code> 的引脚地址。这些地址名称在上面的代码中使用。 例如，要使用引脚BCM5（或引脚29），代码为：</p>\n<pre><code>blueIO = manager.openGpio(&quot;BCM5&quot;);\n</code></pre><p>开始， 我们设置所有的引脚为低电平状态（低电平即为关闭状态），此时 Led 灯为关闭状态。改变引脚的状态值，由低电平调整到高电平，或者有高电平调整为低电平，我们可以看到灯的颜色变化。</p>\n<h2 id=\"步骤三\"><a href=\"#步骤三\" class=\"headerlink\" title=\"步骤三\"></a>步骤三</h2><p>Android Things 另外一个有趣的功能是，为我们提供了 UI Interface。 我们开发一个 UI Interface 给 Android IoT App 和开发 Android UI 一样。就像 Android app 一样， Android Things UI 同样是使用 xml 格式开发。 下面例子，我们去配置控制 RGB Led 显示的 3 个开关：</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n  &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n            android:orientation=&quot;vertical&quot;\n            android:layout_width=&quot;match_parent&quot;\n            android:layout_height=&quot;match_parent&quot;&gt;\n\n &lt;Switch android:text=&quot;Red&quot;\n         android:layout_width=&quot;wrap_content&quot;\n         android:layout_height=&quot;wrap_content&quot;\n         android:id=&quot;@+id/switchRed&quot;\n         android:layout_marginTop=&quot;20dp&quot;/&gt;\n\n &lt;Switch android:text=&quot;Green&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:id=&quot;@+id/switchGreen&quot;\n        android:layout_marginTop=&quot;20dp&quot;/&gt;\n\n &lt;Switch android:text=&quot;Blue&quot;\n         android:layout_width=&quot;wrap_content&quot;\n         android:layout_height=&quot;wrap_content&quot;\n         android:id=&quot;@+id/switchBlue&quot;\n         android:layout_marginTop=&quot;20dp&quot;/&gt;\n\n&lt;/LinearLayout&gt;\n</code></pre><p>在 <code>onCreate</code> 方法中，我们设置 layout 布局：</p>\n<pre><code>@Override\npublic void onCreate (Bundle savedInstanceState) {\n    super.onCreate(saveInstanceState);\n    setContentView(R.layout.activity_main);\n    ...\n}\n</code></pre><p>处理用户开关：</p>\n<pre><code>Switch switchRed = (Switch)findViewById(R.id.switchRed);\nswitch.setOnCheckedChangedListener(new CompoundButton.OnCheckedChangedListener(){\n    @Override\n    public void onCheckedChanged (CompoundButton buttonView, boolean isChecked){\n        try {\n            redIO.setValue(!isChecked);\n        } catch (IOException e) {\n            Log.w(TAG,&quot;Red GPIO Error&quot;, e);\n        }\n    }\n});\n</code></pre><p>我们必须为其他引脚重复同一段代码。最终结果如下：</p>\n<p>因 MarkDown 模式下， 简书不支持视频播放，请点击一下链接观看。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vZW1iZWQvS1RfRkFxTWJiTlE=\" title=\"https://www.youtube.com/embed/KT_FAqMbbNQ\">最终结果展示–需要翻墙 youtube 上观看<i class=\"fa fa-external-link\"></i></span></p>\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/KT_FAqMbbNQ\" frameborder=\"0\" allowfullscreen></iframe>\n\n<p>最后，要使用我们的应用程序，我们必须在 <code>Manifest.xml</code> 文件中条件：</p>\n<pre><code>&lt;uses-library android:name=&quot;com.google.android.things&quot;/&gt;\n</code></pre><p>并且声明我的 <code>Activity</code> 是一个 IoT Activity， 启动脚本为：</p>\n<pre><code>&lt;intent-filter&gt;\n    &lt;category android:name=&quot;android.intent.category.IOT_LAUNCHER&quot;/&gt;\n    &lt;category android:name=&quot;android.intent.category.DEFAULT”/&gt;\n&lt;/intent-filter&gt;\n</code></pre><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>文章最后，你已经知道了如何更好的使用 Android Things。 有趣的是，使用一些新的 API Android 开发人员可以准备下一次技术革命成为物联网。此外，开发过程与 Android 应用程序相同。</p>\n<p>使用简单的几行代码，一个 Android 开发者就可以构建 Android IoT App.</p>"},{"title":"清香木养殖（一）","date":"2019-05-04T13:54:08.000Z","_content":"\n\n激动的心，颤抖的手，京东上面动动手。\n哈哈，很久就有想养一个绿植的想法，经过了半年的挣扎，终于在 3 天前动起了手，入手一株**清香木**，据老板说，清香木可以散发出香味，充满整个房间，香气四溢（还未鉴定，刚收到，正怀着激动的心在写）。\n<!-- more-->\n![清香木](https://raw.githubusercontent.com/boywithsmalleyes/static_file/master/images/WechatIMG68.jpeg)\n\n其实对这枝有一点小失望，就是个头太小，不过没关系，咱俩熬呗，早晚你会长大的。\n<!--more-->\n\n那么问题来了，我是一只程序狗，这种张飞绣花的事儿，着实让我头疼了一番；平日里坐在电脑前，噼里啪啦的敲着键盘，书写着一行行 ABC（突然想起一首歌《都选 C》），徜徉在编码的世界里。忽然之间，生活中多了一株绿植，让那份隐藏在我身体某处多年的小爱心又如雨后春笋一般，萌发了起来。可是啊，在编码的世界里，我可以装装样子，但在 ta 的世界里，我只能装孙子。\n\n自此之后，我将踏上绿植的养护之道，千里之行始于足下，就请你把我带入到你的世界里，深入的了解并爱上你吧。\n\nOK，说正事儿，先来介绍一下**清香木**：\n\n清香木非常收到花友的喜爱，是一种非常理想的盆栽植物，盆景清香木摆放在室内，能营造出一种野外山水树木移入家内的感觉，自然清新。原本生长我国的云脑中部、北部及四川南部等高海拔的干热河谷地带，具有耐阴性，喜好暖，生长缓慢，寿命长等特点（这也会我选择样 ta 的原因）。\n\n这里有一个养花的 APP，[养花大全](https://itunes.apple.com/cn/app/%E5%85%BB%E8%8A%B1%E5%A4%A7%E5%85%A8-%E5%85%BB%E8%8A%B1%E4%BA%BA%E7%9A%84%E5%9C%88%E5%AD%90/id1245612230?mt=8)，我就是在这上学习养花的技术及注意事项的。\n\n虽然我并没有经理过 ta 的出生，但后面的路我想和你一起。为你整理发型（修剪枝叶）、为你安家乐业（上盆定型），呵护你（土壤和水分），一路前行（光照和温度）。\n\n虽然 APP 上介绍了**清香木**一些喜好，也提供了一些养殖方法，但身在门外汉的我还是对绿植界的术语感到头疼，下面来介绍一下\n\n| 术语 | 含义  |\n| --- | --- |\n| 见干见湿 | 见干：土壤干涸，表面看不到潮湿。 见湿：浇水时，看土壤全部浸湿。 |\n| 浇水要浇透 | 浇水时，见到水从底部孔流出 |\n\n这个表格是我在看清香木养殖事项时遇到的问题，以后会继续更新。\n虽然这个术语刚到看的时候，一脸懵。我也请教了我的同事关于养护的问题，他也细心的解释了，而且还特别照顾我这个小白，用很生动的比喻让我理解透了这些属于。\n\n\n那么这里我在详细的说一下我的理解：\n\n* 见干见湿：要解释的和上面的含义一样，那么我还要补充的部分就是，土壤是自上而下干的， 因此表面上虽然干了，但是土壤内部其实还没有干，尤其是土壤底部（植物的根部），这个时候我们可以通过向土壤中插入一根木棍（要插到底儿哦😏），专门用来检测土壤湿度，拔出时记住木棍裸露在土壤外面的位置，拔出后用潮湿的部位去计算位置。保持根部的湿润，可以促进植物根系的发展，因此不需要经常给植物浇水。见湿也就是浇水时，保证土壤湿润即可。\n* 浇水要浇透：当我看到时我也和纳闷什么意思，而且和上面的见湿似乎又冲突，到底是见到土壤湿了就可以，还是要浇透？那什么又是浇透呢？经过我的调研和咨询，终于弄明白，这些情况是和土壤的成分有关系，因为土壤的透气性、保水性都对植物发育有很大影响，一旦有问题，很可能导致叶子发黄，脱落，甚至死亡。Emmm  我们说浇透的事儿，花盆底部是有一个小口的（不养花根部不懂事干嘛的，小时候帮妈妈浇花，水从那漏出来，还以为浪费了呢）。因为土壤成分不同，吸水、蓄水能力也不同，具体土壤成分先不介绍，简单说下原理---可以先浇一遍快水，就是将水分均匀的洒在土壤的表面，不要留干，都浸湿，见盆地有水分流出即可，等到 10 分钟之后，在进行一次浇水，同样是均匀的浇，并底部有水流出即可。这样就可以保证浇透了。\n\n> 小白在这献丑了，后续会持续更新\n\n","source":"_posts/清香木养殖（一）.md","raw":"---\ntitle: 清香木养殖（一）\ndate: 2019-05-04 21:54:08\ntags: 绿植\n---\n\n\n激动的心，颤抖的手，京东上面动动手。\n哈哈，很久就有想养一个绿植的想法，经过了半年的挣扎，终于在 3 天前动起了手，入手一株**清香木**，据老板说，清香木可以散发出香味，充满整个房间，香气四溢（还未鉴定，刚收到，正怀着激动的心在写）。\n<!-- more-->\n![清香木](https://raw.githubusercontent.com/boywithsmalleyes/static_file/master/images/WechatIMG68.jpeg)\n\n其实对这枝有一点小失望，就是个头太小，不过没关系，咱俩熬呗，早晚你会长大的。\n<!--more-->\n\n那么问题来了，我是一只程序狗，这种张飞绣花的事儿，着实让我头疼了一番；平日里坐在电脑前，噼里啪啦的敲着键盘，书写着一行行 ABC（突然想起一首歌《都选 C》），徜徉在编码的世界里。忽然之间，生活中多了一株绿植，让那份隐藏在我身体某处多年的小爱心又如雨后春笋一般，萌发了起来。可是啊，在编码的世界里，我可以装装样子，但在 ta 的世界里，我只能装孙子。\n\n自此之后，我将踏上绿植的养护之道，千里之行始于足下，就请你把我带入到你的世界里，深入的了解并爱上你吧。\n\nOK，说正事儿，先来介绍一下**清香木**：\n\n清香木非常收到花友的喜爱，是一种非常理想的盆栽植物，盆景清香木摆放在室内，能营造出一种野外山水树木移入家内的感觉，自然清新。原本生长我国的云脑中部、北部及四川南部等高海拔的干热河谷地带，具有耐阴性，喜好暖，生长缓慢，寿命长等特点（这也会我选择样 ta 的原因）。\n\n这里有一个养花的 APP，[养花大全](https://itunes.apple.com/cn/app/%E5%85%BB%E8%8A%B1%E5%A4%A7%E5%85%A8-%E5%85%BB%E8%8A%B1%E4%BA%BA%E7%9A%84%E5%9C%88%E5%AD%90/id1245612230?mt=8)，我就是在这上学习养花的技术及注意事项的。\n\n虽然我并没有经理过 ta 的出生，但后面的路我想和你一起。为你整理发型（修剪枝叶）、为你安家乐业（上盆定型），呵护你（土壤和水分），一路前行（光照和温度）。\n\n虽然 APP 上介绍了**清香木**一些喜好，也提供了一些养殖方法，但身在门外汉的我还是对绿植界的术语感到头疼，下面来介绍一下\n\n| 术语 | 含义  |\n| --- | --- |\n| 见干见湿 | 见干：土壤干涸，表面看不到潮湿。 见湿：浇水时，看土壤全部浸湿。 |\n| 浇水要浇透 | 浇水时，见到水从底部孔流出 |\n\n这个表格是我在看清香木养殖事项时遇到的问题，以后会继续更新。\n虽然这个术语刚到看的时候，一脸懵。我也请教了我的同事关于养护的问题，他也细心的解释了，而且还特别照顾我这个小白，用很生动的比喻让我理解透了这些属于。\n\n\n那么这里我在详细的说一下我的理解：\n\n* 见干见湿：要解释的和上面的含义一样，那么我还要补充的部分就是，土壤是自上而下干的， 因此表面上虽然干了，但是土壤内部其实还没有干，尤其是土壤底部（植物的根部），这个时候我们可以通过向土壤中插入一根木棍（要插到底儿哦😏），专门用来检测土壤湿度，拔出时记住木棍裸露在土壤外面的位置，拔出后用潮湿的部位去计算位置。保持根部的湿润，可以促进植物根系的发展，因此不需要经常给植物浇水。见湿也就是浇水时，保证土壤湿润即可。\n* 浇水要浇透：当我看到时我也和纳闷什么意思，而且和上面的见湿似乎又冲突，到底是见到土壤湿了就可以，还是要浇透？那什么又是浇透呢？经过我的调研和咨询，终于弄明白，这些情况是和土壤的成分有关系，因为土壤的透气性、保水性都对植物发育有很大影响，一旦有问题，很可能导致叶子发黄，脱落，甚至死亡。Emmm  我们说浇透的事儿，花盆底部是有一个小口的（不养花根部不懂事干嘛的，小时候帮妈妈浇花，水从那漏出来，还以为浪费了呢）。因为土壤成分不同，吸水、蓄水能力也不同，具体土壤成分先不介绍，简单说下原理---可以先浇一遍快水，就是将水分均匀的洒在土壤的表面，不要留干，都浸湿，见盆地有水分流出即可，等到 10 分钟之后，在进行一次浇水，同样是均匀的浇，并底部有水流出即可。这样就可以保证浇透了。\n\n> 小白在这献丑了，后续会持续更新\n\n","slug":"清香木养殖（一）","published":1,"updated":"2021-01-29T16:03:16.497Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb88m000jsz5q9dfpqo3r","content":"<p>激动的心，颤抖的手，京东上面动动手。<br>哈哈，很久就有想养一个绿植的想法，经过了半年的挣扎，终于在 3 天前动起了手，入手一株<strong>清香木</strong>，据老板说，清香木可以散发出香味，充满整个房间，香气四溢（还未鉴定，刚收到，正怀着激动的心在写）。<br><a id=\"more\"></a><br><img src=\"https://raw.githubusercontent.com/boywithsmalleyes/static_file/master/images/WechatIMG68.jpeg\" alt=\"清香木\"></p>\n<p>其实对这枝有一点小失望，就是个头太小，不过没关系，咱俩熬呗，早晚你会长大的。<br><!--more--></p>\n<p>那么问题来了，我是一只程序狗，这种张飞绣花的事儿，着实让我头疼了一番；平日里坐在电脑前，噼里啪啦的敲着键盘，书写着一行行 ABC（突然想起一首歌《都选 C》），徜徉在编码的世界里。忽然之间，生活中多了一株绿植，让那份隐藏在我身体某处多年的小爱心又如雨后春笋一般，萌发了起来。可是啊，在编码的世界里，我可以装装样子，但在 ta 的世界里，我只能装孙子。</p>\n<p>自此之后，我将踏上绿植的养护之道，千里之行始于足下，就请你把我带入到你的世界里，深入的了解并爱上你吧。</p>\n<p>OK，说正事儿，先来介绍一下<strong>清香木</strong>：</p>\n<p>清香木非常收到花友的喜爱，是一种非常理想的盆栽植物，盆景清香木摆放在室内，能营造出一种野外山水树木移入家内的感觉，自然清新。原本生长我国的云脑中部、北部及四川南部等高海拔的干热河谷地带，具有耐阴性，喜好暖，生长缓慢，寿命长等特点（这也会我选择样 ta 的原因）。</p>\n<p>这里有一个养花的 APP，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9pdHVuZXMuYXBwbGUuY29tL2NuL2FwcC8lRTUlODUlQkIlRTglOEElQjElRTUlQTQlQTclRTUlODUlQTgtJUU1JTg1JUJCJUU4JThBJUIxJUU0JUJBJUJBJUU3JTlBJTg0JUU1JTlDJTg4JUU1JUFEJTkwL2lkMTI0NTYxMjIzMD9tdD04\" title=\"https://itunes.apple.com/cn/app/%E5%85%BB%E8%8A%B1%E5%A4%A7%E5%85%A8-%E5%85%BB%E8%8A%B1%E4%BA%BA%E7%9A%84%E5%9C%88%E5%AD%90/id1245612230?mt=8\">养花大全<i class=\"fa fa-external-link\"></i></span>，我就是在这上学习养花的技术及注意事项的。</p>\n<p>虽然我并没有经理过 ta 的出生，但后面的路我想和你一起。为你整理发型（修剪枝叶）、为你安家乐业（上盆定型），呵护你（土壤和水分），一路前行（光照和温度）。</p>\n<p>虽然 APP 上介绍了<strong>清香木</strong>一些喜好，也提供了一些养殖方法，但身在门外汉的我还是对绿植界的术语感到头疼，下面来介绍一下</p>\n<table>\n<thead>\n<tr>\n<th>术语</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>见干见湿</td>\n<td>见干：土壤干涸，表面看不到潮湿。 见湿：浇水时，看土壤全部浸湿。</td>\n</tr>\n<tr>\n<td>浇水要浇透</td>\n<td>浇水时，见到水从底部孔流出</td>\n</tr>\n</tbody>\n</table>\n<p>这个表格是我在看清香木养殖事项时遇到的问题，以后会继续更新。<br>虽然这个术语刚到看的时候，一脸懵。我也请教了我的同事关于养护的问题，他也细心的解释了，而且还特别照顾我这个小白，用很生动的比喻让我理解透了这些属于。</p>\n<p>那么这里我在详细的说一下我的理解：</p>\n<ul>\n<li>见干见湿：要解释的和上面的含义一样，那么我还要补充的部分就是，土壤是自上而下干的， 因此表面上虽然干了，但是土壤内部其实还没有干，尤其是土壤底部（植物的根部），这个时候我们可以通过向土壤中插入一根木棍（要插到底儿哦😏），专门用来检测土壤湿度，拔出时记住木棍裸露在土壤外面的位置，拔出后用潮湿的部位去计算位置。保持根部的湿润，可以促进植物根系的发展，因此不需要经常给植物浇水。见湿也就是浇水时，保证土壤湿润即可。</li>\n<li>浇水要浇透：当我看到时我也和纳闷什么意思，而且和上面的见湿似乎又冲突，到底是见到土壤湿了就可以，还是要浇透？那什么又是浇透呢？经过我的调研和咨询，终于弄明白，这些情况是和土壤的成分有关系，因为土壤的透气性、保水性都对植物发育有很大影响，一旦有问题，很可能导致叶子发黄，脱落，甚至死亡。Emmm  我们说浇透的事儿，花盆底部是有一个小口的（不养花根部不懂事干嘛的，小时候帮妈妈浇花，水从那漏出来，还以为浪费了呢）。因为土壤成分不同，吸水、蓄水能力也不同，具体土壤成分先不介绍，简单说下原理—可以先浇一遍快水，就是将水分均匀的洒在土壤的表面，不要留干，都浸湿，见盆地有水分流出即可，等到 10 分钟之后，在进行一次浇水，同样是均匀的浇，并底部有水流出即可。这样就可以保证浇透了。</li>\n</ul>\n<blockquote>\n<p>小白在这献丑了，后续会持续更新</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>激动的心，颤抖的手，京东上面动动手。<br>哈哈，很久就有想养一个绿植的想法，经过了半年的挣扎，终于在 3 天前动起了手，入手一株<strong>清香木</strong>，据老板说，清香木可以散发出香味，充满整个房间，香气四溢（还未鉴定，刚收到，正怀着激动的心在写）。<br>","more":"<br><img src=\"https://raw.githubusercontent.com/boywithsmalleyes/static_file/master/images/WechatIMG68.jpeg\" alt=\"清香木\"></p>\n<p>其实对这枝有一点小失望，就是个头太小，不过没关系，咱俩熬呗，早晚你会长大的。<br><!--more--></p>\n<p>那么问题来了，我是一只程序狗，这种张飞绣花的事儿，着实让我头疼了一番；平日里坐在电脑前，噼里啪啦的敲着键盘，书写着一行行 ABC（突然想起一首歌《都选 C》），徜徉在编码的世界里。忽然之间，生活中多了一株绿植，让那份隐藏在我身体某处多年的小爱心又如雨后春笋一般，萌发了起来。可是啊，在编码的世界里，我可以装装样子，但在 ta 的世界里，我只能装孙子。</p>\n<p>自此之后，我将踏上绿植的养护之道，千里之行始于足下，就请你把我带入到你的世界里，深入的了解并爱上你吧。</p>\n<p>OK，说正事儿，先来介绍一下<strong>清香木</strong>：</p>\n<p>清香木非常收到花友的喜爱，是一种非常理想的盆栽植物，盆景清香木摆放在室内，能营造出一种野外山水树木移入家内的感觉，自然清新。原本生长我国的云脑中部、北部及四川南部等高海拔的干热河谷地带，具有耐阴性，喜好暖，生长缓慢，寿命长等特点（这也会我选择样 ta 的原因）。</p>\n<p>这里有一个养花的 APP，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9pdHVuZXMuYXBwbGUuY29tL2NuL2FwcC8lRTUlODUlQkIlRTglOEElQjElRTUlQTQlQTclRTUlODUlQTgtJUU1JTg1JUJCJUU4JThBJUIxJUU0JUJBJUJBJUU3JTlBJTg0JUU1JTlDJTg4JUU1JUFEJTkwL2lkMTI0NTYxMjIzMD9tdD04\" title=\"https://itunes.apple.com/cn/app/%E5%85%BB%E8%8A%B1%E5%A4%A7%E5%85%A8-%E5%85%BB%E8%8A%B1%E4%BA%BA%E7%9A%84%E5%9C%88%E5%AD%90/id1245612230?mt=8\">养花大全<i class=\"fa fa-external-link\"></i></span>，我就是在这上学习养花的技术及注意事项的。</p>\n<p>虽然我并没有经理过 ta 的出生，但后面的路我想和你一起。为你整理发型（修剪枝叶）、为你安家乐业（上盆定型），呵护你（土壤和水分），一路前行（光照和温度）。</p>\n<p>虽然 APP 上介绍了<strong>清香木</strong>一些喜好，也提供了一些养殖方法，但身在门外汉的我还是对绿植界的术语感到头疼，下面来介绍一下</p>\n<table>\n<thead>\n<tr>\n<th>术语</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>见干见湿</td>\n<td>见干：土壤干涸，表面看不到潮湿。 见湿：浇水时，看土壤全部浸湿。</td>\n</tr>\n<tr>\n<td>浇水要浇透</td>\n<td>浇水时，见到水从底部孔流出</td>\n</tr>\n</tbody>\n</table>\n<p>这个表格是我在看清香木养殖事项时遇到的问题，以后会继续更新。<br>虽然这个术语刚到看的时候，一脸懵。我也请教了我的同事关于养护的问题，他也细心的解释了，而且还特别照顾我这个小白，用很生动的比喻让我理解透了这些属于。</p>\n<p>那么这里我在详细的说一下我的理解：</p>\n<ul>\n<li>见干见湿：要解释的和上面的含义一样，那么我还要补充的部分就是，土壤是自上而下干的， 因此表面上虽然干了，但是土壤内部其实还没有干，尤其是土壤底部（植物的根部），这个时候我们可以通过向土壤中插入一根木棍（要插到底儿哦😏），专门用来检测土壤湿度，拔出时记住木棍裸露在土壤外面的位置，拔出后用潮湿的部位去计算位置。保持根部的湿润，可以促进植物根系的发展，因此不需要经常给植物浇水。见湿也就是浇水时，保证土壤湿润即可。</li>\n<li>浇水要浇透：当我看到时我也和纳闷什么意思，而且和上面的见湿似乎又冲突，到底是见到土壤湿了就可以，还是要浇透？那什么又是浇透呢？经过我的调研和咨询，终于弄明白，这些情况是和土壤的成分有关系，因为土壤的透气性、保水性都对植物发育有很大影响，一旦有问题，很可能导致叶子发黄，脱落，甚至死亡。Emmm  我们说浇透的事儿，花盆底部是有一个小口的（不养花根部不懂事干嘛的，小时候帮妈妈浇花，水从那漏出来，还以为浪费了呢）。因为土壤成分不同，吸水、蓄水能力也不同，具体土壤成分先不介绍，简单说下原理—可以先浇一遍快水，就是将水分均匀的洒在土壤的表面，不要留干，都浸湿，见盆地有水分流出即可，等到 10 分钟之后，在进行一次浇水，同样是均匀的浇，并底部有水流出即可。这样就可以保证浇透了。</li>\n</ul>\n<blockquote>\n<p>小白在这献丑了，后续会持续更新</p>\n</blockquote>"},{"title":"清香木养殖（三）","date":"2019-06-23T11:49:19.000Z","_content":"\n距离上一次更新已经过去一个半月了，请不要担心，他还在！\n作为绿植小白，真真切切的体验养殖的快乐、与惊心动魄的时候，是不会想起来要记录博客的。\n<!-- more-->\n这次写这篇文章的目的，依然还是要记录一下它的成长，遭遇，以及一些养殖过程中的经验。好啦，天也不早了，咱也得弄点干货了。\n\n绿植小白，在上手清香木后，查询到的一些养殖的理论知识，在这一个半月的时间里得到了很严峻的挑战。继上次为它替换了新家之后，它就不在是从前的那个可爱的孩子了，淘气的狠；现在造的（东北话，本人东北滴，意思是将自己的身体，外表，或其他弄得破败不堪）还能可看出点模样来。\n\n这段时间，它经历的掉叶、枯黄、旱涝。哈哈，你们有没有感觉到他很可怜。但不论怎样，他现在正在茁壮的成长中，已经逃离了法海。\n\n现在的它，虽然已经没有了挡住的枝繁叶茂，但也没有像我这没程序员一样，寸草不生。那我们就接下来就还是说说它的养殖注意事项吧：\n\n<!--more-->\n\n* 掉叶\n\n掉叶是正常现象，在绿植更新新的环境，移植到新的盆中时，都会因需要对新环境的适应儿掉叶，过几天之后就好了，更换新盆后，将水浇透，静止几天（超过正常浇水周期），但也要考虑突然的蓄水能力以及土壤的潮湿程度。\n\n* 黄叶\n\n黄叶一般是发生在水分过大，导致根部腐烂时会发生，因此我在浇水时，要关注一下突然中水分的含量，适量且有规律的浇水，对绿植的发育是有好处的。\n\n* 土壤\n\n起初我的浇水频率是 3-5 天浇一次，但我发现他经常没有精神，蔫蔫的，每次浇水时，观察土壤都已经要干透了，然后我就改为 2-3 天浇水一次，慢慢的他比以前更加油绿，精神面貌更加挺拔。由此呢，总结下来土壤蓄水能力对植物的生长成正比关系，所以选择好的土壤，更有助于它的生长。目前它的土壤还是自从他来到我这里商家送的，土壤很稀松，杂质比较多，蓄水能力也一般，等到他在打一点，为他换一个新家的时候，会考虑给他换一个土壤。毕竟大自然的力量是很庞大的，也许那时他会成长为参天大树吧。\n\n\n**总结**\n\n总之，老话讲”有志者事竟成“，只要用了真心，就一定会有收获；不论是成功还是失败，我们都要将他看做是我们成功路上的经验，不骄不馁。\n\n习惯是养成的，就像它一样，虽然它在那里，也不会同我讲话，也不会同我互动，就那样静静的看着我，而哪一天看不见它的时候，我也会很想它，有时也不吝自己的目光，多看几眼，只希望它能够拙长成长。\n\n\n","source":"_posts/清香木养殖（三）.md","raw":"---\ntitle: 清香木养殖（三）\ndate: 2019-06-23 19:49:19\ntags: 绿植\n---\n\n距离上一次更新已经过去一个半月了，请不要担心，他还在！\n作为绿植小白，真真切切的体验养殖的快乐、与惊心动魄的时候，是不会想起来要记录博客的。\n<!-- more-->\n这次写这篇文章的目的，依然还是要记录一下它的成长，遭遇，以及一些养殖过程中的经验。好啦，天也不早了，咱也得弄点干货了。\n\n绿植小白，在上手清香木后，查询到的一些养殖的理论知识，在这一个半月的时间里得到了很严峻的挑战。继上次为它替换了新家之后，它就不在是从前的那个可爱的孩子了，淘气的狠；现在造的（东北话，本人东北滴，意思是将自己的身体，外表，或其他弄得破败不堪）还能可看出点模样来。\n\n这段时间，它经历的掉叶、枯黄、旱涝。哈哈，你们有没有感觉到他很可怜。但不论怎样，他现在正在茁壮的成长中，已经逃离了法海。\n\n现在的它，虽然已经没有了挡住的枝繁叶茂，但也没有像我这没程序员一样，寸草不生。那我们就接下来就还是说说它的养殖注意事项吧：\n\n<!--more-->\n\n* 掉叶\n\n掉叶是正常现象，在绿植更新新的环境，移植到新的盆中时，都会因需要对新环境的适应儿掉叶，过几天之后就好了，更换新盆后，将水浇透，静止几天（超过正常浇水周期），但也要考虑突然的蓄水能力以及土壤的潮湿程度。\n\n* 黄叶\n\n黄叶一般是发生在水分过大，导致根部腐烂时会发生，因此我在浇水时，要关注一下突然中水分的含量，适量且有规律的浇水，对绿植的发育是有好处的。\n\n* 土壤\n\n起初我的浇水频率是 3-5 天浇一次，但我发现他经常没有精神，蔫蔫的，每次浇水时，观察土壤都已经要干透了，然后我就改为 2-3 天浇水一次，慢慢的他比以前更加油绿，精神面貌更加挺拔。由此呢，总结下来土壤蓄水能力对植物的生长成正比关系，所以选择好的土壤，更有助于它的生长。目前它的土壤还是自从他来到我这里商家送的，土壤很稀松，杂质比较多，蓄水能力也一般，等到他在打一点，为他换一个新家的时候，会考虑给他换一个土壤。毕竟大自然的力量是很庞大的，也许那时他会成长为参天大树吧。\n\n\n**总结**\n\n总之，老话讲”有志者事竟成“，只要用了真心，就一定会有收获；不论是成功还是失败，我们都要将他看做是我们成功路上的经验，不骄不馁。\n\n习惯是养成的，就像它一样，虽然它在那里，也不会同我讲话，也不会同我互动，就那样静静的看着我，而哪一天看不见它的时候，我也会很想它，有时也不吝自己的目光，多看几眼，只希望它能够拙长成长。\n\n\n","slug":"清香木养殖（三）","published":1,"updated":"2021-01-29T16:03:09.154Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb88o000lsz5qlob7jxu4","content":"<p>距离上一次更新已经过去一个半月了，请不要担心，他还在！<br>作为绿植小白，真真切切的体验养殖的快乐、与惊心动魄的时候，是不会想起来要记录博客的。<br><a id=\"more\"></a><br>这次写这篇文章的目的，依然还是要记录一下它的成长，遭遇，以及一些养殖过程中的经验。好啦，天也不早了，咱也得弄点干货了。</p>\n<p>绿植小白，在上手清香木后，查询到的一些养殖的理论知识，在这一个半月的时间里得到了很严峻的挑战。继上次为它替换了新家之后，它就不在是从前的那个可爱的孩子了，淘气的狠；现在造的（东北话，本人东北滴，意思是将自己的身体，外表，或其他弄得破败不堪）还能可看出点模样来。</p>\n<p>这段时间，它经历的掉叶、枯黄、旱涝。哈哈，你们有没有感觉到他很可怜。但不论怎样，他现在正在茁壮的成长中，已经逃离了法海。</p>\n<p>现在的它，虽然已经没有了挡住的枝繁叶茂，但也没有像我这没程序员一样，寸草不生。那我们就接下来就还是说说它的养殖注意事项吧：</p>\n<!--more-->\n<ul>\n<li>掉叶</li>\n</ul>\n<p>掉叶是正常现象，在绿植更新新的环境，移植到新的盆中时，都会因需要对新环境的适应儿掉叶，过几天之后就好了，更换新盆后，将水浇透，静止几天（超过正常浇水周期），但也要考虑突然的蓄水能力以及土壤的潮湿程度。</p>\n<ul>\n<li>黄叶</li>\n</ul>\n<p>黄叶一般是发生在水分过大，导致根部腐烂时会发生，因此我在浇水时，要关注一下突然中水分的含量，适量且有规律的浇水，对绿植的发育是有好处的。</p>\n<ul>\n<li>土壤</li>\n</ul>\n<p>起初我的浇水频率是 3-5 天浇一次，但我发现他经常没有精神，蔫蔫的，每次浇水时，观察土壤都已经要干透了，然后我就改为 2-3 天浇水一次，慢慢的他比以前更加油绿，精神面貌更加挺拔。由此呢，总结下来土壤蓄水能力对植物的生长成正比关系，所以选择好的土壤，更有助于它的生长。目前它的土壤还是自从他来到我这里商家送的，土壤很稀松，杂质比较多，蓄水能力也一般，等到他在打一点，为他换一个新家的时候，会考虑给他换一个土壤。毕竟大自然的力量是很庞大的，也许那时他会成长为参天大树吧。</p>\n<p><strong>总结</strong></p>\n<p>总之，老话讲”有志者事竟成“，只要用了真心，就一定会有收获；不论是成功还是失败，我们都要将他看做是我们成功路上的经验，不骄不馁。</p>\n<p>习惯是养成的，就像它一样，虽然它在那里，也不会同我讲话，也不会同我互动，就那样静静的看着我，而哪一天看不见它的时候，我也会很想它，有时也不吝自己的目光，多看几眼，只希望它能够拙长成长。</p>\n","site":{"data":{}},"excerpt":"<p>距离上一次更新已经过去一个半月了，请不要担心，他还在！<br>作为绿植小白，真真切切的体验养殖的快乐、与惊心动魄的时候，是不会想起来要记录博客的。<br>","more":"<br>这次写这篇文章的目的，依然还是要记录一下它的成长，遭遇，以及一些养殖过程中的经验。好啦，天也不早了，咱也得弄点干货了。</p>\n<p>绿植小白，在上手清香木后，查询到的一些养殖的理论知识，在这一个半月的时间里得到了很严峻的挑战。继上次为它替换了新家之后，它就不在是从前的那个可爱的孩子了，淘气的狠；现在造的（东北话，本人东北滴，意思是将自己的身体，外表，或其他弄得破败不堪）还能可看出点模样来。</p>\n<p>这段时间，它经历的掉叶、枯黄、旱涝。哈哈，你们有没有感觉到他很可怜。但不论怎样，他现在正在茁壮的成长中，已经逃离了法海。</p>\n<p>现在的它，虽然已经没有了挡住的枝繁叶茂，但也没有像我这没程序员一样，寸草不生。那我们就接下来就还是说说它的养殖注意事项吧：</p>\n<!--more-->\n<ul>\n<li>掉叶</li>\n</ul>\n<p>掉叶是正常现象，在绿植更新新的环境，移植到新的盆中时，都会因需要对新环境的适应儿掉叶，过几天之后就好了，更换新盆后，将水浇透，静止几天（超过正常浇水周期），但也要考虑突然的蓄水能力以及土壤的潮湿程度。</p>\n<ul>\n<li>黄叶</li>\n</ul>\n<p>黄叶一般是发生在水分过大，导致根部腐烂时会发生，因此我在浇水时，要关注一下突然中水分的含量，适量且有规律的浇水，对绿植的发育是有好处的。</p>\n<ul>\n<li>土壤</li>\n</ul>\n<p>起初我的浇水频率是 3-5 天浇一次，但我发现他经常没有精神，蔫蔫的，每次浇水时，观察土壤都已经要干透了，然后我就改为 2-3 天浇水一次，慢慢的他比以前更加油绿，精神面貌更加挺拔。由此呢，总结下来土壤蓄水能力对植物的生长成正比关系，所以选择好的土壤，更有助于它的生长。目前它的土壤还是自从他来到我这里商家送的，土壤很稀松，杂质比较多，蓄水能力也一般，等到他在打一点，为他换一个新家的时候，会考虑给他换一个土壤。毕竟大自然的力量是很庞大的，也许那时他会成长为参天大树吧。</p>\n<p><strong>总结</strong></p>\n<p>总之，老话讲”有志者事竟成“，只要用了真心，就一定会有收获；不论是成功还是失败，我们都要将他看做是我们成功路上的经验，不骄不馁。</p>\n<p>习惯是养成的，就像它一样，虽然它在那里，也不会同我讲话，也不会同我互动，就那样静静的看着我，而哪一天看不见它的时候，我也会很想它，有时也不吝自己的目光，多看几眼，只希望它能够拙长成长。</p>"},{"title":"清香木养殖（二）","date":"2019-05-08T03:02:23.000Z","_content":"\n心心切切,每天都会关注它的变化,可惜心急吃不得热豆腐;经过了几天, 发现它有一些枯叶和干枝,你是在向我宣战吗?????上网查询了一下发现其实是植物在更换了环境之后,需要一段时间的适应,枯叶干枝属于正常现象, 哈哈哈,还好你不是嫌弃我的小屋.\n<!-- more-->\n\n记得高中那会,每天都在书本的海洋里飘荡,生物学自在其中,嘴边也总是在背诵着植物的\"光合作用\",\"呼吸作用\",这些知识早已深深铭记在心中,刻印在脑海,挥之不去.\n\n植物白天进行光合作用,吸收二氧化碳,释放氧气;夜晚呼吸作用吸收氧气,释放二氧化碳.这些知识让我认识了世界,然而并没有让我认识他.起初还是傻乎乎的每天出门上班时,把花放在窗台上,打开窗子,让他沐浴阳光,接受洗礼;可最近在浏览一些网站时,注意到一句话让我困惑不已----\"给予植物充足的光照,可以放在阳台上,但要避免太阳光直射\". 我懵了,我真的懵了, 既然都选择放在窗台上,难道窗台上的阳关就不是太阳直射了嘛????? 我很困惑, 爱琢磨的我在想, 窗台上有玻璃,Uh... 难道是隔着一层玻璃就不算直射了吗,, 哎, 这个问题,到现在我也没有想清楚.在经过不断的查询我发现其实植物进行光合作用并不是之可以有太阳光才可以.\n\n<!--more-->\n\n植物进行光合作用,叶绿体是主要功臣,高等植物的光合色素主要有叶绿素和类胡萝卜素,在颜色上叶绿素(叶绿素a 和叶绿色 b) 主要呈绿色, 类胡萝卜素(胡萝卜素和叶黄素) 呈黄色.叶绿素吸收光的能力极强,而对植物光合作用起到作用的是波长在 640 ~ 670 nm 的红光部分和波长在 430 ~ 450 的蓝紫光部分;因为太阳光不是单一的光,到达地表后波长在 300nm ~ 2600 nm, 只有波长在 390 ~ 770 nm为可见光(也就是我们常说的红橙黄绿青蓝紫,及其混合色),自然太阳光是可以满足植物进行光合作用的,同时,我们日常的照明灯例如:白炽灯,荧光灯,LED 灯,他们也可满足植物进行光合作用,但他们的波长不能满足植物光合作用的所有波长选择, 只能是单一, 比如只满足红光或蓝紫光.使用照明灯进行光照,只会导致植物缺少一些元素;淘宝上也有专门买植物光合作用需要的红光和蓝光的灯,但怎样都不如植物在外面晒几小时,大自然就是这么神奇.\n\n昨天为我的小心念移植了新居,因为刚刚收到他时,他的家有点破败,索性就为他换个豪宅.先用小铲铲松他的根基(不要贴着他,不然会伤害到哦),要不要用力去拔,伤到根部,就再也救不活了.慢慢的,要细心,待整体都很松动,能够连根带土的,一起从盆中带出,在新家先给他挖好容身之所,用手拖住他,细心的放在新家处,并埋好,然后少量的给予一些水分, 让他的家根基更夯实,不要过度浇水,但也要浇头,保持土壤松弛,这样氧气才能进入到土壤,让根部能够充分的进行呼吸作用.一直新家后,小心念属于脆弱的时候,这时不要让他在阳光下暴晒,不利于根部在新家落根.\n\n新家已经安排妥当,之后就是用心去观察他的变化,保持通风,和光照,他才会茁壮成长.\n\n","source":"_posts/清香木养殖（二）.md","raw":"---\ntitle: 清香木养殖（二）\ndate: 2019-05-08 11:02:23\ntags: 绿植\n---\n\n心心切切,每天都会关注它的变化,可惜心急吃不得热豆腐;经过了几天, 发现它有一些枯叶和干枝,你是在向我宣战吗?????上网查询了一下发现其实是植物在更换了环境之后,需要一段时间的适应,枯叶干枝属于正常现象, 哈哈哈,还好你不是嫌弃我的小屋.\n<!-- more-->\n\n记得高中那会,每天都在书本的海洋里飘荡,生物学自在其中,嘴边也总是在背诵着植物的\"光合作用\",\"呼吸作用\",这些知识早已深深铭记在心中,刻印在脑海,挥之不去.\n\n植物白天进行光合作用,吸收二氧化碳,释放氧气;夜晚呼吸作用吸收氧气,释放二氧化碳.这些知识让我认识了世界,然而并没有让我认识他.起初还是傻乎乎的每天出门上班时,把花放在窗台上,打开窗子,让他沐浴阳光,接受洗礼;可最近在浏览一些网站时,注意到一句话让我困惑不已----\"给予植物充足的光照,可以放在阳台上,但要避免太阳光直射\". 我懵了,我真的懵了, 既然都选择放在窗台上,难道窗台上的阳关就不是太阳直射了嘛????? 我很困惑, 爱琢磨的我在想, 窗台上有玻璃,Uh... 难道是隔着一层玻璃就不算直射了吗,, 哎, 这个问题,到现在我也没有想清楚.在经过不断的查询我发现其实植物进行光合作用并不是之可以有太阳光才可以.\n\n<!--more-->\n\n植物进行光合作用,叶绿体是主要功臣,高等植物的光合色素主要有叶绿素和类胡萝卜素,在颜色上叶绿素(叶绿素a 和叶绿色 b) 主要呈绿色, 类胡萝卜素(胡萝卜素和叶黄素) 呈黄色.叶绿素吸收光的能力极强,而对植物光合作用起到作用的是波长在 640 ~ 670 nm 的红光部分和波长在 430 ~ 450 的蓝紫光部分;因为太阳光不是单一的光,到达地表后波长在 300nm ~ 2600 nm, 只有波长在 390 ~ 770 nm为可见光(也就是我们常说的红橙黄绿青蓝紫,及其混合色),自然太阳光是可以满足植物进行光合作用的,同时,我们日常的照明灯例如:白炽灯,荧光灯,LED 灯,他们也可满足植物进行光合作用,但他们的波长不能满足植物光合作用的所有波长选择, 只能是单一, 比如只满足红光或蓝紫光.使用照明灯进行光照,只会导致植物缺少一些元素;淘宝上也有专门买植物光合作用需要的红光和蓝光的灯,但怎样都不如植物在外面晒几小时,大自然就是这么神奇.\n\n昨天为我的小心念移植了新居,因为刚刚收到他时,他的家有点破败,索性就为他换个豪宅.先用小铲铲松他的根基(不要贴着他,不然会伤害到哦),要不要用力去拔,伤到根部,就再也救不活了.慢慢的,要细心,待整体都很松动,能够连根带土的,一起从盆中带出,在新家先给他挖好容身之所,用手拖住他,细心的放在新家处,并埋好,然后少量的给予一些水分, 让他的家根基更夯实,不要过度浇水,但也要浇头,保持土壤松弛,这样氧气才能进入到土壤,让根部能够充分的进行呼吸作用.一直新家后,小心念属于脆弱的时候,这时不要让他在阳光下暴晒,不利于根部在新家落根.\n\n新家已经安排妥当,之后就是用心去观察他的变化,保持通风,和光照,他才会茁壮成长.\n\n","slug":"清香木养殖（二）","published":1,"updated":"2021-01-29T16:03:12.378Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb88q000nsz5qsqln0c20","content":"<p>心心切切,每天都会关注它的变化,可惜心急吃不得热豆腐;经过了几天, 发现它有一些枯叶和干枝,你是在向我宣战吗?????上网查询了一下发现其实是植物在更换了环境之后,需要一段时间的适应,枯叶干枝属于正常现象, 哈哈哈,还好你不是嫌弃我的小屋.<br><a id=\"more\"></a></p>\n<p>记得高中那会,每天都在书本的海洋里飘荡,生物学自在其中,嘴边也总是在背诵着植物的”光合作用”,”呼吸作用”,这些知识早已深深铭记在心中,刻印在脑海,挥之不去.</p>\n<p>植物白天进行光合作用,吸收二氧化碳,释放氧气;夜晚呼吸作用吸收氧气,释放二氧化碳.这些知识让我认识了世界,然而并没有让我认识他.起初还是傻乎乎的每天出门上班时,把花放在窗台上,打开窗子,让他沐浴阳光,接受洗礼;可最近在浏览一些网站时,注意到一句话让我困惑不已—-“给予植物充足的光照,可以放在阳台上,但要避免太阳光直射”. 我懵了,我真的懵了, 既然都选择放在窗台上,难道窗台上的阳关就不是太阳直射了嘛????? 我很困惑, 爱琢磨的我在想, 窗台上有玻璃,Uh… 难道是隔着一层玻璃就不算直射了吗,, 哎, 这个问题,到现在我也没有想清楚.在经过不断的查询我发现其实植物进行光合作用并不是之可以有太阳光才可以.</p>\n<!--more-->\n<p>植物进行光合作用,叶绿体是主要功臣,高等植物的光合色素主要有叶绿素和类胡萝卜素,在颜色上叶绿素(叶绿素a 和叶绿色 b) 主要呈绿色, 类胡萝卜素(胡萝卜素和叶黄素) 呈黄色.叶绿素吸收光的能力极强,而对植物光合作用起到作用的是波长在 640 ~ 670 nm 的红光部分和波长在 430 ~ 450 的蓝紫光部分;因为太阳光不是单一的光,到达地表后波长在 300nm ~ 2600 nm, 只有波长在 390 ~ 770 nm为可见光(也就是我们常说的红橙黄绿青蓝紫,及其混合色),自然太阳光是可以满足植物进行光合作用的,同时,我们日常的照明灯例如:白炽灯,荧光灯,LED 灯,他们也可满足植物进行光合作用,但他们的波长不能满足植物光合作用的所有波长选择, 只能是单一, 比如只满足红光或蓝紫光.使用照明灯进行光照,只会导致植物缺少一些元素;淘宝上也有专门买植物光合作用需要的红光和蓝光的灯,但怎样都不如植物在外面晒几小时,大自然就是这么神奇.</p>\n<p>昨天为我的小心念移植了新居,因为刚刚收到他时,他的家有点破败,索性就为他换个豪宅.先用小铲铲松他的根基(不要贴着他,不然会伤害到哦),要不要用力去拔,伤到根部,就再也救不活了.慢慢的,要细心,待整体都很松动,能够连根带土的,一起从盆中带出,在新家先给他挖好容身之所,用手拖住他,细心的放在新家处,并埋好,然后少量的给予一些水分, 让他的家根基更夯实,不要过度浇水,但也要浇头,保持土壤松弛,这样氧气才能进入到土壤,让根部能够充分的进行呼吸作用.一直新家后,小心念属于脆弱的时候,这时不要让他在阳光下暴晒,不利于根部在新家落根.</p>\n<p>新家已经安排妥当,之后就是用心去观察他的变化,保持通风,和光照,他才会茁壮成长.</p>\n","site":{"data":{}},"excerpt":"<p>心心切切,每天都会关注它的变化,可惜心急吃不得热豆腐;经过了几天, 发现它有一些枯叶和干枝,你是在向我宣战吗?????上网查询了一下发现其实是植物在更换了环境之后,需要一段时间的适应,枯叶干枝属于正常现象, 哈哈哈,还好你不是嫌弃我的小屋.<br>","more":"</p>\n<p>记得高中那会,每天都在书本的海洋里飘荡,生物学自在其中,嘴边也总是在背诵着植物的”光合作用”,”呼吸作用”,这些知识早已深深铭记在心中,刻印在脑海,挥之不去.</p>\n<p>植物白天进行光合作用,吸收二氧化碳,释放氧气;夜晚呼吸作用吸收氧气,释放二氧化碳.这些知识让我认识了世界,然而并没有让我认识他.起初还是傻乎乎的每天出门上班时,把花放在窗台上,打开窗子,让他沐浴阳光,接受洗礼;可最近在浏览一些网站时,注意到一句话让我困惑不已—-“给予植物充足的光照,可以放在阳台上,但要避免太阳光直射”. 我懵了,我真的懵了, 既然都选择放在窗台上,难道窗台上的阳关就不是太阳直射了嘛????? 我很困惑, 爱琢磨的我在想, 窗台上有玻璃,Uh… 难道是隔着一层玻璃就不算直射了吗,, 哎, 这个问题,到现在我也没有想清楚.在经过不断的查询我发现其实植物进行光合作用并不是之可以有太阳光才可以.</p>\n<!--more-->\n<p>植物进行光合作用,叶绿体是主要功臣,高等植物的光合色素主要有叶绿素和类胡萝卜素,在颜色上叶绿素(叶绿素a 和叶绿色 b) 主要呈绿色, 类胡萝卜素(胡萝卜素和叶黄素) 呈黄色.叶绿素吸收光的能力极强,而对植物光合作用起到作用的是波长在 640 ~ 670 nm 的红光部分和波长在 430 ~ 450 的蓝紫光部分;因为太阳光不是单一的光,到达地表后波长在 300nm ~ 2600 nm, 只有波长在 390 ~ 770 nm为可见光(也就是我们常说的红橙黄绿青蓝紫,及其混合色),自然太阳光是可以满足植物进行光合作用的,同时,我们日常的照明灯例如:白炽灯,荧光灯,LED 灯,他们也可满足植物进行光合作用,但他们的波长不能满足植物光合作用的所有波长选择, 只能是单一, 比如只满足红光或蓝紫光.使用照明灯进行光照,只会导致植物缺少一些元素;淘宝上也有专门买植物光合作用需要的红光和蓝光的灯,但怎样都不如植物在外面晒几小时,大自然就是这么神奇.</p>\n<p>昨天为我的小心念移植了新居,因为刚刚收到他时,他的家有点破败,索性就为他换个豪宅.先用小铲铲松他的根基(不要贴着他,不然会伤害到哦),要不要用力去拔,伤到根部,就再也救不活了.慢慢的,要细心,待整体都很松动,能够连根带土的,一起从盆中带出,在新家先给他挖好容身之所,用手拖住他,细心的放在新家处,并埋好,然后少量的给予一些水分, 让他的家根基更夯实,不要过度浇水,但也要浇头,保持土壤松弛,这样氧气才能进入到土壤,让根部能够充分的进行呼吸作用.一直新家后,小心念属于脆弱的时候,这时不要让他在阳光下暴晒,不利于根部在新家落根.</p>\n<p>新家已经安排妥当,之后就是用心去观察他的变化,保持通风,和光照,他才会茁壮成长.</p>"},{"title":"清香木养殖（四）","date":"2019-10-17T09:11:50.000Z","_content":"\n丢了···································· T_T\n\n","source":"_posts/清香木养殖（四）.md","raw":"---\ntitle: 清香木养殖（四）\ndate: 2019-10-17 17:11:50\ntags:\n---\n\n丢了···································· T_T\n\n","slug":"清香木养殖（四）","published":1,"updated":"2020-02-20T09:13:37.992Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb88s000psz5qz2oewu9d","content":"<p>丢了···································· T_T</p>\n","site":{"data":{}},"excerpt":"","more":"<p>丢了···································· T_T</p>\n"},{"title":"Activity 横竖屏","_content":"\n\n## 设置屏幕的方向\n\n| 值               | 描述                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| unspecified      | 默认值，系统自动选择屏幕方向                                 |\n| behind           | 跟 Activity 堆栈中的下面一个 activity 方向一致               |\n| landscape        | 横屏方向，                                                   |\n| portraint        | 竖屏方向                                                     |\n| sensor           | 由设备的物理方向传感器决定，如果用户旋转设备，着屏幕就会横竖切换 |\n| nosensor         | 忽略物理传感器，这样就会不会随着用户旋转设备而横竖屏切换了   |\n| user             | 用户当前首选方向                                             |\n| reverseLandscape | 反向横屏                                                     |\n| reversePortrait  | 反向竖屏                                                     |\n| sensorLandscape  | 横屏，但可以根据物理传感器方向来切换正反向横屏               |\n| sensorPortraint  | 竖屏，但可以根据物理传感器方向来切换真反向竖屏               |\n| fullSensor       | 上下左右四个方向，由物理方向传感器决定                       |\n| locked           | 锁死当前屏幕方向                                             |\n\n<!-- more -->\n\n**第一种**\n\n在 `AndroidManifest` 清单文件中设置 `Activity` 的方向\n\n```xml\n<activity\n          android:name=\".view.main.MainActivity\"\n          android:screenOrientation=\"portrait\">\n\t\t<intent-filter>\n    \t\t<action android:name=\"android.intent.action.MAIN\"/>\n             <category android:name=\"android.intent.category.LAUNCHER\"/>\n    \t</intent-filter>\n</activity>\n```\n\n这样在横竖屏切换时，不会重新创建 `Activity`\n\n**第二种**\n\n```java\nsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);\nsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);\n```\n\n**Android  android:configChanges**\n\n如果我们不配置 `configuration` ，当 `configuration` 发生变化时， activity 会自动处理它。反之，如果我们配置了响应的 `configuration` ，当新的 `configuration` 发生变化时，会回调 Activity  的 `onConfigurationChanged()` 方法\n\n| 值             | 描述                                                         |\n| -------------- | ------------------------------------------------------------ |\n| keyboardHidden | 键盘的可访问性发生变化--例如：用户发现了硬件键盘             |\n| orientation    | 屏幕方向发生变化--用户旋转了屏幕。<br />注意：如果应用程序的目标 API 级别是 13 或更高，也需要生命配置项 screenSize ，因为这将在设备选择肖像和屏幕方向是发生变化 |\n| screenLayout   | 屏幕布局发生变化-- 这回导致显示不同的 Activity。<br />屏幕方向发生变化-- 用户旋转了屏幕 |\n| screenSize     | 当前可用屏幕大小发生变化。代表当前可用大小发生变化，和当前比率相关。这个变化不会影响 Activity 重启。 |\n|                |                                                              |\n\n在 Android 3.2 之后，进行下列配置，横竖屏切换时不会创建新的 Activity，但是回调用 `onConfigurationChanged()` 方法\n\n```xml\n<activity\n          android:name=\".view.main.MainActivity\"\n          android:configChanges=\"keyboardHidden|orientation|screenSize\">\n\t<intent-filter>\n    \t<action android:name=\"android.intent.action.MAIN\"/>\n        <category android:name=\"android.intent.category.LAUNCHER\"/>\n    </intent-filter>\n</activity>\n```\n\n在 3.2 以前，我们需要这样配置\n\n`android:configChagnes=\"keyboardHidden|orientation\"`\n\n```xml\n<activity\n          android:name=\".view.main.MainActivity\"\n          android:configChanges=\"keyboardHidden|orientation\">\n\t<intent-filter>\n    \t<action android:name=\"android.intent.action.MAIN\"/>\n        <category android:name=\"android.intent.category.LAUNCHER\"/>\n    </intent-filter>\n</activity>\n```\n\n## 小结\n\n当我们配置了上面的内容\n\n* 竖屏 —> 横屏 `onConfigurationChanged()` 调用一次\n* 横屏 —> 竖屏 `onConfigurationChanged()` 调用一次\n\n因此我们要进行相应的处理\n\n```java\npublic void onConfigurationChaged(Configuration newConfig) {\n    super.onConfigurationChanged(newConfig);\n    if(this.getResource(0.getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE)) {\n        // 加入横屏要处理的代码\n    } else if(this.getResource().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT){\n        // 加入竖屏处理代码\n    }\n}\n```\n\n**如果同时设置了 `android:configChanges=\"keyboardHidden|orientation|screen\" 和 android:screenOrientation=\"portrait\"` 会如何呢？**\n\n> 如果我们打开系统的自动旋转屏幕，旋转屏幕系统不会发生变化，也不会调用 Activity 的 `onConfigurationChanged` 方法\n>\n> 当我们手动调用 setRequestedOrientation() 方法去改变屏幕方向的时候，还是会调用 onConfigurationChanged() 方法的\n\n## 扩展\n\n### 设置全屏模式\n\n```java\n// 去掉ActionBar\nrequestWindowFeature(Window.FEATURE_NO_TITLE);\n// 设置全屏\ngetWindow().setFlag(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);\n```\n\n**在实际项目中，我们通常都会固定我们应用的屏幕方向，只对一些特定的需要切换屏幕的 Activity 做处理。那么如何统一设置屏幕方向呢**\n\n1. 复制粘贴，在 `AndroidManifest` 清单文件中为每一个 Activity 标签增加设置\n\n   ```xml\n   <activity android:name=\".MainActivity\"\n             android:screenOrientation=\"portrait\"/>\n   ```\n\n2. 以为在 `AppTheme` 里面设置 `android:screenOrientation` ，但是没有效果，查阅官方文档才看到\n\n   > Specify the orientation an activity should be run in. If not specified, it will run in the current preferred orientation of the screen. This attribute is supported by the <activity> element.\n   >\n   > 也就是说， android:screenOrientation 只对 activity 标签生效\n\n3. 在 BaseActivity里面动态设置\n\n   ```java\n   public class BaseActivity extends AppCompatActivity {\n       @Override\n       public void onCreate(BUndle savedInstanceState) {\n           super.onCreate(savedInstanceState);\n           setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);\n       }\n   }\n   ```\n\n### 利用系统的加载机制自动帮我们加载相应布局\n\n如果我们在 `res` 中添加 `layout-land` (横向布局文件) 和 `layout-port` （竖向布局文件) ，重启 Activity 模式的横竖屏切换\n\n**当我们设置了 Activity 的方向为竖屏或者横屏的时候，旋转屏幕并不会重新调用 Activity 的各个生命周期，那么要如何检测？**\n\n那我们就利用我们的传感器，然后根据传感器旋转的方向做相应的处理\n\n```java\n// 注册重力传感器， 屏幕旋转\nmSm = (SensorManager) getSystemService(Context.SENSOR_SERVICE);\nmSensor = mSm.getDefaultSensor(Sensor.TYPE_ACCELLEROMETER);\nmSm.registerListener(mOrientationSensorListener, mSensor, SensorManager.SENSOR_DELAY_UI);\n```\n\n```java\npublic class OrientationSensorListener implements SensorEventListener {\n    private static final int _DATA_X = 0;\n    private static final int _DATA_Y = 1;\n    private static final int _DATA_Z = 2;\n    \n    public static final int ORIENTATION_UNKNOWN = -1;\n    private boolean sensor_flag = true;\n    \n    public static final String TAG = \"XUJUN\";\n    \n    int mLastAngle = -1;\n    \n    AngleChangeListener mAngleChangleListener;\n    \n    public OrientationSensorListener(AngleChangleListener angleChangeleListener) {\n        mAngleChangeleListener = andleChangleListener;\n    }\n    \n    @Override\n    public void onAccuracyChanged(Sensor arg0, int arg1) {\n        // TODO Auto-generated method stub\n    }\n    \n\t@Override\n    public void onSensorChanged(SensorEvent event) {\n        float[] values = event.values;\n        int orientation = ORIENTATION_UNKNOWN;\n        float x = -values[_DATA_X];\n        float y = -values[_DATA_Y];\n        float z = -values[_DATA_Z];\n        \n        \n        /**\n         * 这一段是 Android 源码里面拿出来的计算屏幕旋转的\n         */\n        float magnitude = X * X + Y * Y;\n        if(magnitude * 4 >= Z * Z) {\n            // 屏幕旋转时\n            float oneEightyOverPi = 57.29577956855f;\n            float angle = (float) Math.atan2(-Y, Z) * oneEightOverPi;\n            orientation = 90 - (int)Math.round(angle);\n            \n            while(orientation >= 360) {\n                orientation -= 360;\n            }\n            while(orientation < 0) {\n                orientation +=  360;\n            }\n        }\n        \n        if(orientation > 225 && orientation < 315) { // 横屏\n            sensor_flag = false;\n        } else if ((orientation > 315 && orientation < 360) \n                   || (orientation > 0 && orientation < 45)) { // 竖屏\n            sensor_flag = true;\n        }\n        \n        if(mLastAndgle != orientation && mAngleChangeListener != null) {\n            mAndleChangleListener.onChange(orientation);\n            mLastAngle = orientation;\n        }\n    }\n}\n```\n\n\n\n###  **设备旋转时保存 Activity 的交互状态**\n\n\n\n![Activity生命周期](https://upload-images.jianshu.io/upload_images/2050203-8435a89f42cd9508?imageMogr2/auto-orient/strip|imageView2/2/w/513/format/webp)\n\n如果我们不配置 Activity 的方向，或者 Activity 的 `android:configchange` 属性时，每次旋转屏幕，Activity 都会重新创建，那我们要保存我们的当前状态\n\n> 我们可以考虑在 `onPause()` 和 `onStop()`  里面保存我们相应的数据，再从 `onCreate()` 方法里判断 `savedInstanceState` 是否有缓存过我们的数据就可以。至于选择在 `onPause()` 还是 `onStop()` 保存数据，具体的下需求分析。 `onPause()` 在界面失去焦点的时候会调用， `onStop()` 在界面完全看不见的时候调用\n\n```java\nprivate static final String KEY_INDEX = \"index\";\nprivate int mCurrentIndex = 0;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    if(savedInstanceState != null) {\n        mCurrentIndex = savedInstanceState.getInt(KEY_INDEX, 0);\n    }\n}\n\n@Override\nprotected void onPause(Bundle outState) {\n    super.saveInstanceState(outState);\n    outState.putInt(KEY_INDEX, mCurrentIndex);\n}\n```\n\n**生命周期变化**\n\n> onPause-> onStop -> onDestory -> onCreate -> onStart -> onResume\n\n","source":"_posts/Android 基础/Android 横竖屏的事儿.md","raw":"---\ntitle: Activity 横竖屏\ntag: Android View\n---\n\n\n## 设置屏幕的方向\n\n| 值               | 描述                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| unspecified      | 默认值，系统自动选择屏幕方向                                 |\n| behind           | 跟 Activity 堆栈中的下面一个 activity 方向一致               |\n| landscape        | 横屏方向，                                                   |\n| portraint        | 竖屏方向                                                     |\n| sensor           | 由设备的物理方向传感器决定，如果用户旋转设备，着屏幕就会横竖切换 |\n| nosensor         | 忽略物理传感器，这样就会不会随着用户旋转设备而横竖屏切换了   |\n| user             | 用户当前首选方向                                             |\n| reverseLandscape | 反向横屏                                                     |\n| reversePortrait  | 反向竖屏                                                     |\n| sensorLandscape  | 横屏，但可以根据物理传感器方向来切换正反向横屏               |\n| sensorPortraint  | 竖屏，但可以根据物理传感器方向来切换真反向竖屏               |\n| fullSensor       | 上下左右四个方向，由物理方向传感器决定                       |\n| locked           | 锁死当前屏幕方向                                             |\n\n<!-- more -->\n\n**第一种**\n\n在 `AndroidManifest` 清单文件中设置 `Activity` 的方向\n\n```xml\n<activity\n          android:name=\".view.main.MainActivity\"\n          android:screenOrientation=\"portrait\">\n\t\t<intent-filter>\n    \t\t<action android:name=\"android.intent.action.MAIN\"/>\n             <category android:name=\"android.intent.category.LAUNCHER\"/>\n    \t</intent-filter>\n</activity>\n```\n\n这样在横竖屏切换时，不会重新创建 `Activity`\n\n**第二种**\n\n```java\nsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);\nsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);\n```\n\n**Android  android:configChanges**\n\n如果我们不配置 `configuration` ，当 `configuration` 发生变化时， activity 会自动处理它。反之，如果我们配置了响应的 `configuration` ，当新的 `configuration` 发生变化时，会回调 Activity  的 `onConfigurationChanged()` 方法\n\n| 值             | 描述                                                         |\n| -------------- | ------------------------------------------------------------ |\n| keyboardHidden | 键盘的可访问性发生变化--例如：用户发现了硬件键盘             |\n| orientation    | 屏幕方向发生变化--用户旋转了屏幕。<br />注意：如果应用程序的目标 API 级别是 13 或更高，也需要生命配置项 screenSize ，因为这将在设备选择肖像和屏幕方向是发生变化 |\n| screenLayout   | 屏幕布局发生变化-- 这回导致显示不同的 Activity。<br />屏幕方向发生变化-- 用户旋转了屏幕 |\n| screenSize     | 当前可用屏幕大小发生变化。代表当前可用大小发生变化，和当前比率相关。这个变化不会影响 Activity 重启。 |\n|                |                                                              |\n\n在 Android 3.2 之后，进行下列配置，横竖屏切换时不会创建新的 Activity，但是回调用 `onConfigurationChanged()` 方法\n\n```xml\n<activity\n          android:name=\".view.main.MainActivity\"\n          android:configChanges=\"keyboardHidden|orientation|screenSize\">\n\t<intent-filter>\n    \t<action android:name=\"android.intent.action.MAIN\"/>\n        <category android:name=\"android.intent.category.LAUNCHER\"/>\n    </intent-filter>\n</activity>\n```\n\n在 3.2 以前，我们需要这样配置\n\n`android:configChagnes=\"keyboardHidden|orientation\"`\n\n```xml\n<activity\n          android:name=\".view.main.MainActivity\"\n          android:configChanges=\"keyboardHidden|orientation\">\n\t<intent-filter>\n    \t<action android:name=\"android.intent.action.MAIN\"/>\n        <category android:name=\"android.intent.category.LAUNCHER\"/>\n    </intent-filter>\n</activity>\n```\n\n## 小结\n\n当我们配置了上面的内容\n\n* 竖屏 —> 横屏 `onConfigurationChanged()` 调用一次\n* 横屏 —> 竖屏 `onConfigurationChanged()` 调用一次\n\n因此我们要进行相应的处理\n\n```java\npublic void onConfigurationChaged(Configuration newConfig) {\n    super.onConfigurationChanged(newConfig);\n    if(this.getResource(0.getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE)) {\n        // 加入横屏要处理的代码\n    } else if(this.getResource().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT){\n        // 加入竖屏处理代码\n    }\n}\n```\n\n**如果同时设置了 `android:configChanges=\"keyboardHidden|orientation|screen\" 和 android:screenOrientation=\"portrait\"` 会如何呢？**\n\n> 如果我们打开系统的自动旋转屏幕，旋转屏幕系统不会发生变化，也不会调用 Activity 的 `onConfigurationChanged` 方法\n>\n> 当我们手动调用 setRequestedOrientation() 方法去改变屏幕方向的时候，还是会调用 onConfigurationChanged() 方法的\n\n## 扩展\n\n### 设置全屏模式\n\n```java\n// 去掉ActionBar\nrequestWindowFeature(Window.FEATURE_NO_TITLE);\n// 设置全屏\ngetWindow().setFlag(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);\n```\n\n**在实际项目中，我们通常都会固定我们应用的屏幕方向，只对一些特定的需要切换屏幕的 Activity 做处理。那么如何统一设置屏幕方向呢**\n\n1. 复制粘贴，在 `AndroidManifest` 清单文件中为每一个 Activity 标签增加设置\n\n   ```xml\n   <activity android:name=\".MainActivity\"\n             android:screenOrientation=\"portrait\"/>\n   ```\n\n2. 以为在 `AppTheme` 里面设置 `android:screenOrientation` ，但是没有效果，查阅官方文档才看到\n\n   > Specify the orientation an activity should be run in. If not specified, it will run in the current preferred orientation of the screen. This attribute is supported by the <activity> element.\n   >\n   > 也就是说， android:screenOrientation 只对 activity 标签生效\n\n3. 在 BaseActivity里面动态设置\n\n   ```java\n   public class BaseActivity extends AppCompatActivity {\n       @Override\n       public void onCreate(BUndle savedInstanceState) {\n           super.onCreate(savedInstanceState);\n           setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);\n       }\n   }\n   ```\n\n### 利用系统的加载机制自动帮我们加载相应布局\n\n如果我们在 `res` 中添加 `layout-land` (横向布局文件) 和 `layout-port` （竖向布局文件) ，重启 Activity 模式的横竖屏切换\n\n**当我们设置了 Activity 的方向为竖屏或者横屏的时候，旋转屏幕并不会重新调用 Activity 的各个生命周期，那么要如何检测？**\n\n那我们就利用我们的传感器，然后根据传感器旋转的方向做相应的处理\n\n```java\n// 注册重力传感器， 屏幕旋转\nmSm = (SensorManager) getSystemService(Context.SENSOR_SERVICE);\nmSensor = mSm.getDefaultSensor(Sensor.TYPE_ACCELLEROMETER);\nmSm.registerListener(mOrientationSensorListener, mSensor, SensorManager.SENSOR_DELAY_UI);\n```\n\n```java\npublic class OrientationSensorListener implements SensorEventListener {\n    private static final int _DATA_X = 0;\n    private static final int _DATA_Y = 1;\n    private static final int _DATA_Z = 2;\n    \n    public static final int ORIENTATION_UNKNOWN = -1;\n    private boolean sensor_flag = true;\n    \n    public static final String TAG = \"XUJUN\";\n    \n    int mLastAngle = -1;\n    \n    AngleChangeListener mAngleChangleListener;\n    \n    public OrientationSensorListener(AngleChangleListener angleChangeleListener) {\n        mAngleChangeleListener = andleChangleListener;\n    }\n    \n    @Override\n    public void onAccuracyChanged(Sensor arg0, int arg1) {\n        // TODO Auto-generated method stub\n    }\n    \n\t@Override\n    public void onSensorChanged(SensorEvent event) {\n        float[] values = event.values;\n        int orientation = ORIENTATION_UNKNOWN;\n        float x = -values[_DATA_X];\n        float y = -values[_DATA_Y];\n        float z = -values[_DATA_Z];\n        \n        \n        /**\n         * 这一段是 Android 源码里面拿出来的计算屏幕旋转的\n         */\n        float magnitude = X * X + Y * Y;\n        if(magnitude * 4 >= Z * Z) {\n            // 屏幕旋转时\n            float oneEightyOverPi = 57.29577956855f;\n            float angle = (float) Math.atan2(-Y, Z) * oneEightOverPi;\n            orientation = 90 - (int)Math.round(angle);\n            \n            while(orientation >= 360) {\n                orientation -= 360;\n            }\n            while(orientation < 0) {\n                orientation +=  360;\n            }\n        }\n        \n        if(orientation > 225 && orientation < 315) { // 横屏\n            sensor_flag = false;\n        } else if ((orientation > 315 && orientation < 360) \n                   || (orientation > 0 && orientation < 45)) { // 竖屏\n            sensor_flag = true;\n        }\n        \n        if(mLastAndgle != orientation && mAngleChangeListener != null) {\n            mAndleChangleListener.onChange(orientation);\n            mLastAngle = orientation;\n        }\n    }\n}\n```\n\n\n\n###  **设备旋转时保存 Activity 的交互状态**\n\n\n\n![Activity生命周期](https://upload-images.jianshu.io/upload_images/2050203-8435a89f42cd9508?imageMogr2/auto-orient/strip|imageView2/2/w/513/format/webp)\n\n如果我们不配置 Activity 的方向，或者 Activity 的 `android:configchange` 属性时，每次旋转屏幕，Activity 都会重新创建，那我们要保存我们的当前状态\n\n> 我们可以考虑在 `onPause()` 和 `onStop()`  里面保存我们相应的数据，再从 `onCreate()` 方法里判断 `savedInstanceState` 是否有缓存过我们的数据就可以。至于选择在 `onPause()` 还是 `onStop()` 保存数据，具体的下需求分析。 `onPause()` 在界面失去焦点的时候会调用， `onStop()` 在界面完全看不见的时候调用\n\n```java\nprivate static final String KEY_INDEX = \"index\";\nprivate int mCurrentIndex = 0;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    if(savedInstanceState != null) {\n        mCurrentIndex = savedInstanceState.getInt(KEY_INDEX, 0);\n    }\n}\n\n@Override\nprotected void onPause(Bundle outState) {\n    super.saveInstanceState(outState);\n    outState.putInt(KEY_INDEX, mCurrentIndex);\n}\n```\n\n**生命周期变化**\n\n> onPause-> onStop -> onDestory -> onCreate -> onStart -> onResume\n\n","slug":"Android 基础/Android 横竖屏的事儿","published":1,"date":"2021-01-29T15:54:28.281Z","updated":"2021-01-30T07:04:55.285Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8e60010sz5qmcy2w9cx","content":"<h2 id=\"设置屏幕的方向\"><a href=\"#设置屏幕的方向\" class=\"headerlink\" title=\"设置屏幕的方向\"></a>设置屏幕的方向</h2><table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>unspecified</td>\n<td>默认值，系统自动选择屏幕方向</td>\n</tr>\n<tr>\n<td>behind</td>\n<td>跟 Activity 堆栈中的下面一个 activity 方向一致</td>\n</tr>\n<tr>\n<td>landscape</td>\n<td>横屏方向，</td>\n</tr>\n<tr>\n<td>portraint</td>\n<td>竖屏方向</td>\n</tr>\n<tr>\n<td>sensor</td>\n<td>由设备的物理方向传感器决定，如果用户旋转设备，着屏幕就会横竖切换</td>\n</tr>\n<tr>\n<td>nosensor</td>\n<td>忽略物理传感器，这样就会不会随着用户旋转设备而横竖屏切换了</td>\n</tr>\n<tr>\n<td>user</td>\n<td>用户当前首选方向</td>\n</tr>\n<tr>\n<td>reverseLandscape</td>\n<td>反向横屏</td>\n</tr>\n<tr>\n<td>reversePortrait</td>\n<td>反向竖屏</td>\n</tr>\n<tr>\n<td>sensorLandscape</td>\n<td>横屏，但可以根据物理传感器方向来切换正反向横屏</td>\n</tr>\n<tr>\n<td>sensorPortraint</td>\n<td>竖屏，但可以根据物理传感器方向来切换真反向竖屏</td>\n</tr>\n<tr>\n<td>fullSensor</td>\n<td>上下左右四个方向，由物理方向传感器决定</td>\n</tr>\n<tr>\n<td>locked</td>\n<td>锁死当前屏幕方向</td>\n</tr>\n</tbody>\n</table>\n<a id=\"more\"></a>\n<p><strong>第一种</strong></p>\n<p>在 <code>AndroidManifest</code> 清单文件中设置 <code>Activity</code> 的方向</p>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>activity</span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>.view.main.MainActivity<span class=\"token punctuation\">\"</span></span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>screenOrientation</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>portrait<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>intent-filter</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>action</span> <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>android.intent.action.MAIN<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n             <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>category</span> <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>android.intent.category.LAUNCHER<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>intent-filter</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>activity</span><span class=\"token punctuation\">></span></span>\n</code></pre>\n<p>这样在横竖屏切换时，不会重新创建 <code>Activity</code></p>\n<p><strong>第二种</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token function\">setRequestedOrientation</span><span class=\"token punctuation\">(</span>ActivityInfo<span class=\"token punctuation\">.</span>SCREEN_ORIENTATION_LANDSCAPE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">setRequestedOrientation</span><span class=\"token punctuation\">(</span>ActivityInfo<span class=\"token punctuation\">.</span>SCREEN_ORIENTATION_PORTRAIT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><strong>Android  android:configChanges</strong></p>\n<p>如果我们不配置 <code>configuration</code> ，当 <code>configuration</code> 发生变化时， activity 会自动处理它。反之，如果我们配置了响应的 <code>configuration</code> ，当新的 <code>configuration</code> 发生变化时，会回调 Activity  的 <code>onConfigurationChanged()</code> 方法</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>keyboardHidden</td>\n<td>键盘的可访问性发生变化–例如：用户发现了硬件键盘</td>\n</tr>\n<tr>\n<td>orientation</td>\n<td>屏幕方向发生变化–用户旋转了屏幕。<br>注意：如果应用程序的目标 API 级别是 13 或更高，也需要生命配置项 screenSize ，因为这将在设备选择肖像和屏幕方向是发生变化</td>\n</tr>\n<tr>\n<td>screenLayout</td>\n<td>屏幕布局发生变化– 这回导致显示不同的 Activity。<br>屏幕方向发生变化– 用户旋转了屏幕</td>\n</tr>\n<tr>\n<td>screenSize</td>\n<td>当前可用屏幕大小发生变化。代表当前可用大小发生变化，和当前比率相关。这个变化不会影响 Activity 重启。</td>\n</tr>\n<tr>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>在 Android 3.2 之后，进行下列配置，横竖屏切换时不会创建新的 Activity，但是回调用 <code>onConfigurationChanged()</code> 方法</p>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>activity</span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>.view.main.MainActivity<span class=\"token punctuation\">\"</span></span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>configChanges</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>keyboardHidden|orientation|screenSize<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>intent-filter</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>action</span> <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>android.intent.action.MAIN<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>category</span> <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>android.intent.category.LAUNCHER<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>intent-filter</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>activity</span><span class=\"token punctuation\">></span></span>\n</code></pre>\n<p>在 3.2 以前，我们需要这样配置</p>\n<p><code>android:configChagnes=&quot;keyboardHidden|orientation&quot;</code></p>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>activity</span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>.view.main.MainActivity<span class=\"token punctuation\">\"</span></span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>configChanges</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>keyboardHidden|orientation<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>intent-filter</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>action</span> <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>android.intent.action.MAIN<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>category</span> <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>android.intent.category.LAUNCHER<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>intent-filter</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>activity</span><span class=\"token punctuation\">></span></span>\n</code></pre>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>当我们配置了上面的内容</p>\n<ul>\n<li>竖屏 —&gt; 横屏 <code>onConfigurationChanged()</code> 调用一次</li>\n<li>横屏 —&gt; 竖屏 <code>onConfigurationChanged()</code> 调用一次</li>\n</ul>\n<p>因此我们要进行相应的处理</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onConfigurationChaged</span><span class=\"token punctuation\">(</span>Configuration newConfig<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">onConfigurationChanged</span><span class=\"token punctuation\">(</span>newConfig<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">getResource</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">.</span><span class=\"token function\">getConfiguration</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>orientation <span class=\"token operator\">==</span> Configuration<span class=\"token punctuation\">.</span>ORIENTATION_LANDSCAPE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 加入横屏要处理的代码</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">getResource</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getConfiguration</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>orientation <span class=\"token operator\">==</span> Configuration<span class=\"token punctuation\">.</span>ORIENTATION_PORTRAIT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 加入竖屏处理代码</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>如果同时设置了 <code>android:configChanges=&quot;keyboardHidden|orientation|screen&quot; 和 android:screenOrientation=&quot;portrait&quot;</code> 会如何呢？</strong></p>\n<blockquote>\n<p>如果我们打开系统的自动旋转屏幕，旋转屏幕系统不会发生变化，也不会调用 Activity 的 <code>onConfigurationChanged</code> 方法</p>\n<p>当我们手动调用 setRequestedOrientation() 方法去改变屏幕方向的时候，还是会调用 onConfigurationChanged() 方法的</p>\n</blockquote>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><h3 id=\"设置全屏模式\"><a href=\"#设置全屏模式\" class=\"headerlink\" title=\"设置全屏模式\"></a>设置全屏模式</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// 去掉ActionBar</span>\n<span class=\"token function\">requestWindowFeature</span><span class=\"token punctuation\">(</span>Window<span class=\"token punctuation\">.</span>FEATURE_NO_TITLE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 设置全屏</span>\n<span class=\"token function\">getWindow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">setFlag</span><span class=\"token punctuation\">(</span>WindowManager<span class=\"token punctuation\">.</span>LayoutParams<span class=\"token punctuation\">.</span>FLAG_FULLSCREEN<span class=\"token punctuation\">,</span> WindowManager<span class=\"token punctuation\">.</span>LayoutParams<span class=\"token punctuation\">.</span>FLAG_FULLSCREEN<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><strong>在实际项目中，我们通常都会固定我们应用的屏幕方向，只对一些特定的需要切换屏幕的 Activity 做处理。那么如何统一设置屏幕方向呢</strong></p>\n<ol>\n<li><p>复制粘贴，在 <code>AndroidManifest</code> 清单文件中为每一个 Activity 标签增加设置</p>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>activity</span> <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>.MainActivity<span class=\"token punctuation\">\"</span></span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>screenOrientation</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>portrait<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n</code></pre>\n</li>\n<li><p>以为在 <code>AppTheme</code> 里面设置 <code>android:screenOrientation</code> ，但是没有效果，查阅官方文档才看到</p>\n<blockquote>\n<p>Specify the orientation an activity should be run in. If not specified, it will run in the current preferred orientation of the screen. This attribute is supported by the <activity> element.</activity></p>\n<p>也就是说， android:screenOrientation 只对 activity 标签生效</p>\n</blockquote>\n</li>\n<li><p>在 BaseActivity里面动态设置</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BaseActivity</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AppCompatActivity</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onCreate</span><span class=\"token punctuation\">(</span>BUndle savedInstanceState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">onCreate</span><span class=\"token punctuation\">(</span>savedInstanceState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">setRequestedOrientation</span><span class=\"token punctuation\">(</span>ActivityInfo<span class=\"token punctuation\">.</span>SCREEN_ORIENTATION_PORTRAIT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n</li>\n</ol>\n<h3 id=\"利用系统的加载机制自动帮我们加载相应布局\"><a href=\"#利用系统的加载机制自动帮我们加载相应布局\" class=\"headerlink\" title=\"利用系统的加载机制自动帮我们加载相应布局\"></a>利用系统的加载机制自动帮我们加载相应布局</h3><p>如果我们在 <code>res</code> 中添加 <code>layout-land</code> (横向布局文件) 和 <code>layout-port</code> （竖向布局文件) ，重启 Activity 模式的横竖屏切换</p>\n<p><strong>当我们设置了 Activity 的方向为竖屏或者横屏的时候，旋转屏幕并不会重新调用 Activity 的各个生命周期，那么要如何检测？</strong></p>\n<p>那我们就利用我们的传感器，然后根据传感器旋转的方向做相应的处理</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// 注册重力传感器， 屏幕旋转</span>\nmSm <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>SensorManager<span class=\"token punctuation\">)</span> <span class=\"token function\">getSystemService</span><span class=\"token punctuation\">(</span>Context<span class=\"token punctuation\">.</span>SENSOR_SERVICE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmSensor <span class=\"token operator\">=</span> mSm<span class=\"token punctuation\">.</span><span class=\"token function\">getDefaultSensor</span><span class=\"token punctuation\">(</span>Sensor<span class=\"token punctuation\">.</span>TYPE_ACCELLEROMETER<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmSm<span class=\"token punctuation\">.</span><span class=\"token function\">registerListener</span><span class=\"token punctuation\">(</span>mOrientationSensorListener<span class=\"token punctuation\">,</span> mSensor<span class=\"token punctuation\">,</span> SensorManager<span class=\"token punctuation\">.</span>SENSOR_DELAY_UI<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OrientationSensorListener</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">SensorEventListener</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> _DATA_X <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> _DATA_Y <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> _DATA_Z <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> ORIENTATION_UNKNOWN <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">boolean</span> sensor_flag <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> String TAG <span class=\"token operator\">=</span> <span class=\"token string\">\"XUJUN\"</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> mLastAngle <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n    AngleChangeListener mAngleChangleListener<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">OrientationSensorListener</span><span class=\"token punctuation\">(</span>AngleChangleListener angleChangeleListener<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        mAngleChangeleListener <span class=\"token operator\">=</span> andleChangleListener<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onAccuracyChanged</span><span class=\"token punctuation\">(</span>Sensor arg0<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> arg1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// TODO Auto-generated method stub</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onSensorChanged</span><span class=\"token punctuation\">(</span>SensorEvent event<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">float</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> values <span class=\"token operator\">=</span> event<span class=\"token punctuation\">.</span>values<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> orientation <span class=\"token operator\">=</span> ORIENTATION_UNKNOWN<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">float</span> x <span class=\"token operator\">=</span> <span class=\"token operator\">-</span>values<span class=\"token punctuation\">[</span>_DATA_X<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">float</span> y <span class=\"token operator\">=</span> <span class=\"token operator\">-</span>values<span class=\"token punctuation\">[</span>_DATA_Y<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">float</span> z <span class=\"token operator\">=</span> <span class=\"token operator\">-</span>values<span class=\"token punctuation\">[</span>_DATA_Z<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n\n        <span class=\"token comment\" spellcheck=\"true\">/**\n         * 这一段是 Android 源码里面拿出来的计算屏幕旋转的\n         */</span>\n        <span class=\"token keyword\">float</span> magnitude <span class=\"token operator\">=</span> X <span class=\"token operator\">*</span> X <span class=\"token operator\">+</span> Y <span class=\"token operator\">*</span> Y<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>magnitude <span class=\"token operator\">*</span> <span class=\"token number\">4</span> <span class=\"token operator\">>=</span> Z <span class=\"token operator\">*</span> Z<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 屏幕旋转时</span>\n            <span class=\"token keyword\">float</span> oneEightyOverPi <span class=\"token operator\">=</span> <span class=\"token number\">57.29577956855f</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">float</span> angle <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">atan2</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>Y<span class=\"token punctuation\">,</span> Z<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> oneEightOverPi<span class=\"token punctuation\">;</span>\n            orientation <span class=\"token operator\">=</span> <span class=\"token number\">90</span> <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">round</span><span class=\"token punctuation\">(</span>angle<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>orientation <span class=\"token operator\">>=</span> <span class=\"token number\">360</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                orientation <span class=\"token operator\">-=</span> <span class=\"token number\">360</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>orientation <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                orientation <span class=\"token operator\">+=</span>  <span class=\"token number\">360</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>orientation <span class=\"token operator\">></span> <span class=\"token number\">225</span> <span class=\"token operator\">&amp;&amp;</span> orientation <span class=\"token operator\">&lt;</span> <span class=\"token number\">315</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 横屏</span>\n            sensor_flag <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>orientation <span class=\"token operator\">></span> <span class=\"token number\">315</span> <span class=\"token operator\">&amp;&amp;</span> orientation <span class=\"token operator\">&lt;</span> <span class=\"token number\">360</span><span class=\"token punctuation\">)</span> \n                   <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>orientation <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> orientation <span class=\"token operator\">&lt;</span> <span class=\"token number\">45</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 竖屏</span>\n            sensor_flag <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mLastAndgle <span class=\"token operator\">!=</span> orientation <span class=\"token operator\">&amp;&amp;</span> mAngleChangeListener <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            mAndleChangleListener<span class=\"token punctuation\">.</span><span class=\"token function\">onChange</span><span class=\"token punctuation\">(</span>orientation<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            mLastAngle <span class=\"token operator\">=</span> orientation<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"设备旋转时保存-Activity-的交互状态\"><a href=\"#设备旋转时保存-Activity-的交互状态\" class=\"headerlink\" title=\"设备旋转时保存 Activity 的交互状态\"></a><strong>设备旋转时保存 Activity 的交互状态</strong></h3><p><img src=\"https://upload-images.jianshu.io/upload_images/2050203-8435a89f42cd9508?imageMogr2/auto-orient/strip|imageView2/2/w/513/format/webp\" alt=\"Activity生命周期\"></p>\n<p>如果我们不配置 Activity 的方向，或者 Activity 的 <code>android:configchange</code> 属性时，每次旋转屏幕，Activity 都会重新创建，那我们要保存我们的当前状态</p>\n<blockquote>\n<p>我们可以考虑在 <code>onPause()</code> 和 <code>onStop()</code>  里面保存我们相应的数据，再从 <code>onCreate()</code> 方法里判断 <code>savedInstanceState</code> 是否有缓存过我们的数据就可以。至于选择在 <code>onPause()</code> 还是 <code>onStop()</code> 保存数据，具体的下需求分析。 <code>onPause()</code> 在界面失去焦点的时候会调用， <code>onStop()</code> 在界面完全看不见的时候调用</p>\n</blockquote>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> String KEY_INDEX <span class=\"token operator\">=</span> <span class=\"token string\">\"index\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> mCurrentIndex <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onCreate</span><span class=\"token punctuation\">(</span>Bundle savedInstanceState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>savedInstanceState <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        mCurrentIndex <span class=\"token operator\">=</span> savedInstanceState<span class=\"token punctuation\">.</span><span class=\"token function\">getInt</span><span class=\"token punctuation\">(</span>KEY_INDEX<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onPause</span><span class=\"token punctuation\">(</span>Bundle outState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">saveInstanceState</span><span class=\"token punctuation\">(</span>outState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    outState<span class=\"token punctuation\">.</span><span class=\"token function\">putInt</span><span class=\"token punctuation\">(</span>KEY_INDEX<span class=\"token punctuation\">,</span> mCurrentIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>生命周期变化</strong></p>\n<blockquote>\n<p>onPause-&gt; onStop -&gt; onDestory -&gt; onCreate -&gt; onStart -&gt; onResume</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h2 id=\"设置屏幕的方向\"><a href=\"#设置屏幕的方向\" class=\"headerlink\" title=\"设置屏幕的方向\"></a>设置屏幕的方向</h2><table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>unspecified</td>\n<td>默认值，系统自动选择屏幕方向</td>\n</tr>\n<tr>\n<td>behind</td>\n<td>跟 Activity 堆栈中的下面一个 activity 方向一致</td>\n</tr>\n<tr>\n<td>landscape</td>\n<td>横屏方向，</td>\n</tr>\n<tr>\n<td>portraint</td>\n<td>竖屏方向</td>\n</tr>\n<tr>\n<td>sensor</td>\n<td>由设备的物理方向传感器决定，如果用户旋转设备，着屏幕就会横竖切换</td>\n</tr>\n<tr>\n<td>nosensor</td>\n<td>忽略物理传感器，这样就会不会随着用户旋转设备而横竖屏切换了</td>\n</tr>\n<tr>\n<td>user</td>\n<td>用户当前首选方向</td>\n</tr>\n<tr>\n<td>reverseLandscape</td>\n<td>反向横屏</td>\n</tr>\n<tr>\n<td>reversePortrait</td>\n<td>反向竖屏</td>\n</tr>\n<tr>\n<td>sensorLandscape</td>\n<td>横屏，但可以根据物理传感器方向来切换正反向横屏</td>\n</tr>\n<tr>\n<td>sensorPortraint</td>\n<td>竖屏，但可以根据物理传感器方向来切换真反向竖屏</td>\n</tr>\n<tr>\n<td>fullSensor</td>\n<td>上下左右四个方向，由物理方向传感器决定</td>\n</tr>\n<tr>\n<td>locked</td>\n<td>锁死当前屏幕方向</td>\n</tr>\n</tbody>\n</table>","more":"<p><strong>第一种</strong></p>\n<p>在 <code>AndroidManifest</code> 清单文件中设置 <code>Activity</code> 的方向</p>\n<pre><code class=\"xml\">&lt;activity\n          android:name=&quot;.view.main.MainActivity&quot;\n          android:screenOrientation=&quot;portrait&quot;&gt;\n        &lt;intent-filter&gt;\n            &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;\n             &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;\n        &lt;/intent-filter&gt;\n&lt;/activity&gt;\n</code></pre>\n<p>这样在横竖屏切换时，不会重新创建 <code>Activity</code></p>\n<p><strong>第二种</strong></p>\n<pre><code class=\"java\">setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);\nsetRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);\n</code></pre>\n<p><strong>Android  android:configChanges</strong></p>\n<p>如果我们不配置 <code>configuration</code> ，当 <code>configuration</code> 发生变化时， activity 会自动处理它。反之，如果我们配置了响应的 <code>configuration</code> ，当新的 <code>configuration</code> 发生变化时，会回调 Activity  的 <code>onConfigurationChanged()</code> 方法</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>keyboardHidden</td>\n<td>键盘的可访问性发生变化–例如：用户发现了硬件键盘</td>\n</tr>\n<tr>\n<td>orientation</td>\n<td>屏幕方向发生变化–用户旋转了屏幕。<br>注意：如果应用程序的目标 API 级别是 13 或更高，也需要生命配置项 screenSize ，因为这将在设备选择肖像和屏幕方向是发生变化</td>\n</tr>\n<tr>\n<td>screenLayout</td>\n<td>屏幕布局发生变化– 这回导致显示不同的 Activity。<br>屏幕方向发生变化– 用户旋转了屏幕</td>\n</tr>\n<tr>\n<td>screenSize</td>\n<td>当前可用屏幕大小发生变化。代表当前可用大小发生变化，和当前比率相关。这个变化不会影响 Activity 重启。</td>\n</tr>\n<tr>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>在 Android 3.2 之后，进行下列配置，横竖屏切换时不会创建新的 Activity，但是回调用 <code>onConfigurationChanged()</code> 方法</p>\n<pre><code class=\"xml\">&lt;activity\n          android:name=&quot;.view.main.MainActivity&quot;\n          android:configChanges=&quot;keyboardHidden|orientation|screenSize&quot;&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;\n        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;\n    &lt;/intent-filter&gt;\n&lt;/activity&gt;\n</code></pre>\n<p>在 3.2 以前，我们需要这样配置</p>\n<p><code>android:configChagnes=&quot;keyboardHidden|orientation&quot;</code></p>\n<pre><code class=\"xml\">&lt;activity\n          android:name=&quot;.view.main.MainActivity&quot;\n          android:configChanges=&quot;keyboardHidden|orientation&quot;&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;\n        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;\n    &lt;/intent-filter&gt;\n&lt;/activity&gt;\n</code></pre>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>当我们配置了上面的内容</p>\n<ul>\n<li>竖屏 —&gt; 横屏 <code>onConfigurationChanged()</code> 调用一次</li>\n<li>横屏 —&gt; 竖屏 <code>onConfigurationChanged()</code> 调用一次</li>\n</ul>\n<p>因此我们要进行相应的处理</p>\n<pre><code class=\"java\">public void onConfigurationChaged(Configuration newConfig) {\n    super.onConfigurationChanged(newConfig);\n    if(this.getResource(0.getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE)) {\n        // 加入横屏要处理的代码\n    } else if(this.getResource().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT){\n        // 加入竖屏处理代码\n    }\n}\n</code></pre>\n<p><strong>如果同时设置了 <code>android:configChanges=&quot;keyboardHidden|orientation|screen&quot; 和 android:screenOrientation=&quot;portrait&quot;</code> 会如何呢？</strong></p>\n<blockquote>\n<p>如果我们打开系统的自动旋转屏幕，旋转屏幕系统不会发生变化，也不会调用 Activity 的 <code>onConfigurationChanged</code> 方法</p>\n<p>当我们手动调用 setRequestedOrientation() 方法去改变屏幕方向的时候，还是会调用 onConfigurationChanged() 方法的</p>\n</blockquote>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><h3 id=\"设置全屏模式\"><a href=\"#设置全屏模式\" class=\"headerlink\" title=\"设置全屏模式\"></a>设置全屏模式</h3><pre><code class=\"java\">// 去掉ActionBar\nrequestWindowFeature(Window.FEATURE_NO_TITLE);\n// 设置全屏\ngetWindow().setFlag(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);\n</code></pre>\n<p><strong>在实际项目中，我们通常都会固定我们应用的屏幕方向，只对一些特定的需要切换屏幕的 Activity 做处理。那么如何统一设置屏幕方向呢</strong></p>\n<ol>\n<li><p>复制粘贴，在 <code>AndroidManifest</code> 清单文件中为每一个 Activity 标签增加设置</p>\n<pre><code class=\"xml\">&lt;activity android:name=&quot;.MainActivity&quot;\n          android:screenOrientation=&quot;portrait&quot;/&gt;\n</code></pre>\n</li>\n<li><p>以为在 <code>AppTheme</code> 里面设置 <code>android:screenOrientation</code> ，但是没有效果，查阅官方文档才看到</p>\n<blockquote>\n<p>Specify the orientation an activity should be run in. If not specified, it will run in the current preferred orientation of the screen. This attribute is supported by the <activity> element.</activity></p>\n<p>也就是说， android:screenOrientation 只对 activity 标签生效</p>\n</blockquote>\n</li>\n<li><p>在 BaseActivity里面动态设置</p>\n<pre><code class=\"java\">public class BaseActivity extends AppCompatActivity {\n    @Override\n    public void onCreate(BUndle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);\n    }\n}\n</code></pre>\n</li>\n</ol>\n<h3 id=\"利用系统的加载机制自动帮我们加载相应布局\"><a href=\"#利用系统的加载机制自动帮我们加载相应布局\" class=\"headerlink\" title=\"利用系统的加载机制自动帮我们加载相应布局\"></a>利用系统的加载机制自动帮我们加载相应布局</h3><p>如果我们在 <code>res</code> 中添加 <code>layout-land</code> (横向布局文件) 和 <code>layout-port</code> （竖向布局文件) ，重启 Activity 模式的横竖屏切换</p>\n<p><strong>当我们设置了 Activity 的方向为竖屏或者横屏的时候，旋转屏幕并不会重新调用 Activity 的各个生命周期，那么要如何检测？</strong></p>\n<p>那我们就利用我们的传感器，然后根据传感器旋转的方向做相应的处理</p>\n<pre><code class=\"java\">// 注册重力传感器， 屏幕旋转\nmSm = (SensorManager) getSystemService(Context.SENSOR_SERVICE);\nmSensor = mSm.getDefaultSensor(Sensor.TYPE_ACCELLEROMETER);\nmSm.registerListener(mOrientationSensorListener, mSensor, SensorManager.SENSOR_DELAY_UI);\n</code></pre>\n<pre><code class=\"java\">public class OrientationSensorListener implements SensorEventListener {\n    private static final int _DATA_X = 0;\n    private static final int _DATA_Y = 1;\n    private static final int _DATA_Z = 2;\n\n    public static final int ORIENTATION_UNKNOWN = -1;\n    private boolean sensor_flag = true;\n\n    public static final String TAG = &quot;XUJUN&quot;;\n\n    int mLastAngle = -1;\n\n    AngleChangeListener mAngleChangleListener;\n\n    public OrientationSensorListener(AngleChangleListener angleChangeleListener) {\n        mAngleChangeleListener = andleChangleListener;\n    }\n\n    @Override\n    public void onAccuracyChanged(Sensor arg0, int arg1) {\n        // TODO Auto-generated method stub\n    }\n\n    @Override\n    public void onSensorChanged(SensorEvent event) {\n        float[] values = event.values;\n        int orientation = ORIENTATION_UNKNOWN;\n        float x = -values[_DATA_X];\n        float y = -values[_DATA_Y];\n        float z = -values[_DATA_Z];\n\n\n        /**\n         * 这一段是 Android 源码里面拿出来的计算屏幕旋转的\n         */\n        float magnitude = X * X + Y * Y;\n        if(magnitude * 4 &gt;= Z * Z) {\n            // 屏幕旋转时\n            float oneEightyOverPi = 57.29577956855f;\n            float angle = (float) Math.atan2(-Y, Z) * oneEightOverPi;\n            orientation = 90 - (int)Math.round(angle);\n\n            while(orientation &gt;= 360) {\n                orientation -= 360;\n            }\n            while(orientation &lt; 0) {\n                orientation +=  360;\n            }\n        }\n\n        if(orientation &gt; 225 &amp;&amp; orientation &lt; 315) { // 横屏\n            sensor_flag = false;\n        } else if ((orientation &gt; 315 &amp;&amp; orientation &lt; 360) \n                   || (orientation &gt; 0 &amp;&amp; orientation &lt; 45)) { // 竖屏\n            sensor_flag = true;\n        }\n\n        if(mLastAndgle != orientation &amp;&amp; mAngleChangeListener != null) {\n            mAndleChangleListener.onChange(orientation);\n            mLastAngle = orientation;\n        }\n    }\n}\n</code></pre>\n<h3 id=\"设备旋转时保存-Activity-的交互状态\"><a href=\"#设备旋转时保存-Activity-的交互状态\" class=\"headerlink\" title=\"设备旋转时保存 Activity 的交互状态\"></a><strong>设备旋转时保存 Activity 的交互状态</strong></h3><p><img src=\"https://upload-images.jianshu.io/upload_images/2050203-8435a89f42cd9508?imageMogr2/auto-orient/strip|imageView2/2/w/513/format/webp\" alt=\"Activity生命周期\"></p>\n<p>如果我们不配置 Activity 的方向，或者 Activity 的 <code>android:configchange</code> 属性时，每次旋转屏幕，Activity 都会重新创建，那我们要保存我们的当前状态</p>\n<blockquote>\n<p>我们可以考虑在 <code>onPause()</code> 和 <code>onStop()</code>  里面保存我们相应的数据，再从 <code>onCreate()</code> 方法里判断 <code>savedInstanceState</code> 是否有缓存过我们的数据就可以。至于选择在 <code>onPause()</code> 还是 <code>onStop()</code> 保存数据，具体的下需求分析。 <code>onPause()</code> 在界面失去焦点的时候会调用， <code>onStop()</code> 在界面完全看不见的时候调用</p>\n</blockquote>\n<pre><code class=\"java\">private static final String KEY_INDEX = &quot;index&quot;;\nprivate int mCurrentIndex = 0;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    if(savedInstanceState != null) {\n        mCurrentIndex = savedInstanceState.getInt(KEY_INDEX, 0);\n    }\n}\n\n@Override\nprotected void onPause(Bundle outState) {\n    super.saveInstanceState(outState);\n    outState.putInt(KEY_INDEX, mCurrentIndex);\n}\n</code></pre>\n<p><strong>生命周期变化</strong></p>\n<blockquote>\n<p>onPause-&gt; onStop -&gt; onDestory -&gt; onCreate -&gt; onStart -&gt; onResume</p>\n</blockquote>"},{"title":"Android 中设置全屏的方法","date":"2019-04-16T09:46:31.000Z","_content":"\n在开发中,我们经常需要把我们的应用设置为全屏,这里有两种方式: 一是在代码中设置; 二是在配置文件中设置\n<!-- more-->\n# 一. 在代码中设置\n\n```\npublic class BaseActivity extends Activity {\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(saveInstanceState);\n        // 无title\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        // 全屏\n        getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);\n        setContentView(R.layout.activity_main);\n    } \n}\n```\n\n强调一点: ** 设置全屏的两段代码,必须在 `setContentView()` 之前调用,不然会报错 **\n\n# 二. 在配置文件中修改\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest \n  xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  package=\"com.android.test\"\n  android:versionCode=\"1\"\n  ndroid:versionName=\"1.0\">\n  <application android:icon=\"@drawable/icon\"\n    android:lable=\"@string/app_name>\n    <activity android:name=\".BaseActivity\" \n        android:theme=\"@android:style/Theme.NotitleBar.Fullscreen\"\n        android:lable=\"@string/app_name\">\n        <intent-filter>\n            <action android:name=\"android.intent.action.MAIN\"/>\n            <category android:name=\"android.intent.category.LAUNCHER\"/>\n        </intent-filter>\n  </application>\n</manifest>\n```\n\n使用第一种方法,会在应用运行后,看到一个短暂的状态来, 然后才全屏, 而第二种方法是不会有这种情况的,大家根据需要自行选择.\n\n","source":"_posts/Android 基础/Android-中设置全屏的方法.md","raw":"---\ntitle: Android 中设置全屏的方法\ndate: 2019-04-16 17:46:31\ntags: Android\n---\n\n在开发中,我们经常需要把我们的应用设置为全屏,这里有两种方式: 一是在代码中设置; 二是在配置文件中设置\n<!-- more-->\n# 一. 在代码中设置\n\n```\npublic class BaseActivity extends Activity {\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(saveInstanceState);\n        // 无title\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        // 全屏\n        getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);\n        setContentView(R.layout.activity_main);\n    } \n}\n```\n\n强调一点: ** 设置全屏的两段代码,必须在 `setContentView()` 之前调用,不然会报错 **\n\n# 二. 在配置文件中修改\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest \n  xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  package=\"com.android.test\"\n  android:versionCode=\"1\"\n  ndroid:versionName=\"1.0\">\n  <application android:icon=\"@drawable/icon\"\n    android:lable=\"@string/app_name>\n    <activity android:name=\".BaseActivity\" \n        android:theme=\"@android:style/Theme.NotitleBar.Fullscreen\"\n        android:lable=\"@string/app_name\">\n        <intent-filter>\n            <action android:name=\"android.intent.action.MAIN\"/>\n            <category android:name=\"android.intent.category.LAUNCHER\"/>\n        </intent-filter>\n  </application>\n</manifest>\n```\n\n使用第一种方法,会在应用运行后,看到一个短暂的状态来, 然后才全屏, 而第二种方法是不会有这种情况的,大家根据需要自行选择.\n\n","slug":"Android 基础/Android-中设置全屏的方法","published":1,"updated":"2021-01-29T16:03:46.744Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8e80012sz5qolm14yb6","content":"<p>在开发中,我们经常需要把我们的应用设置为全屏,这里有两种方式: 一是在代码中设置; 二是在配置文件中设置<br><a id=\"more\"></a></p>\n<h1 id=\"一-在代码中设置\"><a href=\"#一-在代码中设置\" class=\"headerlink\" title=\"一. 在代码中设置\"></a>一. 在代码中设置</h1><pre><code>public class BaseActivity extends Activity {\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(saveInstanceState);\n        // 无title\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        // 全屏\n        getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);\n        setContentView(R.layout.activity_main);\n    } \n}\n</code></pre><p>强调一点: <strong> 设置全屏的两段代码,必须在 <code>setContentView()</code> 之前调用,不然会报错 </strong></p>\n<h1 id=\"二-在配置文件中修改\"><a href=\"#二-在配置文件中修改\" class=\"headerlink\" title=\"二. 在配置文件中修改\"></a>二. 在配置文件中修改</h1><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;manifest \n  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  package=&quot;com.android.test&quot;\n  android:versionCode=&quot;1&quot;\n  ndroid:versionName=&quot;1.0&quot;&gt;\n  &lt;application android:icon=&quot;@drawable/icon&quot;\n    android:lable=&quot;@string/app_name&gt;\n    &lt;activity android:name=&quot;.BaseActivity&quot; \n        android:theme=&quot;@android:style/Theme.NotitleBar.Fullscreen&quot;\n        android:lable=&quot;@string/app_name&quot;&gt;\n        &lt;intent-filter&gt;\n            &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;\n            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;\n        &lt;/intent-filter&gt;\n  &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre><p>使用第一种方法,会在应用运行后,看到一个短暂的状态来, 然后才全屏, 而第二种方法是不会有这种情况的,大家根据需要自行选择.</p>\n","site":{"data":{}},"excerpt":"<p>在开发中,我们经常需要把我们的应用设置为全屏,这里有两种方式: 一是在代码中设置; 二是在配置文件中设置<br>","more":"</p>\n<h1 id=\"一-在代码中设置\"><a href=\"#一-在代码中设置\" class=\"headerlink\" title=\"一. 在代码中设置\"></a>一. 在代码中设置</h1><pre><code>public class BaseActivity extends Activity {\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(saveInstanceState);\n        // 无title\n        requestWindowFeature(Window.FEATURE_NO_TITLE);\n        // 全屏\n        getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);\n        setContentView(R.layout.activity_main);\n    } \n}\n</code></pre><p>强调一点: <strong> 设置全屏的两段代码,必须在 <code>setContentView()</code> 之前调用,不然会报错 </strong></p>\n<h1 id=\"二-在配置文件中修改\"><a href=\"#二-在配置文件中修改\" class=\"headerlink\" title=\"二. 在配置文件中修改\"></a>二. 在配置文件中修改</h1><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;manifest \n  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n  package=&quot;com.android.test&quot;\n  android:versionCode=&quot;1&quot;\n  ndroid:versionName=&quot;1.0&quot;&gt;\n  &lt;application android:icon=&quot;@drawable/icon&quot;\n    android:lable=&quot;@string/app_name&gt;\n    &lt;activity android:name=&quot;.BaseActivity&quot; \n        android:theme=&quot;@android:style/Theme.NotitleBar.Fullscreen&quot;\n        android:lable=&quot;@string/app_name&quot;&gt;\n        &lt;intent-filter&gt;\n            &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;\n            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;\n        &lt;/intent-filter&gt;\n  &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre><p>使用第一种方法,会在应用运行后,看到一个短暂的状态来, 然后才全屏, 而第二种方法是不会有这种情况的,大家根据需要自行选择.</p>"},{"title":"Android 在一个应用中启动另外一个应用","date":"2019-04-16T09:45:20.000Z","_content":"\n\n\n# Android 在一个应用中启动另外一个应用\nAndroid 中,从当前 APP 启动另外一个 APP 的需求,不是很常见, 但确实存在着,比如说在某宝还没有现在这么强大时,支付需要启动他们的 APP. 再比如说,某米的钱包系统,需要和他们的金融 APP 在某些业务上是相互依赖的,需要相互启动.\n\n综上所述, 从一个 APP 去启动另外一个 APP 的需求还是有它存在的价值.因此,一下是我在工作和学习中总结的如何通过一个 APP 去启动另外一个 APP 的方式.\n\n<!--more-->\n\n## 1. 通过 APP 启动另一个 APP\n\n```\n  String packageName = \"com.android.calendar\";\n  Intent intent = getPackageManager().getLaunchIntentForPackage(packageName);\n  intent.putExtra(\"type\", true);\n  startActivity(intent);\n```\n\n上面的代码,就可以完成从一个 APP 启动另一个 APP 的业务需求, 这里需要注意的是,我们需要检测一下要启动的 APP 是否已经安装,如果应用未安装, 则会 NullPointException.\n\n通过这种方式, Android 虚拟机会自己在目标 APP 下寻找标签为 `android.intent.action.MAIN` 的 Activity 启动.\n\n这里介绍两种方式,检测目标应用是否已经安装\n\n** 方法一: **\n\n```\nIntent intent = getPackageName().getLaunchIntentForPackage(packageName);\nif (intent == null) {\n  // 这里判断 Intent 为空, 说明应用不存在 \n}\n```\n\n**方法二:**\n\n```\n  PackageInfo packageInfo = getPackageManager(0.getPackageInfo(packageName, 0);\n  if (packageInfo == null) {\n      // 这里如果 packageInfo 为 null, 说明应用不存在\n  }\n```\n\n## 2. 打开另外一个 APP 指定的 Activity\n\n```\n    Intent intent = new Intent();\n    ComponentName componeneName = new ComponeneName(\"com.android.calendar\", \"com.android.calendar.LaunchActivity\");\n    intent.setComponent(componeneName);\n    startActivity(intent);\n```\n\n值得注意: \n\n*  需要将目标 Activity 的 android:export=\"true\" 属性在所属应用的 AndroidMainfest 里设置为 true, 意思是当前 Activity 允许被外部应用访问, 否则会报错\n\n```\n  Caused by: java.lang.SecurityException: Permission Denial: starting  Intent \n  { cmp=com.example.fm/.MainFragmentActivity (has extras) } from ProcessRecord\n  {39282a97 11545:com.xing.toolbardemo1/u0a71}  (pid=11545,     uid=10071) not exported from uid 10067\n```\n* 在 5.0 以前的设备上,需要在当前的 AndroidMainfest 里也生命目标Activity, 否则会报错; 但在 5.0 以后的设备上,就不会报错哦\n\n```\n  Caused by: android.content.ActivityNotFoundException: Unable to find explicit activity class {com.example.fm/com.example.fm.MainFragmentActivity}; \nhave you declared this activity in your AndroidManifest.xml?\n```\n\n\n\n","source":"_posts/Android 基础/Android-在一个应用中启动另外一个应用.md","raw":"---\ntitle: Android 在一个应用中启动另外一个应用\ndate: 2019-04-16 17:45:20\ntags: Android\n---\n\n\n\n# Android 在一个应用中启动另外一个应用\nAndroid 中,从当前 APP 启动另外一个 APP 的需求,不是很常见, 但确实存在着,比如说在某宝还没有现在这么强大时,支付需要启动他们的 APP. 再比如说,某米的钱包系统,需要和他们的金融 APP 在某些业务上是相互依赖的,需要相互启动.\n\n综上所述, 从一个 APP 去启动另外一个 APP 的需求还是有它存在的价值.因此,一下是我在工作和学习中总结的如何通过一个 APP 去启动另外一个 APP 的方式.\n\n<!--more-->\n\n## 1. 通过 APP 启动另一个 APP\n\n```\n  String packageName = \"com.android.calendar\";\n  Intent intent = getPackageManager().getLaunchIntentForPackage(packageName);\n  intent.putExtra(\"type\", true);\n  startActivity(intent);\n```\n\n上面的代码,就可以完成从一个 APP 启动另一个 APP 的业务需求, 这里需要注意的是,我们需要检测一下要启动的 APP 是否已经安装,如果应用未安装, 则会 NullPointException.\n\n通过这种方式, Android 虚拟机会自己在目标 APP 下寻找标签为 `android.intent.action.MAIN` 的 Activity 启动.\n\n这里介绍两种方式,检测目标应用是否已经安装\n\n** 方法一: **\n\n```\nIntent intent = getPackageName().getLaunchIntentForPackage(packageName);\nif (intent == null) {\n  // 这里判断 Intent 为空, 说明应用不存在 \n}\n```\n\n**方法二:**\n\n```\n  PackageInfo packageInfo = getPackageManager(0.getPackageInfo(packageName, 0);\n  if (packageInfo == null) {\n      // 这里如果 packageInfo 为 null, 说明应用不存在\n  }\n```\n\n## 2. 打开另外一个 APP 指定的 Activity\n\n```\n    Intent intent = new Intent();\n    ComponentName componeneName = new ComponeneName(\"com.android.calendar\", \"com.android.calendar.LaunchActivity\");\n    intent.setComponent(componeneName);\n    startActivity(intent);\n```\n\n值得注意: \n\n*  需要将目标 Activity 的 android:export=\"true\" 属性在所属应用的 AndroidMainfest 里设置为 true, 意思是当前 Activity 允许被外部应用访问, 否则会报错\n\n```\n  Caused by: java.lang.SecurityException: Permission Denial: starting  Intent \n  { cmp=com.example.fm/.MainFragmentActivity (has extras) } from ProcessRecord\n  {39282a97 11545:com.xing.toolbardemo1/u0a71}  (pid=11545,     uid=10071) not exported from uid 10067\n```\n* 在 5.0 以前的设备上,需要在当前的 AndroidMainfest 里也生命目标Activity, 否则会报错; 但在 5.0 以后的设备上,就不会报错哦\n\n```\n  Caused by: android.content.ActivityNotFoundException: Unable to find explicit activity class {com.example.fm/com.example.fm.MainFragmentActivity}; \nhave you declared this activity in your AndroidManifest.xml?\n```\n\n\n\n","slug":"Android 基础/Android-在一个应用中启动另外一个应用","published":1,"updated":"2021-01-29T15:54:28.283Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8ej0015sz5qnd102lof","content":"<h1 id=\"Android-在一个应用中启动另外一个应用\"><a href=\"#Android-在一个应用中启动另外一个应用\" class=\"headerlink\" title=\"Android 在一个应用中启动另外一个应用\"></a>Android 在一个应用中启动另外一个应用</h1><p>Android 中,从当前 APP 启动另外一个 APP 的需求,不是很常见, 但确实存在着,比如说在某宝还没有现在这么强大时,支付需要启动他们的 APP. 再比如说,某米的钱包系统,需要和他们的金融 APP 在某些业务上是相互依赖的,需要相互启动.</p>\n<p>综上所述, 从一个 APP 去启动另外一个 APP 的需求还是有它存在的价值.因此,一下是我在工作和学习中总结的如何通过一个 APP 去启动另外一个 APP 的方式.</p>\n<a id=\"more\"></a>\n<h2 id=\"1-通过-APP-启动另一个-APP\"><a href=\"#1-通过-APP-启动另一个-APP\" class=\"headerlink\" title=\"1. 通过 APP 启动另一个 APP\"></a>1. 通过 APP 启动另一个 APP</h2><pre><code>  String packageName = &quot;com.android.calendar&quot;;\n  Intent intent = getPackageManager().getLaunchIntentForPackage(packageName);\n  intent.putExtra(&quot;type&quot;, true);\n  startActivity(intent);\n</code></pre><p>上面的代码,就可以完成从一个 APP 启动另一个 APP 的业务需求, 这里需要注意的是,我们需要检测一下要启动的 APP 是否已经安装,如果应用未安装, 则会 NullPointException.</p>\n<p>通过这种方式, Android 虚拟机会自己在目标 APP 下寻找标签为 <code>android.intent.action.MAIN</code> 的 Activity 启动.</p>\n<p>这里介绍两种方式,检测目标应用是否已经安装</p>\n<p><strong> 方法一: </strong></p>\n<pre><code>Intent intent = getPackageName().getLaunchIntentForPackage(packageName);\nif (intent == null) {\n  // 这里判断 Intent 为空, 说明应用不存在 \n}\n</code></pre><p><strong>方法二:</strong></p>\n<pre><code>  PackageInfo packageInfo = getPackageManager(0.getPackageInfo(packageName, 0);\n  if (packageInfo == null) {\n      // 这里如果 packageInfo 为 null, 说明应用不存在\n  }\n</code></pre><h2 id=\"2-打开另外一个-APP-指定的-Activity\"><a href=\"#2-打开另外一个-APP-指定的-Activity\" class=\"headerlink\" title=\"2. 打开另外一个 APP 指定的 Activity\"></a>2. 打开另外一个 APP 指定的 Activity</h2><pre><code>    Intent intent = new Intent();\n    ComponentName componeneName = new ComponeneName(&quot;com.android.calendar&quot;, &quot;com.android.calendar.LaunchActivity&quot;);\n    intent.setComponent(componeneName);\n    startActivity(intent);\n</code></pre><p>值得注意: </p>\n<ul>\n<li>需要将目标 Activity 的 android:export=”true” 属性在所属应用的 AndroidMainfest 里设置为 true, 意思是当前 Activity 允许被外部应用访问, 否则会报错</li>\n</ul>\n<pre><code>  Caused by: java.lang.SecurityException: Permission Denial: starting  Intent \n  { cmp=com.example.fm/.MainFragmentActivity (has extras) } from ProcessRecord\n  {39282a97 11545:com.xing.toolbardemo1/u0a71}  (pid=11545,     uid=10071) not exported from uid 10067\n</code></pre><ul>\n<li>在 5.0 以前的设备上,需要在当前的 AndroidMainfest 里也生命目标Activity, 否则会报错; 但在 5.0 以后的设备上,就不会报错哦</li>\n</ul>\n<pre><code>  Caused by: android.content.ActivityNotFoundException: Unable to find explicit activity class {com.example.fm/com.example.fm.MainFragmentActivity}; \nhave you declared this activity in your AndroidManifest.xml?\n</code></pre>","site":{"data":{}},"excerpt":"<h1 id=\"Android-在一个应用中启动另外一个应用\"><a href=\"#Android-在一个应用中启动另外一个应用\" class=\"headerlink\" title=\"Android 在一个应用中启动另外一个应用\"></a>Android 在一个应用中启动另外一个应用</h1><p>Android 中,从当前 APP 启动另外一个 APP 的需求,不是很常见, 但确实存在着,比如说在某宝还没有现在这么强大时,支付需要启动他们的 APP. 再比如说,某米的钱包系统,需要和他们的金融 APP 在某些业务上是相互依赖的,需要相互启动.</p>\n<p>综上所述, 从一个 APP 去启动另外一个 APP 的需求还是有它存在的价值.因此,一下是我在工作和学习中总结的如何通过一个 APP 去启动另外一个 APP 的方式.</p>","more":"<h2 id=\"1-通过-APP-启动另一个-APP\"><a href=\"#1-通过-APP-启动另一个-APP\" class=\"headerlink\" title=\"1. 通过 APP 启动另一个 APP\"></a>1. 通过 APP 启动另一个 APP</h2><pre><code>  String packageName = &quot;com.android.calendar&quot;;\n  Intent intent = getPackageManager().getLaunchIntentForPackage(packageName);\n  intent.putExtra(&quot;type&quot;, true);\n  startActivity(intent);\n</code></pre><p>上面的代码,就可以完成从一个 APP 启动另一个 APP 的业务需求, 这里需要注意的是,我们需要检测一下要启动的 APP 是否已经安装,如果应用未安装, 则会 NullPointException.</p>\n<p>通过这种方式, Android 虚拟机会自己在目标 APP 下寻找标签为 <code>android.intent.action.MAIN</code> 的 Activity 启动.</p>\n<p>这里介绍两种方式,检测目标应用是否已经安装</p>\n<p><strong> 方法一: </strong></p>\n<pre><code>Intent intent = getPackageName().getLaunchIntentForPackage(packageName);\nif (intent == null) {\n  // 这里判断 Intent 为空, 说明应用不存在 \n}\n</code></pre><p><strong>方法二:</strong></p>\n<pre><code>  PackageInfo packageInfo = getPackageManager(0.getPackageInfo(packageName, 0);\n  if (packageInfo == null) {\n      // 这里如果 packageInfo 为 null, 说明应用不存在\n  }\n</code></pre><h2 id=\"2-打开另外一个-APP-指定的-Activity\"><a href=\"#2-打开另外一个-APP-指定的-Activity\" class=\"headerlink\" title=\"2. 打开另外一个 APP 指定的 Activity\"></a>2. 打开另外一个 APP 指定的 Activity</h2><pre><code>    Intent intent = new Intent();\n    ComponentName componeneName = new ComponeneName(&quot;com.android.calendar&quot;, &quot;com.android.calendar.LaunchActivity&quot;);\n    intent.setComponent(componeneName);\n    startActivity(intent);\n</code></pre><p>值得注意: </p>\n<ul>\n<li>需要将目标 Activity 的 android:export=”true” 属性在所属应用的 AndroidMainfest 里设置为 true, 意思是当前 Activity 允许被外部应用访问, 否则会报错</li>\n</ul>\n<pre><code>  Caused by: java.lang.SecurityException: Permission Denial: starting  Intent \n  { cmp=com.example.fm/.MainFragmentActivity (has extras) } from ProcessRecord\n  {39282a97 11545:com.xing.toolbardemo1/u0a71}  (pid=11545,     uid=10071) not exported from uid 10067\n</code></pre><ul>\n<li>在 5.0 以前的设备上,需要在当前的 AndroidMainfest 里也生命目标Activity, 否则会报错; 但在 5.0 以后的设备上,就不会报错哦</li>\n</ul>\n<pre><code>  Caused by: android.content.ActivityNotFoundException: Unable to find explicit activity class {com.example.fm/com.example.fm.MainFragmentActivity}; \nhave you declared this activity in your AndroidManifest.xml?\n</code></pre>"},{"title":"Java 堆栈的区别","date":"2019-08-09T13:54:08.000Z","_content":"\n# Java 中堆和栈的区别\n\n## 区别\n\nJava 中堆和栈的区别具体由一下几点\n<!-- more-->\n### 各司其职\n\n**栈：** 用来存储局部变量和方法调用\n\n**堆： ** 用来存储 Java 中的对象，无论是成员变量，局部变量，还是类，他们指向的对象都存储再堆内存中。\n\n### 内存：\n\n**栈：** 内存归属于单个线程，每个线程都会由一个栈内存，其存储的变量只能再其所属线程中可见，即占内存可以理解成线程的私有内存\n\n**堆： ** 内存中的对象堆所有线程可见。堆内存中的对象可以被所有线程访问。\n\n### 异常错误\n\n如果栈内存没有可用空间存储方法调用和局部变量， JVM 会抛出 `java.lang.StackOverFlowError` \n\n如果堆内存没有可用空间存储 生成的对象，  JVM 会抛出 `Java.lang.OutOfMemoryError`\n\n### 空间大小\n\n栈的内存要远远小于堆内存，如果使用递归的话，那么栈很快就会充满。如果递归没有及时跳出，很可能发生 `StackOverFlowError` 问题\n\n","source":"_posts/Java/Java 中堆和栈的区别.md","raw":"\n---\ntitle: Java 堆栈的区别\ndate: 2019-08-09 21:54:08\ntags: Java\n---\n\n# Java 中堆和栈的区别\n\n## 区别\n\nJava 中堆和栈的区别具体由一下几点\n<!-- more-->\n### 各司其职\n\n**栈：** 用来存储局部变量和方法调用\n\n**堆： ** 用来存储 Java 中的对象，无论是成员变量，局部变量，还是类，他们指向的对象都存储再堆内存中。\n\n### 内存：\n\n**栈：** 内存归属于单个线程，每个线程都会由一个栈内存，其存储的变量只能再其所属线程中可见，即占内存可以理解成线程的私有内存\n\n**堆： ** 内存中的对象堆所有线程可见。堆内存中的对象可以被所有线程访问。\n\n### 异常错误\n\n如果栈内存没有可用空间存储方法调用和局部变量， JVM 会抛出 `java.lang.StackOverFlowError` \n\n如果堆内存没有可用空间存储 生成的对象，  JVM 会抛出 `Java.lang.OutOfMemoryError`\n\n### 空间大小\n\n栈的内存要远远小于堆内存，如果使用递归的话，那么栈很快就会充满。如果递归没有及时跳出，很可能发生 `StackOverFlowError` 问题\n\n","slug":"Java/Java 中堆和栈的区别","published":1,"updated":"2021-01-30T07:42:56.812Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8el0018sz5qa7fucnxm","content":"<h1 id=\"Java-中堆和栈的区别\"><a href=\"#Java-中堆和栈的区别\" class=\"headerlink\" title=\"Java 中堆和栈的区别\"></a>Java 中堆和栈的区别</h1><h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2><p>Java 中堆和栈的区别具体由一下几点<br><a id=\"more\"></a></p>\n<h3 id=\"各司其职\"><a href=\"#各司其职\" class=\"headerlink\" title=\"各司其职\"></a>各司其职</h3><p><strong>栈：</strong> 用来存储局部变量和方法调用</p>\n<p><strong>堆： </strong> 用来存储 Java 中的对象，无论是成员变量，局部变量，还是类，他们指向的对象都存储再堆内存中。</p>\n<h3 id=\"内存：\"><a href=\"#内存：\" class=\"headerlink\" title=\"内存：\"></a>内存：</h3><p><strong>栈：</strong> 内存归属于单个线程，每个线程都会由一个栈内存，其存储的变量只能再其所属线程中可见，即占内存可以理解成线程的私有内存</p>\n<p><strong>堆： </strong> 内存中的对象堆所有线程可见。堆内存中的对象可以被所有线程访问。</p>\n<h3 id=\"异常错误\"><a href=\"#异常错误\" class=\"headerlink\" title=\"异常错误\"></a>异常错误</h3><p>如果栈内存没有可用空间存储方法调用和局部变量， JVM 会抛出 <code>java.lang.StackOverFlowError</code> </p>\n<p>如果堆内存没有可用空间存储 生成的对象，  JVM 会抛出 <code>Java.lang.OutOfMemoryError</code></p>\n<h3 id=\"空间大小\"><a href=\"#空间大小\" class=\"headerlink\" title=\"空间大小\"></a>空间大小</h3><p>栈的内存要远远小于堆内存，如果使用递归的话，那么栈很快就会充满。如果递归没有及时跳出，很可能发生 <code>StackOverFlowError</code> 问题</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Java-中堆和栈的区别\"><a href=\"#Java-中堆和栈的区别\" class=\"headerlink\" title=\"Java 中堆和栈的区别\"></a>Java 中堆和栈的区别</h1><h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2><p>Java 中堆和栈的区别具体由一下几点<br>","more":"</p>\n<h3 id=\"各司其职\"><a href=\"#各司其职\" class=\"headerlink\" title=\"各司其职\"></a>各司其职</h3><p><strong>栈：</strong> 用来存储局部变量和方法调用</p>\n<p><strong>堆： </strong> 用来存储 Java 中的对象，无论是成员变量，局部变量，还是类，他们指向的对象都存储再堆内存中。</p>\n<h3 id=\"内存：\"><a href=\"#内存：\" class=\"headerlink\" title=\"内存：\"></a>内存：</h3><p><strong>栈：</strong> 内存归属于单个线程，每个线程都会由一个栈内存，其存储的变量只能再其所属线程中可见，即占内存可以理解成线程的私有内存</p>\n<p><strong>堆： </strong> 内存中的对象堆所有线程可见。堆内存中的对象可以被所有线程访问。</p>\n<h3 id=\"异常错误\"><a href=\"#异常错误\" class=\"headerlink\" title=\"异常错误\"></a>异常错误</h3><p>如果栈内存没有可用空间存储方法调用和局部变量， JVM 会抛出 <code>java.lang.StackOverFlowError</code> </p>\n<p>如果堆内存没有可用空间存储 生成的对象，  JVM 会抛出 <code>Java.lang.OutOfMemoryError</code></p>\n<h3 id=\"空间大小\"><a href=\"#空间大小\" class=\"headerlink\" title=\"空间大小\"></a>空间大小</h3><p>栈的内存要远远小于堆内存，如果使用递归的话，那么栈很快就会充满。如果递归没有及时跳出，很可能发生 <code>StackOverFlowError</code> 问题</p>"},{"title":"Java 文件流","date":"2019-08-09T13:54:08.000Z","_content":"# Java 中文件 Copy 的几种方式\n\n## Java.io\n\n利用 `java.io` 类库。直接为源文件创建一个 `FileInputStream` 负责读取，然后再为目标文件创建一个 `FileOutputStream` 负责写入:\n<!-- more-->\n```java\npublic static void copyFileByStream(File source, File target) throws IOException {\n    InputStream is = null;\n    OutputStream os = null;\n    try {\n        is = new FileInputStream(source);\n        os = new FileOutputStream(target);\n        byte[] buffer = new byte[1024];\n        int length;\n        while((length = is.read(buffer)) > 0) {\n            os.write(buffer, 0, length);\n        }\n    } \n}\n```\n\n## Java.nio\n\n利用 `java.nio` 类库提供的 transferTo 或 transferFrom  方法实现\n\n```java\npublic static void copyFileByChannel(File source, File target) throw IOException {\n    try(FileChannel sc = new FileInputStream(source).getChannel();\n       FileChannel tc = new FileOutputStream(target).getChannel();) {\n        long count = sc.size();\n        while(count > 0) {\n            long transferred = sc.transferTo(sc.position(), count, tc);\n            count -= transferred;\n        }\n    }\n}\n```\n\n## Java.nio.file.File.copy \n\n关于 Copy 效率的问题，其实与操作系统和配置有关，总体来说 nio  transferTo/transferFrom 的方式可能更快，因为它更能利用现代操作系统底层机制，避免不必要拷贝和上下文切换。\n\n","source":"_posts/Java/Java 中文件 Copy 的几种方式.md","raw":"---\ntitle: Java 文件流\ndate: 2019-08-09 21:54:08\ntags: Java\n---\n# Java 中文件 Copy 的几种方式\n\n## Java.io\n\n利用 `java.io` 类库。直接为源文件创建一个 `FileInputStream` 负责读取，然后再为目标文件创建一个 `FileOutputStream` 负责写入:\n<!-- more-->\n```java\npublic static void copyFileByStream(File source, File target) throws IOException {\n    InputStream is = null;\n    OutputStream os = null;\n    try {\n        is = new FileInputStream(source);\n        os = new FileOutputStream(target);\n        byte[] buffer = new byte[1024];\n        int length;\n        while((length = is.read(buffer)) > 0) {\n            os.write(buffer, 0, length);\n        }\n    } \n}\n```\n\n## Java.nio\n\n利用 `java.nio` 类库提供的 transferTo 或 transferFrom  方法实现\n\n```java\npublic static void copyFileByChannel(File source, File target) throw IOException {\n    try(FileChannel sc = new FileInputStream(source).getChannel();\n       FileChannel tc = new FileOutputStream(target).getChannel();) {\n        long count = sc.size();\n        while(count > 0) {\n            long transferred = sc.transferTo(sc.position(), count, tc);\n            count -= transferred;\n        }\n    }\n}\n```\n\n## Java.nio.file.File.copy \n\n关于 Copy 效率的问题，其实与操作系统和配置有关，总体来说 nio  transferTo/transferFrom 的方式可能更快，因为它更能利用现代操作系统底层机制，避免不必要拷贝和上下文切换。\n\n","slug":"Java/Java 中文件 Copy 的几种方式","published":1,"updated":"2021-01-30T07:43:27.383Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8en001bsz5qij1w0rlw","content":"<h1 id=\"Java-中文件-Copy-的几种方式\"><a href=\"#Java-中文件-Copy-的几种方式\" class=\"headerlink\" title=\"Java 中文件 Copy 的几种方式\"></a>Java 中文件 Copy 的几种方式</h1><h2 id=\"Java-io\"><a href=\"#Java-io\" class=\"headerlink\" title=\"Java.io\"></a>Java.io</h2><p>利用 <code>java.io</code> 类库。直接为源文件创建一个 <code>FileInputStream</code> 负责读取，然后再为目标文件创建一个 <code>FileOutputStream</code> 负责写入:<br><a id=\"more\"></a></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">copyFileByStream</span><span class=\"token punctuation\">(</span>File source<span class=\"token punctuation\">,</span> File target<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> IOException <span class=\"token punctuation\">{</span>\n    InputStream is <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n    OutputStream os <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        is <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileInputStream</span><span class=\"token punctuation\">(</span>source<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        os <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileOutputStream</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> buffer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">1024</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> length<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>length <span class=\"token operator\">=</span> is<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            os<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> \n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"Java-nio\"><a href=\"#Java-nio\" class=\"headerlink\" title=\"Java.nio\"></a>Java.nio</h2><p>利用 <code>java.nio</code> 类库提供的 transferTo 或 transferFrom  方法实现</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">copyFileByChannel</span><span class=\"token punctuation\">(</span>File source<span class=\"token punctuation\">,</span> File target<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> IOException <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span><span class=\"token punctuation\">(</span>FileChannel sc <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileInputStream</span><span class=\"token punctuation\">(</span>source<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getChannel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       FileChannel tc <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileOutputStream</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getChannel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">long</span> count <span class=\"token operator\">=</span> sc<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">long</span> transferred <span class=\"token operator\">=</span> sc<span class=\"token punctuation\">.</span><span class=\"token function\">transferTo</span><span class=\"token punctuation\">(</span>sc<span class=\"token punctuation\">.</span><span class=\"token function\">position</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> count<span class=\"token punctuation\">,</span> tc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            count <span class=\"token operator\">-=</span> transferred<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"Java-nio-file-File-copy\"><a href=\"#Java-nio-file-File-copy\" class=\"headerlink\" title=\"Java.nio.file.File.copy\"></a>Java.nio.file.File.copy</h2><p>关于 Copy 效率的问题，其实与操作系统和配置有关，总体来说 nio  transferTo/transferFrom 的方式可能更快，因为它更能利用现代操作系统底层机制，避免不必要拷贝和上下文切换。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Java-中文件-Copy-的几种方式\"><a href=\"#Java-中文件-Copy-的几种方式\" class=\"headerlink\" title=\"Java 中文件 Copy 的几种方式\"></a>Java 中文件 Copy 的几种方式</h1><h2 id=\"Java-io\"><a href=\"#Java-io\" class=\"headerlink\" title=\"Java.io\"></a>Java.io</h2><p>利用 <code>java.io</code> 类库。直接为源文件创建一个 <code>FileInputStream</code> 负责读取，然后再为目标文件创建一个 <code>FileOutputStream</code> 负责写入:<br>","more":"</p>\n<pre><code class=\"java\">public static void copyFileByStream(File source, File target) throws IOException {\n    InputStream is = null;\n    OutputStream os = null;\n    try {\n        is = new FileInputStream(source);\n        os = new FileOutputStream(target);\n        byte[] buffer = new byte[1024];\n        int length;\n        while((length = is.read(buffer)) &gt; 0) {\n            os.write(buffer, 0, length);\n        }\n    } \n}\n</code></pre>\n<h2 id=\"Java-nio\"><a href=\"#Java-nio\" class=\"headerlink\" title=\"Java.nio\"></a>Java.nio</h2><p>利用 <code>java.nio</code> 类库提供的 transferTo 或 transferFrom  方法实现</p>\n<pre><code class=\"java\">public static void copyFileByChannel(File source, File target) throw IOException {\n    try(FileChannel sc = new FileInputStream(source).getChannel();\n       FileChannel tc = new FileOutputStream(target).getChannel();) {\n        long count = sc.size();\n        while(count &gt; 0) {\n            long transferred = sc.transferTo(sc.position(), count, tc);\n            count -= transferred;\n        }\n    }\n}\n</code></pre>\n<h2 id=\"Java-nio-file-File-copy\"><a href=\"#Java-nio-file-File-copy\" class=\"headerlink\" title=\"Java.nio.file.File.copy\"></a>Java.nio.file.File.copy</h2><p>关于 Copy 效率的问题，其实与操作系统和配置有关，总体来说 nio  transferTo/transferFrom 的方式可能更快，因为它更能利用现代操作系统底层机制，避免不必要拷贝和上下文切换。</p>"},{"title":"Java 内存管理","_content":"\n对于 Java 程序员来说，在虚拟机的自动内存管理机制的帮助下，不再需要为每一个 new 操作区写配对的 `delete/free` 代码，而且不容易出现内存泄漏和内存移除问题，看起来一切由虚拟机管理内存一切都很美好。不过也正是 Java 程序员把内存控制的权力交给了 Java 虚拟机，一旦出现内存泄漏和溢出的问题，如果不了解续集及是怎么使用内存的，排查问题就很艰难。\n<!-- more-->\n## 运行时数据区域\n\n![java runtime](https://github.com/xiaomanwong/static_file/blob/master/images/java_runtime_data_area.png?raw=true)\n\n### 程序计数器\n\n程序计数器是一块较小的内存空间，作用是当前线程锁执行的字节码的行号指示器。\n\n由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现，再任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）知乎执行一条线程中的指令，因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间的计数器互不影响，独立存储。\n\n此区域是唯一一个 Java 虚拟机规范中没有任何 **OutOfMemoryError** 情况的区域\n\n### Java 虚拟机栈\n\nJava 虚拟机栈也是线程私有的，生命周期与线程相同。虚拟机描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作站、动态链接、方法处口等信息。\n\n每一个方法被调用直到执行完成的过程，就对应一个栈帧再虚拟机栈中从入栈到出栈的过程。\n\n**局部变量表** 存放了编译器可知的各种基本数据类型（boolean, byte, char, short, int, float, long, double），对象引用(Reference类型)。\n\n\n\n**StackOverflowError**： 如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出 `StackOverflowError` 异常\n\n### 本地方法栈\n\n本地方法栈与虚拟机栈锁发挥的作用时相似的，其区别是虚拟机栈为虚拟机执行 Java 方法服务。而本地方法栈则是为虚拟机使用到的 Navite 方法服务。\n\n### Java 堆\n\n是 Java 虚拟机所管理的内存中最大的一块。Java 堆被所有线程共享的一块内存区域，再虚拟机启动的时候创建。**此区域唯一的目的就是存放对象实例**，几乎所有的对象实例都再这里分配内存。\n\nJava 堆是垃圾回收器管理的主要区域，因此很多时候也被称做 GC 堆，从内存回收角度看，由于现在收集器基本都是采用 **分代收集算法** ，所以 Java 堆中还可以细分为： 新生代和老生代\n\n如果从内存分配角度看，线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区\n\n### **方法区**\n\n方法区与 Java 堆一样，是哥哥线程共享的内存区域，**用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译的代码等数据**。\n\n### **运行时常量池**\n\n运行时常量池是方法去的一部分 ，用于存放编译器申城的各种字面量和符号引用，这部分内容在类加载后存放到方法区的运行时常量池中。\n\n## 垃圾回收\n\n**GC** 真正让程序员的生产力得到了释放，但是程序员很难感知到它的存在。在大多数情况下不是很需要关心 GC ，不过如果设计到一些性能优化，问题排查的时候，深入地了解 GC 还是有必要的。\n\n### Java 内存区域\n\n* 虚拟机栈：表述的是方法执行时的内存模型，线程私有化，生命周期和线程相同，每个方法被执行的同时都会创建栈帧，主要保存执行方法时的具不变量表、操作数栈、动态链接和方法返回地址等信息。方法执行时入栈，执行完成出栈，出栈就相当于清空了数据，入栈出栈的实际很明确，**这块区域不需要进行 GC**\n* 本地方法栈：与虚拟机栈类似，主要在于虚拟机栈为虚拟机执行Java方法是服务，本地方法栈为虚拟机执行本地方法时服务。**不需要进行 GC**\n* 程序计数器：线程独有，可以看作时当前线程执行的字节码行号。**不需要进行 GC**\n* 本地内存：线程共享区域，本地内存；主要存储类的信息、长廊、静态变量、即使编译器编译后代码，这部分由于时在堆中实现的，受 GC 管理。Java 8 以后，这个区域也不需要GC\n* 堆：对象实例和水族都是在堆上分配的， GC 也主要堆这两类数据进行回收\n\n#### 回收算法\n\n##### 引用计数法\n\n最容易想到的一种方式，就是对象被引用一次，再它的头上就加一次引用次数，如果没有被引用（引用次数为0），则此对象可回收。但这种方式存在一个问题：**循环引用**\n\n```java\npublic class Test {\n    Test instance;\n    public Test(String name){}\n    \n    public static void main(String[] args) {\n        // first\n        A a = new Test(\"a\");\n        B b = new Test(\"b\");\n        //second\n        a.instance = b;\n        b.instance = a;\n\t    //third\n        a = null;\n        b = null;\n    }\n}\n```\n\n按照上面的步骤，虽然 a, b 都被置为 null, 但是由于之前他们指向的对象相互引用（引用计数都为1），所以无法收回，也证是无法解决循环引用的问题，现代虚拟机一抛弃这种方法。\n\n##### 可达性算法\n\n以一系列叫做 **GC Root** 的对象为起点出发，引出他们指向的下一个节点，再以下个节点为起点，引出此节点的下一个节点。。。（通过 GC Root 传承的一条线就叫引用链），直到所有的节点都遍历完毕，如果相关对象不再任意一个以 GC Root 为起点的引用链上，则这个对象会被判定为垃圾，进行回收。\n\n但是，一个对象的 `finalize` 方法给了对象一次垂死挣扎的机会，当对象不可达时，发生 GC 时，会先判断对象是否执行了 `finalize` 方法，如果未执行，则会先执行 `finalize` 方法，我们可以再此方法里将当前对象和 GC Root 关联，这样执行 `finalize` 之后，GC 会再次判断对象是否可达，如果不可达，就回收，可达则不回收。\n\n**注意：** `finalize` 方法只会执行一次，如果第一次执行 `finalize` 方法，子对象变成了可达，确定不会回收，但如果对象再次被 GC 则会忽略 `finalize` 方法，对象会被回收。\n\n**GC Root**\n\n那么，什么样的对象可以作为 GC Root 呢\n\n1. 虚拟机栈（栈帧中的本地变量）中的引用对象\n\n2. 方法区中类静态属性引用的对象\n\n3. 方法区中常量引用的对象\n\n4. 本地方法栈中 JNI 引用的对象\n\n**虚拟机栈中的对象**\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        Test a = new Test();\n        a = null;\n    }\n}\n```\n\na 是栈帧中的本地变量，当 a = null 时，由于此时 a  充当了 GC Root 的作用， a 与原来指向的实例 `new Test()` 断开连接，所以对象会被回收。\n\n**方法区中类静态属性引用的对象**\n\n```java\npublic class Test {\n    public static Test instance;\n    public static void main(String[] args) {\n        Test a = new Test();\n        a.instance = new Test();\n        a = null;\n    }\n}\n```\n\n当栈帧中的本地变量  `a = null` 时，由于 a 原来指向的对下个与 GC  Root（变量 instance）断开了连接，所以 a 原来的对象会被回收，而由于我们给 `instance` 赋值了变量的引用， `instance` 在此时是类静态属性引用，充当了 GC Root 的作用，它指向的对象依然存活。\n\n**方法区中常量引用的对象**\n\n```java\npublic class Test {\n    public static final Test instance = new Test();\n    public static void main(String[] args) {\n        Test a = new Test();\n        a = null;\n    }\n}\n```\n\n常量 `instance` 指向的对象并不会因为 a 指向的对象被回收而回收\n\n**本地方法栈中的 JNI 引用的对象**\n\n> 所谓本地方法就是一个 java 调用非 java 代码的接口，该方法并非 java 实现的，可能是 C 或 Python 等其他语言。Java 通过 JNI 来调用本地方法，而本地方法是以库文件的形式存放的。\n\n当调用 Java 方法时，虚拟机会创建一个栈帧并压入 Java 栈，而当它调用的是本地方法时，虚拟机会保持 Java 不变，不会再 Java 栈中压入新的帧，虚拟机只是简单的动态连接并直接调用指定的本地方法。\n\n##### 标记清除算法\n\n**步骤**：\n\n1. 先根据可达性算法 **标记** 出相应的可回收对象\n2. 对可回收对象进行回收\n\n操作起来很简单，也不需要做数据移动的操作。但是却存在一个问题 –> **内存碎片**\n\n假如我们想在内存中分配一块需要连续内存占用的 4M  或 6M 的内存区域，由于内存碎片的存在，有可能得不到分配。\n\n##### 复制算法\n\n把堆等分成两块区域 A 和 B， 区域 A 负责分配对象， 区域 B 不非陪，对区域 A 使用标记清楚算法把存活的对象标记出来，然后把区域 A 中存活的对象都复制到 B 区域（同时将存活的对象都一次紧邻排列），最后把 A 区域对象全部清理掉释放出空间。\n\n**问题：**\n\n比如给堆分配了 500M 内存，结果只有 250M 可用 ，空间平白无故减少了一半。另外每此回收都要把存活的对象移动到另外一般，效率很低下。\n\n##### 标记整理法\n\n步骤：\n\n1. 先根据可达性算法 **标记** 出相应的可回收对象\n2. 对可回收对象进行回收\n3. 将所有存活对象都往一端移动，紧邻排列。\n\n\n","source":"_posts/Java/Java 内存管理.md","raw":"---\ntitle: Java 内存管理\ntag: Java\ncategory: Java\n---\n\n对于 Java 程序员来说，在虚拟机的自动内存管理机制的帮助下，不再需要为每一个 new 操作区写配对的 `delete/free` 代码，而且不容易出现内存泄漏和内存移除问题，看起来一切由虚拟机管理内存一切都很美好。不过也正是 Java 程序员把内存控制的权力交给了 Java 虚拟机，一旦出现内存泄漏和溢出的问题，如果不了解续集及是怎么使用内存的，排查问题就很艰难。\n<!-- more-->\n## 运行时数据区域\n\n![java runtime](https://github.com/xiaomanwong/static_file/blob/master/images/java_runtime_data_area.png?raw=true)\n\n### 程序计数器\n\n程序计数器是一块较小的内存空间，作用是当前线程锁执行的字节码的行号指示器。\n\n由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现，再任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）知乎执行一条线程中的指令，因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间的计数器互不影响，独立存储。\n\n此区域是唯一一个 Java 虚拟机规范中没有任何 **OutOfMemoryError** 情况的区域\n\n### Java 虚拟机栈\n\nJava 虚拟机栈也是线程私有的，生命周期与线程相同。虚拟机描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作站、动态链接、方法处口等信息。\n\n每一个方法被调用直到执行完成的过程，就对应一个栈帧再虚拟机栈中从入栈到出栈的过程。\n\n**局部变量表** 存放了编译器可知的各种基本数据类型（boolean, byte, char, short, int, float, long, double），对象引用(Reference类型)。\n\n\n\n**StackOverflowError**： 如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出 `StackOverflowError` 异常\n\n### 本地方法栈\n\n本地方法栈与虚拟机栈锁发挥的作用时相似的，其区别是虚拟机栈为虚拟机执行 Java 方法服务。而本地方法栈则是为虚拟机使用到的 Navite 方法服务。\n\n### Java 堆\n\n是 Java 虚拟机所管理的内存中最大的一块。Java 堆被所有线程共享的一块内存区域，再虚拟机启动的时候创建。**此区域唯一的目的就是存放对象实例**，几乎所有的对象实例都再这里分配内存。\n\nJava 堆是垃圾回收器管理的主要区域，因此很多时候也被称做 GC 堆，从内存回收角度看，由于现在收集器基本都是采用 **分代收集算法** ，所以 Java 堆中还可以细分为： 新生代和老生代\n\n如果从内存分配角度看，线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区\n\n### **方法区**\n\n方法区与 Java 堆一样，是哥哥线程共享的内存区域，**用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译的代码等数据**。\n\n### **运行时常量池**\n\n运行时常量池是方法去的一部分 ，用于存放编译器申城的各种字面量和符号引用，这部分内容在类加载后存放到方法区的运行时常量池中。\n\n## 垃圾回收\n\n**GC** 真正让程序员的生产力得到了释放，但是程序员很难感知到它的存在。在大多数情况下不是很需要关心 GC ，不过如果设计到一些性能优化，问题排查的时候，深入地了解 GC 还是有必要的。\n\n### Java 内存区域\n\n* 虚拟机栈：表述的是方法执行时的内存模型，线程私有化，生命周期和线程相同，每个方法被执行的同时都会创建栈帧，主要保存执行方法时的具不变量表、操作数栈、动态链接和方法返回地址等信息。方法执行时入栈，执行完成出栈，出栈就相当于清空了数据，入栈出栈的实际很明确，**这块区域不需要进行 GC**\n* 本地方法栈：与虚拟机栈类似，主要在于虚拟机栈为虚拟机执行Java方法是服务，本地方法栈为虚拟机执行本地方法时服务。**不需要进行 GC**\n* 程序计数器：线程独有，可以看作时当前线程执行的字节码行号。**不需要进行 GC**\n* 本地内存：线程共享区域，本地内存；主要存储类的信息、长廊、静态变量、即使编译器编译后代码，这部分由于时在堆中实现的，受 GC 管理。Java 8 以后，这个区域也不需要GC\n* 堆：对象实例和水族都是在堆上分配的， GC 也主要堆这两类数据进行回收\n\n#### 回收算法\n\n##### 引用计数法\n\n最容易想到的一种方式，就是对象被引用一次，再它的头上就加一次引用次数，如果没有被引用（引用次数为0），则此对象可回收。但这种方式存在一个问题：**循环引用**\n\n```java\npublic class Test {\n    Test instance;\n    public Test(String name){}\n    \n    public static void main(String[] args) {\n        // first\n        A a = new Test(\"a\");\n        B b = new Test(\"b\");\n        //second\n        a.instance = b;\n        b.instance = a;\n\t    //third\n        a = null;\n        b = null;\n    }\n}\n```\n\n按照上面的步骤，虽然 a, b 都被置为 null, 但是由于之前他们指向的对象相互引用（引用计数都为1），所以无法收回，也证是无法解决循环引用的问题，现代虚拟机一抛弃这种方法。\n\n##### 可达性算法\n\n以一系列叫做 **GC Root** 的对象为起点出发，引出他们指向的下一个节点，再以下个节点为起点，引出此节点的下一个节点。。。（通过 GC Root 传承的一条线就叫引用链），直到所有的节点都遍历完毕，如果相关对象不再任意一个以 GC Root 为起点的引用链上，则这个对象会被判定为垃圾，进行回收。\n\n但是，一个对象的 `finalize` 方法给了对象一次垂死挣扎的机会，当对象不可达时，发生 GC 时，会先判断对象是否执行了 `finalize` 方法，如果未执行，则会先执行 `finalize` 方法，我们可以再此方法里将当前对象和 GC Root 关联，这样执行 `finalize` 之后，GC 会再次判断对象是否可达，如果不可达，就回收，可达则不回收。\n\n**注意：** `finalize` 方法只会执行一次，如果第一次执行 `finalize` 方法，子对象变成了可达，确定不会回收，但如果对象再次被 GC 则会忽略 `finalize` 方法，对象会被回收。\n\n**GC Root**\n\n那么，什么样的对象可以作为 GC Root 呢\n\n1. 虚拟机栈（栈帧中的本地变量）中的引用对象\n\n2. 方法区中类静态属性引用的对象\n\n3. 方法区中常量引用的对象\n\n4. 本地方法栈中 JNI 引用的对象\n\n**虚拟机栈中的对象**\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        Test a = new Test();\n        a = null;\n    }\n}\n```\n\na 是栈帧中的本地变量，当 a = null 时，由于此时 a  充当了 GC Root 的作用， a 与原来指向的实例 `new Test()` 断开连接，所以对象会被回收。\n\n**方法区中类静态属性引用的对象**\n\n```java\npublic class Test {\n    public static Test instance;\n    public static void main(String[] args) {\n        Test a = new Test();\n        a.instance = new Test();\n        a = null;\n    }\n}\n```\n\n当栈帧中的本地变量  `a = null` 时，由于 a 原来指向的对下个与 GC  Root（变量 instance）断开了连接，所以 a 原来的对象会被回收，而由于我们给 `instance` 赋值了变量的引用， `instance` 在此时是类静态属性引用，充当了 GC Root 的作用，它指向的对象依然存活。\n\n**方法区中常量引用的对象**\n\n```java\npublic class Test {\n    public static final Test instance = new Test();\n    public static void main(String[] args) {\n        Test a = new Test();\n        a = null;\n    }\n}\n```\n\n常量 `instance` 指向的对象并不会因为 a 指向的对象被回收而回收\n\n**本地方法栈中的 JNI 引用的对象**\n\n> 所谓本地方法就是一个 java 调用非 java 代码的接口，该方法并非 java 实现的，可能是 C 或 Python 等其他语言。Java 通过 JNI 来调用本地方法，而本地方法是以库文件的形式存放的。\n\n当调用 Java 方法时，虚拟机会创建一个栈帧并压入 Java 栈，而当它调用的是本地方法时，虚拟机会保持 Java 不变，不会再 Java 栈中压入新的帧，虚拟机只是简单的动态连接并直接调用指定的本地方法。\n\n##### 标记清除算法\n\n**步骤**：\n\n1. 先根据可达性算法 **标记** 出相应的可回收对象\n2. 对可回收对象进行回收\n\n操作起来很简单，也不需要做数据移动的操作。但是却存在一个问题 –> **内存碎片**\n\n假如我们想在内存中分配一块需要连续内存占用的 4M  或 6M 的内存区域，由于内存碎片的存在，有可能得不到分配。\n\n##### 复制算法\n\n把堆等分成两块区域 A 和 B， 区域 A 负责分配对象， 区域 B 不非陪，对区域 A 使用标记清楚算法把存活的对象标记出来，然后把区域 A 中存活的对象都复制到 B 区域（同时将存活的对象都一次紧邻排列），最后把 A 区域对象全部清理掉释放出空间。\n\n**问题：**\n\n比如给堆分配了 500M 内存，结果只有 250M 可用 ，空间平白无故减少了一半。另外每此回收都要把存活的对象移动到另外一般，效率很低下。\n\n##### 标记整理法\n\n步骤：\n\n1. 先根据可达性算法 **标记** 出相应的可回收对象\n2. 对可回收对象进行回收\n3. 将所有存活对象都往一端移动，紧邻排列。\n\n\n","slug":"Java/Java 内存管理","published":1,"date":"2021-01-29T15:54:28.307Z","updated":"2021-01-30T07:43:40.666Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8eq001fsz5qqqckxrwg","content":"<p>对于 Java 程序员来说，在虚拟机的自动内存管理机制的帮助下，不再需要为每一个 new 操作区写配对的 <code>delete/free</code> 代码，而且不容易出现内存泄漏和内存移除问题，看起来一切由虚拟机管理内存一切都很美好。不过也正是 Java 程序员把内存控制的权力交给了 Java 虚拟机，一旦出现内存泄漏和溢出的问题，如果不了解续集及是怎么使用内存的，排查问题就很艰难。<br><a id=\"more\"></a></p>\n<h2 id=\"运行时数据区域\"><a href=\"#运行时数据区域\" class=\"headerlink\" title=\"运行时数据区域\"></a>运行时数据区域</h2><p><img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/java_runtime_data_area.png?raw=true\" alt=\"java runtime\"></p>\n<h3 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h3><p>程序计数器是一块较小的内存空间，作用是当前线程锁执行的字节码的行号指示器。</p>\n<p>由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现，再任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）知乎执行一条线程中的指令，因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间的计数器互不影响，独立存储。</p>\n<p>此区域是唯一一个 Java 虚拟机规范中没有任何 <strong>OutOfMemoryError</strong> 情况的区域</p>\n<h3 id=\"Java-虚拟机栈\"><a href=\"#Java-虚拟机栈\" class=\"headerlink\" title=\"Java 虚拟机栈\"></a>Java 虚拟机栈</h3><p>Java 虚拟机栈也是线程私有的，生命周期与线程相同。虚拟机描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作站、动态链接、方法处口等信息。</p>\n<p>每一个方法被调用直到执行完成的过程，就对应一个栈帧再虚拟机栈中从入栈到出栈的过程。</p>\n<p><strong>局部变量表</strong> 存放了编译器可知的各种基本数据类型（boolean, byte, char, short, int, float, long, double），对象引用(Reference类型)。</p>\n<p><strong>StackOverflowError</strong>： 如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出 <code>StackOverflowError</code> 异常</p>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><p>本地方法栈与虚拟机栈锁发挥的作用时相似的，其区别是虚拟机栈为虚拟机执行 Java 方法服务。而本地方法栈则是为虚拟机使用到的 Navite 方法服务。</p>\n<h3 id=\"Java-堆\"><a href=\"#Java-堆\" class=\"headerlink\" title=\"Java 堆\"></a>Java 堆</h3><p>是 Java 虚拟机所管理的内存中最大的一块。Java 堆被所有线程共享的一块内存区域，再虚拟机启动的时候创建。<strong>此区域唯一的目的就是存放对象实例</strong>，几乎所有的对象实例都再这里分配内存。</p>\n<p>Java 堆是垃圾回收器管理的主要区域，因此很多时候也被称做 GC 堆，从内存回收角度看，由于现在收集器基本都是采用 <strong>分代收集算法</strong> ，所以 Java 堆中还可以细分为： 新生代和老生代</p>\n<p>如果从内存分配角度看，线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区</p>\n<h3 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a><strong>方法区</strong></h3><p>方法区与 Java 堆一样，是哥哥线程共享的内存区域，<strong>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译的代码等数据</strong>。</p>\n<h3 id=\"运行时常量池\"><a href=\"#运行时常量池\" class=\"headerlink\" title=\"运行时常量池\"></a><strong>运行时常量池</strong></h3><p>运行时常量池是方法去的一部分 ，用于存放编译器申城的各种字面量和符号引用，这部分内容在类加载后存放到方法区的运行时常量池中。</p>\n<h2 id=\"垃圾回收\"><a href=\"#垃圾回收\" class=\"headerlink\" title=\"垃圾回收\"></a>垃圾回收</h2><p><strong>GC</strong> 真正让程序员的生产力得到了释放，但是程序员很难感知到它的存在。在大多数情况下不是很需要关心 GC ，不过如果设计到一些性能优化，问题排查的时候，深入地了解 GC 还是有必要的。</p>\n<h3 id=\"Java-内存区域\"><a href=\"#Java-内存区域\" class=\"headerlink\" title=\"Java 内存区域\"></a>Java 内存区域</h3><ul>\n<li>虚拟机栈：表述的是方法执行时的内存模型，线程私有化，生命周期和线程相同，每个方法被执行的同时都会创建栈帧，主要保存执行方法时的具不变量表、操作数栈、动态链接和方法返回地址等信息。方法执行时入栈，执行完成出栈，出栈就相当于清空了数据，入栈出栈的实际很明确，<strong>这块区域不需要进行 GC</strong></li>\n<li>本地方法栈：与虚拟机栈类似，主要在于虚拟机栈为虚拟机执行Java方法是服务，本地方法栈为虚拟机执行本地方法时服务。<strong>不需要进行 GC</strong></li>\n<li>程序计数器：线程独有，可以看作时当前线程执行的字节码行号。<strong>不需要进行 GC</strong></li>\n<li>本地内存：线程共享区域，本地内存；主要存储类的信息、长廊、静态变量、即使编译器编译后代码，这部分由于时在堆中实现的，受 GC 管理。Java 8 以后，这个区域也不需要GC</li>\n<li>堆：对象实例和水族都是在堆上分配的， GC 也主要堆这两类数据进行回收</li>\n</ul>\n<h4 id=\"回收算法\"><a href=\"#回收算法\" class=\"headerlink\" title=\"回收算法\"></a>回收算法</h4><h5 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h5><p>最容易想到的一种方式，就是对象被引用一次，再它的头上就加一次引用次数，如果没有被引用（引用次数为0），则此对象可回收。但这种方式存在一个问题：<strong>循环引用</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">{</span>\n    Test instance<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Test</span><span class=\"token punctuation\">(</span>String name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// first</span>\n        A a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Test</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        B b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Test</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"b\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//second</span>\n        a<span class=\"token punctuation\">.</span>instance <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span>\n        b<span class=\"token punctuation\">.</span>instance <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//third</span>\n        a <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n        b <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>按照上面的步骤，虽然 a, b 都被置为 null, 但是由于之前他们指向的对象相互引用（引用计数都为1），所以无法收回，也证是无法解决循环引用的问题，现代虚拟机一抛弃这种方法。</p>\n<h5 id=\"可达性算法\"><a href=\"#可达性算法\" class=\"headerlink\" title=\"可达性算法\"></a>可达性算法</h5><p>以一系列叫做 <strong>GC Root</strong> 的对象为起点出发，引出他们指向的下一个节点，再以下个节点为起点，引出此节点的下一个节点。。。（通过 GC Root 传承的一条线就叫引用链），直到所有的节点都遍历完毕，如果相关对象不再任意一个以 GC Root 为起点的引用链上，则这个对象会被判定为垃圾，进行回收。</p>\n<p>但是，一个对象的 <code>finalize</code> 方法给了对象一次垂死挣扎的机会，当对象不可达时，发生 GC 时，会先判断对象是否执行了 <code>finalize</code> 方法，如果未执行，则会先执行 <code>finalize</code> 方法，我们可以再此方法里将当前对象和 GC Root 关联，这样执行 <code>finalize</code> 之后，GC 会再次判断对象是否可达，如果不可达，就回收，可达则不回收。</p>\n<p><strong>注意：</strong> <code>finalize</code> 方法只会执行一次，如果第一次执行 <code>finalize</code> 方法，子对象变成了可达，确定不会回收，但如果对象再次被 GC 则会忽略 <code>finalize</code> 方法，对象会被回收。</p>\n<p><strong>GC Root</strong></p>\n<p>那么，什么样的对象可以作为 GC Root 呢</p>\n<ol>\n<li><p>虚拟机栈（栈帧中的本地变量）中的引用对象</p>\n</li>\n<li><p>方法区中类静态属性引用的对象</p>\n</li>\n<li><p>方法区中常量引用的对象</p>\n</li>\n<li><p>本地方法栈中 JNI 引用的对象</p>\n</li>\n</ol>\n<p><strong>虚拟机栈中的对象</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Test a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        a <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>a 是栈帧中的本地变量，当 a = null 时，由于此时 a  充当了 GC Root 的作用， a 与原来指向的实例 <code>new Test()</code> 断开连接，所以对象会被回收。</p>\n<p><strong>方法区中类静态属性引用的对象</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> Test instance<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Test a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        a<span class=\"token punctuation\">.</span>instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        a <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>当栈帧中的本地变量  <code>a = null</code> 时，由于 a 原来指向的对下个与 GC  Root（变量 instance）断开了连接，所以 a 原来的对象会被回收，而由于我们给 <code>instance</code> 赋值了变量的引用， <code>instance</code> 在此时是类静态属性引用，充当了 GC Root 的作用，它指向的对象依然存活。</p>\n<p><strong>方法区中常量引用的对象</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> Test instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Test a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        a <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>常量 <code>instance</code> 指向的对象并不会因为 a 指向的对象被回收而回收</p>\n<p><strong>本地方法栈中的 JNI 引用的对象</strong></p>\n<blockquote>\n<p>所谓本地方法就是一个 java 调用非 java 代码的接口，该方法并非 java 实现的，可能是 C 或 Python 等其他语言。Java 通过 JNI 来调用本地方法，而本地方法是以库文件的形式存放的。</p>\n</blockquote>\n<p>当调用 Java 方法时，虚拟机会创建一个栈帧并压入 Java 栈，而当它调用的是本地方法时，虚拟机会保持 Java 不变，不会再 Java 栈中压入新的帧，虚拟机只是简单的动态连接并直接调用指定的本地方法。</p>\n<h5 id=\"标记清除算法\"><a href=\"#标记清除算法\" class=\"headerlink\" title=\"标记清除算法\"></a>标记清除算法</h5><p><strong>步骤</strong>：</p>\n<ol>\n<li>先根据可达性算法 <strong>标记</strong> 出相应的可回收对象</li>\n<li>对可回收对象进行回收</li>\n</ol>\n<p>操作起来很简单，也不需要做数据移动的操作。但是却存在一个问题 –&gt; <strong>内存碎片</strong></p>\n<p>假如我们想在内存中分配一块需要连续内存占用的 4M  或 6M 的内存区域，由于内存碎片的存在，有可能得不到分配。</p>\n<h5 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h5><p>把堆等分成两块区域 A 和 B， 区域 A 负责分配对象， 区域 B 不非陪，对区域 A 使用标记清楚算法把存活的对象标记出来，然后把区域 A 中存活的对象都复制到 B 区域（同时将存活的对象都一次紧邻排列），最后把 A 区域对象全部清理掉释放出空间。</p>\n<p><strong>问题：</strong></p>\n<p>比如给堆分配了 500M 内存，结果只有 250M 可用 ，空间平白无故减少了一半。另外每此回收都要把存活的对象移动到另外一般，效率很低下。</p>\n<h5 id=\"标记整理法\"><a href=\"#标记整理法\" class=\"headerlink\" title=\"标记整理法\"></a>标记整理法</h5><p>步骤：</p>\n<ol>\n<li>先根据可达性算法 <strong>标记</strong> 出相应的可回收对象</li>\n<li>对可回收对象进行回收</li>\n<li>将所有存活对象都往一端移动，紧邻排列。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>对于 Java 程序员来说，在虚拟机的自动内存管理机制的帮助下，不再需要为每一个 new 操作区写配对的 <code>delete/free</code> 代码，而且不容易出现内存泄漏和内存移除问题，看起来一切由虚拟机管理内存一切都很美好。不过也正是 Java 程序员把内存控制的权力交给了 Java 虚拟机，一旦出现内存泄漏和溢出的问题，如果不了解续集及是怎么使用内存的，排查问题就很艰难。<br>","more":"</p>\n<h2 id=\"运行时数据区域\"><a href=\"#运行时数据区域\" class=\"headerlink\" title=\"运行时数据区域\"></a>运行时数据区域</h2><p><img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/java_runtime_data_area.png?raw=true\" alt=\"java runtime\"></p>\n<h3 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h3><p>程序计数器是一块较小的内存空间，作用是当前线程锁执行的字节码的行号指示器。</p>\n<p>由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现，再任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）知乎执行一条线程中的指令，因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间的计数器互不影响，独立存储。</p>\n<p>此区域是唯一一个 Java 虚拟机规范中没有任何 <strong>OutOfMemoryError</strong> 情况的区域</p>\n<h3 id=\"Java-虚拟机栈\"><a href=\"#Java-虚拟机栈\" class=\"headerlink\" title=\"Java 虚拟机栈\"></a>Java 虚拟机栈</h3><p>Java 虚拟机栈也是线程私有的，生命周期与线程相同。虚拟机描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作站、动态链接、方法处口等信息。</p>\n<p>每一个方法被调用直到执行完成的过程，就对应一个栈帧再虚拟机栈中从入栈到出栈的过程。</p>\n<p><strong>局部变量表</strong> 存放了编译器可知的各种基本数据类型（boolean, byte, char, short, int, float, long, double），对象引用(Reference类型)。</p>\n<p><strong>StackOverflowError</strong>： 如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出 <code>StackOverflowError</code> 异常</p>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><p>本地方法栈与虚拟机栈锁发挥的作用时相似的，其区别是虚拟机栈为虚拟机执行 Java 方法服务。而本地方法栈则是为虚拟机使用到的 Navite 方法服务。</p>\n<h3 id=\"Java-堆\"><a href=\"#Java-堆\" class=\"headerlink\" title=\"Java 堆\"></a>Java 堆</h3><p>是 Java 虚拟机所管理的内存中最大的一块。Java 堆被所有线程共享的一块内存区域，再虚拟机启动的时候创建。<strong>此区域唯一的目的就是存放对象实例</strong>，几乎所有的对象实例都再这里分配内存。</p>\n<p>Java 堆是垃圾回收器管理的主要区域，因此很多时候也被称做 GC 堆，从内存回收角度看，由于现在收集器基本都是采用 <strong>分代收集算法</strong> ，所以 Java 堆中还可以细分为： 新生代和老生代</p>\n<p>如果从内存分配角度看，线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区</p>\n<h3 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a><strong>方法区</strong></h3><p>方法区与 Java 堆一样，是哥哥线程共享的内存区域，<strong>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译的代码等数据</strong>。</p>\n<h3 id=\"运行时常量池\"><a href=\"#运行时常量池\" class=\"headerlink\" title=\"运行时常量池\"></a><strong>运行时常量池</strong></h3><p>运行时常量池是方法去的一部分 ，用于存放编译器申城的各种字面量和符号引用，这部分内容在类加载后存放到方法区的运行时常量池中。</p>\n<h2 id=\"垃圾回收\"><a href=\"#垃圾回收\" class=\"headerlink\" title=\"垃圾回收\"></a>垃圾回收</h2><p><strong>GC</strong> 真正让程序员的生产力得到了释放，但是程序员很难感知到它的存在。在大多数情况下不是很需要关心 GC ，不过如果设计到一些性能优化，问题排查的时候，深入地了解 GC 还是有必要的。</p>\n<h3 id=\"Java-内存区域\"><a href=\"#Java-内存区域\" class=\"headerlink\" title=\"Java 内存区域\"></a>Java 内存区域</h3><ul>\n<li>虚拟机栈：表述的是方法执行时的内存模型，线程私有化，生命周期和线程相同，每个方法被执行的同时都会创建栈帧，主要保存执行方法时的具不变量表、操作数栈、动态链接和方法返回地址等信息。方法执行时入栈，执行完成出栈，出栈就相当于清空了数据，入栈出栈的实际很明确，<strong>这块区域不需要进行 GC</strong></li>\n<li>本地方法栈：与虚拟机栈类似，主要在于虚拟机栈为虚拟机执行Java方法是服务，本地方法栈为虚拟机执行本地方法时服务。<strong>不需要进行 GC</strong></li>\n<li>程序计数器：线程独有，可以看作时当前线程执行的字节码行号。<strong>不需要进行 GC</strong></li>\n<li>本地内存：线程共享区域，本地内存；主要存储类的信息、长廊、静态变量、即使编译器编译后代码，这部分由于时在堆中实现的，受 GC 管理。Java 8 以后，这个区域也不需要GC</li>\n<li>堆：对象实例和水族都是在堆上分配的， GC 也主要堆这两类数据进行回收</li>\n</ul>\n<h4 id=\"回收算法\"><a href=\"#回收算法\" class=\"headerlink\" title=\"回收算法\"></a>回收算法</h4><h5 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h5><p>最容易想到的一种方式，就是对象被引用一次，再它的头上就加一次引用次数，如果没有被引用（引用次数为0），则此对象可回收。但这种方式存在一个问题：<strong>循环引用</strong></p>\n<pre><code class=\"java\">public class Test {\n    Test instance;\n    public Test(String name){}\n\n    public static void main(String[] args) {\n        // first\n        A a = new Test(&quot;a&quot;);\n        B b = new Test(&quot;b&quot;);\n        //second\n        a.instance = b;\n        b.instance = a;\n        //third\n        a = null;\n        b = null;\n    }\n}\n</code></pre>\n<p>按照上面的步骤，虽然 a, b 都被置为 null, 但是由于之前他们指向的对象相互引用（引用计数都为1），所以无法收回，也证是无法解决循环引用的问题，现代虚拟机一抛弃这种方法。</p>\n<h5 id=\"可达性算法\"><a href=\"#可达性算法\" class=\"headerlink\" title=\"可达性算法\"></a>可达性算法</h5><p>以一系列叫做 <strong>GC Root</strong> 的对象为起点出发，引出他们指向的下一个节点，再以下个节点为起点，引出此节点的下一个节点。。。（通过 GC Root 传承的一条线就叫引用链），直到所有的节点都遍历完毕，如果相关对象不再任意一个以 GC Root 为起点的引用链上，则这个对象会被判定为垃圾，进行回收。</p>\n<p>但是，一个对象的 <code>finalize</code> 方法给了对象一次垂死挣扎的机会，当对象不可达时，发生 GC 时，会先判断对象是否执行了 <code>finalize</code> 方法，如果未执行，则会先执行 <code>finalize</code> 方法，我们可以再此方法里将当前对象和 GC Root 关联，这样执行 <code>finalize</code> 之后，GC 会再次判断对象是否可达，如果不可达，就回收，可达则不回收。</p>\n<p><strong>注意：</strong> <code>finalize</code> 方法只会执行一次，如果第一次执行 <code>finalize</code> 方法，子对象变成了可达，确定不会回收，但如果对象再次被 GC 则会忽略 <code>finalize</code> 方法，对象会被回收。</p>\n<p><strong>GC Root</strong></p>\n<p>那么，什么样的对象可以作为 GC Root 呢</p>\n<ol>\n<li><p>虚拟机栈（栈帧中的本地变量）中的引用对象</p>\n</li>\n<li><p>方法区中类静态属性引用的对象</p>\n</li>\n<li><p>方法区中常量引用的对象</p>\n</li>\n<li><p>本地方法栈中 JNI 引用的对象</p>\n</li>\n</ol>\n<p><strong>虚拟机栈中的对象</strong></p>\n<pre><code class=\"java\">public class Test {\n    public static void main(String[] args) {\n        Test a = new Test();\n        a = null;\n    }\n}\n</code></pre>\n<p>a 是栈帧中的本地变量，当 a = null 时，由于此时 a  充当了 GC Root 的作用， a 与原来指向的实例 <code>new Test()</code> 断开连接，所以对象会被回收。</p>\n<p><strong>方法区中类静态属性引用的对象</strong></p>\n<pre><code class=\"java\">public class Test {\n    public static Test instance;\n    public static void main(String[] args) {\n        Test a = new Test();\n        a.instance = new Test();\n        a = null;\n    }\n}\n</code></pre>\n<p>当栈帧中的本地变量  <code>a = null</code> 时，由于 a 原来指向的对下个与 GC  Root（变量 instance）断开了连接，所以 a 原来的对象会被回收，而由于我们给 <code>instance</code> 赋值了变量的引用， <code>instance</code> 在此时是类静态属性引用，充当了 GC Root 的作用，它指向的对象依然存活。</p>\n<p><strong>方法区中常量引用的对象</strong></p>\n<pre><code class=\"java\">public class Test {\n    public static final Test instance = new Test();\n    public static void main(String[] args) {\n        Test a = new Test();\n        a = null;\n    }\n}\n</code></pre>\n<p>常量 <code>instance</code> 指向的对象并不会因为 a 指向的对象被回收而回收</p>\n<p><strong>本地方法栈中的 JNI 引用的对象</strong></p>\n<blockquote>\n<p>所谓本地方法就是一个 java 调用非 java 代码的接口，该方法并非 java 实现的，可能是 C 或 Python 等其他语言。Java 通过 JNI 来调用本地方法，而本地方法是以库文件的形式存放的。</p>\n</blockquote>\n<p>当调用 Java 方法时，虚拟机会创建一个栈帧并压入 Java 栈，而当它调用的是本地方法时，虚拟机会保持 Java 不变，不会再 Java 栈中压入新的帧，虚拟机只是简单的动态连接并直接调用指定的本地方法。</p>\n<h5 id=\"标记清除算法\"><a href=\"#标记清除算法\" class=\"headerlink\" title=\"标记清除算法\"></a>标记清除算法</h5><p><strong>步骤</strong>：</p>\n<ol>\n<li>先根据可达性算法 <strong>标记</strong> 出相应的可回收对象</li>\n<li>对可回收对象进行回收</li>\n</ol>\n<p>操作起来很简单，也不需要做数据移动的操作。但是却存在一个问题 –&gt; <strong>内存碎片</strong></p>\n<p>假如我们想在内存中分配一块需要连续内存占用的 4M  或 6M 的内存区域，由于内存碎片的存在，有可能得不到分配。</p>\n<h5 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h5><p>把堆等分成两块区域 A 和 B， 区域 A 负责分配对象， 区域 B 不非陪，对区域 A 使用标记清楚算法把存活的对象标记出来，然后把区域 A 中存活的对象都复制到 B 区域（同时将存活的对象都一次紧邻排列），最后把 A 区域对象全部清理掉释放出空间。</p>\n<p><strong>问题：</strong></p>\n<p>比如给堆分配了 500M 内存，结果只有 250M 可用 ，空间平白无故减少了一半。另外每此回收都要把存活的对象移动到另外一般，效率很低下。</p>\n<h5 id=\"标记整理法\"><a href=\"#标记整理法\" class=\"headerlink\" title=\"标记整理法\"></a>标记整理法</h5><p>步骤：</p>\n<ol>\n<li>先根据可达性算法 <strong>标记</strong> 出相应的可回收对象</li>\n<li>对可回收对象进行回收</li>\n<li>将所有存活对象都往一端移动，紧邻排列。</li>\n</ol>"},{"title":"Java Reference","date":"2019-08-09T13:54:08.000Z","_content":"\n\n\n## Reference 引用\n\n继承自 Object， 有 SoftReference, WeakReference, PhantomReference 三个直接子类。\n\n| 名称                         | 特点                                             |\n| ---------------------------- | ------------------------------------------------ |\n| StrongReferenceSoftReference | 只要引用链不断开，不会被回收                     |\n| SoftReference                | 直到虚拟机内存不足时垃圾回收才回收此堆内存空间。 |\n| WeakReference                | 没有任何强引用指向弱引用指向的对象               |\n| PhantomReference             | 任何时候都可以被垃圾回收                         |\n\n<!-- more-->\n\n三个子类的构造方法中涉及到 ReferenceQueue 和 Referent：\n\n* Referent： 被引用对象\n* ReferenceQueue：当引用（软引用、弱引用、虚引用）的 Referent 被回收后，该引用（软引用、弱引用、虚引用）会被 enqueue 到这个 ReferenceQueue 中。\n\n\n\n```java\npublic class ReferenceTest{\n    public static void main(String[] args) {\n        \n    }\n    \n    static class Person　{\n        private String name;\n        private String getName(){\n            return name;\n        }\n        private void setName(String name) {\n            this.name = name;\n        }\n        \n        @Override\n        protected void finalize() throws Throwable {\n            super.finalize();\n            System.out.println(\"in Person finalize\");\n        }\n    }\n}\n\n```\n\n\n\n<!-- more -->\n\n\n\n## StrongReference 强引用\n\nJava 中使用的最多，普通的引用 `Object obj = new Object();  Person p = new Person();` 都属于`强引用` \n\n强引用本身存储在栈中，new 出来的对象存储在堆中。栈中保存的引用指向堆中对象的地址。\n\n一般情况下，当引用不在指向堆中对象的地址时（person = null） GC collector 就开始考虑对此内存（堆中的对象）进行回收。\n\n\n\n```Java\nPerson p = new Person();\n```\n\nperson 就是一个强引用，强引用不会被 GC，即使内存不够抛出 OOM 时也不会被回收。\n\n\n\n## SoftReference 软引用\n\n软引用普通使用形式：\n\n```java\nPerson p = new Person();\nSoftReference<Person> sr = new SoftReference<Person>(person);\n```\n\n强引用 person 作为参数，创建了一个软引用对象 sr, 下面是例子：\n\n```java\nprivate static void testSofeReference(){\n    // 创建强引用对象\n    Person person = new Person();\n    System.out.println(\"person 对象为\" + person);\n    \n    // 创建软引用对象\n    SoftReference<Person> sr = new SoftReference<Person>(person);\n    person = null; // 之前 new 出的 Person 对象不会立即被回收，除非 JVM 需要内存(OOM 之前)\n    if(sr.get() == null) {\n        System.out.println(\"person 对象进入 GC 流程\");\n    } else {\n        System.out.println(\"person 对象尚未被回收\" + sr.get());\n    }\n    \n    System.gc();\n    \n    if(sr.get() == null){\n        System.out.println(\"person 对象进入 GC 流程\");\n    } else {\n        System.out.println(\"person 对象尚未被回收\" + sr.get());\n    }\n}\n\n```\n\n执行上面的例子：\n\n```\nperson 对象为 com.example.ReferenceTest$Person@522d9d8c\nperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c\nperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c\n```\n\n* 当执行 person = null 后，堆内存的 Person 对象不再有任何强引用指向它，但此时还存在 sr 引用的对象指向 Person 对象。此时调用 sr.get() 方法，返回 Person 对象，即之前堆中的强引用对象了。我们可以合理猜测GC collector 很有可能尚未进行垃圾回收，所以此时 sr.get() 方法返回不为空。\n* 我们继续执行 `System.gc()` 强制进行垃圾回收，打印结果可以看到， sr.get() 返回依然不为空，说明 Person 对象依旧没有被回收。\n\n\n\n**软引用所指向的对象要进行回收，需要满足两个条件：**\n\n1. 没有任何强引用指向软引用指向的对象（内存中的 Person 对象）\n2.  JVM 需要内存时，即在抛出 OOM 之前\n\n**总结：** SoftReference 变相延长了其只是对象占据堆内存的时间，直到虚拟机内存不足时垃圾回收才回收此堆内存空间。\n\n\n\n**软引用还可以和一个 ReferenceQueue 一起使用，** 当 SoftReference 的 Referent 被回收以后，这个 SoftReference 会被自动 enqueue 到这个 ReferenctQueue 中。\n\n```java\nprivate static void testSoftReferenceWithQueue(){\n    Person person = new Person();\n    System.out.println(\"person 对象为：\" + person);\n    \n    ReferenceQueue<Person> queue = new ReferenceQueue<>();\n    SoftReference<Person> sr = new SoftReference<>(person, queue);\n    \n    person = null; // 之前 new 出的 Person 对象不会立即被回收，除非 JVM 需要内存 （OOM 前）\n    if(sr.get() == null) {\n        System.out.println(\"person 对象进入 GC 流程\");\n    } else {\n        System.out.println(\"person 对象尚未被回收\" + sr.get());\n    }\n    \n    System.out.println(\"加入 ReferenceQueue 的对象为：\" + queue.poll());\n    \n    System.gc();\n    \n    if(sr.get() == null) {\n        System.out.println(\"person 对象进入 GC 流程\");\n    } else {\n        System.out.println(\"person 对象尚未被回收\" + sr.get());\n    }\n    \n    System.out.println(\"加入 ReferenceQueue 的对象为： \" + queue.poll());\n}\n```\n\n执行上述例子，结果如下：\n\n```\nperson 对象为 com.example.ReferenceTest$Person@522d9d8c\nperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c\n加入 ReferenceQueue 的对象为 null\nperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c\n加入 ReferenceQueue 的对象为 null\n```\n\n**注意：** 当 SoftReference 或 WeakReference 的 get() 方法返回 null 时，仅表明其指示的对象已经进入垃圾回收流程，此时对象不一定已经被垃圾回收。\n\n而只有确认被垃圾回收后，如果有 ReferenceQueue ，其引用才会被放置于 ReferenceQueue 中。\n\n\n\n## WeakReference 弱引用\n\n弱引用的一般使用形式：\n\n```Java\nprivate static void testWeakReference(){\n    Person person = new Person();\n    System.out.println(\"person 对象为： \" + person);\n    \n    WeakReference<Person> wr = new WeakReference<>(person);\n    person = null; // 被 GC 后，之前 new 出的 Person 对象会立即被回收，进入 GC 流程。\n    if (wr.get() == null) {\n        System.out.println(\"person 对象进入 GC 流程\");\n    } else {\n        System.out.println(\"person 对象尚未被回收\" + wr.get());\n    }\n    \n    System.gc();\n    \n    if (wr.get() == null) {\n        System.out.println(\"person 对象进入 GC 流程\");\n    } else {\n        System.out.println(\"person 对象尚未被回收\" + wr.get());\n    }\n}\n```\n\n执行结果为：\n\n```\nperson 对象为 com.example.ReferenceTest$Person@522d9d8c\nperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c\nperson 对象进入 GC 流程\nin Person finalize\n```\n\n* 当执行 `person = null` 后，堆内存的  Person 对象不再有任何引用指向它，但此时还存在 wr 引用的对象指向 Person 对象。\n\n  此时调用 `wr.get()` 方法，返回 Person 对象，即之前堆中的强引用对象，我们可以合理猜测 GC collector 很有可能尚未进行垃圾回收，所以此时 `wr.get()` 方法返回不为空。\n\n* 继续执行 `System.gc()` 强制执行垃圾回收，打印结果可以看到，`wr.get()` 返回为空 “person 对象进入 GC 流程” ，且执行了静态内部类中的 finalize 方法。说明 Person 对象被回收，进入垃圾回收流程。\n\n\n\n**弱引用所指向的对象要进行回收，只需要满足条件：**\n\n​\t没有任何强引用指向弱引用指向的对象（内存中的 Person 对象）\n\n\n\n**总结：**\n\n​\tWeakReference 不改变原有的强引用独享的垃圾回收机制，一旦其指示对象没有任何强引用对象时，此对象即进入正常的垃圾回收流程。\n\n\n\n**其主要使用场景见于：** \n\n​\t当前已有强引用指向强引用对象，此时由于业务需要，需要增加对此对象的引用，同时又不希望改变此引用的垃圾回收机制，此时 `WeakReference` 正好符合需求，常见于一些与生命周期的场景中，比如 Activity 中的 Handler 的使用，为了防止内存泄露需要用到弱引用。\n\n\n\n与 SoftReference 一样，可以同 ReferenceQueue 一起使用。当 WeakReference 的 Referent 被回收以后，这个 WeakReference 会被自动 enqueue 到这个 ReferenceQueue 中。\n\n```java\nprivate static void testWeakReferenceWithQueue () {\n    Person person = new Person();\n    System.out.println(\"person 对象为 \" + person);\n    \n    ReferenceQueue<Person> queue = new ReferenceQueue<>();\n    WeakReference<Person> wr = new WeakReference<>(person, queue);\n    System.out.println(\"wr 对象为 \" + wr);\n    \n    if (wr.get() == null) {\n        System.out.println(\"person 对象进入 GC 流程\");\n    } else {\n        System.out.println(\"person 对象尚未被回收\" + wr.get());\n    }\n    \n    System.out.println(\"Whether or not this reference has been enqueued:\" + wr.isEnqueued());\n    System.out.println(\"Queue item: \" + queue.pull());\n    \n    System.gc();\n    \n    if (wr.get() == null) {// 仅是表名指示的对象已经进入垃圾回收流程，此时对象不一定已经被垃圾回收，只有确认被垃圾回收后，如果有 ReferenceQueue ，其引用才会被放置于 ReferenceQueue 中。\n        System.out.println(\"person 对象进入 GC 流程\");\n    } else {\n        System.out.println(\"person 对象尚未被回收\" + wr.get());\n    }\n    \n    try {\n        // 确保垃圾回收线程能够执行\n        Thread.sleep(1);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n\n    System.out.println(\"Whether or not this reference has been enqueued: \" + wr.isEnqueued());\n    System.out.println(\"queue item: \" + queue.poll());\n}\n```\n\n\n\n**执行结果：**\n\n```\nperson 对象为 com.example.ReferenceTEst$Person@522d9d8c\nwr 对象为 java.lang.ref.WeakReference@603828d2\nperson 对象尚未被回收 com.example.ReferenceTEst$Person@522d9d8c\nWhether or not this reference has been enqueued: false\nqueue item: null\nperson 对象进入回收流程\nin Person finalize\nWhether or not this reference has been enqueued: true\nqueue item: java.lang.ref.WeakReference@603828d2\n```\n\n\n\n从第二行到最后行可以看出， person 进入 GC 流程后，wr 被加入到 queue 中。\n\n**注意：**\n\n​\t 当 SoftReference 或者 WeakReference 的 get() 方法返回 null 时，仅表示其指示对象已经进入垃圾回收流程，此时对象不一定已经被垃圾回收。\n\n​\t而只有确认被垃圾回收后，如果有 ReferenceQueue， 其引用才会被放置于 ReferenceQueue 中。\n\n\n\n## PhantomReference 虚引用\n\n虚引用源码：\n\n```java\npackage java.lang.ref;\n\nimport java.lang.ref.Reference;\nimport java.lang.ref.ReferenceQueue;\n\npublic class PhantomReference<T> extends Reference<T> {\n    public T get(){\n        return null;\n    }\n    \n    public PhantomReference(T var1, ReferenceQueue<? super T> var2) {\n        super.(var1, var2);\n    }\n}\n```\n\n\n\n* PhantomReference 只有一个构造函数 `PhantomReference(T referenct, ReferenceQueue<? super T> q) `  因此，PhantomReference 使用必须结合 ReferenceQueue；\n* 不管有无强引用指向 PhantomReference 的指示对象， PhantomReference 的 get() 方法返回结果都是 null\n\n举例：\n\n```java\nprivate static void testPhantomReference() {\n    Person person = new Person();\n    System.out.println(\"person 对象为\" + person);\n    \n    ReferenceQueue<Person> queue = new ReferenceQueue<>();\n    PhantomReference<Person> pr = new PhantomReference<>(person, queue);\n    \n    System.out.println(\"pr 对象为\" + pr);\n    System.out.println(\"pr.get() = \" + pr.get());\n    \n    person = null;\n    \n    System.gc();\n    \n    try{\n        // 确保垃圾回收线程执行\n        Thread.sleep(1);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    \n    System.out.println(\"queue item: \" + queue.poll());\n}\n```\n\n**执行结果：**\n\n```\nperson 对象为 com.example.ReferenceTEst$Person@522d9d8c\npr 对象为 java.lang.ref.PhantomReference@60e35b53\npr.get() = null\nin Person finalize\nqueue ite: java.lang.ref.PhantomReference@60e35b53\n```\n\n\n\n**总结：**\n\n​\t与 WeakReference 一样，不改变原有的强引用对象的垃圾回收机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可以被垃圾回收。虚引用主要用来跟踪对象被垃圾回收后的活动（监听并采取必要的行动）\n\n\n\n**用途：**\n\n​\t当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。\n\n​\t程序可以通过判断医用队列中是否已经加入虚引用来了解被引用的对象是否将要被垃圾回收。\n\n​\t程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前才去必要的行动。\n\n","source":"_posts/Java/Java 各引用之间的区别.md","raw":"---\ntitle: Java Reference\ndate: 2019-08-09 21:54:08\ntags: Java\n---\n\n\n\n## Reference 引用\n\n继承自 Object， 有 SoftReference, WeakReference, PhantomReference 三个直接子类。\n\n| 名称                         | 特点                                             |\n| ---------------------------- | ------------------------------------------------ |\n| StrongReferenceSoftReference | 只要引用链不断开，不会被回收                     |\n| SoftReference                | 直到虚拟机内存不足时垃圾回收才回收此堆内存空间。 |\n| WeakReference                | 没有任何强引用指向弱引用指向的对象               |\n| PhantomReference             | 任何时候都可以被垃圾回收                         |\n\n<!-- more-->\n\n三个子类的构造方法中涉及到 ReferenceQueue 和 Referent：\n\n* Referent： 被引用对象\n* ReferenceQueue：当引用（软引用、弱引用、虚引用）的 Referent 被回收后，该引用（软引用、弱引用、虚引用）会被 enqueue 到这个 ReferenceQueue 中。\n\n\n\n```java\npublic class ReferenceTest{\n    public static void main(String[] args) {\n        \n    }\n    \n    static class Person　{\n        private String name;\n        private String getName(){\n            return name;\n        }\n        private void setName(String name) {\n            this.name = name;\n        }\n        \n        @Override\n        protected void finalize() throws Throwable {\n            super.finalize();\n            System.out.println(\"in Person finalize\");\n        }\n    }\n}\n\n```\n\n\n\n<!-- more -->\n\n\n\n## StrongReference 强引用\n\nJava 中使用的最多，普通的引用 `Object obj = new Object();  Person p = new Person();` 都属于`强引用` \n\n强引用本身存储在栈中，new 出来的对象存储在堆中。栈中保存的引用指向堆中对象的地址。\n\n一般情况下，当引用不在指向堆中对象的地址时（person = null） GC collector 就开始考虑对此内存（堆中的对象）进行回收。\n\n\n\n```Java\nPerson p = new Person();\n```\n\nperson 就是一个强引用，强引用不会被 GC，即使内存不够抛出 OOM 时也不会被回收。\n\n\n\n## SoftReference 软引用\n\n软引用普通使用形式：\n\n```java\nPerson p = new Person();\nSoftReference<Person> sr = new SoftReference<Person>(person);\n```\n\n强引用 person 作为参数，创建了一个软引用对象 sr, 下面是例子：\n\n```java\nprivate static void testSofeReference(){\n    // 创建强引用对象\n    Person person = new Person();\n    System.out.println(\"person 对象为\" + person);\n    \n    // 创建软引用对象\n    SoftReference<Person> sr = new SoftReference<Person>(person);\n    person = null; // 之前 new 出的 Person 对象不会立即被回收，除非 JVM 需要内存(OOM 之前)\n    if(sr.get() == null) {\n        System.out.println(\"person 对象进入 GC 流程\");\n    } else {\n        System.out.println(\"person 对象尚未被回收\" + sr.get());\n    }\n    \n    System.gc();\n    \n    if(sr.get() == null){\n        System.out.println(\"person 对象进入 GC 流程\");\n    } else {\n        System.out.println(\"person 对象尚未被回收\" + sr.get());\n    }\n}\n\n```\n\n执行上面的例子：\n\n```\nperson 对象为 com.example.ReferenceTest$Person@522d9d8c\nperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c\nperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c\n```\n\n* 当执行 person = null 后，堆内存的 Person 对象不再有任何强引用指向它，但此时还存在 sr 引用的对象指向 Person 对象。此时调用 sr.get() 方法，返回 Person 对象，即之前堆中的强引用对象了。我们可以合理猜测GC collector 很有可能尚未进行垃圾回收，所以此时 sr.get() 方法返回不为空。\n* 我们继续执行 `System.gc()` 强制进行垃圾回收，打印结果可以看到， sr.get() 返回依然不为空，说明 Person 对象依旧没有被回收。\n\n\n\n**软引用所指向的对象要进行回收，需要满足两个条件：**\n\n1. 没有任何强引用指向软引用指向的对象（内存中的 Person 对象）\n2.  JVM 需要内存时，即在抛出 OOM 之前\n\n**总结：** SoftReference 变相延长了其只是对象占据堆内存的时间，直到虚拟机内存不足时垃圾回收才回收此堆内存空间。\n\n\n\n**软引用还可以和一个 ReferenceQueue 一起使用，** 当 SoftReference 的 Referent 被回收以后，这个 SoftReference 会被自动 enqueue 到这个 ReferenctQueue 中。\n\n```java\nprivate static void testSoftReferenceWithQueue(){\n    Person person = new Person();\n    System.out.println(\"person 对象为：\" + person);\n    \n    ReferenceQueue<Person> queue = new ReferenceQueue<>();\n    SoftReference<Person> sr = new SoftReference<>(person, queue);\n    \n    person = null; // 之前 new 出的 Person 对象不会立即被回收，除非 JVM 需要内存 （OOM 前）\n    if(sr.get() == null) {\n        System.out.println(\"person 对象进入 GC 流程\");\n    } else {\n        System.out.println(\"person 对象尚未被回收\" + sr.get());\n    }\n    \n    System.out.println(\"加入 ReferenceQueue 的对象为：\" + queue.poll());\n    \n    System.gc();\n    \n    if(sr.get() == null) {\n        System.out.println(\"person 对象进入 GC 流程\");\n    } else {\n        System.out.println(\"person 对象尚未被回收\" + sr.get());\n    }\n    \n    System.out.println(\"加入 ReferenceQueue 的对象为： \" + queue.poll());\n}\n```\n\n执行上述例子，结果如下：\n\n```\nperson 对象为 com.example.ReferenceTest$Person@522d9d8c\nperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c\n加入 ReferenceQueue 的对象为 null\nperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c\n加入 ReferenceQueue 的对象为 null\n```\n\n**注意：** 当 SoftReference 或 WeakReference 的 get() 方法返回 null 时，仅表明其指示的对象已经进入垃圾回收流程，此时对象不一定已经被垃圾回收。\n\n而只有确认被垃圾回收后，如果有 ReferenceQueue ，其引用才会被放置于 ReferenceQueue 中。\n\n\n\n## WeakReference 弱引用\n\n弱引用的一般使用形式：\n\n```Java\nprivate static void testWeakReference(){\n    Person person = new Person();\n    System.out.println(\"person 对象为： \" + person);\n    \n    WeakReference<Person> wr = new WeakReference<>(person);\n    person = null; // 被 GC 后，之前 new 出的 Person 对象会立即被回收，进入 GC 流程。\n    if (wr.get() == null) {\n        System.out.println(\"person 对象进入 GC 流程\");\n    } else {\n        System.out.println(\"person 对象尚未被回收\" + wr.get());\n    }\n    \n    System.gc();\n    \n    if (wr.get() == null) {\n        System.out.println(\"person 对象进入 GC 流程\");\n    } else {\n        System.out.println(\"person 对象尚未被回收\" + wr.get());\n    }\n}\n```\n\n执行结果为：\n\n```\nperson 对象为 com.example.ReferenceTest$Person@522d9d8c\nperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c\nperson 对象进入 GC 流程\nin Person finalize\n```\n\n* 当执行 `person = null` 后，堆内存的  Person 对象不再有任何引用指向它，但此时还存在 wr 引用的对象指向 Person 对象。\n\n  此时调用 `wr.get()` 方法，返回 Person 对象，即之前堆中的强引用对象，我们可以合理猜测 GC collector 很有可能尚未进行垃圾回收，所以此时 `wr.get()` 方法返回不为空。\n\n* 继续执行 `System.gc()` 强制执行垃圾回收，打印结果可以看到，`wr.get()` 返回为空 “person 对象进入 GC 流程” ，且执行了静态内部类中的 finalize 方法。说明 Person 对象被回收，进入垃圾回收流程。\n\n\n\n**弱引用所指向的对象要进行回收，只需要满足条件：**\n\n​\t没有任何强引用指向弱引用指向的对象（内存中的 Person 对象）\n\n\n\n**总结：**\n\n​\tWeakReference 不改变原有的强引用独享的垃圾回收机制，一旦其指示对象没有任何强引用对象时，此对象即进入正常的垃圾回收流程。\n\n\n\n**其主要使用场景见于：** \n\n​\t当前已有强引用指向强引用对象，此时由于业务需要，需要增加对此对象的引用，同时又不希望改变此引用的垃圾回收机制，此时 `WeakReference` 正好符合需求，常见于一些与生命周期的场景中，比如 Activity 中的 Handler 的使用，为了防止内存泄露需要用到弱引用。\n\n\n\n与 SoftReference 一样，可以同 ReferenceQueue 一起使用。当 WeakReference 的 Referent 被回收以后，这个 WeakReference 会被自动 enqueue 到这个 ReferenceQueue 中。\n\n```java\nprivate static void testWeakReferenceWithQueue () {\n    Person person = new Person();\n    System.out.println(\"person 对象为 \" + person);\n    \n    ReferenceQueue<Person> queue = new ReferenceQueue<>();\n    WeakReference<Person> wr = new WeakReference<>(person, queue);\n    System.out.println(\"wr 对象为 \" + wr);\n    \n    if (wr.get() == null) {\n        System.out.println(\"person 对象进入 GC 流程\");\n    } else {\n        System.out.println(\"person 对象尚未被回收\" + wr.get());\n    }\n    \n    System.out.println(\"Whether or not this reference has been enqueued:\" + wr.isEnqueued());\n    System.out.println(\"Queue item: \" + queue.pull());\n    \n    System.gc();\n    \n    if (wr.get() == null) {// 仅是表名指示的对象已经进入垃圾回收流程，此时对象不一定已经被垃圾回收，只有确认被垃圾回收后，如果有 ReferenceQueue ，其引用才会被放置于 ReferenceQueue 中。\n        System.out.println(\"person 对象进入 GC 流程\");\n    } else {\n        System.out.println(\"person 对象尚未被回收\" + wr.get());\n    }\n    \n    try {\n        // 确保垃圾回收线程能够执行\n        Thread.sleep(1);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n\n    System.out.println(\"Whether or not this reference has been enqueued: \" + wr.isEnqueued());\n    System.out.println(\"queue item: \" + queue.poll());\n}\n```\n\n\n\n**执行结果：**\n\n```\nperson 对象为 com.example.ReferenceTEst$Person@522d9d8c\nwr 对象为 java.lang.ref.WeakReference@603828d2\nperson 对象尚未被回收 com.example.ReferenceTEst$Person@522d9d8c\nWhether or not this reference has been enqueued: false\nqueue item: null\nperson 对象进入回收流程\nin Person finalize\nWhether or not this reference has been enqueued: true\nqueue item: java.lang.ref.WeakReference@603828d2\n```\n\n\n\n从第二行到最后行可以看出， person 进入 GC 流程后，wr 被加入到 queue 中。\n\n**注意：**\n\n​\t 当 SoftReference 或者 WeakReference 的 get() 方法返回 null 时，仅表示其指示对象已经进入垃圾回收流程，此时对象不一定已经被垃圾回收。\n\n​\t而只有确认被垃圾回收后，如果有 ReferenceQueue， 其引用才会被放置于 ReferenceQueue 中。\n\n\n\n## PhantomReference 虚引用\n\n虚引用源码：\n\n```java\npackage java.lang.ref;\n\nimport java.lang.ref.Reference;\nimport java.lang.ref.ReferenceQueue;\n\npublic class PhantomReference<T> extends Reference<T> {\n    public T get(){\n        return null;\n    }\n    \n    public PhantomReference(T var1, ReferenceQueue<? super T> var2) {\n        super.(var1, var2);\n    }\n}\n```\n\n\n\n* PhantomReference 只有一个构造函数 `PhantomReference(T referenct, ReferenceQueue<? super T> q) `  因此，PhantomReference 使用必须结合 ReferenceQueue；\n* 不管有无强引用指向 PhantomReference 的指示对象， PhantomReference 的 get() 方法返回结果都是 null\n\n举例：\n\n```java\nprivate static void testPhantomReference() {\n    Person person = new Person();\n    System.out.println(\"person 对象为\" + person);\n    \n    ReferenceQueue<Person> queue = new ReferenceQueue<>();\n    PhantomReference<Person> pr = new PhantomReference<>(person, queue);\n    \n    System.out.println(\"pr 对象为\" + pr);\n    System.out.println(\"pr.get() = \" + pr.get());\n    \n    person = null;\n    \n    System.gc();\n    \n    try{\n        // 确保垃圾回收线程执行\n        Thread.sleep(1);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    \n    System.out.println(\"queue item: \" + queue.poll());\n}\n```\n\n**执行结果：**\n\n```\nperson 对象为 com.example.ReferenceTEst$Person@522d9d8c\npr 对象为 java.lang.ref.PhantomReference@60e35b53\npr.get() = null\nin Person finalize\nqueue ite: java.lang.ref.PhantomReference@60e35b53\n```\n\n\n\n**总结：**\n\n​\t与 WeakReference 一样，不改变原有的强引用对象的垃圾回收机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可以被垃圾回收。虚引用主要用来跟踪对象被垃圾回收后的活动（监听并采取必要的行动）\n\n\n\n**用途：**\n\n​\t当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。\n\n​\t程序可以通过判断医用队列中是否已经加入虚引用来了解被引用的对象是否将要被垃圾回收。\n\n​\t程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前才去必要的行动。\n\n","slug":"Java/Java 各引用之间的区别","published":1,"updated":"2021-01-29T16:04:05.903Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8es001gsz5qbxx4ydsp","content":"<h2 id=\"Reference-引用\"><a href=\"#Reference-引用\" class=\"headerlink\" title=\"Reference 引用\"></a>Reference 引用</h2><p>继承自 Object， 有 SoftReference, WeakReference, PhantomReference 三个直接子类。</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>StrongReferenceSoftReference</td>\n<td>只要引用链不断开，不会被回收</td>\n</tr>\n<tr>\n<td>SoftReference</td>\n<td>直到虚拟机内存不足时垃圾回收才回收此堆内存空间。</td>\n</tr>\n<tr>\n<td>WeakReference</td>\n<td>没有任何强引用指向弱引用指向的对象</td>\n</tr>\n<tr>\n<td>PhantomReference</td>\n<td>任何时候都可以被垃圾回收</td>\n</tr>\n</tbody>\n</table>\n<a id=\"more\"></a>\n<p>三个子类的构造方法中涉及到 ReferenceQueue 和 Referent：</p>\n<ul>\n<li>Referent： 被引用对象</li>\n<li>ReferenceQueue：当引用（软引用、弱引用、虚引用）的 Referent 被回收后，该引用（软引用、弱引用、虚引用）会被 enqueue 到这个 ReferenceQueue 中。</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ReferenceTest</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span>　<span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">private</span> String name<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">private</span> String <span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> name<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setName</span><span class=\"token punctuation\">(</span>String name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">finalize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Throwable <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">finalize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"in Person finalize\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<!-- more -->\n<h2 id=\"StrongReference-强引用\"><a href=\"#StrongReference-强引用\" class=\"headerlink\" title=\"StrongReference 强引用\"></a>StrongReference 强引用</h2><p>Java 中使用的最多，普通的引用 <code>Object obj = new Object();  Person p = new Person();</code> 都属于<code>强引用</code> </p>\n<p>强引用本身存储在栈中，new 出来的对象存储在堆中。栈中保存的引用指向堆中对象的地址。</p>\n<p>一般情况下，当引用不在指向堆中对象的地址时（person = null） GC collector 就开始考虑对此内存（堆中的对象）进行回收。</p>\n<pre class=\" language-Java\"><code class=\"language-Java\">Person p = new Person();\n</code></pre>\n<p>person 就是一个强引用，强引用不会被 GC，即使内存不够抛出 OOM 时也不会被回收。</p>\n<h2 id=\"SoftReference-软引用\"><a href=\"#SoftReference-软引用\" class=\"headerlink\" title=\"SoftReference 软引用\"></a>SoftReference 软引用</h2><p>软引用普通使用形式：</p>\n<pre class=\" language-java\"><code class=\"language-java\">Person p <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nSoftReference<span class=\"token operator\">&lt;</span>Person<span class=\"token operator\">></span> sr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SoftReference</span><span class=\"token operator\">&lt;</span>Person<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>强引用 person 作为参数，创建了一个软引用对象 sr, 下面是例子：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">testSofeReference</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 创建强引用对象</span>\n    Person person <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"person 对象为\"</span> <span class=\"token operator\">+</span> person<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 创建软引用对象</span>\n    SoftReference<span class=\"token operator\">&lt;</span>Person<span class=\"token operator\">></span> sr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SoftReference</span><span class=\"token operator\">&lt;</span>Person<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    person <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 之前 new 出的 Person 对象不会立即被回收，除非 JVM 需要内存(OOM 之前)</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>sr<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"person 对象进入 GC 流程\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"person 对象尚未被回收\"</span> <span class=\"token operator\">+</span> sr<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    System<span class=\"token punctuation\">.</span><span class=\"token function\">gc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>sr<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"person 对象进入 GC 流程\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"person 对象尚未被回收\"</span> <span class=\"token operator\">+</span> sr<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>执行上面的例子：</p>\n<pre><code>person 对象为 com.example.ReferenceTest$Person@522d9d8c\nperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c\nperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c\n</code></pre><ul>\n<li>当执行 person = null 后，堆内存的 Person 对象不再有任何强引用指向它，但此时还存在 sr 引用的对象指向 Person 对象。此时调用 sr.get() 方法，返回 Person 对象，即之前堆中的强引用对象了。我们可以合理猜测GC collector 很有可能尚未进行垃圾回收，所以此时 sr.get() 方法返回不为空。</li>\n<li>我们继续执行 <code>System.gc()</code> 强制进行垃圾回收，打印结果可以看到， sr.get() 返回依然不为空，说明 Person 对象依旧没有被回收。</li>\n</ul>\n<p><strong>软引用所指向的对象要进行回收，需要满足两个条件：</strong></p>\n<ol>\n<li>没有任何强引用指向软引用指向的对象（内存中的 Person 对象）</li>\n<li>JVM 需要内存时，即在抛出 OOM 之前</li>\n</ol>\n<p><strong>总结：</strong> SoftReference 变相延长了其只是对象占据堆内存的时间，直到虚拟机内存不足时垃圾回收才回收此堆内存空间。</p>\n<p><strong>软引用还可以和一个 ReferenceQueue 一起使用，</strong> 当 SoftReference 的 Referent 被回收以后，这个 SoftReference 会被自动 enqueue 到这个 ReferenctQueue 中。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">testSoftReferenceWithQueue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    Person person <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"person 对象为：\"</span> <span class=\"token operator\">+</span> person<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    ReferenceQueue<span class=\"token operator\">&lt;</span>Person<span class=\"token operator\">></span> queue <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReferenceQueue</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    SoftReference<span class=\"token operator\">&lt;</span>Person<span class=\"token operator\">></span> sr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SoftReference</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">,</span> queue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    person <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 之前 new 出的 Person 对象不会立即被回收，除非 JVM 需要内存 （OOM 前）</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>sr<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"person 对象进入 GC 流程\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"person 对象尚未被回收\"</span> <span class=\"token operator\">+</span> sr<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"加入 ReferenceQueue 的对象为：\"</span> <span class=\"token operator\">+</span> queue<span class=\"token punctuation\">.</span><span class=\"token function\">poll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    System<span class=\"token punctuation\">.</span><span class=\"token function\">gc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>sr<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"person 对象进入 GC 流程\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"person 对象尚未被回收\"</span> <span class=\"token operator\">+</span> sr<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"加入 ReferenceQueue 的对象为： \"</span> <span class=\"token operator\">+</span> queue<span class=\"token punctuation\">.</span><span class=\"token function\">poll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>执行上述例子，结果如下：</p>\n<pre><code>person 对象为 com.example.ReferenceTest$Person@522d9d8c\nperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c\n加入 ReferenceQueue 的对象为 null\nperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c\n加入 ReferenceQueue 的对象为 null\n</code></pre><p><strong>注意：</strong> 当 SoftReference 或 WeakReference 的 get() 方法返回 null 时，仅表明其指示的对象已经进入垃圾回收流程，此时对象不一定已经被垃圾回收。</p>\n<p>而只有确认被垃圾回收后，如果有 ReferenceQueue ，其引用才会被放置于 ReferenceQueue 中。</p>\n<h2 id=\"WeakReference-弱引用\"><a href=\"#WeakReference-弱引用\" class=\"headerlink\" title=\"WeakReference 弱引用\"></a>WeakReference 弱引用</h2><p>弱引用的一般使用形式：</p>\n<pre class=\" language-Java\"><code class=\"language-Java\">private static void testWeakReference(){\n    Person person = new Person();\n    System.out.println(\"person 对象为： \" + person);\n\n    WeakReference<Person> wr = new WeakReference<>(person);\n    person = null; // 被 GC 后，之前 new 出的 Person 对象会立即被回收，进入 GC 流程。\n    if (wr.get() == null) {\n        System.out.println(\"person 对象进入 GC 流程\");\n    } else {\n        System.out.println(\"person 对象尚未被回收\" + wr.get());\n    }\n\n    System.gc();\n\n    if (wr.get() == null) {\n        System.out.println(\"person 对象进入 GC 流程\");\n    } else {\n        System.out.println(\"person 对象尚未被回收\" + wr.get());\n    }\n}\n</code></pre>\n<p>执行结果为：</p>\n<pre><code>person 对象为 com.example.ReferenceTest$Person@522d9d8c\nperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c\nperson 对象进入 GC 流程\nin Person finalize\n</code></pre><ul>\n<li><p>当执行 <code>person = null</code> 后，堆内存的  Person 对象不再有任何引用指向它，但此时还存在 wr 引用的对象指向 Person 对象。</p>\n<p>此时调用 <code>wr.get()</code> 方法，返回 Person 对象，即之前堆中的强引用对象，我们可以合理猜测 GC collector 很有可能尚未进行垃圾回收，所以此时 <code>wr.get()</code> 方法返回不为空。</p>\n</li>\n<li><p>继续执行 <code>System.gc()</code> 强制执行垃圾回收，打印结果可以看到，<code>wr.get()</code> 返回为空 “person 对象进入 GC 流程” ，且执行了静态内部类中的 finalize 方法。说明 Person 对象被回收，进入垃圾回收流程。</p>\n</li>\n</ul>\n<p><strong>弱引用所指向的对象要进行回收，只需要满足条件：</strong></p>\n<p>​    没有任何强引用指向弱引用指向的对象（内存中的 Person 对象）</p>\n<p><strong>总结：</strong></p>\n<p>​    WeakReference 不改变原有的强引用独享的垃圾回收机制，一旦其指示对象没有任何强引用对象时，此对象即进入正常的垃圾回收流程。</p>\n<p><strong>其主要使用场景见于：</strong> </p>\n<p>​    当前已有强引用指向强引用对象，此时由于业务需要，需要增加对此对象的引用，同时又不希望改变此引用的垃圾回收机制，此时 <code>WeakReference</code> 正好符合需求，常见于一些与生命周期的场景中，比如 Activity 中的 Handler 的使用，为了防止内存泄露需要用到弱引用。</p>\n<p>与 SoftReference 一样，可以同 ReferenceQueue 一起使用。当 WeakReference 的 Referent 被回收以后，这个 WeakReference 会被自动 enqueue 到这个 ReferenceQueue 中。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">testWeakReferenceWithQueue</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Person person <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"person 对象为 \"</span> <span class=\"token operator\">+</span> person<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    ReferenceQueue<span class=\"token operator\">&lt;</span>Person<span class=\"token operator\">></span> queue <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReferenceQueue</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    WeakReference<span class=\"token operator\">&lt;</span>Person<span class=\"token operator\">></span> wr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WeakReference</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">,</span> queue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"wr 对象为 \"</span> <span class=\"token operator\">+</span> wr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>wr<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"person 对象进入 GC 流程\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"person 对象尚未被回收\"</span> <span class=\"token operator\">+</span> wr<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Whether or not this reference has been enqueued:\"</span> <span class=\"token operator\">+</span> wr<span class=\"token punctuation\">.</span><span class=\"token function\">isEnqueued</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Queue item: \"</span> <span class=\"token operator\">+</span> queue<span class=\"token punctuation\">.</span><span class=\"token function\">pull</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    System<span class=\"token punctuation\">.</span><span class=\"token function\">gc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>wr<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token comment\" spellcheck=\"true\">// 仅是表名指示的对象已经进入垃圾回收流程，此时对象不一定已经被垃圾回收，只有确认被垃圾回收后，如果有 ReferenceQueue ，其引用才会被放置于 ReferenceQueue 中。</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"person 对象进入 GC 流程\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"person 对象尚未被回收\"</span> <span class=\"token operator\">+</span> wr<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 确保垃圾回收线程能够执行</span>\n        Thread<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Whether or not this reference has been enqueued: \"</span> <span class=\"token operator\">+</span> wr<span class=\"token punctuation\">.</span><span class=\"token function\">isEnqueued</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"queue item: \"</span> <span class=\"token operator\">+</span> queue<span class=\"token punctuation\">.</span><span class=\"token function\">poll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>执行结果：</strong></p>\n<pre><code>person 对象为 com.example.ReferenceTEst$Person@522d9d8c\nwr 对象为 java.lang.ref.WeakReference@603828d2\nperson 对象尚未被回收 com.example.ReferenceTEst$Person@522d9d8c\nWhether or not this reference has been enqueued: false\nqueue item: null\nperson 对象进入回收流程\nin Person finalize\nWhether or not this reference has been enqueued: true\nqueue item: java.lang.ref.WeakReference@603828d2\n</code></pre><p>从第二行到最后行可以看出， person 进入 GC 流程后，wr 被加入到 queue 中。</p>\n<p><strong>注意：</strong></p>\n<p>​     当 SoftReference 或者 WeakReference 的 get() 方法返回 null 时，仅表示其指示对象已经进入垃圾回收流程，此时对象不一定已经被垃圾回收。</p>\n<p>​    而只有确认被垃圾回收后，如果有 ReferenceQueue， 其引用才会被放置于 ReferenceQueue 中。</p>\n<h2 id=\"PhantomReference-虚引用\"><a href=\"#PhantomReference-虚引用\" class=\"headerlink\" title=\"PhantomReference 虚引用\"></a>PhantomReference 虚引用</h2><p>虚引用源码：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>ref<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>ref<span class=\"token punctuation\">.</span>Reference<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>ref<span class=\"token punctuation\">.</span>ReferenceQueue<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">PhantomReference</span><span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Reference</span><span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> T <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> null<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">PhantomReference</span><span class=\"token punctuation\">(</span>T var1<span class=\"token punctuation\">,</span> ReferenceQueue<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> T<span class=\"token operator\">></span> var2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span>var1<span class=\"token punctuation\">,</span> var2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<ul>\n<li>PhantomReference 只有一个构造函数 <code>PhantomReference(T referenct, ReferenceQueue&lt;? super T&gt; q)</code>  因此，PhantomReference 使用必须结合 ReferenceQueue；</li>\n<li>不管有无强引用指向 PhantomReference 的指示对象， PhantomReference 的 get() 方法返回结果都是 null</li>\n</ul>\n<p>举例：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">testPhantomReference</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Person person <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"person 对象为\"</span> <span class=\"token operator\">+</span> person<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    ReferenceQueue<span class=\"token operator\">&lt;</span>Person<span class=\"token operator\">></span> queue <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReferenceQueue</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    PhantomReference<span class=\"token operator\">&lt;</span>Person<span class=\"token operator\">></span> pr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">PhantomReference</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">,</span> queue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"pr 对象为\"</span> <span class=\"token operator\">+</span> pr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"pr.get() = \"</span> <span class=\"token operator\">+</span> pr<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    person <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n\n    System<span class=\"token punctuation\">.</span><span class=\"token function\">gc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">try</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 确保垃圾回收线程执行</span>\n        Thread<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"queue item: \"</span> <span class=\"token operator\">+</span> queue<span class=\"token punctuation\">.</span><span class=\"token function\">poll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>执行结果：</strong></p>\n<pre><code>person 对象为 com.example.ReferenceTEst$Person@522d9d8c\npr 对象为 java.lang.ref.PhantomReference@60e35b53\npr.get() = null\nin Person finalize\nqueue ite: java.lang.ref.PhantomReference@60e35b53\n</code></pre><p><strong>总结：</strong></p>\n<p>​    与 WeakReference 一样，不改变原有的强引用对象的垃圾回收机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可以被垃圾回收。虚引用主要用来跟踪对象被垃圾回收后的活动（监听并采取必要的行动）</p>\n<p><strong>用途：</strong></p>\n<p>​    当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>\n<p>​    程序可以通过判断医用队列中是否已经加入虚引用来了解被引用的对象是否将要被垃圾回收。</p>\n<p>​    程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前才去必要的行动。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Reference-引用\"><a href=\"#Reference-引用\" class=\"headerlink\" title=\"Reference 引用\"></a>Reference 引用</h2><p>继承自 Object， 有 SoftReference, WeakReference, PhantomReference 三个直接子类。</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>StrongReferenceSoftReference</td>\n<td>只要引用链不断开，不会被回收</td>\n</tr>\n<tr>\n<td>SoftReference</td>\n<td>直到虚拟机内存不足时垃圾回收才回收此堆内存空间。</td>\n</tr>\n<tr>\n<td>WeakReference</td>\n<td>没有任何强引用指向弱引用指向的对象</td>\n</tr>\n<tr>\n<td>PhantomReference</td>\n<td>任何时候都可以被垃圾回收</td>\n</tr>\n</tbody>\n</table>","more":"<p>三个子类的构造方法中涉及到 ReferenceQueue 和 Referent：</p>\n<ul>\n<li>Referent： 被引用对象</li>\n<li>ReferenceQueue：当引用（软引用、弱引用、虚引用）的 Referent 被回收后，该引用（软引用、弱引用、虚引用）会被 enqueue 到这个 ReferenceQueue 中。</li>\n</ul>\n<pre><code class=\"java\">public class ReferenceTest{\n    public static void main(String[] args) {\n\n    }\n\n    static class Person　{\n        private String name;\n        private String getName(){\n            return name;\n        }\n        private void setName(String name) {\n            this.name = name;\n        }\n\n        @Override\n        protected void finalize() throws Throwable {\n            super.finalize();\n            System.out.println(&quot;in Person finalize&quot;);\n        }\n    }\n}\n\n</code></pre>\n<!-- more -->\n<h2 id=\"StrongReference-强引用\"><a href=\"#StrongReference-强引用\" class=\"headerlink\" title=\"StrongReference 强引用\"></a>StrongReference 强引用</h2><p>Java 中使用的最多，普通的引用 <code>Object obj = new Object();  Person p = new Person();</code> 都属于<code>强引用</code> </p>\n<p>强引用本身存储在栈中，new 出来的对象存储在堆中。栈中保存的引用指向堆中对象的地址。</p>\n<p>一般情况下，当引用不在指向堆中对象的地址时（person = null） GC collector 就开始考虑对此内存（堆中的对象）进行回收。</p>\n<pre><code class=\"Java\">Person p = new Person();\n</code></pre>\n<p>person 就是一个强引用，强引用不会被 GC，即使内存不够抛出 OOM 时也不会被回收。</p>\n<h2 id=\"SoftReference-软引用\"><a href=\"#SoftReference-软引用\" class=\"headerlink\" title=\"SoftReference 软引用\"></a>SoftReference 软引用</h2><p>软引用普通使用形式：</p>\n<pre><code class=\"java\">Person p = new Person();\nSoftReference&lt;Person&gt; sr = new SoftReference&lt;Person&gt;(person);\n</code></pre>\n<p>强引用 person 作为参数，创建了一个软引用对象 sr, 下面是例子：</p>\n<pre><code class=\"java\">private static void testSofeReference(){\n    // 创建强引用对象\n    Person person = new Person();\n    System.out.println(&quot;person 对象为&quot; + person);\n\n    // 创建软引用对象\n    SoftReference&lt;Person&gt; sr = new SoftReference&lt;Person&gt;(person);\n    person = null; // 之前 new 出的 Person 对象不会立即被回收，除非 JVM 需要内存(OOM 之前)\n    if(sr.get() == null) {\n        System.out.println(&quot;person 对象进入 GC 流程&quot;);\n    } else {\n        System.out.println(&quot;person 对象尚未被回收&quot; + sr.get());\n    }\n\n    System.gc();\n\n    if(sr.get() == null){\n        System.out.println(&quot;person 对象进入 GC 流程&quot;);\n    } else {\n        System.out.println(&quot;person 对象尚未被回收&quot; + sr.get());\n    }\n}\n\n</code></pre>\n<p>执行上面的例子：</p>\n<pre><code>person 对象为 com.example.ReferenceTest$Person@522d9d8c\nperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c\nperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c\n</code></pre><ul>\n<li>当执行 person = null 后，堆内存的 Person 对象不再有任何强引用指向它，但此时还存在 sr 引用的对象指向 Person 对象。此时调用 sr.get() 方法，返回 Person 对象，即之前堆中的强引用对象了。我们可以合理猜测GC collector 很有可能尚未进行垃圾回收，所以此时 sr.get() 方法返回不为空。</li>\n<li>我们继续执行 <code>System.gc()</code> 强制进行垃圾回收，打印结果可以看到， sr.get() 返回依然不为空，说明 Person 对象依旧没有被回收。</li>\n</ul>\n<p><strong>软引用所指向的对象要进行回收，需要满足两个条件：</strong></p>\n<ol>\n<li>没有任何强引用指向软引用指向的对象（内存中的 Person 对象）</li>\n<li>JVM 需要内存时，即在抛出 OOM 之前</li>\n</ol>\n<p><strong>总结：</strong> SoftReference 变相延长了其只是对象占据堆内存的时间，直到虚拟机内存不足时垃圾回收才回收此堆内存空间。</p>\n<p><strong>软引用还可以和一个 ReferenceQueue 一起使用，</strong> 当 SoftReference 的 Referent 被回收以后，这个 SoftReference 会被自动 enqueue 到这个 ReferenctQueue 中。</p>\n<pre><code class=\"java\">private static void testSoftReferenceWithQueue(){\n    Person person = new Person();\n    System.out.println(&quot;person 对象为：&quot; + person);\n\n    ReferenceQueue&lt;Person&gt; queue = new ReferenceQueue&lt;&gt;();\n    SoftReference&lt;Person&gt; sr = new SoftReference&lt;&gt;(person, queue);\n\n    person = null; // 之前 new 出的 Person 对象不会立即被回收，除非 JVM 需要内存 （OOM 前）\n    if(sr.get() == null) {\n        System.out.println(&quot;person 对象进入 GC 流程&quot;);\n    } else {\n        System.out.println(&quot;person 对象尚未被回收&quot; + sr.get());\n    }\n\n    System.out.println(&quot;加入 ReferenceQueue 的对象为：&quot; + queue.poll());\n\n    System.gc();\n\n    if(sr.get() == null) {\n        System.out.println(&quot;person 对象进入 GC 流程&quot;);\n    } else {\n        System.out.println(&quot;person 对象尚未被回收&quot; + sr.get());\n    }\n\n    System.out.println(&quot;加入 ReferenceQueue 的对象为： &quot; + queue.poll());\n}\n</code></pre>\n<p>执行上述例子，结果如下：</p>\n<pre><code>person 对象为 com.example.ReferenceTest$Person@522d9d8c\nperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c\n加入 ReferenceQueue 的对象为 null\nperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c\n加入 ReferenceQueue 的对象为 null\n</code></pre><p><strong>注意：</strong> 当 SoftReference 或 WeakReference 的 get() 方法返回 null 时，仅表明其指示的对象已经进入垃圾回收流程，此时对象不一定已经被垃圾回收。</p>\n<p>而只有确认被垃圾回收后，如果有 ReferenceQueue ，其引用才会被放置于 ReferenceQueue 中。</p>\n<h2 id=\"WeakReference-弱引用\"><a href=\"#WeakReference-弱引用\" class=\"headerlink\" title=\"WeakReference 弱引用\"></a>WeakReference 弱引用</h2><p>弱引用的一般使用形式：</p>\n<pre><code class=\"Java\">private static void testWeakReference(){\n    Person person = new Person();\n    System.out.println(&quot;person 对象为： &quot; + person);\n\n    WeakReference&lt;Person&gt; wr = new WeakReference&lt;&gt;(person);\n    person = null; // 被 GC 后，之前 new 出的 Person 对象会立即被回收，进入 GC 流程。\n    if (wr.get() == null) {\n        System.out.println(&quot;person 对象进入 GC 流程&quot;);\n    } else {\n        System.out.println(&quot;person 对象尚未被回收&quot; + wr.get());\n    }\n\n    System.gc();\n\n    if (wr.get() == null) {\n        System.out.println(&quot;person 对象进入 GC 流程&quot;);\n    } else {\n        System.out.println(&quot;person 对象尚未被回收&quot; + wr.get());\n    }\n}\n</code></pre>\n<p>执行结果为：</p>\n<pre><code>person 对象为 com.example.ReferenceTest$Person@522d9d8c\nperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c\nperson 对象进入 GC 流程\nin Person finalize\n</code></pre><ul>\n<li><p>当执行 <code>person = null</code> 后，堆内存的  Person 对象不再有任何引用指向它，但此时还存在 wr 引用的对象指向 Person 对象。</p>\n<p>此时调用 <code>wr.get()</code> 方法，返回 Person 对象，即之前堆中的强引用对象，我们可以合理猜测 GC collector 很有可能尚未进行垃圾回收，所以此时 <code>wr.get()</code> 方法返回不为空。</p>\n</li>\n<li><p>继续执行 <code>System.gc()</code> 强制执行垃圾回收，打印结果可以看到，<code>wr.get()</code> 返回为空 “person 对象进入 GC 流程” ，且执行了静态内部类中的 finalize 方法。说明 Person 对象被回收，进入垃圾回收流程。</p>\n</li>\n</ul>\n<p><strong>弱引用所指向的对象要进行回收，只需要满足条件：</strong></p>\n<p>​    没有任何强引用指向弱引用指向的对象（内存中的 Person 对象）</p>\n<p><strong>总结：</strong></p>\n<p>​    WeakReference 不改变原有的强引用独享的垃圾回收机制，一旦其指示对象没有任何强引用对象时，此对象即进入正常的垃圾回收流程。</p>\n<p><strong>其主要使用场景见于：</strong> </p>\n<p>​    当前已有强引用指向强引用对象，此时由于业务需要，需要增加对此对象的引用，同时又不希望改变此引用的垃圾回收机制，此时 <code>WeakReference</code> 正好符合需求，常见于一些与生命周期的场景中，比如 Activity 中的 Handler 的使用，为了防止内存泄露需要用到弱引用。</p>\n<p>与 SoftReference 一样，可以同 ReferenceQueue 一起使用。当 WeakReference 的 Referent 被回收以后，这个 WeakReference 会被自动 enqueue 到这个 ReferenceQueue 中。</p>\n<pre><code class=\"java\">private static void testWeakReferenceWithQueue () {\n    Person person = new Person();\n    System.out.println(&quot;person 对象为 &quot; + person);\n\n    ReferenceQueue&lt;Person&gt; queue = new ReferenceQueue&lt;&gt;();\n    WeakReference&lt;Person&gt; wr = new WeakReference&lt;&gt;(person, queue);\n    System.out.println(&quot;wr 对象为 &quot; + wr);\n\n    if (wr.get() == null) {\n        System.out.println(&quot;person 对象进入 GC 流程&quot;);\n    } else {\n        System.out.println(&quot;person 对象尚未被回收&quot; + wr.get());\n    }\n\n    System.out.println(&quot;Whether or not this reference has been enqueued:&quot; + wr.isEnqueued());\n    System.out.println(&quot;Queue item: &quot; + queue.pull());\n\n    System.gc();\n\n    if (wr.get() == null) {// 仅是表名指示的对象已经进入垃圾回收流程，此时对象不一定已经被垃圾回收，只有确认被垃圾回收后，如果有 ReferenceQueue ，其引用才会被放置于 ReferenceQueue 中。\n        System.out.println(&quot;person 对象进入 GC 流程&quot;);\n    } else {\n        System.out.println(&quot;person 对象尚未被回收&quot; + wr.get());\n    }\n\n    try {\n        // 确保垃圾回收线程能够执行\n        Thread.sleep(1);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n\n    System.out.println(&quot;Whether or not this reference has been enqueued: &quot; + wr.isEnqueued());\n    System.out.println(&quot;queue item: &quot; + queue.poll());\n}\n</code></pre>\n<p><strong>执行结果：</strong></p>\n<pre><code>person 对象为 com.example.ReferenceTEst$Person@522d9d8c\nwr 对象为 java.lang.ref.WeakReference@603828d2\nperson 对象尚未被回收 com.example.ReferenceTEst$Person@522d9d8c\nWhether or not this reference has been enqueued: false\nqueue item: null\nperson 对象进入回收流程\nin Person finalize\nWhether or not this reference has been enqueued: true\nqueue item: java.lang.ref.WeakReference@603828d2\n</code></pre><p>从第二行到最后行可以看出， person 进入 GC 流程后，wr 被加入到 queue 中。</p>\n<p><strong>注意：</strong></p>\n<p>​     当 SoftReference 或者 WeakReference 的 get() 方法返回 null 时，仅表示其指示对象已经进入垃圾回收流程，此时对象不一定已经被垃圾回收。</p>\n<p>​    而只有确认被垃圾回收后，如果有 ReferenceQueue， 其引用才会被放置于 ReferenceQueue 中。</p>\n<h2 id=\"PhantomReference-虚引用\"><a href=\"#PhantomReference-虚引用\" class=\"headerlink\" title=\"PhantomReference 虚引用\"></a>PhantomReference 虚引用</h2><p>虚引用源码：</p>\n<pre><code class=\"java\">package java.lang.ref;\n\nimport java.lang.ref.Reference;\nimport java.lang.ref.ReferenceQueue;\n\npublic class PhantomReference&lt;T&gt; extends Reference&lt;T&gt; {\n    public T get(){\n        return null;\n    }\n\n    public PhantomReference(T var1, ReferenceQueue&lt;? super T&gt; var2) {\n        super.(var1, var2);\n    }\n}\n</code></pre>\n<ul>\n<li>PhantomReference 只有一个构造函数 <code>PhantomReference(T referenct, ReferenceQueue&lt;? super T&gt; q)</code>  因此，PhantomReference 使用必须结合 ReferenceQueue；</li>\n<li>不管有无强引用指向 PhantomReference 的指示对象， PhantomReference 的 get() 方法返回结果都是 null</li>\n</ul>\n<p>举例：</p>\n<pre><code class=\"java\">private static void testPhantomReference() {\n    Person person = new Person();\n    System.out.println(&quot;person 对象为&quot; + person);\n\n    ReferenceQueue&lt;Person&gt; queue = new ReferenceQueue&lt;&gt;();\n    PhantomReference&lt;Person&gt; pr = new PhantomReference&lt;&gt;(person, queue);\n\n    System.out.println(&quot;pr 对象为&quot; + pr);\n    System.out.println(&quot;pr.get() = &quot; + pr.get());\n\n    person = null;\n\n    System.gc();\n\n    try{\n        // 确保垃圾回收线程执行\n        Thread.sleep(1);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n\n    System.out.println(&quot;queue item: &quot; + queue.poll());\n}\n</code></pre>\n<p><strong>执行结果：</strong></p>\n<pre><code>person 对象为 com.example.ReferenceTEst$Person@522d9d8c\npr 对象为 java.lang.ref.PhantomReference@60e35b53\npr.get() = null\nin Person finalize\nqueue ite: java.lang.ref.PhantomReference@60e35b53\n</code></pre><p><strong>总结：</strong></p>\n<p>​    与 WeakReference 一样，不改变原有的强引用对象的垃圾回收机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可以被垃圾回收。虚引用主要用来跟踪对象被垃圾回收后的活动（监听并采取必要的行动）</p>\n<p><strong>用途：</strong></p>\n<p>​    当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>\n<p>​    程序可以通过判断医用队列中是否已经加入虚引用来了解被引用的对象是否将要被垃圾回收。</p>\n<p>​    程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前才去必要的行动。</p>"},{"title":"Java 判断字符串是否是数字的方法","date":"2019-04-16T09:47:06.000Z","_content":"\n* 使用 Java自带的函数\n\n```\npublic static boolean isNumeric (String str) {\n    for (int i = str.length(); --i >=0) {\n          if (!Character.isDigit(str.charAt(i))) {\n                return false;\n          }\n    }\n    return true;\n}\n```\n\n<!--more-->\n\n* 使用正则表达式\n\n方法一:\n\n```\npublic static boolean isNumeric(String str) {\n    Pattern pattern = Pattern.compile(\"^[-\\\\+]?[\\\\d]*$\");\n    return pattern.matcher(str).matches();\n}\n```\n\n方法二:\n\n```\npublic static boolean isNumeric(String str) {\n    if (str != null && !\"\".equals(str.trim())) {\n          return s.matches(\"^[0-9]*$\");\n    }\n    return false;\n}\n```\n\n方法三:\n\n```\n public static boolean isNumeric (String str) {\n    Pattern pattern = Pattern.compile(\"[0-9]*\");\n    return pattern.matcher(str).matcher();\n}\n```\n\n* 使用 ASCII 码\n\n```\npublic static boolean isNumeric (String str) {\n    for (int i = str.length(); --i>=0;) {\n        int chr = str.charAt(i);\n        if (chr < 48 || chr > 57) {\n            return false;\n        }\n   }\n   return true;\n}\n```\n\n* 判断是不是浮点型数据\n\n```\npublic static boolean isDouble(String str) {\n    Pattern pattern = Pattern.compile(\"^[-\\\\+]?[.\\\\d]*$\");\n    return pattern.matcher(str).matches();\n}\n```\n\n","source":"_posts/Java/Java-判断字符串是否是数字的方法.md","raw":"---\ntitle: Java 判断字符串是否是数字的方法\ndate: 2019-04-16 17:47:06\ntags: Java\n---\n\n* 使用 Java自带的函数\n\n```\npublic static boolean isNumeric (String str) {\n    for (int i = str.length(); --i >=0) {\n          if (!Character.isDigit(str.charAt(i))) {\n                return false;\n          }\n    }\n    return true;\n}\n```\n\n<!--more-->\n\n* 使用正则表达式\n\n方法一:\n\n```\npublic static boolean isNumeric(String str) {\n    Pattern pattern = Pattern.compile(\"^[-\\\\+]?[\\\\d]*$\");\n    return pattern.matcher(str).matches();\n}\n```\n\n方法二:\n\n```\npublic static boolean isNumeric(String str) {\n    if (str != null && !\"\".equals(str.trim())) {\n          return s.matches(\"^[0-9]*$\");\n    }\n    return false;\n}\n```\n\n方法三:\n\n```\n public static boolean isNumeric (String str) {\n    Pattern pattern = Pattern.compile(\"[0-9]*\");\n    return pattern.matcher(str).matcher();\n}\n```\n\n* 使用 ASCII 码\n\n```\npublic static boolean isNumeric (String str) {\n    for (int i = str.length(); --i>=0;) {\n        int chr = str.charAt(i);\n        if (chr < 48 || chr > 57) {\n            return false;\n        }\n   }\n   return true;\n}\n```\n\n* 判断是不是浮点型数据\n\n```\npublic static boolean isDouble(String str) {\n    Pattern pattern = Pattern.compile(\"^[-\\\\+]?[.\\\\d]*$\");\n    return pattern.matcher(str).matches();\n}\n```\n\n","slug":"Java/Java-判断字符串是否是数字的方法","published":1,"updated":"2021-01-29T15:54:28.308Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8et001isz5q4ubmbre3","content":"<ul>\n<li>使用 Java自带的函数</li>\n</ul>\n<pre><code>public static boolean isNumeric (String str) {\n    for (int i = str.length(); --i &gt;=0) {\n          if (!Character.isDigit(str.charAt(i))) {\n                return false;\n          }\n    }\n    return true;\n}\n</code></pre><a id=\"more\"></a>\n<ul>\n<li>使用正则表达式</li>\n</ul>\n<p>方法一:</p>\n<pre><code>public static boolean isNumeric(String str) {\n    Pattern pattern = Pattern.compile(&quot;^[-\\\\+]?[\\\\d]*$&quot;);\n    return pattern.matcher(str).matches();\n}\n</code></pre><p>方法二:</p>\n<pre><code>public static boolean isNumeric(String str) {\n    if (str != null &amp;&amp; !&quot;&quot;.equals(str.trim())) {\n          return s.matches(&quot;^[0-9]*$&quot;);\n    }\n    return false;\n}\n</code></pre><p>方法三:</p>\n<pre><code> public static boolean isNumeric (String str) {\n    Pattern pattern = Pattern.compile(&quot;[0-9]*&quot;);\n    return pattern.matcher(str).matcher();\n}\n</code></pre><ul>\n<li>使用 ASCII 码</li>\n</ul>\n<pre><code>public static boolean isNumeric (String str) {\n    for (int i = str.length(); --i&gt;=0;) {\n        int chr = str.charAt(i);\n        if (chr &lt; 48 || chr &gt; 57) {\n            return false;\n        }\n   }\n   return true;\n}\n</code></pre><ul>\n<li>判断是不是浮点型数据</li>\n</ul>\n<pre><code>public static boolean isDouble(String str) {\n    Pattern pattern = Pattern.compile(&quot;^[-\\\\+]?[.\\\\d]*$&quot;);\n    return pattern.matcher(str).matches();\n}\n</code></pre>","site":{"data":{}},"excerpt":"<ul>\n<li>使用 Java自带的函数</li>\n</ul>\n<pre><code>public static boolean isNumeric (String str) {\n    for (int i = str.length(); --i &gt;=0) {\n          if (!Character.isDigit(str.charAt(i))) {\n                return false;\n          }\n    }\n    return true;\n}\n</code></pre>","more":"<ul>\n<li>使用正则表达式</li>\n</ul>\n<p>方法一:</p>\n<pre><code>public static boolean isNumeric(String str) {\n    Pattern pattern = Pattern.compile(&quot;^[-\\\\+]?[\\\\d]*$&quot;);\n    return pattern.matcher(str).matches();\n}\n</code></pre><p>方法二:</p>\n<pre><code>public static boolean isNumeric(String str) {\n    if (str != null &amp;&amp; !&quot;&quot;.equals(str.trim())) {\n          return s.matches(&quot;^[0-9]*$&quot;);\n    }\n    return false;\n}\n</code></pre><p>方法三:</p>\n<pre><code> public static boolean isNumeric (String str) {\n    Pattern pattern = Pattern.compile(&quot;[0-9]*&quot;);\n    return pattern.matcher(str).matcher();\n}\n</code></pre><ul>\n<li>使用 ASCII 码</li>\n</ul>\n<pre><code>public static boolean isNumeric (String str) {\n    for (int i = str.length(); --i&gt;=0;) {\n        int chr = str.charAt(i);\n        if (chr &lt; 48 || chr &gt; 57) {\n            return false;\n        }\n   }\n   return true;\n}\n</code></pre><ul>\n<li>判断是不是浮点型数据</li>\n</ul>\n<pre><code>public static boolean isDouble(String str) {\n    Pattern pattern = Pattern.compile(&quot;^[-\\\\+]?[.\\\\d]*$&quot;);\n    return pattern.matcher(str).matches();\n}\n</code></pre>"},{"title":"Java 异常","_content":"\n**Crash** 应用崩溃，是由于代码异常而导致 APP 非正常退出，导致应用程序无法正常使用，所有工作都停止的现象。\n<!-- more-->\n发生 **Crash** 后需要重新启动应用（有些情况也会自动重启），而且不管应用在开发阶段做得多么优秀，也无法避免 **Crash** 的放生，在 **Android** 系统中，系统碎片化比较严重，各 **Rom** 之间的差异，设置系统的 BUG ，都可能导致 **Crash** 的发生。\n\n在 **Android** 应用 中发生 **Crash** 有两种类型： Java 层的 Crash 和 Native 的 Crash。这两种 **Crash** 的监控和获取堆栈信息有所不同。\n\n## Java Crash\n\nJava 的 Crash 监控非常简单，**Java 中的 Thread 定义了一个接口： `UncaughtExceptionHandler` , 用于处理未捕获的异常导致线程的终止（catch 了的是捕获不到）**，当应用发生了 Crash 的时候，就会走 `UNcaughtExceptionHandler.uncaughtException` ，该方法中可以获取到异常的信息，我们通过 `Thread.setDefaultUncaughtExceptionHandler` ，该方法来设置线程的默认异常处理器，我们可以将异常信息保存到本地或者上传到服务器，方便我们快速定位问题。\n\n```java\npublic class CrashHandler implements Thread.UncaughtExceptionHandler {\n    private static final String FILE_NAME_STUFFIX = \".trace\";\n    private static Thread.UncaughtExceptionHandler mDefaultCrashHandler;\n    private static Context mContext;\n    \n    private CrashHandler(){}\n    \n    public static void init(Context context) {\n        mDefaultCrashHandler = Thread.getDefaultUncaughtExceptionHandler();\n        Thread.setDefaultUncaughtExceptionHandler(this);\n        mContext = context.getApplicationContext();\n    }\n    \n    /**\n     * 当程序中有未捕获异常，系统将会调用这个方法\n     */\n    @Override\n    public void uncaughtException(Thread t, Throwable e) {\n        try {\n            // 自行处理，可以保存到本地，也可以上传到后台\n            File file = dealException(e);\n            \n        } catch (Exception e1) {\n            e1.printStackTrace();\n        } finally {\n            // 交给系统默认程序处理，否则会重复自启动\n            if(mDefaultCrashHandler != null) {\n                mDefaultCrashHandler.uncaughtException(t, e);\n            }\n        }\n    }\n    \n    /**\n     * 导出异常到 SD 卡\n     */\n     private File dealException(Thread t, Throwable e) throw Exception {\n         String time = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date());\n         File f = new File(mContext.getExternalCacheDir().getAbsoluteFile(), \"crash_info\");\n         if(!f.exists()) {\n             f.mkdirs();\n         }\n         File crashFile = new File(f, time+ FILE_NAME_SUFFIX);\n         // 向文件中写入数据,可以自定义存储内容，尽量详细方便我们快速定位问题\n         PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(f)));\n         pw.println(time);\n         pw.println(\"Thread:\" + t.getName());\n         e.printStackTrace(pw);// 写入 crash 堆栈\n         pw.flush();\n         pw.close();\n         return f;\n     }\n}\n```\n\n## NDK Crash\n\n### Linux 信号机制\n\n信号机制是 Linux 进程间通信的一种重要方式，Linux 信号一方面用于正常的进程间通信和同步，另一方面还负责监控系统异常及中断。当应用程序运行异常是， Linux 内核将产生错误信号并通知当前进程。当前进程在接收到该错误信号后，可以有三种不同的处理方式：\n\n* 忽略该信号\n* 捕捉该信号并执行对应的信号处理函数（信号处理程序）\n* 执行该信号的缺省操作（如终止进程）\n\n当 Linux 应用程序在执行时发生严重错误，一般会导致程序崩溃。其中 Linux 专门提供了一类 crash 信号，在程序接收到该信号时，缺省操作时将崩溃的线程信息记录到核心文件，然后终止进程。\n\n常见的崩溃信号列表：\n\n* **SIGSEGV: ** 内存引用无效\n* **SIGBUS: ** 访问内存对象的未定义部分\n* **SIGFPE: ** 算数运算错误\n* **SIGILL: ** 非法指令，如执行垃圾或特权指令\n* **SIGSYS: ** 糟糕的系统调用\n* **SIGXCPU: ** 超过 CPU 时间限制\n* **SIGXFSZ: ** 文件大小限制\n\n一般出现崩溃信号， Android 系统会默认缺省操作时直接退出程序。但是系统允许我们给某一个进程的某一个特定信号注册一个相应的处理函数（singal） ，即对该信号的默认处理动作进行修改。因此 NDK Crash 的监控可以采用这种信号机制，捕获崩溃信号执行我们自己的信号处理函数，从而捕获 NKD Crash。\n\n\n\n### BreakPad\n\n[Google breakpad](https://github.com/google/breakpad) 是一个跨平台的崩溃转储和分析框架和工具的集合。 breakpad 在 Linux 中的实现就是借助了 Linux 信号捕获机制实现的。因为其实现为  C++, 在 Android 中必须要借助 NDK 工具。\n\n [Crash监控.pdf](..\\..\\技术文档\\Crash监控.pdf) \n\n","source":"_posts/Java/Java-异常.md","raw":"---\ntitle: Java 异常\ntag: Java\n---\n\n**Crash** 应用崩溃，是由于代码异常而导致 APP 非正常退出，导致应用程序无法正常使用，所有工作都停止的现象。\n<!-- more-->\n发生 **Crash** 后需要重新启动应用（有些情况也会自动重启），而且不管应用在开发阶段做得多么优秀，也无法避免 **Crash** 的放生，在 **Android** 系统中，系统碎片化比较严重，各 **Rom** 之间的差异，设置系统的 BUG ，都可能导致 **Crash** 的发生。\n\n在 **Android** 应用 中发生 **Crash** 有两种类型： Java 层的 Crash 和 Native 的 Crash。这两种 **Crash** 的监控和获取堆栈信息有所不同。\n\n## Java Crash\n\nJava 的 Crash 监控非常简单，**Java 中的 Thread 定义了一个接口： `UncaughtExceptionHandler` , 用于处理未捕获的异常导致线程的终止（catch 了的是捕获不到）**，当应用发生了 Crash 的时候，就会走 `UNcaughtExceptionHandler.uncaughtException` ，该方法中可以获取到异常的信息，我们通过 `Thread.setDefaultUncaughtExceptionHandler` ，该方法来设置线程的默认异常处理器，我们可以将异常信息保存到本地或者上传到服务器，方便我们快速定位问题。\n\n```java\npublic class CrashHandler implements Thread.UncaughtExceptionHandler {\n    private static final String FILE_NAME_STUFFIX = \".trace\";\n    private static Thread.UncaughtExceptionHandler mDefaultCrashHandler;\n    private static Context mContext;\n    \n    private CrashHandler(){}\n    \n    public static void init(Context context) {\n        mDefaultCrashHandler = Thread.getDefaultUncaughtExceptionHandler();\n        Thread.setDefaultUncaughtExceptionHandler(this);\n        mContext = context.getApplicationContext();\n    }\n    \n    /**\n     * 当程序中有未捕获异常，系统将会调用这个方法\n     */\n    @Override\n    public void uncaughtException(Thread t, Throwable e) {\n        try {\n            // 自行处理，可以保存到本地，也可以上传到后台\n            File file = dealException(e);\n            \n        } catch (Exception e1) {\n            e1.printStackTrace();\n        } finally {\n            // 交给系统默认程序处理，否则会重复自启动\n            if(mDefaultCrashHandler != null) {\n                mDefaultCrashHandler.uncaughtException(t, e);\n            }\n        }\n    }\n    \n    /**\n     * 导出异常到 SD 卡\n     */\n     private File dealException(Thread t, Throwable e) throw Exception {\n         String time = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date());\n         File f = new File(mContext.getExternalCacheDir().getAbsoluteFile(), \"crash_info\");\n         if(!f.exists()) {\n             f.mkdirs();\n         }\n         File crashFile = new File(f, time+ FILE_NAME_SUFFIX);\n         // 向文件中写入数据,可以自定义存储内容，尽量详细方便我们快速定位问题\n         PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(f)));\n         pw.println(time);\n         pw.println(\"Thread:\" + t.getName());\n         e.printStackTrace(pw);// 写入 crash 堆栈\n         pw.flush();\n         pw.close();\n         return f;\n     }\n}\n```\n\n## NDK Crash\n\n### Linux 信号机制\n\n信号机制是 Linux 进程间通信的一种重要方式，Linux 信号一方面用于正常的进程间通信和同步，另一方面还负责监控系统异常及中断。当应用程序运行异常是， Linux 内核将产生错误信号并通知当前进程。当前进程在接收到该错误信号后，可以有三种不同的处理方式：\n\n* 忽略该信号\n* 捕捉该信号并执行对应的信号处理函数（信号处理程序）\n* 执行该信号的缺省操作（如终止进程）\n\n当 Linux 应用程序在执行时发生严重错误，一般会导致程序崩溃。其中 Linux 专门提供了一类 crash 信号，在程序接收到该信号时，缺省操作时将崩溃的线程信息记录到核心文件，然后终止进程。\n\n常见的崩溃信号列表：\n\n* **SIGSEGV: ** 内存引用无效\n* **SIGBUS: ** 访问内存对象的未定义部分\n* **SIGFPE: ** 算数运算错误\n* **SIGILL: ** 非法指令，如执行垃圾或特权指令\n* **SIGSYS: ** 糟糕的系统调用\n* **SIGXCPU: ** 超过 CPU 时间限制\n* **SIGXFSZ: ** 文件大小限制\n\n一般出现崩溃信号， Android 系统会默认缺省操作时直接退出程序。但是系统允许我们给某一个进程的某一个特定信号注册一个相应的处理函数（singal） ，即对该信号的默认处理动作进行修改。因此 NDK Crash 的监控可以采用这种信号机制，捕获崩溃信号执行我们自己的信号处理函数，从而捕获 NKD Crash。\n\n\n\n### BreakPad\n\n[Google breakpad](https://github.com/google/breakpad) 是一个跨平台的崩溃转储和分析框架和工具的集合。 breakpad 在 Linux 中的实现就是借助了 Linux 信号捕获机制实现的。因为其实现为  C++, 在 Android 中必须要借助 NDK 工具。\n\n [Crash监控.pdf](..\\..\\技术文档\\Crash监控.pdf) \n\n","slug":"Java/Java-异常","published":1,"date":"2021-01-29T15:54:28.308Z","updated":"2021-01-29T16:03:56.918Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8ev001lsz5qg1r7o1uu","content":"<p><strong>Crash</strong> 应用崩溃，是由于代码异常而导致 APP 非正常退出，导致应用程序无法正常使用，所有工作都停止的现象。<br><a id=\"more\"></a><br>发生 <strong>Crash</strong> 后需要重新启动应用（有些情况也会自动重启），而且不管应用在开发阶段做得多么优秀，也无法避免 <strong>Crash</strong> 的放生，在 <strong>Android</strong> 系统中，系统碎片化比较严重，各 <strong>Rom</strong> 之间的差异，设置系统的 BUG ，都可能导致 <strong>Crash</strong> 的发生。</p>\n<p>在 <strong>Android</strong> 应用 中发生 <strong>Crash</strong> 有两种类型： Java 层的 Crash 和 Native 的 Crash。这两种 <strong>Crash</strong> 的监控和获取堆栈信息有所不同。</p>\n<h2 id=\"Java-Crash\"><a href=\"#Java-Crash\" class=\"headerlink\" title=\"Java Crash\"></a>Java Crash</h2><p>Java 的 Crash 监控非常简单，<strong>Java 中的 Thread 定义了一个接口： <code>UncaughtExceptionHandler</code> , 用于处理未捕获的异常导致线程的终止（catch 了的是捕获不到）</strong>，当应用发生了 Crash 的时候，就会走 <code>UNcaughtExceptionHandler.uncaughtException</code> ，该方法中可以获取到异常的信息，我们通过 <code>Thread.setDefaultUncaughtExceptionHandler</code> ，该方法来设置线程的默认异常处理器，我们可以将异常信息保存到本地或者上传到服务器，方便我们快速定位问题。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CrashHandler</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Thread<span class=\"token punctuation\">.</span>UncaughtExceptionHandler</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> String FILE_NAME_STUFFIX <span class=\"token operator\">=</span> <span class=\"token string\">\".trace\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> Thread<span class=\"token punctuation\">.</span>UncaughtExceptionHandler mDefaultCrashHandler<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> Context mContext<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token function\">CrashHandler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span>Context context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        mDefaultCrashHandler <span class=\"token operator\">=</span> Thread<span class=\"token punctuation\">.</span><span class=\"token function\">getDefaultUncaughtExceptionHandler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Thread<span class=\"token punctuation\">.</span><span class=\"token function\">setDefaultUncaughtExceptionHandler</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        mContext <span class=\"token operator\">=</span> context<span class=\"token punctuation\">.</span><span class=\"token function\">getApplicationContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 当程序中有未捕获异常，系统将会调用这个方法\n     */</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">uncaughtException</span><span class=\"token punctuation\">(</span>Thread t<span class=\"token punctuation\">,</span> Throwable e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 自行处理，可以保存到本地，也可以上传到后台</span>\n            File file <span class=\"token operator\">=</span> <span class=\"token function\">dealException</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e1<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 交给系统默认程序处理，否则会重复自启动</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mDefaultCrashHandler <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                mDefaultCrashHandler<span class=\"token punctuation\">.</span><span class=\"token function\">uncaughtException</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 导出异常到 SD 卡\n     */</span>\n     <span class=\"token keyword\">private</span> File <span class=\"token function\">dealException</span><span class=\"token punctuation\">(</span>Thread t<span class=\"token punctuation\">,</span> Throwable e<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> Exception <span class=\"token punctuation\">{</span>\n         String time <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SimpleDateFormat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"yyyy-MM-dd HH:mm:ss\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">format</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         File f <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">(</span>mContext<span class=\"token punctuation\">.</span><span class=\"token function\">getExternalCacheDir</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getAbsoluteFile</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"crash_info\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>f<span class=\"token punctuation\">.</span><span class=\"token function\">exists</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n             f<span class=\"token punctuation\">.</span><span class=\"token function\">mkdirs</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">}</span>\n         File crashFile <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">,</span> time<span class=\"token operator\">+</span> FILE_NAME_SUFFIX<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token comment\" spellcheck=\"true\">// 向文件中写入数据,可以自定义存储内容，尽量详细方便我们快速定位问题</span>\n         PrintWriter pw <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">PrintWriter</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">BufferedWriter</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">FileWriter</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         pw<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         pw<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Thread:\"</span> <span class=\"token operator\">+</span> t<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span>pw<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// 写入 crash 堆栈</span>\n         pw<span class=\"token punctuation\">.</span><span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         pw<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token keyword\">return</span> f<span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"NDK-Crash\"><a href=\"#NDK-Crash\" class=\"headerlink\" title=\"NDK Crash\"></a>NDK Crash</h2><h3 id=\"Linux-信号机制\"><a href=\"#Linux-信号机制\" class=\"headerlink\" title=\"Linux 信号机制\"></a>Linux 信号机制</h3><p>信号机制是 Linux 进程间通信的一种重要方式，Linux 信号一方面用于正常的进程间通信和同步，另一方面还负责监控系统异常及中断。当应用程序运行异常是， Linux 内核将产生错误信号并通知当前进程。当前进程在接收到该错误信号后，可以有三种不同的处理方式：</p>\n<ul>\n<li>忽略该信号</li>\n<li>捕捉该信号并执行对应的信号处理函数（信号处理程序）</li>\n<li>执行该信号的缺省操作（如终止进程）</li>\n</ul>\n<p>当 Linux 应用程序在执行时发生严重错误，一般会导致程序崩溃。其中 Linux 专门提供了一类 crash 信号，在程序接收到该信号时，缺省操作时将崩溃的线程信息记录到核心文件，然后终止进程。</p>\n<p>常见的崩溃信号列表：</p>\n<ul>\n<li><strong>SIGSEGV: </strong> 内存引用无效</li>\n<li><strong>SIGBUS: </strong> 访问内存对象的未定义部分</li>\n<li><strong>SIGFPE: </strong> 算数运算错误</li>\n<li><strong>SIGILL: </strong> 非法指令，如执行垃圾或特权指令</li>\n<li><strong>SIGSYS: </strong> 糟糕的系统调用</li>\n<li><strong>SIGXCPU: </strong> 超过 CPU 时间限制</li>\n<li><strong>SIGXFSZ: </strong> 文件大小限制</li>\n</ul>\n<p>一般出现崩溃信号， Android 系统会默认缺省操作时直接退出程序。但是系统允许我们给某一个进程的某一个特定信号注册一个相应的处理函数（singal） ，即对该信号的默认处理动作进行修改。因此 NDK Crash 的监控可以采用这种信号机制，捕获崩溃信号执行我们自己的信号处理函数，从而捕获 NKD Crash。</p>\n<h3 id=\"BreakPad\"><a href=\"#BreakPad\" class=\"headerlink\" title=\"BreakPad\"></a>BreakPad</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9icmVha3BhZA==\" title=\"https://github.com/google/breakpad\">Google breakpad<i class=\"fa fa-external-link\"></i></span> 是一个跨平台的崩溃转储和分析框架和工具的集合。 breakpad 在 Linux 中的实现就是借助了 Linux 信号捕获机制实现的。因为其实现为  C++, 在 Android 中必须要借助 NDK 工具。</p>\n<p> <a href=\"..\\..\\技术文档\\Crash监控.pdf\">Crash监控.pdf</a> </p>\n","site":{"data":{}},"excerpt":"<p><strong>Crash</strong> 应用崩溃，是由于代码异常而导致 APP 非正常退出，导致应用程序无法正常使用，所有工作都停止的现象。<br>","more":"<br>发生 <strong>Crash</strong> 后需要重新启动应用（有些情况也会自动重启），而且不管应用在开发阶段做得多么优秀，也无法避免 <strong>Crash</strong> 的放生，在 <strong>Android</strong> 系统中，系统碎片化比较严重，各 <strong>Rom</strong> 之间的差异，设置系统的 BUG ，都可能导致 <strong>Crash</strong> 的发生。</p>\n<p>在 <strong>Android</strong> 应用 中发生 <strong>Crash</strong> 有两种类型： Java 层的 Crash 和 Native 的 Crash。这两种 <strong>Crash</strong> 的监控和获取堆栈信息有所不同。</p>\n<h2 id=\"Java-Crash\"><a href=\"#Java-Crash\" class=\"headerlink\" title=\"Java Crash\"></a>Java Crash</h2><p>Java 的 Crash 监控非常简单，<strong>Java 中的 Thread 定义了一个接口： <code>UncaughtExceptionHandler</code> , 用于处理未捕获的异常导致线程的终止（catch 了的是捕获不到）</strong>，当应用发生了 Crash 的时候，就会走 <code>UNcaughtExceptionHandler.uncaughtException</code> ，该方法中可以获取到异常的信息，我们通过 <code>Thread.setDefaultUncaughtExceptionHandler</code> ，该方法来设置线程的默认异常处理器，我们可以将异常信息保存到本地或者上传到服务器，方便我们快速定位问题。</p>\n<pre><code class=\"java\">public class CrashHandler implements Thread.UncaughtExceptionHandler {\n    private static final String FILE_NAME_STUFFIX = &quot;.trace&quot;;\n    private static Thread.UncaughtExceptionHandler mDefaultCrashHandler;\n    private static Context mContext;\n\n    private CrashHandler(){}\n\n    public static void init(Context context) {\n        mDefaultCrashHandler = Thread.getDefaultUncaughtExceptionHandler();\n        Thread.setDefaultUncaughtExceptionHandler(this);\n        mContext = context.getApplicationContext();\n    }\n\n    /**\n     * 当程序中有未捕获异常，系统将会调用这个方法\n     */\n    @Override\n    public void uncaughtException(Thread t, Throwable e) {\n        try {\n            // 自行处理，可以保存到本地，也可以上传到后台\n            File file = dealException(e);\n\n        } catch (Exception e1) {\n            e1.printStackTrace();\n        } finally {\n            // 交给系统默认程序处理，否则会重复自启动\n            if(mDefaultCrashHandler != null) {\n                mDefaultCrashHandler.uncaughtException(t, e);\n            }\n        }\n    }\n\n    /**\n     * 导出异常到 SD 卡\n     */\n     private File dealException(Thread t, Throwable e) throw Exception {\n         String time = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date());\n         File f = new File(mContext.getExternalCacheDir().getAbsoluteFile(), &quot;crash_info&quot;);\n         if(!f.exists()) {\n             f.mkdirs();\n         }\n         File crashFile = new File(f, time+ FILE_NAME_SUFFIX);\n         // 向文件中写入数据,可以自定义存储内容，尽量详细方便我们快速定位问题\n         PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(f)));\n         pw.println(time);\n         pw.println(&quot;Thread:&quot; + t.getName());\n         e.printStackTrace(pw);// 写入 crash 堆栈\n         pw.flush();\n         pw.close();\n         return f;\n     }\n}\n</code></pre>\n<h2 id=\"NDK-Crash\"><a href=\"#NDK-Crash\" class=\"headerlink\" title=\"NDK Crash\"></a>NDK Crash</h2><h3 id=\"Linux-信号机制\"><a href=\"#Linux-信号机制\" class=\"headerlink\" title=\"Linux 信号机制\"></a>Linux 信号机制</h3><p>信号机制是 Linux 进程间通信的一种重要方式，Linux 信号一方面用于正常的进程间通信和同步，另一方面还负责监控系统异常及中断。当应用程序运行异常是， Linux 内核将产生错误信号并通知当前进程。当前进程在接收到该错误信号后，可以有三种不同的处理方式：</p>\n<ul>\n<li>忽略该信号</li>\n<li>捕捉该信号并执行对应的信号处理函数（信号处理程序）</li>\n<li>执行该信号的缺省操作（如终止进程）</li>\n</ul>\n<p>当 Linux 应用程序在执行时发生严重错误，一般会导致程序崩溃。其中 Linux 专门提供了一类 crash 信号，在程序接收到该信号时，缺省操作时将崩溃的线程信息记录到核心文件，然后终止进程。</p>\n<p>常见的崩溃信号列表：</p>\n<ul>\n<li><strong>SIGSEGV: </strong> 内存引用无效</li>\n<li><strong>SIGBUS: </strong> 访问内存对象的未定义部分</li>\n<li><strong>SIGFPE: </strong> 算数运算错误</li>\n<li><strong>SIGILL: </strong> 非法指令，如执行垃圾或特权指令</li>\n<li><strong>SIGSYS: </strong> 糟糕的系统调用</li>\n<li><strong>SIGXCPU: </strong> 超过 CPU 时间限制</li>\n<li><strong>SIGXFSZ: </strong> 文件大小限制</li>\n</ul>\n<p>一般出现崩溃信号， Android 系统会默认缺省操作时直接退出程序。但是系统允许我们给某一个进程的某一个特定信号注册一个相应的处理函数（singal） ，即对该信号的默认处理动作进行修改。因此 NDK Crash 的监控可以采用这种信号机制，捕获崩溃信号执行我们自己的信号处理函数，从而捕获 NKD Crash。</p>\n<h3 id=\"BreakPad\"><a href=\"#BreakPad\" class=\"headerlink\" title=\"BreakPad\"></a>BreakPad</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9icmVha3BhZA==\" title=\"https://github.com/google/breakpad\">Google breakpad<i class=\"fa fa-external-link\"></i></span> 是一个跨平台的崩溃转储和分析框架和工具的集合。 breakpad 在 Linux 中的实现就是借助了 Linux 信号捕获机制实现的。因为其实现为  C++, 在 Android 中必须要借助 NDK 工具。</p>\n<p> <a href=\"..\\..\\技术文档\\Crash监控.pdf\">Crash监控.pdf</a> </p>"},{"title":"阻塞队列","_content":"\n## 什么是阻塞队列\n\n`BlockingQueue` 是一个支持两个附加操作的队列。\n\n在队列为空时，获取元素的线程会等待队列变为非空；当队列满时，存储元素的线程会等待队列可用。\n<!-- more-->\n阻塞队列常用于生产消费者模的场景中，生产者是往队列里添加元素的线程；消费者是从队列里拿元素的线程。\n\n阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素\n\n* ArrayBlockingQueue: 一个由数组结构组成的有界阻塞队列\n* LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列\n* PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列\n* DelayQueue: 一个使用优先级排序的无界阻塞队列\n* SynchronousQueue：一个不存储元素的阻塞队列\n* LinkedTransferQueue: 一个由链表结构组成的无界阻塞队列\n* LinkedBlockingDeque：一个由链表组成的双向阻塞队列\n\n## 阻塞队列的实现原理\n\n使用**通知模式**实现\n\n所谓 **通知模式** 就是当生产者往**`满的队列`**里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。\n\n**ArrayBlockingQueue：**\n\n```Java\nprivate final Condition notFull;\nprivate final Condition notEmpty;\n\npublic ArrayBlockingQueue(int capacity, boolean fair) {\n    if (capacity <= 0){\n\t    throw new IllegalArgumentException();        \n    }\n    this.items = new Object[capacity];\n    lock = new ReentrantLock(fair);\n    notEmpty = lock.newCondition();\n    notFull = lock.newCondition();\n}\n\npublic void put(E e) throws InterruptedException {\n    checkNotNull(e);\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        while(count == items.length) {\n            notFull.await();\n            insert(e);\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\npublic E take() throws InterruptedException {\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        while (count == 0) {\n            notEmpty = await();\n        }\n        return extract();\n    } finally {\n        lock.unlock();\n    }\n}\n\nprivate void insert(E x) {\n    items[putIndex] = x;\n    putIndex = inc(putIndex);\n    ++count;\n    // 唤醒一个等待线程\n    notEmpty.signal();\n} \n```\n\n当我们往队列里插入一个元素时，如果队列不可用，阻塞生产者主要通过 `LockSupport.park(this)`  来实现\n\n```java\npublic final void await() throws InterruptedException {\n    if(Thread.interrupted()) {\n        throw new InterruptedException();\n    }\n    \n    Node node = addConditionWaiter();\n    int savedState = fullyRelease(node);\n    int interruptMode = 0;\n    while(!isOnSyncQueue(node)) {\n        LockSupport.park(this);\n        if((interruptMode = checkInterruptWhileWaitting(node)) != 0) {\n            break;\n        }\n    }\n    \n    if(acquireQueued(node, savedState) && interruptMode != THROW_IE) {\n        interruptMode = REINTERRUPT;\n    }\n    \n    if(node.nextWaiter != null) {\n        unlinkCancelledWaiters();\n    }\n    \n    if(interruptMode != 0) {\n        reportInterruptAfterWait(interruptMode);\n    }\n}\n```\n\n","source":"_posts/Java/阻塞队列.md","raw":"---\ntitle: 阻塞队列\ntag: Java\n---\n\n## 什么是阻塞队列\n\n`BlockingQueue` 是一个支持两个附加操作的队列。\n\n在队列为空时，获取元素的线程会等待队列变为非空；当队列满时，存储元素的线程会等待队列可用。\n<!-- more-->\n阻塞队列常用于生产消费者模的场景中，生产者是往队列里添加元素的线程；消费者是从队列里拿元素的线程。\n\n阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素\n\n* ArrayBlockingQueue: 一个由数组结构组成的有界阻塞队列\n* LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列\n* PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列\n* DelayQueue: 一个使用优先级排序的无界阻塞队列\n* SynchronousQueue：一个不存储元素的阻塞队列\n* LinkedTransferQueue: 一个由链表结构组成的无界阻塞队列\n* LinkedBlockingDeque：一个由链表组成的双向阻塞队列\n\n## 阻塞队列的实现原理\n\n使用**通知模式**实现\n\n所谓 **通知模式** 就是当生产者往**`满的队列`**里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。\n\n**ArrayBlockingQueue：**\n\n```Java\nprivate final Condition notFull;\nprivate final Condition notEmpty;\n\npublic ArrayBlockingQueue(int capacity, boolean fair) {\n    if (capacity <= 0){\n\t    throw new IllegalArgumentException();        \n    }\n    this.items = new Object[capacity];\n    lock = new ReentrantLock(fair);\n    notEmpty = lock.newCondition();\n    notFull = lock.newCondition();\n}\n\npublic void put(E e) throws InterruptedException {\n    checkNotNull(e);\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        while(count == items.length) {\n            notFull.await();\n            insert(e);\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\npublic E take() throws InterruptedException {\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        while (count == 0) {\n            notEmpty = await();\n        }\n        return extract();\n    } finally {\n        lock.unlock();\n    }\n}\n\nprivate void insert(E x) {\n    items[putIndex] = x;\n    putIndex = inc(putIndex);\n    ++count;\n    // 唤醒一个等待线程\n    notEmpty.signal();\n} \n```\n\n当我们往队列里插入一个元素时，如果队列不可用，阻塞生产者主要通过 `LockSupport.park(this)`  来实现\n\n```java\npublic final void await() throws InterruptedException {\n    if(Thread.interrupted()) {\n        throw new InterruptedException();\n    }\n    \n    Node node = addConditionWaiter();\n    int savedState = fullyRelease(node);\n    int interruptMode = 0;\n    while(!isOnSyncQueue(node)) {\n        LockSupport.park(this);\n        if((interruptMode = checkInterruptWhileWaitting(node)) != 0) {\n            break;\n        }\n    }\n    \n    if(acquireQueued(node, savedState) && interruptMode != THROW_IE) {\n        interruptMode = REINTERRUPT;\n    }\n    \n    if(node.nextWaiter != null) {\n        unlinkCancelledWaiters();\n    }\n    \n    if(interruptMode != 0) {\n        reportInterruptAfterWait(interruptMode);\n    }\n}\n```\n\n","slug":"Java/阻塞队列","published":1,"date":"2021-01-29T15:54:28.312Z","updated":"2021-01-29T16:03:53.964Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8ey001nsz5qk2q8rde6","content":"<h2 id=\"什么是阻塞队列\"><a href=\"#什么是阻塞队列\" class=\"headerlink\" title=\"什么是阻塞队列\"></a>什么是阻塞队列</h2><p><code>BlockingQueue</code> 是一个支持两个附加操作的队列。</p>\n<p>在队列为空时，获取元素的线程会等待队列变为非空；当队列满时，存储元素的线程会等待队列可用。<br><a id=\"more\"></a><br>阻塞队列常用于生产消费者模的场景中，生产者是往队列里添加元素的线程；消费者是从队列里拿元素的线程。</p>\n<p>阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素</p>\n<ul>\n<li>ArrayBlockingQueue: 一个由数组结构组成的有界阻塞队列</li>\n<li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列</li>\n<li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列</li>\n<li>DelayQueue: 一个使用优先级排序的无界阻塞队列</li>\n<li>SynchronousQueue：一个不存储元素的阻塞队列</li>\n<li>LinkedTransferQueue: 一个由链表结构组成的无界阻塞队列</li>\n<li>LinkedBlockingDeque：一个由链表组成的双向阻塞队列</li>\n</ul>\n<h2 id=\"阻塞队列的实现原理\"><a href=\"#阻塞队列的实现原理\" class=\"headerlink\" title=\"阻塞队列的实现原理\"></a>阻塞队列的实现原理</h2><p>使用<strong>通知模式</strong>实现</p>\n<p>所谓 <strong>通知模式</strong> 就是当生产者往<strong><code>满的队列</code></strong>里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。</p>\n<p><strong>ArrayBlockingQueue：</strong></p>\n<pre class=\" language-Java\"><code class=\"language-Java\">private final Condition notFull;\nprivate final Condition notEmpty;\n\npublic ArrayBlockingQueue(int capacity, boolean fair) {\n    if (capacity <= 0){\n        throw new IllegalArgumentException();        \n    }\n    this.items = new Object[capacity];\n    lock = new ReentrantLock(fair);\n    notEmpty = lock.newCondition();\n    notFull = lock.newCondition();\n}\n\npublic void put(E e) throws InterruptedException {\n    checkNotNull(e);\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        while(count == items.length) {\n            notFull.await();\n            insert(e);\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\npublic E take() throws InterruptedException {\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        while (count == 0) {\n            notEmpty = await();\n        }\n        return extract();\n    } finally {\n        lock.unlock();\n    }\n}\n\nprivate void insert(E x) {\n    items[putIndex] = x;\n    putIndex = inc(putIndex);\n    ++count;\n    // 唤醒一个等待线程\n    notEmpty.signal();\n} \n</code></pre>\n<p>当我们往队列里插入一个元素时，如果队列不可用，阻塞生产者主要通过 <code>LockSupport.park(this)</code>  来实现</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">interrupted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">InterruptedException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    Node node <span class=\"token operator\">=</span> <span class=\"token function\">addConditionWaiter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> savedState <span class=\"token operator\">=</span> <span class=\"token function\">fullyRelease</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> interruptMode <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">isOnSyncQueue</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        LockSupport<span class=\"token punctuation\">.</span><span class=\"token function\">park</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>interruptMode <span class=\"token operator\">=</span> <span class=\"token function\">checkInterruptWhileWaitting</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">acquireQueued</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">,</span> savedState<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> interruptMode <span class=\"token operator\">!=</span> THROW_IE<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        interruptMode <span class=\"token operator\">=</span> REINTERRUPT<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>nextWaiter <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">unlinkCancelledWaiters</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>interruptMode <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">reportInterruptAfterWait</span><span class=\"token punctuation\">(</span>interruptMode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n","site":{"data":{}},"excerpt":"<h2 id=\"什么是阻塞队列\"><a href=\"#什么是阻塞队列\" class=\"headerlink\" title=\"什么是阻塞队列\"></a>什么是阻塞队列</h2><p><code>BlockingQueue</code> 是一个支持两个附加操作的队列。</p>\n<p>在队列为空时，获取元素的线程会等待队列变为非空；当队列满时，存储元素的线程会等待队列可用。<br>","more":"<br>阻塞队列常用于生产消费者模的场景中，生产者是往队列里添加元素的线程；消费者是从队列里拿元素的线程。</p>\n<p>阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素</p>\n<ul>\n<li>ArrayBlockingQueue: 一个由数组结构组成的有界阻塞队列</li>\n<li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列</li>\n<li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列</li>\n<li>DelayQueue: 一个使用优先级排序的无界阻塞队列</li>\n<li>SynchronousQueue：一个不存储元素的阻塞队列</li>\n<li>LinkedTransferQueue: 一个由链表结构组成的无界阻塞队列</li>\n<li>LinkedBlockingDeque：一个由链表组成的双向阻塞队列</li>\n</ul>\n<h2 id=\"阻塞队列的实现原理\"><a href=\"#阻塞队列的实现原理\" class=\"headerlink\" title=\"阻塞队列的实现原理\"></a>阻塞队列的实现原理</h2><p>使用<strong>通知模式</strong>实现</p>\n<p>所谓 <strong>通知模式</strong> 就是当生产者往<strong><code>满的队列</code></strong>里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。</p>\n<p><strong>ArrayBlockingQueue：</strong></p>\n<pre><code class=\"Java\">private final Condition notFull;\nprivate final Condition notEmpty;\n\npublic ArrayBlockingQueue(int capacity, boolean fair) {\n    if (capacity &lt;= 0){\n        throw new IllegalArgumentException();        \n    }\n    this.items = new Object[capacity];\n    lock = new ReentrantLock(fair);\n    notEmpty = lock.newCondition();\n    notFull = lock.newCondition();\n}\n\npublic void put(E e) throws InterruptedException {\n    checkNotNull(e);\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        while(count == items.length) {\n            notFull.await();\n            insert(e);\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\npublic E take() throws InterruptedException {\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        while (count == 0) {\n            notEmpty = await();\n        }\n        return extract();\n    } finally {\n        lock.unlock();\n    }\n}\n\nprivate void insert(E x) {\n    items[putIndex] = x;\n    putIndex = inc(putIndex);\n    ++count;\n    // 唤醒一个等待线程\n    notEmpty.signal();\n} \n</code></pre>\n<p>当我们往队列里插入一个元素时，如果队列不可用，阻塞生产者主要通过 <code>LockSupport.park(this)</code>  来实现</p>\n<pre><code class=\"java\">public final void await() throws InterruptedException {\n    if(Thread.interrupted()) {\n        throw new InterruptedException();\n    }\n\n    Node node = addConditionWaiter();\n    int savedState = fullyRelease(node);\n    int interruptMode = 0;\n    while(!isOnSyncQueue(node)) {\n        LockSupport.park(this);\n        if((interruptMode = checkInterruptWhileWaitting(node)) != 0) {\n            break;\n        }\n    }\n\n    if(acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) {\n        interruptMode = REINTERRUPT;\n    }\n\n    if(node.nextWaiter != null) {\n        unlinkCancelledWaiters();\n    }\n\n    if(interruptMode != 0) {\n        reportInterruptAfterWait(interruptMode);\n    }\n}\n</code></pre>"},{"title":"Android Room","_content":"\n[翻译自官网文档](https://developer.android.com/reference/android/arch/persistence/room/package-summary?hl=zh-cn)\n\n\n\nRoom 是一个关系映射对象库，可以使我们很方便的访问 App 数据库\n\n* **Database:** 注解用来标记问数据库，该类须继承 RoomDatabase,运行时，可以通过 Room.databaseBuilder 或者获取他的实例 Room.inMemoryDatabasebuilder\n* **Entity:** 将 Model 或 pojo 类，标记为数据库行，每个 Entity 都会创建一个数据库表来保存项目。实体类必须在 Database#entities  数组中引用。除非另有说明，否则 Entity 的每个字段（及其父类）都将 Entity 保留在数据库中\n* **Dao:** 将类或接口标记为数据访问对象。数据访问对象负责定义访问数据库的方法。带有注释的类 Database 必须具有一个带有 0 个参数的抽象方法，并返回带有 Dao 注释的类。\n\n<!-- more-->\n\n``` java\n// File: User.java\n@Entity\npublic class User {\n    @PrimaryKey\n    private int uid;\n    private String name;\n    @ColumnInfo(name = \"last_name\")\n    private String lastName;\n    // Room 请求 set 和 get 方法去访问数据\n}\n\n// File: UserDao.java\n@Dao\npublic interface UserDao {\n    @Query(\"select * from user\") \n    List<User> loadAll();\n    \n    @Query(\"select * from user where uid in (:userIds)\")\n    List<User> loadAllByUserId(int... userIds);\n    \n    @Query(\"select * from user where name like :first and last_name like :last limit 1\")\n    User loadOneByNameAndLastName(String first, String last);\n    \n    @Insert\n    void insertAll(User... users);\n    \n    @Delete\n    void delete(User user);\n}\n\n// File: AppDatabse.java\n@Database(entities = {User.java})\npublic abstract class AppDatabase extends RoomDatabase {\n    public abstract UserDao userDao();\n}\n\n// 创建 AppDatabase 实例\nAppDatabse db = Room.databaseBuilder(getApplicationContext(), AppDatabase.class, \"database_name\").build();\n```\n\n一旦 Room 在编译期，就开始检测注解，扫描所有可以访问的表/\n\n可以通过使用 `InvalidtaionTracker` 类来观察一个数据表的变化。\n\nRoom 允许通过 `Query`  方法返回一个 `LiveData` 类型的数据。它会自动观察相关数据表，一旦发生数据改变，就会触发 `LiveData` 的观察者\n\n\n\n```java\n// LiveData 会自动分发数据表的改变\n@Query(\"Select * from user order by name limit 5\") \npublic LiveData<List<User>> loadFirstFiveUsers();\n```\n\n","source":"_posts/Jetpack/Android Room.md","raw":"---\ntitle: Android Room\ntag: Android\n---\n\n[翻译自官网文档](https://developer.android.com/reference/android/arch/persistence/room/package-summary?hl=zh-cn)\n\n\n\nRoom 是一个关系映射对象库，可以使我们很方便的访问 App 数据库\n\n* **Database:** 注解用来标记问数据库，该类须继承 RoomDatabase,运行时，可以通过 Room.databaseBuilder 或者获取他的实例 Room.inMemoryDatabasebuilder\n* **Entity:** 将 Model 或 pojo 类，标记为数据库行，每个 Entity 都会创建一个数据库表来保存项目。实体类必须在 Database#entities  数组中引用。除非另有说明，否则 Entity 的每个字段（及其父类）都将 Entity 保留在数据库中\n* **Dao:** 将类或接口标记为数据访问对象。数据访问对象负责定义访问数据库的方法。带有注释的类 Database 必须具有一个带有 0 个参数的抽象方法，并返回带有 Dao 注释的类。\n\n<!-- more-->\n\n``` java\n// File: User.java\n@Entity\npublic class User {\n    @PrimaryKey\n    private int uid;\n    private String name;\n    @ColumnInfo(name = \"last_name\")\n    private String lastName;\n    // Room 请求 set 和 get 方法去访问数据\n}\n\n// File: UserDao.java\n@Dao\npublic interface UserDao {\n    @Query(\"select * from user\") \n    List<User> loadAll();\n    \n    @Query(\"select * from user where uid in (:userIds)\")\n    List<User> loadAllByUserId(int... userIds);\n    \n    @Query(\"select * from user where name like :first and last_name like :last limit 1\")\n    User loadOneByNameAndLastName(String first, String last);\n    \n    @Insert\n    void insertAll(User... users);\n    \n    @Delete\n    void delete(User user);\n}\n\n// File: AppDatabse.java\n@Database(entities = {User.java})\npublic abstract class AppDatabase extends RoomDatabase {\n    public abstract UserDao userDao();\n}\n\n// 创建 AppDatabase 实例\nAppDatabse db = Room.databaseBuilder(getApplicationContext(), AppDatabase.class, \"database_name\").build();\n```\n\n一旦 Room 在编译期，就开始检测注解，扫描所有可以访问的表/\n\n可以通过使用 `InvalidtaionTracker` 类来观察一个数据表的变化。\n\nRoom 允许通过 `Query`  方法返回一个 `LiveData` 类型的数据。它会自动观察相关数据表，一旦发生数据改变，就会触发 `LiveData` 的观察者\n\n\n\n```java\n// LiveData 会自动分发数据表的改变\n@Query(\"Select * from user order by name limit 5\") \npublic LiveData<List<User>> loadFirstFiveUsers();\n```\n\n","slug":"Jetpack/Android Room","published":1,"date":"2021-01-29T15:54:28.312Z","updated":"2021-01-29T16:04:45.937Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8ez001qsz5q15ozfm8z","content":"<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvYXJjaC9wZXJzaXN0ZW5jZS9yb29tL3BhY2thZ2Utc3VtbWFyeT9obD16aC1jbg==\" title=\"https://developer.android.com/reference/android/arch/persistence/room/package-summary?hl=zh-cn\">翻译自官网文档<i class=\"fa fa-external-link\"></i></span></p>\n<p>Room 是一个关系映射对象库，可以使我们很方便的访问 App 数据库</p>\n<ul>\n<li><strong>Database:</strong> 注解用来标记问数据库，该类须继承 RoomDatabase,运行时，可以通过 Room.databaseBuilder 或者获取他的实例 Room.inMemoryDatabasebuilder</li>\n<li><strong>Entity:</strong> 将 Model 或 pojo 类，标记为数据库行，每个 Entity 都会创建一个数据库表来保存项目。实体类必须在 Database#entities  数组中引用。除非另有说明，否则 Entity 的每个字段（及其父类）都将 Entity 保留在数据库中</li>\n<li><strong>Dao:</strong> 将类或接口标记为数据访问对象。数据访问对象负责定义访问数据库的方法。带有注释的类 Database 必须具有一个带有 0 个参数的抽象方法，并返回带有 Dao 注释的类。</li>\n</ul>\n<a id=\"more\"></a>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// File: User.java</span>\n<span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">User</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@PrimaryKey</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> uid<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> String name<span class=\"token punctuation\">;</span>\n    <span class=\"token annotation punctuation\">@ColumnInfo</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"last_name\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> String lastName<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Room 请求 set 和 get 方法去访问数据</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// File: UserDao.java</span>\n<span class=\"token annotation punctuation\">@Dao</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">UserDao</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Query</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"select * from user\"</span><span class=\"token punctuation\">)</span> \n    List<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span> <span class=\"token function\">loadAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@Query</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"select * from user where uid in (:userIds)\"</span><span class=\"token punctuation\">)</span>\n    List<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span> <span class=\"token function\">loadAllByUserId</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> userIds<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@Query</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"select * from user where name like :first and last_name like :last limit 1\"</span><span class=\"token punctuation\">)</span>\n    User <span class=\"token function\">loadOneByNameAndLastName</span><span class=\"token punctuation\">(</span>String first<span class=\"token punctuation\">,</span> String last<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@Insert</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">insertAll</span><span class=\"token punctuation\">(</span>User<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> users<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@Delete</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">delete</span><span class=\"token punctuation\">(</span>User user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// File: AppDatabse.java</span>\n<span class=\"token annotation punctuation\">@Database</span><span class=\"token punctuation\">(</span>entities <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>User<span class=\"token punctuation\">.</span>java<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AppDatabase</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">RoomDatabase</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> UserDao <span class=\"token function\">userDao</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 创建 AppDatabase 实例</span>\nAppDatabse db <span class=\"token operator\">=</span> Room<span class=\"token punctuation\">.</span><span class=\"token function\">databaseBuilder</span><span class=\"token punctuation\">(</span><span class=\"token function\">getApplicationContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> AppDatabase<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"database_name\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>一旦 Room 在编译期，就开始检测注解，扫描所有可以访问的表/</p>\n<p>可以通过使用 <code>InvalidtaionTracker</code> 类来观察一个数据表的变化。</p>\n<p>Room 允许通过 <code>Query</code>  方法返回一个 <code>LiveData</code> 类型的数据。它会自动观察相关数据表，一旦发生数据改变，就会触发 <code>LiveData</code> 的观察者</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// LiveData 会自动分发数据表的改变</span>\n<span class=\"token annotation punctuation\">@Query</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Select * from user order by name limit 5\"</span><span class=\"token punctuation\">)</span> \n<span class=\"token keyword\">public</span> LiveData<span class=\"token operator\">&lt;</span>List<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">>></span> <span class=\"token function\">loadFirstFiveUsers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n","site":{"data":{}},"excerpt":"<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvYXJjaC9wZXJzaXN0ZW5jZS9yb29tL3BhY2thZ2Utc3VtbWFyeT9obD16aC1jbg==\" title=\"https://developer.android.com/reference/android/arch/persistence/room/package-summary?hl=zh-cn\">翻译自官网文档<i class=\"fa fa-external-link\"></i></span></p>\n<p>Room 是一个关系映射对象库，可以使我们很方便的访问 App 数据库</p>\n<ul>\n<li><strong>Database:</strong> 注解用来标记问数据库，该类须继承 RoomDatabase,运行时，可以通过 Room.databaseBuilder 或者获取他的实例 Room.inMemoryDatabasebuilder</li>\n<li><strong>Entity:</strong> 将 Model 或 pojo 类，标记为数据库行，每个 Entity 都会创建一个数据库表来保存项目。实体类必须在 Database#entities  数组中引用。除非另有说明，否则 Entity 的每个字段（及其父类）都将 Entity 保留在数据库中</li>\n<li><strong>Dao:</strong> 将类或接口标记为数据访问对象。数据访问对象负责定义访问数据库的方法。带有注释的类 Database 必须具有一个带有 0 个参数的抽象方法，并返回带有 Dao 注释的类。</li>\n</ul>","more":"<pre><code class=\"java\">// File: User.java\n@Entity\npublic class User {\n    @PrimaryKey\n    private int uid;\n    private String name;\n    @ColumnInfo(name = &quot;last_name&quot;)\n    private String lastName;\n    // Room 请求 set 和 get 方法去访问数据\n}\n\n// File: UserDao.java\n@Dao\npublic interface UserDao {\n    @Query(&quot;select * from user&quot;) \n    List&lt;User&gt; loadAll();\n\n    @Query(&quot;select * from user where uid in (:userIds)&quot;)\n    List&lt;User&gt; loadAllByUserId(int... userIds);\n\n    @Query(&quot;select * from user where name like :first and last_name like :last limit 1&quot;)\n    User loadOneByNameAndLastName(String first, String last);\n\n    @Insert\n    void insertAll(User... users);\n\n    @Delete\n    void delete(User user);\n}\n\n// File: AppDatabse.java\n@Database(entities = {User.java})\npublic abstract class AppDatabase extends RoomDatabase {\n    public abstract UserDao userDao();\n}\n\n// 创建 AppDatabase 实例\nAppDatabse db = Room.databaseBuilder(getApplicationContext(), AppDatabase.class, &quot;database_name&quot;).build();\n</code></pre>\n<p>一旦 Room 在编译期，就开始检测注解，扫描所有可以访问的表/</p>\n<p>可以通过使用 <code>InvalidtaionTracker</code> 类来观察一个数据表的变化。</p>\n<p>Room 允许通过 <code>Query</code>  方法返回一个 <code>LiveData</code> 类型的数据。它会自动观察相关数据表，一旦发生数据改变，就会触发 <code>LiveData</code> 的观察者</p>\n<pre><code class=\"java\">// LiveData 会自动分发数据表的改变\n@Query(&quot;Select * from user order by name limit 5&quot;) \npublic LiveData&lt;List&lt;User&gt;&gt; loadFirstFiveUsers();\n</code></pre>"},{"title":"Android 架构组件","_content":"\n\n\n## 应用架构指南\n\n* 当您在自己喜欢的社交网络应用中分享照片时会发生什么：\n  1. 该应用将触发相机 Intent。 Android 操作系统随后会启动相机应用来处理请求。此时，用户已离开社交应用，但他们的体验仍然是无缝的\n  2. 相机应用可能会触发其他 intent（如启动文件选择器），而这可能会再启动一个应用\n  3. 最后，用户返回社交网络应用并分享照片\n<!-- more-->\n此过程中，用户随时可能会被电话或通知打断。处理之后，用户希望能够返回并继续分享照片。这种应用跳跃行为再移动设备上很常见，因此应用必须正确处理这些流程。\n\n移动设备的资源也是有限的，因此操作系统可能会随时终止某些应用进程，一边为新的进程腾出空间\n\n因此，不应该再应用组件中存储任何应用数据或状态，并且应用组件不应相互依赖\n\n## 常见架构原则\n\n### 分离关注点\n\n常见错误是再 `activity` 和 `fragment` 中编写所有代码。这些基于界面的类应仅包含处理界面的操作系统交互的逻辑。您应使用这些类尽可能的保持精简，这样可以避免许多生命周期相关的问题\n\n### 通过模型驱动界面\n\n通过模型驱动界面（最好是持久性模型）。模型是负责处理应用数据的组件。独立于应用中的 View 对象和应用组件，因此不受应用生命周期以及相关的关注点影响。\n\n持久性是思想之选，原因如下:\n\n\t1. 如果 Android 操作系统销毁应用以释放资源，用户不会丢失数据\n\t2. 当网络连接不稳定或不可用时，应用会继续工作\n\n应用所基于的模型类应明确数据管理职责，这样使应用更可测试且更一致。\n\n\n\n## 推荐应用架构\n\n![img](https://developer.android.com/topic/libraries/architecture/images/final-architecture.png)\n\n每个组件仅依赖于其下一级的组件。例如，Activity和Fragment 依赖于视图模型。存储区是唯一依赖于其他多个类的类；再本例中，存储区依赖于持久性数据模型和远程后端数据源。\n\n这种设计打造了一致且愉快的用户体验。无论用户上次使用应用是再几分钟前还是几天前，现在回到应用时都会立即看到应用再本地保留的用户信息。如果此数据已过时，则应用的存储区模块将开始再后台更新数据。\n\n\n\n## 构建界面\n\n界面由Fragment `UserProfileFragment` 及其对应的布局文件 `user_profile_layout.xml` 组成\n\n如需驱动该界面，数据模型需要存储以下数据元素\n\n* 用户 ID： 用户的标识符。最好使用 Fragment 参数将此信息传递到相关的 Fragment中。如果 Android 系统销毁我们的进场，此类信息将保留，以便下次重启应用时 ID 可用。\n* 用户对象：用于存储用户详细信息的数据类\n\n> ViewModel 对象为特定的界面组件（如 Fragment 和 Activity）提供数据，并包含数据处理业务逻辑，以与模型进行通信。例如，View Model 可以调用其他组件来加载数据，还可以转发用户请求来修改数据。 View Model 不了解界面组件，因此不受配置更改（如再旋转设备时重新创建 Activity）的影响\n\n* `user_profile.xml` : 屏幕的界面布局\n* `UserProfileFragment`：显示数据的界面控制器\n* `UserProfileViewModel` : 准备数据以便再 `UserProfileFragment` 中查看并对用户互动做出响应的类\n\n**UserProfileViewModel**\n\n```kotlin\nclass UserProfileViewModel: ViewModel(){\n\tval userId:String = TODO()\n    val user: User = TODO()\n}\n```\n\n**UserProfileFragment**\n\n```kotlin\nclass UserProfileFragment: Fragment(){\n    // 使用 ViewModels() 拓展函数，以及 \"androidx.fragment:fragment-ktx:lastest-version\" 在 模块下的 build.gradle \n    private val viewModel: UserProfileViewModel by viewModels()\n    \n    override fun onCreateView(\n    inflater: LayoutInflater,\n    container: ViewGroup?,\n    savedInstanceState: Bundle?): View {\n        return inflater.infalte(R.layout.main_fragment, container, false)\n    }\n}\n```\n\n现在，由了这些代码块，需要将他们串联起来，毕竟在 `UserProfileViewModel` 类中设置 `user` 字段时，我们需要一种方法来通知界面\n\n要获取 `user` 我们的 `ViewModel` 需要访问 Fragment 参数。我们可以通过 fragment 传递，或者更好的办法时使用 `SaveState` 模块，我们可以让 View Model 直接读取参数\n\n> SavedStateHandle 允许 ViewModel 访问相关 Fragment 或 Activity 的已保存状态和参数\n\n```kotlin\n// UserProfileViewModel\nclass UserProfileViewModel (savedStatedHandle: SavedStateHandle) :ViewModel(){\n    val userId:String = savedStateHandle[\"uid\"] ?: throw IllegalArgumentException(\"missing user id\")\n    val user: User = TODO()\n}\n\n// UserProfileFragment\nprivate val viewModel: UserProfileViewModel by viewModels(\n    factoryProducer = {SavedStateVMFactory(this)}\n)\n```\n\n\n\n","source":"_posts/Jetpack/Android架构组件.md","raw":"---\ntitle: Android 架构组件\ntag: Android\n---\n\n\n\n## 应用架构指南\n\n* 当您在自己喜欢的社交网络应用中分享照片时会发生什么：\n  1. 该应用将触发相机 Intent。 Android 操作系统随后会启动相机应用来处理请求。此时，用户已离开社交应用，但他们的体验仍然是无缝的\n  2. 相机应用可能会触发其他 intent（如启动文件选择器），而这可能会再启动一个应用\n  3. 最后，用户返回社交网络应用并分享照片\n<!-- more-->\n此过程中，用户随时可能会被电话或通知打断。处理之后，用户希望能够返回并继续分享照片。这种应用跳跃行为再移动设备上很常见，因此应用必须正确处理这些流程。\n\n移动设备的资源也是有限的，因此操作系统可能会随时终止某些应用进程，一边为新的进程腾出空间\n\n因此，不应该再应用组件中存储任何应用数据或状态，并且应用组件不应相互依赖\n\n## 常见架构原则\n\n### 分离关注点\n\n常见错误是再 `activity` 和 `fragment` 中编写所有代码。这些基于界面的类应仅包含处理界面的操作系统交互的逻辑。您应使用这些类尽可能的保持精简，这样可以避免许多生命周期相关的问题\n\n### 通过模型驱动界面\n\n通过模型驱动界面（最好是持久性模型）。模型是负责处理应用数据的组件。独立于应用中的 View 对象和应用组件，因此不受应用生命周期以及相关的关注点影响。\n\n持久性是思想之选，原因如下:\n\n\t1. 如果 Android 操作系统销毁应用以释放资源，用户不会丢失数据\n\t2. 当网络连接不稳定或不可用时，应用会继续工作\n\n应用所基于的模型类应明确数据管理职责，这样使应用更可测试且更一致。\n\n\n\n## 推荐应用架构\n\n![img](https://developer.android.com/topic/libraries/architecture/images/final-architecture.png)\n\n每个组件仅依赖于其下一级的组件。例如，Activity和Fragment 依赖于视图模型。存储区是唯一依赖于其他多个类的类；再本例中，存储区依赖于持久性数据模型和远程后端数据源。\n\n这种设计打造了一致且愉快的用户体验。无论用户上次使用应用是再几分钟前还是几天前，现在回到应用时都会立即看到应用再本地保留的用户信息。如果此数据已过时，则应用的存储区模块将开始再后台更新数据。\n\n\n\n## 构建界面\n\n界面由Fragment `UserProfileFragment` 及其对应的布局文件 `user_profile_layout.xml` 组成\n\n如需驱动该界面，数据模型需要存储以下数据元素\n\n* 用户 ID： 用户的标识符。最好使用 Fragment 参数将此信息传递到相关的 Fragment中。如果 Android 系统销毁我们的进场，此类信息将保留，以便下次重启应用时 ID 可用。\n* 用户对象：用于存储用户详细信息的数据类\n\n> ViewModel 对象为特定的界面组件（如 Fragment 和 Activity）提供数据，并包含数据处理业务逻辑，以与模型进行通信。例如，View Model 可以调用其他组件来加载数据，还可以转发用户请求来修改数据。 View Model 不了解界面组件，因此不受配置更改（如再旋转设备时重新创建 Activity）的影响\n\n* `user_profile.xml` : 屏幕的界面布局\n* `UserProfileFragment`：显示数据的界面控制器\n* `UserProfileViewModel` : 准备数据以便再 `UserProfileFragment` 中查看并对用户互动做出响应的类\n\n**UserProfileViewModel**\n\n```kotlin\nclass UserProfileViewModel: ViewModel(){\n\tval userId:String = TODO()\n    val user: User = TODO()\n}\n```\n\n**UserProfileFragment**\n\n```kotlin\nclass UserProfileFragment: Fragment(){\n    // 使用 ViewModels() 拓展函数，以及 \"androidx.fragment:fragment-ktx:lastest-version\" 在 模块下的 build.gradle \n    private val viewModel: UserProfileViewModel by viewModels()\n    \n    override fun onCreateView(\n    inflater: LayoutInflater,\n    container: ViewGroup?,\n    savedInstanceState: Bundle?): View {\n        return inflater.infalte(R.layout.main_fragment, container, false)\n    }\n}\n```\n\n现在，由了这些代码块，需要将他们串联起来，毕竟在 `UserProfileViewModel` 类中设置 `user` 字段时，我们需要一种方法来通知界面\n\n要获取 `user` 我们的 `ViewModel` 需要访问 Fragment 参数。我们可以通过 fragment 传递，或者更好的办法时使用 `SaveState` 模块，我们可以让 View Model 直接读取参数\n\n> SavedStateHandle 允许 ViewModel 访问相关 Fragment 或 Activity 的已保存状态和参数\n\n```kotlin\n// UserProfileViewModel\nclass UserProfileViewModel (savedStatedHandle: SavedStateHandle) :ViewModel(){\n    val userId:String = savedStateHandle[\"uid\"] ?: throw IllegalArgumentException(\"missing user id\")\n    val user: User = TODO()\n}\n\n// UserProfileFragment\nprivate val viewModel: UserProfileViewModel by viewModels(\n    factoryProducer = {SavedStateVMFactory(this)}\n)\n```\n\n\n\n","slug":"Jetpack/Android架构组件","published":1,"date":"2021-01-29T15:54:28.313Z","updated":"2021-01-29T16:04:41.495Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8f7001ssz5quh6h2vqj","content":"<h2 id=\"应用架构指南\"><a href=\"#应用架构指南\" class=\"headerlink\" title=\"应用架构指南\"></a>应用架构指南</h2><ul>\n<li>当您在自己喜欢的社交网络应用中分享照片时会发生什么：<ol>\n<li>该应用将触发相机 Intent。 Android 操作系统随后会启动相机应用来处理请求。此时，用户已离开社交应用，但他们的体验仍然是无缝的</li>\n<li>相机应用可能会触发其他 intent（如启动文件选择器），而这可能会再启动一个应用</li>\n<li>最后，用户返回社交网络应用并分享照片<a id=\"more\"></a>\n此过程中，用户随时可能会被电话或通知打断。处理之后，用户希望能够返回并继续分享照片。这种应用跳跃行为再移动设备上很常见，因此应用必须正确处理这些流程。</li>\n</ol>\n</li>\n</ul>\n<p>移动设备的资源也是有限的，因此操作系统可能会随时终止某些应用进程，一边为新的进程腾出空间</p>\n<p>因此，不应该再应用组件中存储任何应用数据或状态，并且应用组件不应相互依赖</p>\n<h2 id=\"常见架构原则\"><a href=\"#常见架构原则\" class=\"headerlink\" title=\"常见架构原则\"></a>常见架构原则</h2><h3 id=\"分离关注点\"><a href=\"#分离关注点\" class=\"headerlink\" title=\"分离关注点\"></a>分离关注点</h3><p>常见错误是再 <code>activity</code> 和 <code>fragment</code> 中编写所有代码。这些基于界面的类应仅包含处理界面的操作系统交互的逻辑。您应使用这些类尽可能的保持精简，这样可以避免许多生命周期相关的问题</p>\n<h3 id=\"通过模型驱动界面\"><a href=\"#通过模型驱动界面\" class=\"headerlink\" title=\"通过模型驱动界面\"></a>通过模型驱动界面</h3><p>通过模型驱动界面（最好是持久性模型）。模型是负责处理应用数据的组件。独立于应用中的 View 对象和应用组件，因此不受应用生命周期以及相关的关注点影响。</p>\n<p>持久性是思想之选，原因如下:</p>\n<pre><code>1. 如果 Android 操作系统销毁应用以释放资源，用户不会丢失数据\n2. 当网络连接不稳定或不可用时，应用会继续工作\n</code></pre><p>应用所基于的模型类应明确数据管理职责，这样使应用更可测试且更一致。</p>\n<h2 id=\"推荐应用架构\"><a href=\"#推荐应用架构\" class=\"headerlink\" title=\"推荐应用架构\"></a>推荐应用架构</h2><p><img src=\"https://developer.android.com/topic/libraries/architecture/images/final-architecture.png\" alt=\"img\"></p>\n<p>每个组件仅依赖于其下一级的组件。例如，Activity和Fragment 依赖于视图模型。存储区是唯一依赖于其他多个类的类；再本例中，存储区依赖于持久性数据模型和远程后端数据源。</p>\n<p>这种设计打造了一致且愉快的用户体验。无论用户上次使用应用是再几分钟前还是几天前，现在回到应用时都会立即看到应用再本地保留的用户信息。如果此数据已过时，则应用的存储区模块将开始再后台更新数据。</p>\n<h2 id=\"构建界面\"><a href=\"#构建界面\" class=\"headerlink\" title=\"构建界面\"></a>构建界面</h2><p>界面由Fragment <code>UserProfileFragment</code> 及其对应的布局文件 <code>user_profile_layout.xml</code> 组成</p>\n<p>如需驱动该界面，数据模型需要存储以下数据元素</p>\n<ul>\n<li>用户 ID： 用户的标识符。最好使用 Fragment 参数将此信息传递到相关的 Fragment中。如果 Android 系统销毁我们的进场，此类信息将保留，以便下次重启应用时 ID 可用。</li>\n<li>用户对象：用于存储用户详细信息的数据类</li>\n</ul>\n<blockquote>\n<p>ViewModel 对象为特定的界面组件（如 Fragment 和 Activity）提供数据，并包含数据处理业务逻辑，以与模型进行通信。例如，View Model 可以调用其他组件来加载数据，还可以转发用户请求来修改数据。 View Model 不了解界面组件，因此不受配置更改（如再旋转设备时重新创建 Activity）的影响</p>\n</blockquote>\n<ul>\n<li><code>user_profile.xml</code> : 屏幕的界面布局</li>\n<li><code>UserProfileFragment</code>：显示数据的界面控制器</li>\n<li><code>UserProfileViewModel</code> : 准备数据以便再 <code>UserProfileFragment</code> 中查看并对用户互动做出响应的类</li>\n</ul>\n<p><strong>UserProfileViewModel</strong></p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">class</span> UserProfileViewModel<span class=\"token operator\">:</span> <span class=\"token function\">ViewModel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> userId<span class=\"token operator\">:</span>String <span class=\"token operator\">=</span> <span class=\"token function\">TODO</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">val</span> user<span class=\"token operator\">:</span> User <span class=\"token operator\">=</span> <span class=\"token function\">TODO</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>UserProfileFragment</strong></p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">class</span> UserProfileFragment<span class=\"token operator\">:</span> <span class=\"token function\">Fragment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 使用 ViewModels() 拓展函数，以及 \"androidx.fragment:fragment-ktx:lastest-version\" 在 模块下的 build.gradle </span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">val</span> viewModel<span class=\"token operator\">:</span> UserProfileViewModel <span class=\"token keyword\">by</span> <span class=\"token function\">viewModels</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">onCreateView</span><span class=\"token punctuation\">(</span>\n    inflater<span class=\"token operator\">:</span> LayoutInflater<span class=\"token punctuation\">,</span>\n    container<span class=\"token operator\">:</span> ViewGroup<span class=\"token operator\">?</span><span class=\"token punctuation\">,</span>\n    savedInstanceState<span class=\"token operator\">:</span> Bundle<span class=\"token operator\">?</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> View <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> inflater<span class=\"token punctuation\">.</span><span class=\"token function\">infalte</span><span class=\"token punctuation\">(</span>R<span class=\"token punctuation\">.</span>layout<span class=\"token punctuation\">.</span>main_fragment<span class=\"token punctuation\">,</span> container<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>现在，由了这些代码块，需要将他们串联起来，毕竟在 <code>UserProfileViewModel</code> 类中设置 <code>user</code> 字段时，我们需要一种方法来通知界面</p>\n<p>要获取 <code>user</code> 我们的 <code>ViewModel</code> 需要访问 Fragment 参数。我们可以通过 fragment 传递，或者更好的办法时使用 <code>SaveState</code> 模块，我们可以让 View Model 直接读取参数</p>\n<blockquote>\n<p>SavedStateHandle 允许 ViewModel 访问相关 Fragment 或 Activity 的已保存状态和参数</p>\n</blockquote>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token comment\" spellcheck=\"true\">// UserProfileViewModel</span>\n<span class=\"token keyword\">class</span> <span class=\"token function\">UserProfileViewModel</span> <span class=\"token punctuation\">(</span>savedStatedHandle<span class=\"token operator\">:</span> SavedStateHandle<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span><span class=\"token function\">ViewModel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> userId<span class=\"token operator\">:</span>String <span class=\"token operator\">=</span> savedStateHandle<span class=\"token punctuation\">[</span><span class=\"token string\">\"uid\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">?:</span> <span class=\"token keyword\">throw</span> <span class=\"token function\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"missing user id\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">val</span> user<span class=\"token operator\">:</span> User <span class=\"token operator\">=</span> <span class=\"token function\">TODO</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// UserProfileFragment</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">val</span> viewModel<span class=\"token operator\">:</span> UserProfileViewModel <span class=\"token keyword\">by</span> <span class=\"token function\">viewModels</span><span class=\"token punctuation\">(</span>\n    factoryProducer <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token function\">SavedStateVMFactory</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span>\n</code></pre>\n","site":{"data":{}},"excerpt":"<h2 id=\"应用架构指南\"><a href=\"#应用架构指南\" class=\"headerlink\" title=\"应用架构指南\"></a>应用架构指南</h2><ul>\n<li>当您在自己喜欢的社交网络应用中分享照片时会发生什么：<ol>\n<li>该应用将触发相机 Intent。 Android 操作系统随后会启动相机应用来处理请求。此时，用户已离开社交应用，但他们的体验仍然是无缝的</li>\n<li>相机应用可能会触发其他 intent（如启动文件选择器），而这可能会再启动一个应用</li>\n<li>最后，用户返回社交网络应用并分享照片","more":"此过程中，用户随时可能会被电话或通知打断。处理之后，用户希望能够返回并继续分享照片。这种应用跳跃行为再移动设备上很常见，因此应用必须正确处理这些流程。</li>\n</ol>\n</li>\n</ul>\n<p>移动设备的资源也是有限的，因此操作系统可能会随时终止某些应用进程，一边为新的进程腾出空间</p>\n<p>因此，不应该再应用组件中存储任何应用数据或状态，并且应用组件不应相互依赖</p>\n<h2 id=\"常见架构原则\"><a href=\"#常见架构原则\" class=\"headerlink\" title=\"常见架构原则\"></a>常见架构原则</h2><h3 id=\"分离关注点\"><a href=\"#分离关注点\" class=\"headerlink\" title=\"分离关注点\"></a>分离关注点</h3><p>常见错误是再 <code>activity</code> 和 <code>fragment</code> 中编写所有代码。这些基于界面的类应仅包含处理界面的操作系统交互的逻辑。您应使用这些类尽可能的保持精简，这样可以避免许多生命周期相关的问题</p>\n<h3 id=\"通过模型驱动界面\"><a href=\"#通过模型驱动界面\" class=\"headerlink\" title=\"通过模型驱动界面\"></a>通过模型驱动界面</h3><p>通过模型驱动界面（最好是持久性模型）。模型是负责处理应用数据的组件。独立于应用中的 View 对象和应用组件，因此不受应用生命周期以及相关的关注点影响。</p>\n<p>持久性是思想之选，原因如下:</p>\n<pre><code>1. 如果 Android 操作系统销毁应用以释放资源，用户不会丢失数据\n2. 当网络连接不稳定或不可用时，应用会继续工作\n</code></pre><p>应用所基于的模型类应明确数据管理职责，这样使应用更可测试且更一致。</p>\n<h2 id=\"推荐应用架构\"><a href=\"#推荐应用架构\" class=\"headerlink\" title=\"推荐应用架构\"></a>推荐应用架构</h2><p><img src=\"https://developer.android.com/topic/libraries/architecture/images/final-architecture.png\" alt=\"img\"></p>\n<p>每个组件仅依赖于其下一级的组件。例如，Activity和Fragment 依赖于视图模型。存储区是唯一依赖于其他多个类的类；再本例中，存储区依赖于持久性数据模型和远程后端数据源。</p>\n<p>这种设计打造了一致且愉快的用户体验。无论用户上次使用应用是再几分钟前还是几天前，现在回到应用时都会立即看到应用再本地保留的用户信息。如果此数据已过时，则应用的存储区模块将开始再后台更新数据。</p>\n<h2 id=\"构建界面\"><a href=\"#构建界面\" class=\"headerlink\" title=\"构建界面\"></a>构建界面</h2><p>界面由Fragment <code>UserProfileFragment</code> 及其对应的布局文件 <code>user_profile_layout.xml</code> 组成</p>\n<p>如需驱动该界面，数据模型需要存储以下数据元素</p>\n<ul>\n<li>用户 ID： 用户的标识符。最好使用 Fragment 参数将此信息传递到相关的 Fragment中。如果 Android 系统销毁我们的进场，此类信息将保留，以便下次重启应用时 ID 可用。</li>\n<li>用户对象：用于存储用户详细信息的数据类</li>\n</ul>\n<blockquote>\n<p>ViewModel 对象为特定的界面组件（如 Fragment 和 Activity）提供数据，并包含数据处理业务逻辑，以与模型进行通信。例如，View Model 可以调用其他组件来加载数据，还可以转发用户请求来修改数据。 View Model 不了解界面组件，因此不受配置更改（如再旋转设备时重新创建 Activity）的影响</p>\n</blockquote>\n<ul>\n<li><code>user_profile.xml</code> : 屏幕的界面布局</li>\n<li><code>UserProfileFragment</code>：显示数据的界面控制器</li>\n<li><code>UserProfileViewModel</code> : 准备数据以便再 <code>UserProfileFragment</code> 中查看并对用户互动做出响应的类</li>\n</ul>\n<p><strong>UserProfileViewModel</strong></p>\n<pre><code class=\"kotlin\">class UserProfileViewModel: ViewModel(){\n    val userId:String = TODO()\n    val user: User = TODO()\n}\n</code></pre>\n<p><strong>UserProfileFragment</strong></p>\n<pre><code class=\"kotlin\">class UserProfileFragment: Fragment(){\n    // 使用 ViewModels() 拓展函数，以及 &quot;androidx.fragment:fragment-ktx:lastest-version&quot; 在 模块下的 build.gradle \n    private val viewModel: UserProfileViewModel by viewModels()\n\n    override fun onCreateView(\n    inflater: LayoutInflater,\n    container: ViewGroup?,\n    savedInstanceState: Bundle?): View {\n        return inflater.infalte(R.layout.main_fragment, container, false)\n    }\n}\n</code></pre>\n<p>现在，由了这些代码块，需要将他们串联起来，毕竟在 <code>UserProfileViewModel</code> 类中设置 <code>user</code> 字段时，我们需要一种方法来通知界面</p>\n<p>要获取 <code>user</code> 我们的 <code>ViewModel</code> 需要访问 Fragment 参数。我们可以通过 fragment 传递，或者更好的办法时使用 <code>SaveState</code> 模块，我们可以让 View Model 直接读取参数</p>\n<blockquote>\n<p>SavedStateHandle 允许 ViewModel 访问相关 Fragment 或 Activity 的已保存状态和参数</p>\n</blockquote>\n<pre><code class=\"kotlin\">// UserProfileViewModel\nclass UserProfileViewModel (savedStatedHandle: SavedStateHandle) :ViewModel(){\n    val userId:String = savedStateHandle[&quot;uid&quot;] ?: throw IllegalArgumentException(&quot;missing user id&quot;)\n    val user: User = TODO()\n}\n\n// UserProfileFragment\nprivate val viewModel: UserProfileViewModel by viewModels(\n    factoryProducer = {SavedStateVMFactory(this)}\n)\n</code></pre>"},{"title":"Android Data Binding","_content":"\n# Data Binding\n\n## 概念\n\n### 布局和绑定表达式 \n\n借助表达式语言，可以编写将变量关联到布局中的视图的表达式。数据绑定库会自动生成将布局中的视图与数据对象绑定所需的类。该库提供了可在布局中使用的导入、变量和包含等功能。\n<!-- more-->\n该库的这些功能可与您的选优布局无缝共享。例如可以在表达式中使用的绑定变量在 `data` 元素（界面布局根元素的同级）内定义。这两个元素都封装在 `layout` 标记中。\n\n```xml\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        xmlns:app=\"http://scheams.android.com/apk/res-auto\">\n\t<data>\n    \t<variable\n                  name=\"viewModel\"\n                  type=\"com.myapp.data.ViewModel\">\n        </variable>\n    </data>\n    \n    <ConstraintLayout>\n    \t<!-- UI layout`s root element-->\n    </ConstraintLayout>\n</layout>\n```\n\n### 使用可观察的数据对象\n\n\n\n数据绑定库提供了可让您轻松地观察数据更改情况的类和方法。不必操心在底层始建于发生更改时刷新界面。可以将变量或其他属性设为可观察。借助该库，可以将对象、字段或集合设为可观察。\n\n### 生成的绑定类\n\n数据绑定库可以生成用于访问布局变量和视图的绑定类。此页面展示了如何使用和自定义所生成的绑定类。\n\n### 绑定适配器\n\n每一个布局表达式都又一个对应的绑定适配器，要求必须进行框架调用来设置响应的属性或监听。例如，绑定适配器负责调用 `setText()` 方法来设置文本属性，或者调用 `setOnClickListener()` 方法向点击事件添加监听器。最常用的帮i的那个适配器（例如针对本页面的示例中使用的 `android:text` 属性）可供您在 `android.databinding.adapters` 软件包中使用。也可以自定义适配器\n\n``` kotlin\n@BindingAdapter(\"app:goneUnless\") \nfun goneUnless(view: View, visiable: Boolean) {\n    view.visibility = if (visiable) View.VISIABLE else View.GONE\n}\n```\n\n\n### 双向数据绑定\n\n数据绑定库支持双向数据绑定。此类绑定使用的表示法支持以下操作：接收对属性的数据更改，同时监听用户对此属性的更新\n\n## 使用入门\n\n### 编译环境\n\n要开始使用数据绑定，从 Android SDK 管理器中的 **支持代码库** 下载。要将应用配置为使用配置绑定，需要在应用模块的 `build.gradle` 文件中添加 `databinding` 元素\n\n```groovy\nandroid{\n    ...\n        dataBinding{\n            enabled = true\n        }\n}\n```\n\n> 即使应用模块不直接使用数据绑定，也必须为依赖于与使用数据绑定库的应用模块配置数据绑定\n\n### 布局和绑定表达式\n\n借助表达式语言，可以编写表达式类处理视图分派的事件。事件绑定库会自动生成将布局中的视图与您的数据对象绑定所需的类。\n\n数据绑定布局文件略有不同，以根标记`layout` 开头，后跟 `data` 和 `view` 根元素。此视图元素是非绑定布局文件的根\n\n```xml\n<?xml version=\"1.0\" encodeing=\"utf-8\"?>\n<layout xmlns:android=\"http://scheams.android.comapk/res/android\">\n\t<data>\n    \t<variable name=\"user\"\n                  type=\"com.example.User\"/>\n    </data>\n    \n    <LinearLayout android:orientation=\"vertical\"\n                  android:layout_width=\"match_parent\"\n                  android:layout_height=\"match_parent\">\n    \t\n        <TextView android:layout_width=\"wrap_content\"\n             \t  android:layout_height=\"wrap_content\"\n\t              android:text=\"@{user.fiestName}\"/>\n        \n        <TextView android:layout_width=\"wrap_content\"\n                  android:layout_height=\"warp_content\"\n                  android:text=\"@{user.lastName}\"/>\n        \n    </LinearLayout>\n</layout>\n```\n\n`data` 中的 `user` 变量描述了可在此布局中使用的属性\n\n```xml\n<variable name=\"user\" type=\"com.example.User\"/>\n```\n\n布局中的表达式使用了 `@{}` 语法写入特性属性中，在这里， `TextView` 文本被设置为 `user.fistName` 和 `user.lastName`\n\n```xml\n<TextView android:layout_width=\"wrap_content\"\n          android:layout_height=\"warp_content\"\n          android:text=\"@{user.firstName}\"/>\n\n<TextView android:layout_width=\"wrap_content\"\n          android:layout_height=\"warp_content\"\n          android:text=\"@{user.lastName}\"/>\n```\n\n### 数据对象\n\n```kotlin\ndata class User(val firstName:String, val lastName: String)\n```\n\n### 绑定数据\n\n系统会为每个布局文件生成一个绑定类。默认情况下，类名称基于布局文件的名称，它会转换为 Pascal 大小写姓氏并再末尾添加 Binding 后缀。以上布局文件名为 `activity_main.xml` ,因此生成的对应类为 `ActivityMainBinding`。 此类包含从布局属性（例如, user 变量）到布局视图的所有绑定，并且知道如何为绑定表达式指定值。建议的绑定创建方法是再扩充布局时创建。\n\n```kotlin\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    \n    val binding: ActivityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main)\n    \n    binding.user= User('Test', \"User\")\n}\n```\n\n再运行时，应用会再界面中显示 Test 用户。 或者，您可以使用 **LayoutInflater** 获取视图，\n\n```kotlin\nval binding: ActivityMainBinding= ActivityMainBinding.inflate(getLayoutInflater())\n```\n\n如果需要再 `Fragment` `ListView` 或 `RecyclerView` 适配器中使用数据绑定项，您可能更愿意使用绑定类或 `DataBindingUtil` 类的 `inflate()` 方法\n\n```kotlin\nval listItemBinding = ListItemBinding.inflate(layoutInflater, viewGroup, false)\n// or\nval listItemBinding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false)\n```\n\n### 表达式语言\n\n| 名称             | 符号                                |\n| ---------------- | ----------------------------------- |\n| 算数运算符       | +, -, /, *, %                       |\n| 字符串连接运算符 | +                                   |\n| 逻辑运算符       | &&, \\|\\|                            |\n| 二元运算符       | &, \\|, ^                            |\n| 一元运算符       | +, -, !, ~                          |\n| 移位运算符       | >> , <<, >>>                        |\n| 比较运算符       | ==, >, <(需要转义为'&lt ;'), >=, <= |\n|                  | instanceof                          |\n| 分组运算符       | ()                                  |\n| 字面运算符       | 字符，字符串，数字， null           |\n| 类型转换         |                                     |\n| 方法调用         |                                     |\n| 字段访问         |                                     |\n| 数组访问         | []                                  |\n| 三元运算符       | ?:                                  |\n\n```xml\n<TextView\n          android:text=\"@{String.valueOf(index+1)}\"\n          android:visibility=\"@{age > 13 ? View.GONE : View.VISIBLE}\"\n          android:transitionName=\"@{\"image_\"+id}\"\n```\n\n\n\n### Null 合并运算符\n\n> 如果左边运算不是 null, 则 Null 合并运算符(??) 选择左边运算数，如果左边为 null, 则选择右边\n\n```\nandroid:text=\"@{user.displayName ?? user.lastName}\"\n```\n\n等效于\n\n```\nandroid:text=\"@{user.displayName != null ? user.displayName : user.lastName}\"\n```\n\n### 视图引用\n\n表达式可以通过以下语法按 ID  引用布局中的其他视图，并会将 ID 自动转换为驼峰法\n\n```xml\n<EditText\n          android:id=\"@+id/example_text\"\n          android:layout_width=\"match_parent\"\n          android:layout_height=\"wrap_content\"/>\n<TextView\n          android:id=\"@+id/example_output\"\n          android:layout_width=\"match_parent\"\n          android:layout_height=\"wrap_content\"\n          android:text=\"@{exampleText.text}\"/>\n```\n\n### 集合\n\n可以使用 `[]` 运算符访问常见集合，例如数组、列表、Hash 列表、和映射\n\n```xml\n<data>\n\t<import type=\"android.util.SparseArray\"/>\n    <import type=\"java.util.Map\"/>\n    <import type=\"java.util.List\"/>\n    <variable name=\"list\" type=\"List$lt;String>\"/>\n    <variable name=\"sparse\" type=\"Sparse$lt;String>\"/>\n    <variable name=\"map\" type=\"Map$lt;<String, String>\"/>\n    <variable name=\"index\" type=\"int\"/>\n    <variable name=\"key\" type=\"String\"/>\n</data>\n\n​```\nandroid:text=\"@{list[index]}\"\n​```\nandroid:text=\"@{sparse[index]}\"\n​```\nandroid:text=\"@{map[key]}\"\n```\n\n### 资源\n\n表达式可以使用一下语法引用资源\n\n```\nandroid:padding=\"@{large?@dimen/largePadding : @dimen/smallPadding}\"\n```\n\n某些资源需要显示类型求值\n\n| 类型              | 常规引用  | 表达式引用         |\n| ----------------- | --------- | ------------------ |\n| String[]          | @array    | @stringArray       |\n| int[]             | @array    | @intArray          |\n| TypedArray        | @array    | @typedArray        |\n| Animator          | @animator | @animator          |\n| StateListAnimator | @animator | @stateListAnimator |\n| color int         | @color    | @color             |\n| ColorStateList    | @color    | @colorStateList    |\n\n### 事件处理\n\n可以编写从视图分派的表达式处理事件如：`onClick` \n\n#### 方法引用\n\n事件可以直接绑定到处理脚本方法，类似于为 Activity 中的方法指定`android:onClick` 的方式。与 View d  onClick 特性相比，一个主要有点时表达式再编译时进行处理，因此，如果该方法不存在或其签名不正确，则会收到编译时错误。\n\n方法引用和监听器绑定之间的主要却别在于实际监听器实现实在绑定数据时创建的，而不是再事件触发时创建的。\n\n```kotlin\nclass MyHandler{\n    fun onClickFriend(view:View){...}\n}\n```\n\n绑定白哦大师可见视图的点击监听器分配给 `onClickFriend()` 方法\n\n```xml\n<layout xmlns:android=\"http://scheams.android.com/apk/res/android\">\n\t<data>\n    \t<variable name=\"handlers\" type=\"com.example.MyHandler\"/>\n        <variable name=\"user\" type=\"com.example.User\"/>\n    </data>\n    \n    <LinearLayout\n                  android:orientation=\"vertical\"\n                  android:layout_width=\"match_parent\"\n                  android:layout_height=\"match_parent\">\n    \t<TextView\n                  android:layout_width=\"wrap_content\"\n                  android:layout_height=\"wrap_content\"\n                  android:text=\"@{user.firstName}\"\n                  android:onClick=\"@{handlers::onClickFriend}\"/>\n    </LinearLayout>\n              \n</layout>\n```\n\n#### 监听器绑定\n\n监听器绑定时再事件发生时运行的绑定表达式。类似于方法引用，但允许您运行任意数据绑定表达式。\n\n在方法引用中，方法的参数必须与事件监听器的参数匹配。在监听器绑定中，只有您的返回值必须与监听器的预期返回值相匹配。\n\n```kotlin\nclass Presenter {\n    fun onSaveClick(task: Task)\n}\n```\n\n将事件绑定到 `onSaveClick()` 方法\n\n```xml\n<layout xmlns:android=\"http://scheams.android.com/apk/res/android\">\n\t<data>\n    \t<variable name=\"\" type=\"com.example.Task\"/>\n        <variable name=\"presenter\" type=\"com.example.Presenter\"/>\n    </data>\n    \n    <LinearLayout\n                  android:orientation=\"vertical\"\n                  android:onClick=\"@{() -> presenter.onSaveClick(task)}\"\n                  android:layout_width=\"match_parent\"\n                  android:layout_height=\"match_parent\"/>              \n</layout>\n```\n\n在表达式中使用回调时，数据绑定会自动为事件创建并注册必要的监听器。当视图触发事件时，数据绑定会对给定表达式求值。与常规绑定表达式一样，在对这些监听器表达式求值时，仍会获得数据绑定的 Null 值和线程安全。\n\n**避免使用复杂的监听器** 监听器表达式共嗯非常强大，可以使代码非常易于阅读。另一方面，包含复杂表达式的监听器会使布局难以阅读和维护。这些表达式应该像可用数据从界面传递到回调方法一样简单。\n\n\n\n#### 导入、变量和 包含\n\n导入：可以轻松的在布局文件中引用类\n\n变量：可以描述可在绑定表达式中使用的属性\n\n包含：可以在整个应用中重复使用复杂的布局\n\n##### 导入\n\n在 `data` 元素中使用多个 `import` 元素，也可以不用。\n\n```xml\n<data>\n\t<import type=\"android.view.View\"/>\n</data>\n```\n\n导入 View 类可以通过绑定表达式引用该类\n\n```xml\n<TextView\n          android:text=\"@{user.name}\"\n          android:layout_width=\"wrap_content\"\n          android:layout_height=\"wrap_content\"\n          android:visibility=\"@{user.isAdult ? View.VISIBLE : View.GONE}\">\n</TextView>\n```\n\n*类型别名*\n\n当类名有冲突时，其中一个类可使用别名重命名。\n\n```xml\n<import type=\"android.view.View\"/>\n<import type=\"com.example.real.estate.View\"\n        alias=\"Visia\"/>\n```\n\n##### 变量\n\n`variable`  每个元素都描述了一个可以在布局上设置、并将在布局文件中的绑定表达式中使用的属性。\n\n```xml\n<data>\n\t<import type=\"android.graphics.drawable.Drawable\"/>\n    <variable name=\"user\" type=\"com.example.User\"/>\n    <variable name=\"image\" type=\"Drawable\"/>\n    <variable name=\"note\" type=\"String\"/>\n</data>\n```\n\n变量类型在编译时进行检查，因此如果实现了  `Observable` 或者时 **可观察集合**，则因反应在类型中。\n\n在生成的绑定类中，每个描述的变量都有一个对应的 setter 和 getter。在调用 setter 之前，这些变量一直采用默认的托管代码。\n\n##### 包含\n\n通过使用应用命名空间和特性中的变量名称，变量可以从包含的布局传递到被包含的布局绑定。\n\n```xml\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n            xmlns:bind=\"http://schemas.android.com/apk/res-auto\">\n       <data>\n           <variable name=\"user\" type=\"com.example.User\"/>\n       </data>\n       <LinearLayout\n           android:orientation=\"vertical\"\n           android:layout_width=\"match_parent\"\n           android:layout_height=\"match_parent\">\n           <include layout=\"@layout/name\"\n               bind:user=\"@{user}\"/>\n           <include layout=\"@layout/contact\"\n               bind:user=\"@{user}\"/>\n       </LinearLayout>\n    </layout>\n```\n\n","source":"_posts/Jetpack/Data Binding.md","raw":"---\ntitle: Android Data Binding\ntag: Android\n---\n\n# Data Binding\n\n## 概念\n\n### 布局和绑定表达式 \n\n借助表达式语言，可以编写将变量关联到布局中的视图的表达式。数据绑定库会自动生成将布局中的视图与数据对象绑定所需的类。该库提供了可在布局中使用的导入、变量和包含等功能。\n<!-- more-->\n该库的这些功能可与您的选优布局无缝共享。例如可以在表达式中使用的绑定变量在 `data` 元素（界面布局根元素的同级）内定义。这两个元素都封装在 `layout` 标记中。\n\n```xml\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n        xmlns:app=\"http://scheams.android.com/apk/res-auto\">\n\t<data>\n    \t<variable\n                  name=\"viewModel\"\n                  type=\"com.myapp.data.ViewModel\">\n        </variable>\n    </data>\n    \n    <ConstraintLayout>\n    \t<!-- UI layout`s root element-->\n    </ConstraintLayout>\n</layout>\n```\n\n### 使用可观察的数据对象\n\n\n\n数据绑定库提供了可让您轻松地观察数据更改情况的类和方法。不必操心在底层始建于发生更改时刷新界面。可以将变量或其他属性设为可观察。借助该库，可以将对象、字段或集合设为可观察。\n\n### 生成的绑定类\n\n数据绑定库可以生成用于访问布局变量和视图的绑定类。此页面展示了如何使用和自定义所生成的绑定类。\n\n### 绑定适配器\n\n每一个布局表达式都又一个对应的绑定适配器，要求必须进行框架调用来设置响应的属性或监听。例如，绑定适配器负责调用 `setText()` 方法来设置文本属性，或者调用 `setOnClickListener()` 方法向点击事件添加监听器。最常用的帮i的那个适配器（例如针对本页面的示例中使用的 `android:text` 属性）可供您在 `android.databinding.adapters` 软件包中使用。也可以自定义适配器\n\n``` kotlin\n@BindingAdapter(\"app:goneUnless\") \nfun goneUnless(view: View, visiable: Boolean) {\n    view.visibility = if (visiable) View.VISIABLE else View.GONE\n}\n```\n\n\n### 双向数据绑定\n\n数据绑定库支持双向数据绑定。此类绑定使用的表示法支持以下操作：接收对属性的数据更改，同时监听用户对此属性的更新\n\n## 使用入门\n\n### 编译环境\n\n要开始使用数据绑定，从 Android SDK 管理器中的 **支持代码库** 下载。要将应用配置为使用配置绑定，需要在应用模块的 `build.gradle` 文件中添加 `databinding` 元素\n\n```groovy\nandroid{\n    ...\n        dataBinding{\n            enabled = true\n        }\n}\n```\n\n> 即使应用模块不直接使用数据绑定，也必须为依赖于与使用数据绑定库的应用模块配置数据绑定\n\n### 布局和绑定表达式\n\n借助表达式语言，可以编写表达式类处理视图分派的事件。事件绑定库会自动生成将布局中的视图与您的数据对象绑定所需的类。\n\n数据绑定布局文件略有不同，以根标记`layout` 开头，后跟 `data` 和 `view` 根元素。此视图元素是非绑定布局文件的根\n\n```xml\n<?xml version=\"1.0\" encodeing=\"utf-8\"?>\n<layout xmlns:android=\"http://scheams.android.comapk/res/android\">\n\t<data>\n    \t<variable name=\"user\"\n                  type=\"com.example.User\"/>\n    </data>\n    \n    <LinearLayout android:orientation=\"vertical\"\n                  android:layout_width=\"match_parent\"\n                  android:layout_height=\"match_parent\">\n    \t\n        <TextView android:layout_width=\"wrap_content\"\n             \t  android:layout_height=\"wrap_content\"\n\t              android:text=\"@{user.fiestName}\"/>\n        \n        <TextView android:layout_width=\"wrap_content\"\n                  android:layout_height=\"warp_content\"\n                  android:text=\"@{user.lastName}\"/>\n        \n    </LinearLayout>\n</layout>\n```\n\n`data` 中的 `user` 变量描述了可在此布局中使用的属性\n\n```xml\n<variable name=\"user\" type=\"com.example.User\"/>\n```\n\n布局中的表达式使用了 `@{}` 语法写入特性属性中，在这里， `TextView` 文本被设置为 `user.fistName` 和 `user.lastName`\n\n```xml\n<TextView android:layout_width=\"wrap_content\"\n          android:layout_height=\"warp_content\"\n          android:text=\"@{user.firstName}\"/>\n\n<TextView android:layout_width=\"wrap_content\"\n          android:layout_height=\"warp_content\"\n          android:text=\"@{user.lastName}\"/>\n```\n\n### 数据对象\n\n```kotlin\ndata class User(val firstName:String, val lastName: String)\n```\n\n### 绑定数据\n\n系统会为每个布局文件生成一个绑定类。默认情况下，类名称基于布局文件的名称，它会转换为 Pascal 大小写姓氏并再末尾添加 Binding 后缀。以上布局文件名为 `activity_main.xml` ,因此生成的对应类为 `ActivityMainBinding`。 此类包含从布局属性（例如, user 变量）到布局视图的所有绑定，并且知道如何为绑定表达式指定值。建议的绑定创建方法是再扩充布局时创建。\n\n```kotlin\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    \n    val binding: ActivityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main)\n    \n    binding.user= User('Test', \"User\")\n}\n```\n\n再运行时，应用会再界面中显示 Test 用户。 或者，您可以使用 **LayoutInflater** 获取视图，\n\n```kotlin\nval binding: ActivityMainBinding= ActivityMainBinding.inflate(getLayoutInflater())\n```\n\n如果需要再 `Fragment` `ListView` 或 `RecyclerView` 适配器中使用数据绑定项，您可能更愿意使用绑定类或 `DataBindingUtil` 类的 `inflate()` 方法\n\n```kotlin\nval listItemBinding = ListItemBinding.inflate(layoutInflater, viewGroup, false)\n// or\nval listItemBinding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false)\n```\n\n### 表达式语言\n\n| 名称             | 符号                                |\n| ---------------- | ----------------------------------- |\n| 算数运算符       | +, -, /, *, %                       |\n| 字符串连接运算符 | +                                   |\n| 逻辑运算符       | &&, \\|\\|                            |\n| 二元运算符       | &, \\|, ^                            |\n| 一元运算符       | +, -, !, ~                          |\n| 移位运算符       | >> , <<, >>>                        |\n| 比较运算符       | ==, >, <(需要转义为'&lt ;'), >=, <= |\n|                  | instanceof                          |\n| 分组运算符       | ()                                  |\n| 字面运算符       | 字符，字符串，数字， null           |\n| 类型转换         |                                     |\n| 方法调用         |                                     |\n| 字段访问         |                                     |\n| 数组访问         | []                                  |\n| 三元运算符       | ?:                                  |\n\n```xml\n<TextView\n          android:text=\"@{String.valueOf(index+1)}\"\n          android:visibility=\"@{age > 13 ? View.GONE : View.VISIBLE}\"\n          android:transitionName=\"@{\"image_\"+id}\"\n```\n\n\n\n### Null 合并运算符\n\n> 如果左边运算不是 null, 则 Null 合并运算符(??) 选择左边运算数，如果左边为 null, 则选择右边\n\n```\nandroid:text=\"@{user.displayName ?? user.lastName}\"\n```\n\n等效于\n\n```\nandroid:text=\"@{user.displayName != null ? user.displayName : user.lastName}\"\n```\n\n### 视图引用\n\n表达式可以通过以下语法按 ID  引用布局中的其他视图，并会将 ID 自动转换为驼峰法\n\n```xml\n<EditText\n          android:id=\"@+id/example_text\"\n          android:layout_width=\"match_parent\"\n          android:layout_height=\"wrap_content\"/>\n<TextView\n          android:id=\"@+id/example_output\"\n          android:layout_width=\"match_parent\"\n          android:layout_height=\"wrap_content\"\n          android:text=\"@{exampleText.text}\"/>\n```\n\n### 集合\n\n可以使用 `[]` 运算符访问常见集合，例如数组、列表、Hash 列表、和映射\n\n```xml\n<data>\n\t<import type=\"android.util.SparseArray\"/>\n    <import type=\"java.util.Map\"/>\n    <import type=\"java.util.List\"/>\n    <variable name=\"list\" type=\"List$lt;String>\"/>\n    <variable name=\"sparse\" type=\"Sparse$lt;String>\"/>\n    <variable name=\"map\" type=\"Map$lt;<String, String>\"/>\n    <variable name=\"index\" type=\"int\"/>\n    <variable name=\"key\" type=\"String\"/>\n</data>\n\n​```\nandroid:text=\"@{list[index]}\"\n​```\nandroid:text=\"@{sparse[index]}\"\n​```\nandroid:text=\"@{map[key]}\"\n```\n\n### 资源\n\n表达式可以使用一下语法引用资源\n\n```\nandroid:padding=\"@{large?@dimen/largePadding : @dimen/smallPadding}\"\n```\n\n某些资源需要显示类型求值\n\n| 类型              | 常规引用  | 表达式引用         |\n| ----------------- | --------- | ------------------ |\n| String[]          | @array    | @stringArray       |\n| int[]             | @array    | @intArray          |\n| TypedArray        | @array    | @typedArray        |\n| Animator          | @animator | @animator          |\n| StateListAnimator | @animator | @stateListAnimator |\n| color int         | @color    | @color             |\n| ColorStateList    | @color    | @colorStateList    |\n\n### 事件处理\n\n可以编写从视图分派的表达式处理事件如：`onClick` \n\n#### 方法引用\n\n事件可以直接绑定到处理脚本方法，类似于为 Activity 中的方法指定`android:onClick` 的方式。与 View d  onClick 特性相比，一个主要有点时表达式再编译时进行处理，因此，如果该方法不存在或其签名不正确，则会收到编译时错误。\n\n方法引用和监听器绑定之间的主要却别在于实际监听器实现实在绑定数据时创建的，而不是再事件触发时创建的。\n\n```kotlin\nclass MyHandler{\n    fun onClickFriend(view:View){...}\n}\n```\n\n绑定白哦大师可见视图的点击监听器分配给 `onClickFriend()` 方法\n\n```xml\n<layout xmlns:android=\"http://scheams.android.com/apk/res/android\">\n\t<data>\n    \t<variable name=\"handlers\" type=\"com.example.MyHandler\"/>\n        <variable name=\"user\" type=\"com.example.User\"/>\n    </data>\n    \n    <LinearLayout\n                  android:orientation=\"vertical\"\n                  android:layout_width=\"match_parent\"\n                  android:layout_height=\"match_parent\">\n    \t<TextView\n                  android:layout_width=\"wrap_content\"\n                  android:layout_height=\"wrap_content\"\n                  android:text=\"@{user.firstName}\"\n                  android:onClick=\"@{handlers::onClickFriend}\"/>\n    </LinearLayout>\n              \n</layout>\n```\n\n#### 监听器绑定\n\n监听器绑定时再事件发生时运行的绑定表达式。类似于方法引用，但允许您运行任意数据绑定表达式。\n\n在方法引用中，方法的参数必须与事件监听器的参数匹配。在监听器绑定中，只有您的返回值必须与监听器的预期返回值相匹配。\n\n```kotlin\nclass Presenter {\n    fun onSaveClick(task: Task)\n}\n```\n\n将事件绑定到 `onSaveClick()` 方法\n\n```xml\n<layout xmlns:android=\"http://scheams.android.com/apk/res/android\">\n\t<data>\n    \t<variable name=\"\" type=\"com.example.Task\"/>\n        <variable name=\"presenter\" type=\"com.example.Presenter\"/>\n    </data>\n    \n    <LinearLayout\n                  android:orientation=\"vertical\"\n                  android:onClick=\"@{() -> presenter.onSaveClick(task)}\"\n                  android:layout_width=\"match_parent\"\n                  android:layout_height=\"match_parent\"/>              \n</layout>\n```\n\n在表达式中使用回调时，数据绑定会自动为事件创建并注册必要的监听器。当视图触发事件时，数据绑定会对给定表达式求值。与常规绑定表达式一样，在对这些监听器表达式求值时，仍会获得数据绑定的 Null 值和线程安全。\n\n**避免使用复杂的监听器** 监听器表达式共嗯非常强大，可以使代码非常易于阅读。另一方面，包含复杂表达式的监听器会使布局难以阅读和维护。这些表达式应该像可用数据从界面传递到回调方法一样简单。\n\n\n\n#### 导入、变量和 包含\n\n导入：可以轻松的在布局文件中引用类\n\n变量：可以描述可在绑定表达式中使用的属性\n\n包含：可以在整个应用中重复使用复杂的布局\n\n##### 导入\n\n在 `data` 元素中使用多个 `import` 元素，也可以不用。\n\n```xml\n<data>\n\t<import type=\"android.view.View\"/>\n</data>\n```\n\n导入 View 类可以通过绑定表达式引用该类\n\n```xml\n<TextView\n          android:text=\"@{user.name}\"\n          android:layout_width=\"wrap_content\"\n          android:layout_height=\"wrap_content\"\n          android:visibility=\"@{user.isAdult ? View.VISIBLE : View.GONE}\">\n</TextView>\n```\n\n*类型别名*\n\n当类名有冲突时，其中一个类可使用别名重命名。\n\n```xml\n<import type=\"android.view.View\"/>\n<import type=\"com.example.real.estate.View\"\n        alias=\"Visia\"/>\n```\n\n##### 变量\n\n`variable`  每个元素都描述了一个可以在布局上设置、并将在布局文件中的绑定表达式中使用的属性。\n\n```xml\n<data>\n\t<import type=\"android.graphics.drawable.Drawable\"/>\n    <variable name=\"user\" type=\"com.example.User\"/>\n    <variable name=\"image\" type=\"Drawable\"/>\n    <variable name=\"note\" type=\"String\"/>\n</data>\n```\n\n变量类型在编译时进行检查，因此如果实现了  `Observable` 或者时 **可观察集合**，则因反应在类型中。\n\n在生成的绑定类中，每个描述的变量都有一个对应的 setter 和 getter。在调用 setter 之前，这些变量一直采用默认的托管代码。\n\n##### 包含\n\n通过使用应用命名空间和特性中的变量名称，变量可以从包含的布局传递到被包含的布局绑定。\n\n```xml\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n            xmlns:bind=\"http://schemas.android.com/apk/res-auto\">\n       <data>\n           <variable name=\"user\" type=\"com.example.User\"/>\n       </data>\n       <LinearLayout\n           android:orientation=\"vertical\"\n           android:layout_width=\"match_parent\"\n           android:layout_height=\"match_parent\">\n           <include layout=\"@layout/name\"\n               bind:user=\"@{user}\"/>\n           <include layout=\"@layout/contact\"\n               bind:user=\"@{user}\"/>\n       </LinearLayout>\n    </layout>\n```\n\n","slug":"Jetpack/Data Binding","published":1,"date":"2021-01-29T15:54:28.313Z","updated":"2021-01-29T16:04:38.897Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8f8001vsz5qruif60o6","content":"<h1 id=\"Data-Binding\"><a href=\"#Data-Binding\" class=\"headerlink\" title=\"Data Binding\"></a>Data Binding</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><h3 id=\"布局和绑定表达式\"><a href=\"#布局和绑定表达式\" class=\"headerlink\" title=\"布局和绑定表达式\"></a>布局和绑定表达式</h3><p>借助表达式语言，可以编写将变量关联到布局中的视图的表达式。数据绑定库会自动生成将布局中的视图与数据对象绑定所需的类。该库提供了可在布局中使用的导入、变量和包含等功能。<br><a id=\"more\"></a><br>该库的这些功能可与您的选优布局无缝共享。例如可以在表达式中使用的绑定变量在 <code>data</code> 元素（界面布局根元素的同级）内定义。这两个元素都封装在 <code>layout</code> 标记中。</p>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>layout</span> <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>android</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>http://schemas.android.com/apk/res/android<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>app</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>http://scheams.android.com/apk/res-auto<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>data</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>variable</span>\n                  <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>viewModel<span class=\"token punctuation\">\"</span></span>\n                  <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>com.myapp.data.ViewModel<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>variable</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>data</span><span class=\"token punctuation\">></span></span>\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ConstraintLayout</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token comment\" spellcheck=\"true\">&lt;!-- UI layout`s root element--></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ConstraintLayout</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>layout</span><span class=\"token punctuation\">></span></span>\n</code></pre>\n<h3 id=\"使用可观察的数据对象\"><a href=\"#使用可观察的数据对象\" class=\"headerlink\" title=\"使用可观察的数据对象\"></a>使用可观察的数据对象</h3><p>数据绑定库提供了可让您轻松地观察数据更改情况的类和方法。不必操心在底层始建于发生更改时刷新界面。可以将变量或其他属性设为可观察。借助该库，可以将对象、字段或集合设为可观察。</p>\n<h3 id=\"生成的绑定类\"><a href=\"#生成的绑定类\" class=\"headerlink\" title=\"生成的绑定类\"></a>生成的绑定类</h3><p>数据绑定库可以生成用于访问布局变量和视图的绑定类。此页面展示了如何使用和自定义所生成的绑定类。</p>\n<h3 id=\"绑定适配器\"><a href=\"#绑定适配器\" class=\"headerlink\" title=\"绑定适配器\"></a>绑定适配器</h3><p>每一个布局表达式都又一个对应的绑定适配器，要求必须进行框架调用来设置响应的属性或监听。例如，绑定适配器负责调用 <code>setText()</code> 方法来设置文本属性，或者调用 <code>setOnClickListener()</code> 方法向点击事件添加监听器。最常用的帮i的那个适配器（例如针对本页面的示例中使用的 <code>android:text</code> 属性）可供您在 <code>android.databinding.adapters</code> 软件包中使用。也可以自定义适配器</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@BindingAdapter</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"app:goneUnless\"</span><span class=\"token punctuation\">)</span> \n<span class=\"token keyword\">fun</span> <span class=\"token function\">goneUnless</span><span class=\"token punctuation\">(</span>view<span class=\"token operator\">:</span> View<span class=\"token punctuation\">,</span> visiable<span class=\"token operator\">:</span> Boolean<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    view<span class=\"token punctuation\">.</span>visibility <span class=\"token operator\">=</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>visiable<span class=\"token punctuation\">)</span> View<span class=\"token punctuation\">.</span>VISIABLE <span class=\"token keyword\">else</span> View<span class=\"token punctuation\">.</span>GONE\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"双向数据绑定\"><a href=\"#双向数据绑定\" class=\"headerlink\" title=\"双向数据绑定\"></a>双向数据绑定</h3><p>数据绑定库支持双向数据绑定。此类绑定使用的表示法支持以下操作：接收对属性的数据更改，同时监听用户对此属性的更新</p>\n<h2 id=\"使用入门\"><a href=\"#使用入门\" class=\"headerlink\" title=\"使用入门\"></a>使用入门</h2><h3 id=\"编译环境\"><a href=\"#编译环境\" class=\"headerlink\" title=\"编译环境\"></a>编译环境</h3><p>要开始使用数据绑定，从 Android SDK 管理器中的 <strong>支持代码库</strong> 下载。要将应用配置为使用配置绑定，需要在应用模块的 <code>build.gradle</code> 文件中添加 <code>databinding</code> 元素</p>\n<pre class=\" language-groovy\"><code class=\"language-groovy\">android<span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">...</span>\n        dataBinding<span class=\"token punctuation\">{</span>\n            enabled <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n        <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<blockquote>\n<p>即使应用模块不直接使用数据绑定，也必须为依赖于与使用数据绑定库的应用模块配置数据绑定</p>\n</blockquote>\n<h3 id=\"布局和绑定表达式-1\"><a href=\"#布局和绑定表达式-1\" class=\"headerlink\" title=\"布局和绑定表达式\"></a>布局和绑定表达式</h3><p>借助表达式语言，可以编写表达式类处理视图分派的事件。事件绑定库会自动生成将布局中的视图与您的数据对象绑定所需的类。</p>\n<p>数据绑定布局文件略有不同，以根标记<code>layout</code> 开头，后跟 <code>data</code> 和 <code>view</code> 根元素。此视图元素是非绑定布局文件的根</p>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token prolog\">&lt;?xml version=\"1.0\" encodeing=\"utf-8\"?></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>layout</span> <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>android</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>http://scheams.android.comapk/res/android<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>data</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>variable</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>user<span class=\"token punctuation\">\"</span></span>\n                  <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>com.example.User<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>data</span><span class=\"token punctuation\">></span></span>\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>LinearLayout</span> <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>orientation</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>vertical<span class=\"token punctuation\">\"</span></span>\n                  <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_width</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>match_parent<span class=\"token punctuation\">\"</span></span>\n                  <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_height</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>match_parent<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>TextView</span> <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_width</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>wrap_content<span class=\"token punctuation\">\"</span></span>\n                   <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_height</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>wrap_content<span class=\"token punctuation\">\"</span></span>\n                  <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>text</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@{user.fiestName}<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>TextView</span> <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_width</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>wrap_content<span class=\"token punctuation\">\"</span></span>\n                  <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_height</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>warp_content<span class=\"token punctuation\">\"</span></span>\n                  <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>text</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@{user.lastName}<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>LinearLayout</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>layout</span><span class=\"token punctuation\">></span></span>\n</code></pre>\n<p><code>data</code> 中的 <code>user</code> 变量描述了可在此布局中使用的属性</p>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>variable</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>user<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>com.example.User<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n</code></pre>\n<p>布局中的表达式使用了 <code>@{}</code> 语法写入特性属性中，在这里， <code>TextView</code> 文本被设置为 <code>user.fistName</code> 和 <code>user.lastName</code></p>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>TextView</span> <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_width</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>wrap_content<span class=\"token punctuation\">\"</span></span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_height</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>warp_content<span class=\"token punctuation\">\"</span></span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>text</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@{user.firstName}<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>TextView</span> <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_width</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>wrap_content<span class=\"token punctuation\">\"</span></span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_height</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>warp_content<span class=\"token punctuation\">\"</span></span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>text</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@{user.lastName}<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n</code></pre>\n<h3 id=\"数据对象\"><a href=\"#数据对象\" class=\"headerlink\" title=\"数据对象\"></a>数据对象</h3><pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">data</span> <span class=\"token keyword\">class</span> <span class=\"token function\">User</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">val</span> firstName<span class=\"token operator\">:</span>String<span class=\"token punctuation\">,</span> <span class=\"token keyword\">val</span> lastName<span class=\"token operator\">:</span> String<span class=\"token punctuation\">)</span>\n</code></pre>\n<h3 id=\"绑定数据\"><a href=\"#绑定数据\" class=\"headerlink\" title=\"绑定数据\"></a>绑定数据</h3><p>系统会为每个布局文件生成一个绑定类。默认情况下，类名称基于布局文件的名称，它会转换为 Pascal 大小写姓氏并再末尾添加 Binding 后缀。以上布局文件名为 <code>activity_main.xml</code> ,因此生成的对应类为 <code>ActivityMainBinding</code>。 此类包含从布局属性（例如, user 变量）到布局视图的所有绑定，并且知道如何为绑定表达式指定值。建议的绑定创建方法是再扩充布局时创建。</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">onCreate</span><span class=\"token punctuation\">(</span>savedInstanceState<span class=\"token operator\">:</span> Bundle<span class=\"token operator\">?</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">onCreate</span><span class=\"token punctuation\">(</span>savedInstanceState<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">val</span> binding<span class=\"token operator\">:</span> ActivityMainBinding <span class=\"token operator\">=</span> DataBindingUtil<span class=\"token punctuation\">.</span><span class=\"token function\">setContentView</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> R<span class=\"token punctuation\">.</span>layout<span class=\"token punctuation\">.</span>activity_main<span class=\"token punctuation\">)</span>\n\n    binding<span class=\"token punctuation\">.</span>user<span class=\"token operator\">=</span> <span class=\"token function\">User</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Test'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"User\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>再运行时，应用会再界面中显示 Test 用户。 或者，您可以使用 <strong>LayoutInflater</strong> 获取视图，</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> binding<span class=\"token operator\">:</span> ActivityMainBinding<span class=\"token operator\">=</span> ActivityMainBinding<span class=\"token punctuation\">.</span><span class=\"token function\">inflate</span><span class=\"token punctuation\">(</span><span class=\"token function\">getLayoutInflater</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>如果需要再 <code>Fragment</code> <code>ListView</code> 或 <code>RecyclerView</code> 适配器中使用数据绑定项，您可能更愿意使用绑定类或 <code>DataBindingUtil</code> 类的 <code>inflate()</code> 方法</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> listItemBinding <span class=\"token operator\">=</span> ListItemBinding<span class=\"token punctuation\">.</span><span class=\"token function\">inflate</span><span class=\"token punctuation\">(</span>layoutInflater<span class=\"token punctuation\">,</span> viewGroup<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\">// or</span>\n<span class=\"token keyword\">val</span> listItemBinding <span class=\"token operator\">=</span> DataBindingUtil<span class=\"token punctuation\">.</span><span class=\"token function\">inflate</span><span class=\"token punctuation\">(</span>layoutInflater<span class=\"token punctuation\">,</span> R<span class=\"token punctuation\">.</span>layout<span class=\"token punctuation\">.</span>list_item<span class=\"token punctuation\">,</span> viewGroup<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<h3 id=\"表达式语言\"><a href=\"#表达式语言\" class=\"headerlink\" title=\"表达式语言\"></a>表达式语言</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>符号</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>算数运算符</td>\n<td>+, -, /, *, %</td>\n</tr>\n<tr>\n<td>字符串连接运算符</td>\n<td>+</td>\n</tr>\n<tr>\n<td>逻辑运算符</td>\n<td>&amp;&amp;, \\</td>\n<td>\\</td>\n<td></td>\n</tr>\n<tr>\n<td>二元运算符</td>\n<td>&amp;, \\</td>\n<td>, ^</td>\n</tr>\n<tr>\n<td>一元运算符</td>\n<td>+, -, !, ~</td>\n</tr>\n<tr>\n<td>移位运算符</td>\n<td>&gt;&gt; , &lt;&lt;, &gt;&gt;&gt;</td>\n</tr>\n<tr>\n<td>比较运算符</td>\n<td>==, &gt;, &lt;(需要转义为’&amp;lt ;’), &gt;=, &lt;=</td>\n</tr>\n<tr>\n<td></td>\n<td>instanceof</td>\n</tr>\n<tr>\n<td>分组运算符</td>\n<td>()</td>\n</tr>\n<tr>\n<td>字面运算符</td>\n<td>字符，字符串，数字， null</td>\n</tr>\n<tr>\n<td>类型转换</td>\n<td></td>\n</tr>\n<tr>\n<td>方法调用</td>\n<td></td>\n</tr>\n<tr>\n<td>字段访问</td>\n<td></td>\n</tr>\n<tr>\n<td>数组访问</td>\n<td>[]</td>\n</tr>\n<tr>\n<td>三元运算符</td>\n<td>?:</td>\n</tr>\n</tbody>\n</table>\n<pre class=\" language-xml\"><code class=\"language-xml\">&lt;TextView\n          android:text=\"@{String.valueOf(index+1)}\"\n          android:visibility=\"@{age > 13 ? View.GONE : View.VISIBLE}\"\n          android:transitionName=\"@{\"image_\"+id}\"\n</code></pre>\n<h3 id=\"Null-合并运算符\"><a href=\"#Null-合并运算符\" class=\"headerlink\" title=\"Null 合并运算符\"></a>Null 合并运算符</h3><blockquote>\n<p>如果左边运算不是 null, 则 Null 合并运算符(??) 选择左边运算数，如果左边为 null, 则选择右边</p>\n</blockquote>\n<pre><code>android:text=&quot;@{user.displayName ?? user.lastName}&quot;\n</code></pre><p>等效于</p>\n<pre><code>android:text=&quot;@{user.displayName != null ? user.displayName : user.lastName}&quot;\n</code></pre><h3 id=\"视图引用\"><a href=\"#视图引用\" class=\"headerlink\" title=\"视图引用\"></a>视图引用</h3><p>表达式可以通过以下语法按 ID  引用布局中的其他视图，并会将 ID 自动转换为驼峰法</p>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>EditText</span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@+id/example_text<span class=\"token punctuation\">\"</span></span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_width</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>match_parent<span class=\"token punctuation\">\"</span></span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_height</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>wrap_content<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>TextView</span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@+id/example_output<span class=\"token punctuation\">\"</span></span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_width</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>match_parent<span class=\"token punctuation\">\"</span></span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_height</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>wrap_content<span class=\"token punctuation\">\"</span></span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>text</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@{exampleText.text}<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n</code></pre>\n<h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><p>可以使用 <code>[]</code> 运算符访问常见集合，例如数组、列表、Hash 列表、和映射</p>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>data</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>import</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>android.util.SparseArray<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>import</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>java.util.Map<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>import</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>java.util.List<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>variable</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>list<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>List$lt;String<span class=\"token punctuation\">></span><span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>variable</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>sparse<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>Sparse$lt;String<span class=\"token punctuation\">></span><span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>variable</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>map<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>Map$lt;&lt;String, String<span class=\"token punctuation\">></span><span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>variable</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>index<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>int<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>variable</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>key<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>String<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>data</span><span class=\"token punctuation\">></span></span>\n\n​\n</code></pre>\n<p>android:text=”@{list[index]}”<br>​<code>android:text=&quot;@{sparse[index]}&quot;\n​</code><br>android:text=”@{map[key]}”</p>\n<pre><code>\n### 资源\n\n表达式可以使用一下语法引用资源\n\n</code></pre><p>android:padding=”@{large?@dimen/largePadding : @dimen/smallPadding}”</p>\n<pre><code>\n某些资源需要显示类型求值\n\n| 类型              | 常规引用  | 表达式引用         |\n| ----------------- | --------- | ------------------ |\n| String[]          | @array    | @stringArray       |\n| int[]             | @array    | @intArray          |\n| TypedArray        | @array    | @typedArray        |\n| Animator          | @animator | @animator          |\n| StateListAnimator | @animator | @stateListAnimator |\n| color int         | @color    | @color             |\n| ColorStateList    | @color    | @colorStateList    |\n\n### 事件处理\n\n可以编写从视图分派的表达式处理事件如：`onClick` \n\n#### 方法引用\n\n事件可以直接绑定到处理脚本方法，类似于为 Activity 中的方法指定`android:onClick` 的方式。与 View d  onClick 特性相比，一个主要有点时表达式再编译时进行处理，因此，如果该方法不存在或其签名不正确，则会收到编译时错误。\n\n方法引用和监听器绑定之间的主要却别在于实际监听器实现实在绑定数据时创建的，而不是再事件触发时创建的。\n\n```kotlin\nclass MyHandler{\n    fun onClickFriend(view:View){...}\n}\n</code></pre><p>绑定白哦大师可见视图的点击监听器分配给 <code>onClickFriend()</code> 方法</p>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>layout</span> <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>android</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>http://scheams.android.com/apk/res/android<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>data</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>variable</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>handlers<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>com.example.MyHandler<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>variable</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>user<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>com.example.User<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>data</span><span class=\"token punctuation\">></span></span>\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>LinearLayout</span>\n                  <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>orientation</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>vertical<span class=\"token punctuation\">\"</span></span>\n                  <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_width</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>match_parent<span class=\"token punctuation\">\"</span></span>\n                  <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_height</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>match_parent<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>TextView</span>\n                  <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_width</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>wrap_content<span class=\"token punctuation\">\"</span></span>\n                  <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_height</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>wrap_content<span class=\"token punctuation\">\"</span></span>\n                  <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>text</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@{user.firstName}<span class=\"token punctuation\">\"</span></span>\n                  <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>onClick</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@{handlers::onClickFriend}<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>LinearLayout</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>layout</span><span class=\"token punctuation\">></span></span>\n</code></pre>\n<h4 id=\"监听器绑定\"><a href=\"#监听器绑定\" class=\"headerlink\" title=\"监听器绑定\"></a>监听器绑定</h4><p>监听器绑定时再事件发生时运行的绑定表达式。类似于方法引用，但允许您运行任意数据绑定表达式。</p>\n<p>在方法引用中，方法的参数必须与事件监听器的参数匹配。在监听器绑定中，只有您的返回值必须与监听器的预期返回值相匹配。</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">class</span> Presenter <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">onSaveClick</span><span class=\"token punctuation\">(</span>task<span class=\"token operator\">:</span> Task<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>将事件绑定到 <code>onSaveClick()</code> 方法</p>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>layout</span> <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>android</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>http://scheams.android.com/apk/res/android<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>data</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>variable</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span><span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>com.example.Task<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>variable</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>presenter<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>com.example.Presenter<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>data</span><span class=\"token punctuation\">></span></span>\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>LinearLayout</span>\n                  <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>orientation</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>vertical<span class=\"token punctuation\">\"</span></span>\n                  <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>onClick</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@{() -<span class=\"token punctuation\">></span> presenter.onSaveClick(task)}<span class=\"token punctuation\">\"</span></span>\n                  <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_width</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>match_parent<span class=\"token punctuation\">\"</span></span>\n                  <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_height</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>match_parent<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>              \n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>layout</span><span class=\"token punctuation\">></span></span>\n</code></pre>\n<p>在表达式中使用回调时，数据绑定会自动为事件创建并注册必要的监听器。当视图触发事件时，数据绑定会对给定表达式求值。与常规绑定表达式一样，在对这些监听器表达式求值时，仍会获得数据绑定的 Null 值和线程安全。</p>\n<p><strong>避免使用复杂的监听器</strong> 监听器表达式共嗯非常强大，可以使代码非常易于阅读。另一方面，包含复杂表达式的监听器会使布局难以阅读和维护。这些表达式应该像可用数据从界面传递到回调方法一样简单。</p>\n<h4 id=\"导入、变量和-包含\"><a href=\"#导入、变量和-包含\" class=\"headerlink\" title=\"导入、变量和 包含\"></a>导入、变量和 包含</h4><p>导入：可以轻松的在布局文件中引用类</p>\n<p>变量：可以描述可在绑定表达式中使用的属性</p>\n<p>包含：可以在整个应用中重复使用复杂的布局</p>\n<h5 id=\"导入\"><a href=\"#导入\" class=\"headerlink\" title=\"导入\"></a>导入</h5><p>在 <code>data</code> 元素中使用多个 <code>import</code> 元素，也可以不用。</p>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>data</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>import</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>android.view.View<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>data</span><span class=\"token punctuation\">></span></span>\n</code></pre>\n<p>导入 View 类可以通过绑定表达式引用该类</p>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>TextView</span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>text</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@{user.name}<span class=\"token punctuation\">\"</span></span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_width</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>wrap_content<span class=\"token punctuation\">\"</span></span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_height</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>wrap_content<span class=\"token punctuation\">\"</span></span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>visibility</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@{user.isAdult ? View.VISIBLE : View.GONE}<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>TextView</span><span class=\"token punctuation\">></span></span>\n</code></pre>\n<p><em>类型别名</em></p>\n<p>当类名有冲突时，其中一个类可使用别名重命名。</p>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>import</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>android.view.View<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>import</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>com.example.real.estate.View<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\">alias</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>Visia<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n</code></pre>\n<h5 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h5><p><code>variable</code>  每个元素都描述了一个可以在布局上设置、并将在布局文件中的绑定表达式中使用的属性。</p>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>data</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>import</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>android.graphics.drawable.Drawable<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>variable</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>user<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>com.example.User<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>variable</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>image<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>Drawable<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>variable</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>note<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>String<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>data</span><span class=\"token punctuation\">></span></span>\n</code></pre>\n<p>变量类型在编译时进行检查，因此如果实现了  <code>Observable</code> 或者时 <strong>可观察集合</strong>，则因反应在类型中。</p>\n<p>在生成的绑定类中，每个描述的变量都有一个对应的 setter 和 getter。在调用 setter 之前，这些变量一直采用默认的托管代码。</p>\n<h5 id=\"包含\"><a href=\"#包含\" class=\"headerlink\" title=\"包含\"></a>包含</h5><p>通过使用应用命名空间和特性中的变量名称，变量可以从包含的布局传递到被包含的布局绑定。</p>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>layout</span> <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>android</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>http://schemas.android.com/apk/res/android<span class=\"token punctuation\">\"</span></span>\n            <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>bind</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>http://schemas.android.com/apk/res-auto<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n       <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>data</span><span class=\"token punctuation\">></span></span>\n           <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>variable</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>user<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>com.example.User<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n       <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>data</span><span class=\"token punctuation\">></span></span>\n       <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>LinearLayout</span>\n           <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>orientation</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>vertical<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_width</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>match_parent<span class=\"token punctuation\">\"</span></span>\n           <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_height</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>match_parent<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n           <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>include</span> <span class=\"token attr-name\">layout</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@layout/name<span class=\"token punctuation\">\"</span></span>\n               <span class=\"token attr-name\"><span class=\"token namespace\">bind:</span>user</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@{user}<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n           <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>include</span> <span class=\"token attr-name\">layout</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@layout/contact<span class=\"token punctuation\">\"</span></span>\n               <span class=\"token attr-name\"><span class=\"token namespace\">bind:</span>user</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@{user}<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n       <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>LinearLayout</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>layout</span><span class=\"token punctuation\">></span></span>\n</code></pre>\n","site":{"data":{}},"excerpt":"<h1 id=\"Data-Binding\"><a href=\"#Data-Binding\" class=\"headerlink\" title=\"Data Binding\"></a>Data Binding</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><h3 id=\"布局和绑定表达式\"><a href=\"#布局和绑定表达式\" class=\"headerlink\" title=\"布局和绑定表达式\"></a>布局和绑定表达式</h3><p>借助表达式语言，可以编写将变量关联到布局中的视图的表达式。数据绑定库会自动生成将布局中的视图与数据对象绑定所需的类。该库提供了可在布局中使用的导入、变量和包含等功能。<br>","more":"<br>该库的这些功能可与您的选优布局无缝共享。例如可以在表达式中使用的绑定变量在 <code>data</code> 元素（界面布局根元素的同级）内定义。这两个元素都封装在 <code>layout</code> 标记中。</p>\n<pre><code class=\"xml\">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n        xmlns:app=&quot;http://scheams.android.com/apk/res-auto&quot;&gt;\n    &lt;data&gt;\n        &lt;variable\n                  name=&quot;viewModel&quot;\n                  type=&quot;com.myapp.data.ViewModel&quot;&gt;\n        &lt;/variable&gt;\n    &lt;/data&gt;\n\n    &lt;ConstraintLayout&gt;\n        &lt;!-- UI layout`s root element--&gt;\n    &lt;/ConstraintLayout&gt;\n&lt;/layout&gt;\n</code></pre>\n<h3 id=\"使用可观察的数据对象\"><a href=\"#使用可观察的数据对象\" class=\"headerlink\" title=\"使用可观察的数据对象\"></a>使用可观察的数据对象</h3><p>数据绑定库提供了可让您轻松地观察数据更改情况的类和方法。不必操心在底层始建于发生更改时刷新界面。可以将变量或其他属性设为可观察。借助该库，可以将对象、字段或集合设为可观察。</p>\n<h3 id=\"生成的绑定类\"><a href=\"#生成的绑定类\" class=\"headerlink\" title=\"生成的绑定类\"></a>生成的绑定类</h3><p>数据绑定库可以生成用于访问布局变量和视图的绑定类。此页面展示了如何使用和自定义所生成的绑定类。</p>\n<h3 id=\"绑定适配器\"><a href=\"#绑定适配器\" class=\"headerlink\" title=\"绑定适配器\"></a>绑定适配器</h3><p>每一个布局表达式都又一个对应的绑定适配器，要求必须进行框架调用来设置响应的属性或监听。例如，绑定适配器负责调用 <code>setText()</code> 方法来设置文本属性，或者调用 <code>setOnClickListener()</code> 方法向点击事件添加监听器。最常用的帮i的那个适配器（例如针对本页面的示例中使用的 <code>android:text</code> 属性）可供您在 <code>android.databinding.adapters</code> 软件包中使用。也可以自定义适配器</p>\n<pre><code class=\"kotlin\">@BindingAdapter(&quot;app:goneUnless&quot;) \nfun goneUnless(view: View, visiable: Boolean) {\n    view.visibility = if (visiable) View.VISIABLE else View.GONE\n}\n</code></pre>\n<h3 id=\"双向数据绑定\"><a href=\"#双向数据绑定\" class=\"headerlink\" title=\"双向数据绑定\"></a>双向数据绑定</h3><p>数据绑定库支持双向数据绑定。此类绑定使用的表示法支持以下操作：接收对属性的数据更改，同时监听用户对此属性的更新</p>\n<h2 id=\"使用入门\"><a href=\"#使用入门\" class=\"headerlink\" title=\"使用入门\"></a>使用入门</h2><h3 id=\"编译环境\"><a href=\"#编译环境\" class=\"headerlink\" title=\"编译环境\"></a>编译环境</h3><p>要开始使用数据绑定，从 Android SDK 管理器中的 <strong>支持代码库</strong> 下载。要将应用配置为使用配置绑定，需要在应用模块的 <code>build.gradle</code> 文件中添加 <code>databinding</code> 元素</p>\n<pre><code class=\"groovy\">android{\n    ...\n        dataBinding{\n            enabled = true\n        }\n}\n</code></pre>\n<blockquote>\n<p>即使应用模块不直接使用数据绑定，也必须为依赖于与使用数据绑定库的应用模块配置数据绑定</p>\n</blockquote>\n<h3 id=\"布局和绑定表达式-1\"><a href=\"#布局和绑定表达式-1\" class=\"headerlink\" title=\"布局和绑定表达式\"></a>布局和绑定表达式</h3><p>借助表达式语言，可以编写表达式类处理视图分派的事件。事件绑定库会自动生成将布局中的视图与您的数据对象绑定所需的类。</p>\n<p>数据绑定布局文件略有不同，以根标记<code>layout</code> 开头，后跟 <code>data</code> 和 <code>view</code> 根元素。此视图元素是非绑定布局文件的根</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encodeing=&quot;utf-8&quot;?&gt;\n&lt;layout xmlns:android=&quot;http://scheams.android.comapk/res/android&quot;&gt;\n    &lt;data&gt;\n        &lt;variable name=&quot;user&quot;\n                  type=&quot;com.example.User&quot;/&gt;\n    &lt;/data&gt;\n\n    &lt;LinearLayout android:orientation=&quot;vertical&quot;\n                  android:layout_width=&quot;match_parent&quot;\n                  android:layout_height=&quot;match_parent&quot;&gt;\n\n        &lt;TextView android:layout_width=&quot;wrap_content&quot;\n                   android:layout_height=&quot;wrap_content&quot;\n                  android:text=&quot;@{user.fiestName}&quot;/&gt;\n\n        &lt;TextView android:layout_width=&quot;wrap_content&quot;\n                  android:layout_height=&quot;warp_content&quot;\n                  android:text=&quot;@{user.lastName}&quot;/&gt;\n\n    &lt;/LinearLayout&gt;\n&lt;/layout&gt;\n</code></pre>\n<p><code>data</code> 中的 <code>user</code> 变量描述了可在此布局中使用的属性</p>\n<pre><code class=\"xml\">&lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt;\n</code></pre>\n<p>布局中的表达式使用了 <code>@{}</code> 语法写入特性属性中，在这里， <code>TextView</code> 文本被设置为 <code>user.fistName</code> 和 <code>user.lastName</code></p>\n<pre><code class=\"xml\">&lt;TextView android:layout_width=&quot;wrap_content&quot;\n          android:layout_height=&quot;warp_content&quot;\n          android:text=&quot;@{user.firstName}&quot;/&gt;\n\n&lt;TextView android:layout_width=&quot;wrap_content&quot;\n          android:layout_height=&quot;warp_content&quot;\n          android:text=&quot;@{user.lastName}&quot;/&gt;\n</code></pre>\n<h3 id=\"数据对象\"><a href=\"#数据对象\" class=\"headerlink\" title=\"数据对象\"></a>数据对象</h3><pre><code class=\"kotlin\">data class User(val firstName:String, val lastName: String)\n</code></pre>\n<h3 id=\"绑定数据\"><a href=\"#绑定数据\" class=\"headerlink\" title=\"绑定数据\"></a>绑定数据</h3><p>系统会为每个布局文件生成一个绑定类。默认情况下，类名称基于布局文件的名称，它会转换为 Pascal 大小写姓氏并再末尾添加 Binding 后缀。以上布局文件名为 <code>activity_main.xml</code> ,因此生成的对应类为 <code>ActivityMainBinding</code>。 此类包含从布局属性（例如, user 变量）到布局视图的所有绑定，并且知道如何为绑定表达式指定值。建议的绑定创建方法是再扩充布局时创建。</p>\n<pre><code class=\"kotlin\">override fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n\n    val binding: ActivityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main)\n\n    binding.user= User(&#39;Test&#39;, &quot;User&quot;)\n}\n</code></pre>\n<p>再运行时，应用会再界面中显示 Test 用户。 或者，您可以使用 <strong>LayoutInflater</strong> 获取视图，</p>\n<pre><code class=\"kotlin\">val binding: ActivityMainBinding= ActivityMainBinding.inflate(getLayoutInflater())\n</code></pre>\n<p>如果需要再 <code>Fragment</code> <code>ListView</code> 或 <code>RecyclerView</code> 适配器中使用数据绑定项，您可能更愿意使用绑定类或 <code>DataBindingUtil</code> 类的 <code>inflate()</code> 方法</p>\n<pre><code class=\"kotlin\">val listItemBinding = ListItemBinding.inflate(layoutInflater, viewGroup, false)\n// or\nval listItemBinding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false)\n</code></pre>\n<h3 id=\"表达式语言\"><a href=\"#表达式语言\" class=\"headerlink\" title=\"表达式语言\"></a>表达式语言</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>符号</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>算数运算符</td>\n<td>+, -, /, *, %</td>\n</tr>\n<tr>\n<td>字符串连接运算符</td>\n<td>+</td>\n</tr>\n<tr>\n<td>逻辑运算符</td>\n<td>&amp;&amp;, \\</td>\n<td>\\</td>\n<td></td>\n</tr>\n<tr>\n<td>二元运算符</td>\n<td>&amp;, \\</td>\n<td>, ^</td>\n</tr>\n<tr>\n<td>一元运算符</td>\n<td>+, -, !, ~</td>\n</tr>\n<tr>\n<td>移位运算符</td>\n<td>&gt;&gt; , &lt;&lt;, &gt;&gt;&gt;</td>\n</tr>\n<tr>\n<td>比较运算符</td>\n<td>==, &gt;, &lt;(需要转义为’&amp;lt ;’), &gt;=, &lt;=</td>\n</tr>\n<tr>\n<td></td>\n<td>instanceof</td>\n</tr>\n<tr>\n<td>分组运算符</td>\n<td>()</td>\n</tr>\n<tr>\n<td>字面运算符</td>\n<td>字符，字符串，数字， null</td>\n</tr>\n<tr>\n<td>类型转换</td>\n<td></td>\n</tr>\n<tr>\n<td>方法调用</td>\n<td></td>\n</tr>\n<tr>\n<td>字段访问</td>\n<td></td>\n</tr>\n<tr>\n<td>数组访问</td>\n<td>[]</td>\n</tr>\n<tr>\n<td>三元运算符</td>\n<td>?:</td>\n</tr>\n</tbody>\n</table>\n<pre><code class=\"xml\">&lt;TextView\n          android:text=&quot;@{String.valueOf(index+1)}&quot;\n          android:visibility=&quot;@{age &gt; 13 ? View.GONE : View.VISIBLE}&quot;\n          android:transitionName=&quot;@{&quot;image_&quot;+id}&quot;\n</code></pre>\n<h3 id=\"Null-合并运算符\"><a href=\"#Null-合并运算符\" class=\"headerlink\" title=\"Null 合并运算符\"></a>Null 合并运算符</h3><blockquote>\n<p>如果左边运算不是 null, 则 Null 合并运算符(??) 选择左边运算数，如果左边为 null, 则选择右边</p>\n</blockquote>\n<pre><code>android:text=&quot;@{user.displayName ?? user.lastName}&quot;\n</code></pre><p>等效于</p>\n<pre><code>android:text=&quot;@{user.displayName != null ? user.displayName : user.lastName}&quot;\n</code></pre><h3 id=\"视图引用\"><a href=\"#视图引用\" class=\"headerlink\" title=\"视图引用\"></a>视图引用</h3><p>表达式可以通过以下语法按 ID  引用布局中的其他视图，并会将 ID 自动转换为驼峰法</p>\n<pre><code class=\"xml\">&lt;EditText\n          android:id=&quot;@+id/example_text&quot;\n          android:layout_width=&quot;match_parent&quot;\n          android:layout_height=&quot;wrap_content&quot;/&gt;\n&lt;TextView\n          android:id=&quot;@+id/example_output&quot;\n          android:layout_width=&quot;match_parent&quot;\n          android:layout_height=&quot;wrap_content&quot;\n          android:text=&quot;@{exampleText.text}&quot;/&gt;\n</code></pre>\n<h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><p>可以使用 <code>[]</code> 运算符访问常见集合，例如数组、列表、Hash 列表、和映射</p>\n<pre><code class=\"xml\">&lt;data&gt;\n    &lt;import type=&quot;android.util.SparseArray&quot;/&gt;\n    &lt;import type=&quot;java.util.Map&quot;/&gt;\n    &lt;import type=&quot;java.util.List&quot;/&gt;\n    &lt;variable name=&quot;list&quot; type=&quot;List$lt;String&gt;&quot;/&gt;\n    &lt;variable name=&quot;sparse&quot; type=&quot;Sparse$lt;String&gt;&quot;/&gt;\n    &lt;variable name=&quot;map&quot; type=&quot;Map$lt;&lt;String, String&gt;&quot;/&gt;\n    &lt;variable name=&quot;index&quot; type=&quot;int&quot;/&gt;\n    &lt;variable name=&quot;key&quot; type=&quot;String&quot;/&gt;\n&lt;/data&gt;\n\n​\n</code></pre>\n<p>android:text=”@{list[index]}”<br>​<code>android:text=&quot;@{sparse[index]}&quot;\n​</code><br>android:text=”@{map[key]}”</p>\n<pre><code>\n### 资源\n\n表达式可以使用一下语法引用资源\n\n</code></pre><p>android:padding=”@{large?@dimen/largePadding : @dimen/smallPadding}”</p>\n<pre><code>\n某些资源需要显示类型求值\n\n| 类型              | 常规引用  | 表达式引用         |\n| ----------------- | --------- | ------------------ |\n| String[]          | @array    | @stringArray       |\n| int[]             | @array    | @intArray          |\n| TypedArray        | @array    | @typedArray        |\n| Animator          | @animator | @animator          |\n| StateListAnimator | @animator | @stateListAnimator |\n| color int         | @color    | @color             |\n| ColorStateList    | @color    | @colorStateList    |\n\n### 事件处理\n\n可以编写从视图分派的表达式处理事件如：`onClick` \n\n#### 方法引用\n\n事件可以直接绑定到处理脚本方法，类似于为 Activity 中的方法指定`android:onClick` 的方式。与 View d  onClick 特性相比，一个主要有点时表达式再编译时进行处理，因此，如果该方法不存在或其签名不正确，则会收到编译时错误。\n\n方法引用和监听器绑定之间的主要却别在于实际监听器实现实在绑定数据时创建的，而不是再事件触发时创建的。\n\n```kotlin\nclass MyHandler{\n    fun onClickFriend(view:View){...}\n}\n</code></pre><p>绑定白哦大师可见视图的点击监听器分配给 <code>onClickFriend()</code> 方法</p>\n<pre><code class=\"xml\">&lt;layout xmlns:android=&quot;http://scheams.android.com/apk/res/android&quot;&gt;\n    &lt;data&gt;\n        &lt;variable name=&quot;handlers&quot; type=&quot;com.example.MyHandler&quot;/&gt;\n        &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt;\n    &lt;/data&gt;\n\n    &lt;LinearLayout\n                  android:orientation=&quot;vertical&quot;\n                  android:layout_width=&quot;match_parent&quot;\n                  android:layout_height=&quot;match_parent&quot;&gt;\n        &lt;TextView\n                  android:layout_width=&quot;wrap_content&quot;\n                  android:layout_height=&quot;wrap_content&quot;\n                  android:text=&quot;@{user.firstName}&quot;\n                  android:onClick=&quot;@{handlers::onClickFriend}&quot;/&gt;\n    &lt;/LinearLayout&gt;\n\n&lt;/layout&gt;\n</code></pre>\n<h4 id=\"监听器绑定\"><a href=\"#监听器绑定\" class=\"headerlink\" title=\"监听器绑定\"></a>监听器绑定</h4><p>监听器绑定时再事件发生时运行的绑定表达式。类似于方法引用，但允许您运行任意数据绑定表达式。</p>\n<p>在方法引用中，方法的参数必须与事件监听器的参数匹配。在监听器绑定中，只有您的返回值必须与监听器的预期返回值相匹配。</p>\n<pre><code class=\"kotlin\">class Presenter {\n    fun onSaveClick(task: Task)\n}\n</code></pre>\n<p>将事件绑定到 <code>onSaveClick()</code> 方法</p>\n<pre><code class=\"xml\">&lt;layout xmlns:android=&quot;http://scheams.android.com/apk/res/android&quot;&gt;\n    &lt;data&gt;\n        &lt;variable name=&quot;&quot; type=&quot;com.example.Task&quot;/&gt;\n        &lt;variable name=&quot;presenter&quot; type=&quot;com.example.Presenter&quot;/&gt;\n    &lt;/data&gt;\n\n    &lt;LinearLayout\n                  android:orientation=&quot;vertical&quot;\n                  android:onClick=&quot;@{() -&gt; presenter.onSaveClick(task)}&quot;\n                  android:layout_width=&quot;match_parent&quot;\n                  android:layout_height=&quot;match_parent&quot;/&gt;              \n&lt;/layout&gt;\n</code></pre>\n<p>在表达式中使用回调时，数据绑定会自动为事件创建并注册必要的监听器。当视图触发事件时，数据绑定会对给定表达式求值。与常规绑定表达式一样，在对这些监听器表达式求值时，仍会获得数据绑定的 Null 值和线程安全。</p>\n<p><strong>避免使用复杂的监听器</strong> 监听器表达式共嗯非常强大，可以使代码非常易于阅读。另一方面，包含复杂表达式的监听器会使布局难以阅读和维护。这些表达式应该像可用数据从界面传递到回调方法一样简单。</p>\n<h4 id=\"导入、变量和-包含\"><a href=\"#导入、变量和-包含\" class=\"headerlink\" title=\"导入、变量和 包含\"></a>导入、变量和 包含</h4><p>导入：可以轻松的在布局文件中引用类</p>\n<p>变量：可以描述可在绑定表达式中使用的属性</p>\n<p>包含：可以在整个应用中重复使用复杂的布局</p>\n<h5 id=\"导入\"><a href=\"#导入\" class=\"headerlink\" title=\"导入\"></a>导入</h5><p>在 <code>data</code> 元素中使用多个 <code>import</code> 元素，也可以不用。</p>\n<pre><code class=\"xml\">&lt;data&gt;\n    &lt;import type=&quot;android.view.View&quot;/&gt;\n&lt;/data&gt;\n</code></pre>\n<p>导入 View 类可以通过绑定表达式引用该类</p>\n<pre><code class=\"xml\">&lt;TextView\n          android:text=&quot;@{user.name}&quot;\n          android:layout_width=&quot;wrap_content&quot;\n          android:layout_height=&quot;wrap_content&quot;\n          android:visibility=&quot;@{user.isAdult ? View.VISIBLE : View.GONE}&quot;&gt;\n&lt;/TextView&gt;\n</code></pre>\n<p><em>类型别名</em></p>\n<p>当类名有冲突时，其中一个类可使用别名重命名。</p>\n<pre><code class=\"xml\">&lt;import type=&quot;android.view.View&quot;/&gt;\n&lt;import type=&quot;com.example.real.estate.View&quot;\n        alias=&quot;Visia&quot;/&gt;\n</code></pre>\n<h5 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h5><p><code>variable</code>  每个元素都描述了一个可以在布局上设置、并将在布局文件中的绑定表达式中使用的属性。</p>\n<pre><code class=\"xml\">&lt;data&gt;\n    &lt;import type=&quot;android.graphics.drawable.Drawable&quot;/&gt;\n    &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt;\n    &lt;variable name=&quot;image&quot; type=&quot;Drawable&quot;/&gt;\n    &lt;variable name=&quot;note&quot; type=&quot;String&quot;/&gt;\n&lt;/data&gt;\n</code></pre>\n<p>变量类型在编译时进行检查，因此如果实现了  <code>Observable</code> 或者时 <strong>可观察集合</strong>，则因反应在类型中。</p>\n<p>在生成的绑定类中，每个描述的变量都有一个对应的 setter 和 getter。在调用 setter 之前，这些变量一直采用默认的托管代码。</p>\n<h5 id=\"包含\"><a href=\"#包含\" class=\"headerlink\" title=\"包含\"></a>包含</h5><p>通过使用应用命名空间和特性中的变量名称，变量可以从包含的布局传递到被包含的布局绑定。</p>\n<pre><code class=\"xml\">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n            xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;\n       &lt;data&gt;\n           &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt;\n       &lt;/data&gt;\n       &lt;LinearLayout\n           android:orientation=&quot;vertical&quot;\n           android:layout_width=&quot;match_parent&quot;\n           android:layout_height=&quot;match_parent&quot;&gt;\n           &lt;include layout=&quot;@layout/name&quot;\n               bind:user=&quot;@{user}&quot;/&gt;\n           &lt;include layout=&quot;@layout/contact&quot;\n               bind:user=&quot;@{user}&quot;/&gt;\n       &lt;/LinearLayout&gt;\n    &lt;/layout&gt;\n</code></pre>"},{"title":"Android Lifecycle","_content":"\n## 开始是废话（翻译自源码）\n\n定义了一个 Android 生命周期的对象。 `Fragment`和`FragmentActivity`类实现`LifecycleOwner`接口， 并可以通过 `getLifecycle()` 方法来访问生命周期。 我们也可以实现`LifecycleOwner`在自己的类。\n<!-- more-->\n```Java\n// 在此类事件后分发 LifecycleOwner 的相关方法的返回时。 \nLifecycle.Event.ON_CREATE ， Lifecycle.Event.ON_START ， Lifecycle.Event.ON_RESUME\n// 在此类事件在之前分派LifecycleOwner被称为的相关方法。 例如， Lifecycle.Event.ON_START后会被分派onStart回报， Lifecycle.Event.ON_STOP之前将派出onStop被调用。 这给你一定的保证在其国家的主人在不在。\nLifecycle.Event.ON_PAUSE ， Lifecycle.Event.ON_STOP ， Lifecycle.Event.ON_DESTROY\n```\n\n\n如果您使用Java 8 语言 ，然后使用`DefaultLifecycleObserver` 观察事件。 需要将`\"androidx.lifecycle:common-java8:<version>\"` 增加到你的 `build.gradle` 文件中。\n\n```java\nclass TestObserver implements DefaultLifecycleObserver {\n    @Override\n    public void onCreate(LifecycleOwner owner) {\n        // your code\n    }\n}\n```\n\n  \n\n如果你使用的Java 7 语言 ，使用的注解观察生命周期事件。 一旦Java的8语言成为在Android上的主流，注释将被弃用，所以`DefaultLifecycleObserver`和注释之间，则须偏向 `DefaultLifecycleObserver `。\n\n   ```java \nclass TestObserver implements LifecycleObserver {\n    @OnLifecycleEvent(ON_STOP)\n    void onStopped() {}\n}\n   ```\n\n观测方法可以接收零个或一个参数。 如果使用，第一个参数的类型必须为`LifecycleOwner` 。 带注释的方法`Lifecycle.Event.ON_ANY` 可以接收第二个参数，它必须是类型的`Lifecycle.Event `。\n\n  ```java\nclass TestObserver implements LifecycleObserver {\n    @OnLifecycleEvent(ON_CREATE)\n    void onCreated(LifecycleOwner source) {}\n    @OnLifecycleEvent(ON_ANY)\n    void onAny(LifecycleOwner source, Event event) {}\n}\n  ```\n\n提供这些额外的参数可以让您方便地观察到多个供应商和事件，而无需手动跟踪他们。\n\n##  那我能做什么呢\n\n说到这里，我们就应该想到一些在开发中常常不被我们忽视，但又不怎么使用的东西 **友盟统计**\n\n在友盟统计中，我们经常会在 `BaseActivity` 中插入友盟对页面流转的统计, `onStart()` `onResume()` `onPause()` `onStop()` 等，然而这里有一点不好的是，我们的业务和公共组件耦合在了一起。\n\n干货~~~来了\n\n那么解决上述问题的方案就来了，我们通过实现 `LifecycleObserver` ，通过标识声明周期方法之后，仅需一句 `addObserver(this)` ，就可以将 `Activity` 或 `Fragment ` 的声明周期方法与我们定义的 `Observer` 方法关联起来。通过感知 `Activity` 或 `Fragment` 的声明周期方法，实现友盟统计，此时就将业务整体与 `BaseActivity` 抽离开，是的公共组件变得更简洁一些。\n\n当然，这只是 `Lifecycle` 的一种简单应用，其他的使用方法还是需要我们不断的去探索。\n\n## 源码分析\n\n### **`Lifecycle UML`**\n\n![Lifecycle UML](https://github.com/xiaomanwong/static_file/blob/master/images/Lifecycle%20UML.png?raw=true)\n\n**想理解一个东西，最好的方式就是去阅读它**， 这是开发多年总结出的一句话。\n\n那么通过上面的 UML 类图关系，我们能够看出， `Lifecycle` 的内容并不是很多。但它怎么就会这么强大呢。\n\n### **`ComponentActivity` & `ReportFragment`**\n\n就算没看过源码，知道`Lifecycle` 的人，也应该听说个，这是要给声明周期监控类，那么既然和生命周期有关，那自然是和 `Activity` 有关，通过`AppCompatActivity` 类，我们向上查找，我们可以看到 `ComponentActivity` 这个类，实现了 `LifecycleOwner` 接口，并返回了一个 `mLifecycleRegistry`\n\n```java\n// ComponentActivity 类初始化是，创建了一个 LifecycleRegistry，并将自己传入过去\nprivate final LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);\n\n// LifecycleOwner 接口，提供了一个 getLifecycle() 方法\n@Override\npublic Lifecycle getLifecycle(){\n    return mLifecycleRegistry;\n}\n```\n\n在 `ComponentActivity` 的构造方法里，适配了不同的平台版本。\n\n```java\npublic ComponentActivity() {\n    Lifecycle lifecycle = getLifecycle();\n    //noinspection ConstantConditions\n    if (lifecycle == null) {\n        throw new IllegalStateException(\"getLifecycle() returned null in ComponentActivity's \"\n                                        + \"constructor. Please make sure you are lazily constructing your Lifecycle \"\n                                        + \"in the first call to getLifecycle() rather than relying on field \"\n                                        + \"initialization.\");\n    }\n    if (Build.VERSION.SDK_INT >= 19) {\n        getLifecycle().addObserver(new LifecycleEventObserver() {\n            @Override\n            public void onStateChanged(@NonNull LifecycleOwner source,\n                                       @NonNull Lifecycle.Event event) {\n                if (event == Lifecycle.Event.ON_STOP) {\n                    Window window = getWindow();\n                    final View decor = window != null ? window.peekDecorView() : null;\n                    if (decor != null) {\n                        decor.cancelPendingInputEvents();\n                    }\n                }\n            }\n        });\n    }\n    getLifecycle().addObserver(new LifecycleEventObserver() {\n        @Override\n        public void onStateChanged(@NonNull LifecycleOwner source,\n                                   @NonNull Lifecycle.Event event) {\n            if (event == Lifecycle.Event.ON_DESTROY) {\n                if (!isChangingConfigurations()) {\n                    getViewModelStore().clear();\n                }\n            }\n        }\n    });\n\n    if (19 <= SDK_INT && SDK_INT <= 23) {\n        getLifecycle().addObserver(new ImmLeaksCleaner(this));\n    }\n}\n```\n\n通过构造方法，有没有发现一个很重要的信息， `addObserver()`， 由此，我们不难看出 ，`LifecycleRegister` 的一个重要的方法就是 `addObserver()` 。翻阅类结构了解到 `LifecycleRegister` 是 `Lifecycle` 派生的一个子类，有关所有和声明周期有关的内容，都和这个类有关。\n\n我们先不着急看 `LifecycleRegister`，继续看 `CompontentActivity` 类，既然是个 `Activity` 那么一定会有创建过程，回看 `onCreate()` 方法，我们可以观察到一个有趣的东西：\n\n```java\n/**\n     * {@inheritDoc}\n     *\n     * If your ComponentActivity is annotated with {@link ContentView}, this will\n     * call {@link #setContentView(int)} for you.\n     */\n@Override\nprotected void onCreate(@Nullable Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    mSavedStateRegistryController.performRestore(savedInstanceState);\n    ReportFragment.injectIfNeededIn(this);\n    if (mContentLayoutId != 0) {\n        setContentView(mContentLayoutId);\n    }\n}\n```\n\n`ReportFragment.injectIfNeededIn(this)` 咦？？？？？？？？？？？ 你是谁，你在这儿做什么。\n\n别慌，进去看。\n\n#### `ReportFragment`\n\n```java\npublic static void injectIfNeededIn(Activity activity) {\n    // ProcessLifecycleOwner should always correctly work and some activities may not extend\n    // FragmentActivity from support lib, so we use framework fragments for activities\n    android.app.FragmentManager manager = activity.getFragmentManager();\n    if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) {\n        manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit();\n        // Hopefully, we are the first to make a transaction.\n        manager.executePendingTransactions();\n    }\n}\n```\n\n咦？？？？为什么要在我的 `Activity` 上添加一个 `Fragment`， 翻遍代码，我们也未见到任何布局，你是一个**空的** ，😱😱😱， 太可怕了！\n\n按照 `Fragment` 的生命周期，我们继续看\n\n##### `dispatch()`\n\n```java\n\n@Override\npublic void onActivityCreated(Bundle savedInstanceState) {\n    super.onActivityCreated(savedInstanceState);\n    dispatchCreate(mProcessListener);\n    dispatch(Lifecycle.Event.ON_CREATE);\n}\n\n@Override\npublic void onStart() {\n    super.onStart();\n    dispatchStart(mProcessListener);\n    dispatch(Lifecycle.Event.ON_START);\n}\n\n@Override\npublic void onResume() {\n    super.onResume();\n    dispatchResume(mProcessListener);\n    dispatch(Lifecycle.Event.ON_RESUME);\n}\n\n@Override\npublic void onPause() {\n    super.onPause();\n    dispatch(Lifecycle.Event.ON_PAUSE);\n}\n\n@Override\npublic void onStop() {\n    super.onStop();\n    dispatch(Lifecycle.Event.ON_STOP);\n}\n\n@Override\npublic void onDestroy() {\n    super.onDestroy();\n    dispatch(Lifecycle.Event.ON_DESTROY);\n    // just want to be sure that we won't leak reference to an activity\n    mProcessListener = null;\n}\n```\n\n有没有发现， 又有一个方法被重复的利用，没错，就是`dispatch(Lifecycle.Event event)` 而且传入的参数，又和 `Activity` 的生命周期一致。那么我们来看看它.\n\n##### `handleLifecycleEvent()`\n\n```java\nprivate void dispatch(Lifecycle.Event event) {\n    Activity activity = getActivity();\n    if (activity instanceof LifecycleRegistryOwner) {\n        ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);\n        return;\n    }\n\n    if (activity instanceof LifecycleOwner) {\n        Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();\n        if (lifecycle instanceof LifecycleRegistry) {\n            ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);\n        }\n    }\n}\n```\n\n虽然经过了两个判断，但这没关系，因为这是系统帮助我们做的适配工作，无论如何，他们队中都调用了 `handleLifecycleEvent(event)` 方法，又蒙蔽了不，这里啥也没干，就跑了。\n\n你跑，那我就追！\n\n### **`LifecycleRegister`** \n\n```java\n/**\n     * Sets the current state and notifies the observers.\n     * <p>\n     * Note that if the {@code currentState} is the same state as the last call to this method,\n     * calling this method has no effect.\n     *\n     * @param event The event that was received\n     */\npublic void handleLifecycleEvent(@NonNull Lifecycle.Event event) {\n    State next = getStateAfter(event);\n    moveToState(next);\n}\n\nprivate void moveToState(State next) {\n    if (mState == next) {\n        return;\n    }\n    mState = next;\n    if (mHandlingEvent || mAddingObserverCounter != 0) {\n        mNewEventOccurred = true;\n        // we will figure out what to do on upper level.\n        return;\n    }\n    mHandlingEvent = true;\n    sync();\n    mHandlingEvent = false;\n}\n```\n\n两个方法，我们翻译下注释\n\n> 设置当前状态，并通知观察者\n>\n> 注意，如果当前状态和上一次方法调用时相同，那么这次调用则无效\n\n#### `getStateAfter()`\n\n现在我们来分析源码，`getStateAfter(event)` 这个方法，我们先进去看下做了什么：\n\n```java\nstatic State getStateAfter(Event event) {\n    switch (event) {\n        case ON_CREATE:\n        case ON_STOP:\n            return CREATED;\n        case ON_START:\n        case ON_PAUSE:\n            return STARTED;\n        case ON_RESUME:\n            return RESUMED;\n        case ON_DESTROY:\n            return DESTROYED;\n        case ON_ANY:\n            break;\n    }\n    throw new IllegalArgumentException(\"Unexpected event value \" + event);\n}\n```\n\n原来是一个静态方法，通过传入的 `Event` 事件，找到当前事件对应的下一个生命周期状态 `State`\n\n\n\n我们还有一个方法没有分析 `moveToState(State next)`, 从函数名上，可以看出，这是一个状态移动的方法，具体是什么呢，我们进入方法内可以看到 \n\n``` java\nif (mState == next) {\n\treturn;\n}\n```\n\n如果当前状态和下一个（操作后的）状态一致，则直接 `return` 这也映照了注释中的那句话。\n\n#### `sync()`\n\n继续就是将操作的下一个状态做了一次记录，中间的一些判断条件我们不看，顺序的会看到一个 `sync()` 方法，咦，这又是什么呢？===> 状态同步\n\n```java\n/**\n     * Custom list that keeps observers and can handle removals / additions during traversal.\n     *\n     * Invariant: at any moment of time for observer1 & observer2:\n     * if addition_order(observer1) < addition_order(observer2), then\n     * state(observer1) >= state(observer2),\n     */\nprivate FastSafeIterableMap<LifecycleObserver, ObserverWithState> mObserverMap =\n    new FastSafeIterableMap<>();\n// happens only on the top of stack (never in reentrance),\n// so it doesn't have to take in account parents\nprivate void sync() {\n    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();\n    if (lifecycleOwner == null) {\n        throw new IllegalStateException(\"LifecycleOwner of this LifecycleRegistry is already\"\n                                        + \"garbage collected. It is too late to change lifecycle state.\");\n    }\n    while (!isSynced()) {\n        mNewEventOccurred = false;\n        // no need to check eldest for nullability, because isSynced does it for us.\n        if (mState.compareTo(mObserverMap.eldest().getValue().mState) < 0) {\n            backwardPass(lifecycleOwner);\n        }\n        Entry<LifecycleObserver, ObserverWithState> newest = mObserverMap.newest();\n        if (!mNewEventOccurred && newest != null\n            && mState.compareTo(newest.getValue().mState) > 0) {\n            forwardPass(lifecycleOwner);\n        }\n    }\n    mNewEventOccurred = false;\n}\n```\n\n这里出现了一个新东西 `mObserverMap` 向上我们找他的它类型，这里对数据结构不做研究，简单说一下，它是一个双向链表，并提供了一个 map 做缓冲区，且提供了一个可以快速迭代的结构。\n\n继续分析源码\n\n`mState.compareTo(mObserverMap.eldest().getValue().mState) < 0` 从缓存的观察者中拿出最旧的状态，与当前状态进行比较，如果小于 0， 说明观察者的状态提前于当前状态，那么就执行一个`backwardPass(lifecycleOwner)` 方法，让观察者的状态回退到当前状态上\n\n` mState.compareTo(newest.getValue().mState) > 0` 这个判断正好和上面相反，说明当前的观察者状态落后于当前状态，那么就让观察者的状态追上当前状态，执行 `forwardPass(lifecycleOwner)`\n\n#### **`Lifecycle State Sequence`**\n\n通过分析 `forwardPass` 和 `backwardPass` 方法，我们看到其内部又调用了两个方法, `downEvent` 和 `upEvent`，我们称呼为升级事件和降级事件\n\n```java\n private static Event downEvent(State state) {\n        switch (state) {\n            case INITIALIZED:\n                throw new IllegalArgumentException();\n            case CREATED:\n                return ON_DESTROY;\n            case STARTED:\n                return ON_STOP;\n            case RESUMED:\n                return ON_PAUSE;\n            case DESTROYED:\n                throw new IllegalArgumentException();\n        }\n        throw new IllegalArgumentException(\"Unexpected state value \" + state);\n    }\n\n    private static Event upEvent(State state) {\n        switch (state) {\n            case INITIALIZED:\n            case DESTROYED:\n                return ON_CREATE;\n            case CREATED:\n                return ON_START;\n            case STARTED:\n                return ON_RESUME;\n            case RESUMED:\n                throw new IllegalArgumentException();\n        }\n        throw new IllegalArgumentException(\"Unexpected state value \" + state);\n    }\n```\n\n通过上面两个方法，我们总结出 `Lifecycle` 中 `State` 和 `Event` 的时序关系，如下图\n\n![Lifecycle State Sequence](https://github.com/xiaomanwong/static_file/blob/master/images/Lifecycle%20State%20secquece.png?raw=true)\n\n同时我们也回顾一下，`getStateAfter()` 方法，对事件和状态的判断，也就明白了状态和事件的关系。\n\n#### `dispatchEvent`\n\n```java\nprivate void forwardPass(LifecycleOwner lifecycleOwner) {\n    Iterator<Entry<LifecycleObserver, ObserverWithState>> ascendingIterator =\n        mObserverMap.iteratorWithAdditions();\n    while (ascendingIterator.hasNext() && !mNewEventOccurred) {\n        Entry<LifecycleObserver, ObserverWithState> entry = ascendingIterator.next();\n        ObserverWithState observer = entry.getValue();\n        while ((observer.mState.compareTo(mState) < 0 && !mNewEventOccurred\n                && mObserverMap.contains(entry.getKey()))) {\n            pushParentState(observer.mState);\n            observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState));\n            popParentState();\n        }\n    }\n}\n\nprivate void backwardPass(LifecycleOwner lifecycleOwner) {\n    Iterator<Entry<LifecycleObserver, ObserverWithState>> descendingIterator =\n        mObserverMap.descendingIterator();\n    while (descendingIterator.hasNext() && !mNewEventOccurred) {\n        Entry<LifecycleObserver, ObserverWithState> entry = descendingIterator.next();\n        ObserverWithState observer = entry.getValue();\n        while ((observer.mState.compareTo(mState) > 0 && !mNewEventOccurred\n                && mObserverMap.contains(entry.getKey()))) {\n            Event event = downEvent(observer.mState);\n            pushParentState(getStateAfter(event));\n            observer.dispatchEvent(lifecycleOwner, event);\n            popParentState();\n        }\n    }\n}\n```\n\n迟到的两个方法终于来了，这里也没有什么可以复杂的。只是通过循环找到所有的观察者，并进行事件的分发`observer.dispatchEvent(lifecycleOwner, event)`\n\n```java\nvoid dispatchEvent(LifecycleOwner owner, Event event) {\n    State newState = getStateAfter(event);\n    mState = min(mState, newState);\n    mLifecycleObserver.onStateChanged(owner, event);\n    mState = newState;\n}\n```\n\n哈哈， 又是一个方法进入了我们的视线 `onStateChanged(owner, event)`，再次点击去后，发现是一个接口。查询可以看到有很多实现类，困惑吗？？？？\n\n但我们只需要关注 `ReflectiveGenericLifecycleObserver` , 想知道为什么吗？ 我也是看了源码才总结出来的。\n\n#### `ReflectiveGenericLifecycleObserver`\n\n```java\n/**\n * An internal implementation of {@link LifecycleObserver} that relies on reflection.\n */\nclass ReflectiveGenericLifecycleObserver implements LifecycleEventObserver {\n    private final Object mWrapped;\n    private final CallbackInfo mInfo;\n\n    ReflectiveGenericLifecycleObserver(Object wrapped) {\n        mWrapped = wrapped;\n        mInfo = ClassesInfoCache.sInstance.getInfo(mWrapped.getClass());\n    }\n\n    @Override\n    public void onStateChanged(LifecycleOwner source, Event event) {\n        mInfo.invokeCallbacks(source, event, mWrapped);\n    }\n}\n```\n\n哎，`mInfo.invokeCallbacks(source,event,mWrapped);` 这又是什么，捋下来还从没见过，我们也没见过这个类的初始化和加载过程，对不对😨😨😨\n\n既然是类嘛，那肯定是要创建的，那就看下构造器呗。\n\n`wrapped` 这东西，经过了缓存，Emmm ，我也是点进去 `ClassesInfoCache` 之后，都了它的注释才明白的。\n\n那 `wrapped` 又是什么呢？通过 `ClassesInfoCache` 和我们追踪 `ReflectiveGenericLifecycleObserver` 可以看出， `ClassesInfoCache` 缓存了 `LifecycleObserver` 的类对象，`ReflectiveGenericLifecycleObserver` 也是向下传递一个 `LifecycleObserver`。由此我们可以判断出，其实这个 `LifecycleObserver` 就是我们自己定义的观察者。\n\n而系统帮我做的事儿，就是使用反射技术，通过我们自己标注的注解，并根据当前生命周期的状态，反射执行我们的方法 `mInfo.invokeCallback(source event, mWrapped);`\n\n#### `reflect invoke method`\n\n```java\nvoid invokeCallback(LifecycleOwner source, Lifecycle.Event event, Object target) {\n    //noinspection TryWithIdenticalCatches\n    try {\n        switch (mCallType) {\n            case CALL_TYPE_NO_ARG:\n                mMethod.invoke(target);\n                break;\n            case CALL_TYPE_PROVIDER:\n                mMethod.invoke(target, source);\n                break;\n            case CALL_TYPE_PROVIDER_WITH_EVENT:\n                mMethod.invoke(target, source, event);\n                break;\n        }\n    } catch (InvocationTargetException e) {\n        throw new RuntimeException(\"Failed to call observer method\", e.getCause());\n    } catch (IllegalAccessException e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n\n还记得文章开头对 `Lifecycle` 注解的翻译吗？ 这里的判断就是依据其注解标注，并回调对应的参数方法\n\n至此，似乎我们已经不能再追下去了，代码执行到这里已经结束了。\n\n但是！！！！！！！！！！！！！！！！\n\n我们还有一大块没有分析！！！！！！！！！！！！！！！！！！！！！！！！\n\n#### `addObserver()`\n\n前面我们说了一大堆，都是对 `Lifecycle` 如何处理，并监听我们的生命周期的方法，也就是 `Lifecycle`是如何处理监听的。那么我们前面一直都没有说过，观察者那里来的？？？？？？？？？\n\n好，我们继续观察 `LifecycleRegister` 中的 `addObserver(LifecycleObserver)` 这个也是我们自定义观察者后，需要调用的方法\n\n```java\n@Override\npublic void addObserver(@NonNull LifecycleObserver observer) {\n    State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;\n    ObserverWithState statefulObserver = new ObserverWithState(observer, initialState);\n    ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);\n\n    if (previous != null) {\n        return;\n    }\n    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();\n    if (lifecycleOwner == null) {\n        // it is null we should be destroyed. Fallback quickly\n        return;\n    }\n\n    boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent;\n    State targetState = calculateTargetState(observer);\n    mAddingObserverCounter++;\n    while ((statefulObserver.mState.compareTo(targetState) < 0\n            && mObserverMap.contains(observer))) {\n        pushParentState(statefulObserver.mState);\n        statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));\n        popParentState();\n        // mState / subling may have been changed recalculate\n        targetState = calculateTargetState(observer);\n    }\n\n    if (!isReentrance) {\n        // we do sync only on the top level.\n        sync();\n    }\n    mAddingObserverCounter--;\n}\n```\n\n哈哈，看起来代码并不是很多丫！！！！   哼，天真的你！但它就是这么多\n\n我们这里要逐行清点\n\n`State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;` 嗯，一上来就初始化了一个 `INITIALIZED` 状态的状态，哈哈哈，好拗口。\n\n随后创建了一个 `ObserverWithState` ，这是一个有状态的观察者，从名字上我们就可以看出来。两个参数分别是我们传入的观察者和我们刚刚创建好的状态。这是个装饰器模式，目的是给原对象，增加一个新属性，但又不改变原数据结构的方案。\n\n紧接着又把这个观察者和带有状态的观察者，放进了事先已经创建好的 `Map` 中，也就是 `mObserverMap` 然后返回了个东西， 阅读后发现，又和 `Lifecycle` 的注释对上了。\n\n之后，计算出当前 `Activity` 或 `Fragment` 的状态，并判断，如果当前观察者的状态落后于 `Activity` 或 `Fragment` 的状态，则立即执行`dispatchEvent()` 方法，执行回调。\n\n\n\n## 总结\n\n认真阅读源码后，我们能够看出，其实 `Lifecycle` 的技术很简单，只有**反射**，**观察者**，**装饰器**，它将这三个东西应用的很神。\n\n总结一下，分析源码我们从两方面入手\n\n1. `addObserver()`\n\n    这个方法是对用户最直接的内容，当我们创建一个 `Observer` 后，都会通过 `add` 的方式，将我们自己定义的观察者传入，那么从这个突破口我们进入源码分析观察到\n\n   1. 给要添加的`Observer` 一个初始的状态（装饰器模式，包装数据）\n   2. 将数据存储再本地缓存中 （`mObserverMap`）\n   3. 立即进行状态判断，决定是否处理生命周期变化\n\n2. `ReportFragment`\n\n   作用是，附着再 `Activity` 上，用来感知 `Activity` 的生命周期变化，也起到将业务从 `Activity` 中分离出来。通过生命感知生命周期的变化，执行 `dispatch()` 方法，将生命周期事件分发给它所有的观察者去处理消息 `handleLifecycleEvent`\n\n3. **反射**\n\n   这里的东西比较抽象，没有任何内容是能看出来和我们有什么关系的， 只要你熟悉反射，那么你就能明白它再做什么。\n\n4. `sync()`\n\n   这个方法是用来快速同步观察者状态与 `Activity` 和 `Fragment`  ，目的也是能够让观察者执行到它所有观察的数据。两个方法 `forwardPass()` 和 `backwardPass()`  是其实现的原理。\n\n","source":"_posts/Jetpack/Lifecycle 源码分析.md","raw":"---\ntitle: Android Lifecycle\ntag: Android\n\n---\n\n## 开始是废话（翻译自源码）\n\n定义了一个 Android 生命周期的对象。 `Fragment`和`FragmentActivity`类实现`LifecycleOwner`接口， 并可以通过 `getLifecycle()` 方法来访问生命周期。 我们也可以实现`LifecycleOwner`在自己的类。\n<!-- more-->\n```Java\n// 在此类事件后分发 LifecycleOwner 的相关方法的返回时。 \nLifecycle.Event.ON_CREATE ， Lifecycle.Event.ON_START ， Lifecycle.Event.ON_RESUME\n// 在此类事件在之前分派LifecycleOwner被称为的相关方法。 例如， Lifecycle.Event.ON_START后会被分派onStart回报， Lifecycle.Event.ON_STOP之前将派出onStop被调用。 这给你一定的保证在其国家的主人在不在。\nLifecycle.Event.ON_PAUSE ， Lifecycle.Event.ON_STOP ， Lifecycle.Event.ON_DESTROY\n```\n\n\n如果您使用Java 8 语言 ，然后使用`DefaultLifecycleObserver` 观察事件。 需要将`\"androidx.lifecycle:common-java8:<version>\"` 增加到你的 `build.gradle` 文件中。\n\n```java\nclass TestObserver implements DefaultLifecycleObserver {\n    @Override\n    public void onCreate(LifecycleOwner owner) {\n        // your code\n    }\n}\n```\n\n  \n\n如果你使用的Java 7 语言 ，使用的注解观察生命周期事件。 一旦Java的8语言成为在Android上的主流，注释将被弃用，所以`DefaultLifecycleObserver`和注释之间，则须偏向 `DefaultLifecycleObserver `。\n\n   ```java \nclass TestObserver implements LifecycleObserver {\n    @OnLifecycleEvent(ON_STOP)\n    void onStopped() {}\n}\n   ```\n\n观测方法可以接收零个或一个参数。 如果使用，第一个参数的类型必须为`LifecycleOwner` 。 带注释的方法`Lifecycle.Event.ON_ANY` 可以接收第二个参数，它必须是类型的`Lifecycle.Event `。\n\n  ```java\nclass TestObserver implements LifecycleObserver {\n    @OnLifecycleEvent(ON_CREATE)\n    void onCreated(LifecycleOwner source) {}\n    @OnLifecycleEvent(ON_ANY)\n    void onAny(LifecycleOwner source, Event event) {}\n}\n  ```\n\n提供这些额外的参数可以让您方便地观察到多个供应商和事件，而无需手动跟踪他们。\n\n##  那我能做什么呢\n\n说到这里，我们就应该想到一些在开发中常常不被我们忽视，但又不怎么使用的东西 **友盟统计**\n\n在友盟统计中，我们经常会在 `BaseActivity` 中插入友盟对页面流转的统计, `onStart()` `onResume()` `onPause()` `onStop()` 等，然而这里有一点不好的是，我们的业务和公共组件耦合在了一起。\n\n干货~~~来了\n\n那么解决上述问题的方案就来了，我们通过实现 `LifecycleObserver` ，通过标识声明周期方法之后，仅需一句 `addObserver(this)` ，就可以将 `Activity` 或 `Fragment ` 的声明周期方法与我们定义的 `Observer` 方法关联起来。通过感知 `Activity` 或 `Fragment` 的声明周期方法，实现友盟统计，此时就将业务整体与 `BaseActivity` 抽离开，是的公共组件变得更简洁一些。\n\n当然，这只是 `Lifecycle` 的一种简单应用，其他的使用方法还是需要我们不断的去探索。\n\n## 源码分析\n\n### **`Lifecycle UML`**\n\n![Lifecycle UML](https://github.com/xiaomanwong/static_file/blob/master/images/Lifecycle%20UML.png?raw=true)\n\n**想理解一个东西，最好的方式就是去阅读它**， 这是开发多年总结出的一句话。\n\n那么通过上面的 UML 类图关系，我们能够看出， `Lifecycle` 的内容并不是很多。但它怎么就会这么强大呢。\n\n### **`ComponentActivity` & `ReportFragment`**\n\n就算没看过源码，知道`Lifecycle` 的人，也应该听说个，这是要给声明周期监控类，那么既然和生命周期有关，那自然是和 `Activity` 有关，通过`AppCompatActivity` 类，我们向上查找，我们可以看到 `ComponentActivity` 这个类，实现了 `LifecycleOwner` 接口，并返回了一个 `mLifecycleRegistry`\n\n```java\n// ComponentActivity 类初始化是，创建了一个 LifecycleRegistry，并将自己传入过去\nprivate final LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);\n\n// LifecycleOwner 接口，提供了一个 getLifecycle() 方法\n@Override\npublic Lifecycle getLifecycle(){\n    return mLifecycleRegistry;\n}\n```\n\n在 `ComponentActivity` 的构造方法里，适配了不同的平台版本。\n\n```java\npublic ComponentActivity() {\n    Lifecycle lifecycle = getLifecycle();\n    //noinspection ConstantConditions\n    if (lifecycle == null) {\n        throw new IllegalStateException(\"getLifecycle() returned null in ComponentActivity's \"\n                                        + \"constructor. Please make sure you are lazily constructing your Lifecycle \"\n                                        + \"in the first call to getLifecycle() rather than relying on field \"\n                                        + \"initialization.\");\n    }\n    if (Build.VERSION.SDK_INT >= 19) {\n        getLifecycle().addObserver(new LifecycleEventObserver() {\n            @Override\n            public void onStateChanged(@NonNull LifecycleOwner source,\n                                       @NonNull Lifecycle.Event event) {\n                if (event == Lifecycle.Event.ON_STOP) {\n                    Window window = getWindow();\n                    final View decor = window != null ? window.peekDecorView() : null;\n                    if (decor != null) {\n                        decor.cancelPendingInputEvents();\n                    }\n                }\n            }\n        });\n    }\n    getLifecycle().addObserver(new LifecycleEventObserver() {\n        @Override\n        public void onStateChanged(@NonNull LifecycleOwner source,\n                                   @NonNull Lifecycle.Event event) {\n            if (event == Lifecycle.Event.ON_DESTROY) {\n                if (!isChangingConfigurations()) {\n                    getViewModelStore().clear();\n                }\n            }\n        }\n    });\n\n    if (19 <= SDK_INT && SDK_INT <= 23) {\n        getLifecycle().addObserver(new ImmLeaksCleaner(this));\n    }\n}\n```\n\n通过构造方法，有没有发现一个很重要的信息， `addObserver()`， 由此，我们不难看出 ，`LifecycleRegister` 的一个重要的方法就是 `addObserver()` 。翻阅类结构了解到 `LifecycleRegister` 是 `Lifecycle` 派生的一个子类，有关所有和声明周期有关的内容，都和这个类有关。\n\n我们先不着急看 `LifecycleRegister`，继续看 `CompontentActivity` 类，既然是个 `Activity` 那么一定会有创建过程，回看 `onCreate()` 方法，我们可以观察到一个有趣的东西：\n\n```java\n/**\n     * {@inheritDoc}\n     *\n     * If your ComponentActivity is annotated with {@link ContentView}, this will\n     * call {@link #setContentView(int)} for you.\n     */\n@Override\nprotected void onCreate(@Nullable Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    mSavedStateRegistryController.performRestore(savedInstanceState);\n    ReportFragment.injectIfNeededIn(this);\n    if (mContentLayoutId != 0) {\n        setContentView(mContentLayoutId);\n    }\n}\n```\n\n`ReportFragment.injectIfNeededIn(this)` 咦？？？？？？？？？？？ 你是谁，你在这儿做什么。\n\n别慌，进去看。\n\n#### `ReportFragment`\n\n```java\npublic static void injectIfNeededIn(Activity activity) {\n    // ProcessLifecycleOwner should always correctly work and some activities may not extend\n    // FragmentActivity from support lib, so we use framework fragments for activities\n    android.app.FragmentManager manager = activity.getFragmentManager();\n    if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) {\n        manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit();\n        // Hopefully, we are the first to make a transaction.\n        manager.executePendingTransactions();\n    }\n}\n```\n\n咦？？？？为什么要在我的 `Activity` 上添加一个 `Fragment`， 翻遍代码，我们也未见到任何布局，你是一个**空的** ，😱😱😱， 太可怕了！\n\n按照 `Fragment` 的生命周期，我们继续看\n\n##### `dispatch()`\n\n```java\n\n@Override\npublic void onActivityCreated(Bundle savedInstanceState) {\n    super.onActivityCreated(savedInstanceState);\n    dispatchCreate(mProcessListener);\n    dispatch(Lifecycle.Event.ON_CREATE);\n}\n\n@Override\npublic void onStart() {\n    super.onStart();\n    dispatchStart(mProcessListener);\n    dispatch(Lifecycle.Event.ON_START);\n}\n\n@Override\npublic void onResume() {\n    super.onResume();\n    dispatchResume(mProcessListener);\n    dispatch(Lifecycle.Event.ON_RESUME);\n}\n\n@Override\npublic void onPause() {\n    super.onPause();\n    dispatch(Lifecycle.Event.ON_PAUSE);\n}\n\n@Override\npublic void onStop() {\n    super.onStop();\n    dispatch(Lifecycle.Event.ON_STOP);\n}\n\n@Override\npublic void onDestroy() {\n    super.onDestroy();\n    dispatch(Lifecycle.Event.ON_DESTROY);\n    // just want to be sure that we won't leak reference to an activity\n    mProcessListener = null;\n}\n```\n\n有没有发现， 又有一个方法被重复的利用，没错，就是`dispatch(Lifecycle.Event event)` 而且传入的参数，又和 `Activity` 的生命周期一致。那么我们来看看它.\n\n##### `handleLifecycleEvent()`\n\n```java\nprivate void dispatch(Lifecycle.Event event) {\n    Activity activity = getActivity();\n    if (activity instanceof LifecycleRegistryOwner) {\n        ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);\n        return;\n    }\n\n    if (activity instanceof LifecycleOwner) {\n        Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();\n        if (lifecycle instanceof LifecycleRegistry) {\n            ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);\n        }\n    }\n}\n```\n\n虽然经过了两个判断，但这没关系，因为这是系统帮助我们做的适配工作，无论如何，他们队中都调用了 `handleLifecycleEvent(event)` 方法，又蒙蔽了不，这里啥也没干，就跑了。\n\n你跑，那我就追！\n\n### **`LifecycleRegister`** \n\n```java\n/**\n     * Sets the current state and notifies the observers.\n     * <p>\n     * Note that if the {@code currentState} is the same state as the last call to this method,\n     * calling this method has no effect.\n     *\n     * @param event The event that was received\n     */\npublic void handleLifecycleEvent(@NonNull Lifecycle.Event event) {\n    State next = getStateAfter(event);\n    moveToState(next);\n}\n\nprivate void moveToState(State next) {\n    if (mState == next) {\n        return;\n    }\n    mState = next;\n    if (mHandlingEvent || mAddingObserverCounter != 0) {\n        mNewEventOccurred = true;\n        // we will figure out what to do on upper level.\n        return;\n    }\n    mHandlingEvent = true;\n    sync();\n    mHandlingEvent = false;\n}\n```\n\n两个方法，我们翻译下注释\n\n> 设置当前状态，并通知观察者\n>\n> 注意，如果当前状态和上一次方法调用时相同，那么这次调用则无效\n\n#### `getStateAfter()`\n\n现在我们来分析源码，`getStateAfter(event)` 这个方法，我们先进去看下做了什么：\n\n```java\nstatic State getStateAfter(Event event) {\n    switch (event) {\n        case ON_CREATE:\n        case ON_STOP:\n            return CREATED;\n        case ON_START:\n        case ON_PAUSE:\n            return STARTED;\n        case ON_RESUME:\n            return RESUMED;\n        case ON_DESTROY:\n            return DESTROYED;\n        case ON_ANY:\n            break;\n    }\n    throw new IllegalArgumentException(\"Unexpected event value \" + event);\n}\n```\n\n原来是一个静态方法，通过传入的 `Event` 事件，找到当前事件对应的下一个生命周期状态 `State`\n\n\n\n我们还有一个方法没有分析 `moveToState(State next)`, 从函数名上，可以看出，这是一个状态移动的方法，具体是什么呢，我们进入方法内可以看到 \n\n``` java\nif (mState == next) {\n\treturn;\n}\n```\n\n如果当前状态和下一个（操作后的）状态一致，则直接 `return` 这也映照了注释中的那句话。\n\n#### `sync()`\n\n继续就是将操作的下一个状态做了一次记录，中间的一些判断条件我们不看，顺序的会看到一个 `sync()` 方法，咦，这又是什么呢？===> 状态同步\n\n```java\n/**\n     * Custom list that keeps observers and can handle removals / additions during traversal.\n     *\n     * Invariant: at any moment of time for observer1 & observer2:\n     * if addition_order(observer1) < addition_order(observer2), then\n     * state(observer1) >= state(observer2),\n     */\nprivate FastSafeIterableMap<LifecycleObserver, ObserverWithState> mObserverMap =\n    new FastSafeIterableMap<>();\n// happens only on the top of stack (never in reentrance),\n// so it doesn't have to take in account parents\nprivate void sync() {\n    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();\n    if (lifecycleOwner == null) {\n        throw new IllegalStateException(\"LifecycleOwner of this LifecycleRegistry is already\"\n                                        + \"garbage collected. It is too late to change lifecycle state.\");\n    }\n    while (!isSynced()) {\n        mNewEventOccurred = false;\n        // no need to check eldest for nullability, because isSynced does it for us.\n        if (mState.compareTo(mObserverMap.eldest().getValue().mState) < 0) {\n            backwardPass(lifecycleOwner);\n        }\n        Entry<LifecycleObserver, ObserverWithState> newest = mObserverMap.newest();\n        if (!mNewEventOccurred && newest != null\n            && mState.compareTo(newest.getValue().mState) > 0) {\n            forwardPass(lifecycleOwner);\n        }\n    }\n    mNewEventOccurred = false;\n}\n```\n\n这里出现了一个新东西 `mObserverMap` 向上我们找他的它类型，这里对数据结构不做研究，简单说一下，它是一个双向链表，并提供了一个 map 做缓冲区，且提供了一个可以快速迭代的结构。\n\n继续分析源码\n\n`mState.compareTo(mObserverMap.eldest().getValue().mState) < 0` 从缓存的观察者中拿出最旧的状态，与当前状态进行比较，如果小于 0， 说明观察者的状态提前于当前状态，那么就执行一个`backwardPass(lifecycleOwner)` 方法，让观察者的状态回退到当前状态上\n\n` mState.compareTo(newest.getValue().mState) > 0` 这个判断正好和上面相反，说明当前的观察者状态落后于当前状态，那么就让观察者的状态追上当前状态，执行 `forwardPass(lifecycleOwner)`\n\n#### **`Lifecycle State Sequence`**\n\n通过分析 `forwardPass` 和 `backwardPass` 方法，我们看到其内部又调用了两个方法, `downEvent` 和 `upEvent`，我们称呼为升级事件和降级事件\n\n```java\n private static Event downEvent(State state) {\n        switch (state) {\n            case INITIALIZED:\n                throw new IllegalArgumentException();\n            case CREATED:\n                return ON_DESTROY;\n            case STARTED:\n                return ON_STOP;\n            case RESUMED:\n                return ON_PAUSE;\n            case DESTROYED:\n                throw new IllegalArgumentException();\n        }\n        throw new IllegalArgumentException(\"Unexpected state value \" + state);\n    }\n\n    private static Event upEvent(State state) {\n        switch (state) {\n            case INITIALIZED:\n            case DESTROYED:\n                return ON_CREATE;\n            case CREATED:\n                return ON_START;\n            case STARTED:\n                return ON_RESUME;\n            case RESUMED:\n                throw new IllegalArgumentException();\n        }\n        throw new IllegalArgumentException(\"Unexpected state value \" + state);\n    }\n```\n\n通过上面两个方法，我们总结出 `Lifecycle` 中 `State` 和 `Event` 的时序关系，如下图\n\n![Lifecycle State Sequence](https://github.com/xiaomanwong/static_file/blob/master/images/Lifecycle%20State%20secquece.png?raw=true)\n\n同时我们也回顾一下，`getStateAfter()` 方法，对事件和状态的判断，也就明白了状态和事件的关系。\n\n#### `dispatchEvent`\n\n```java\nprivate void forwardPass(LifecycleOwner lifecycleOwner) {\n    Iterator<Entry<LifecycleObserver, ObserverWithState>> ascendingIterator =\n        mObserverMap.iteratorWithAdditions();\n    while (ascendingIterator.hasNext() && !mNewEventOccurred) {\n        Entry<LifecycleObserver, ObserverWithState> entry = ascendingIterator.next();\n        ObserverWithState observer = entry.getValue();\n        while ((observer.mState.compareTo(mState) < 0 && !mNewEventOccurred\n                && mObserverMap.contains(entry.getKey()))) {\n            pushParentState(observer.mState);\n            observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState));\n            popParentState();\n        }\n    }\n}\n\nprivate void backwardPass(LifecycleOwner lifecycleOwner) {\n    Iterator<Entry<LifecycleObserver, ObserverWithState>> descendingIterator =\n        mObserverMap.descendingIterator();\n    while (descendingIterator.hasNext() && !mNewEventOccurred) {\n        Entry<LifecycleObserver, ObserverWithState> entry = descendingIterator.next();\n        ObserverWithState observer = entry.getValue();\n        while ((observer.mState.compareTo(mState) > 0 && !mNewEventOccurred\n                && mObserverMap.contains(entry.getKey()))) {\n            Event event = downEvent(observer.mState);\n            pushParentState(getStateAfter(event));\n            observer.dispatchEvent(lifecycleOwner, event);\n            popParentState();\n        }\n    }\n}\n```\n\n迟到的两个方法终于来了，这里也没有什么可以复杂的。只是通过循环找到所有的观察者，并进行事件的分发`observer.dispatchEvent(lifecycleOwner, event)`\n\n```java\nvoid dispatchEvent(LifecycleOwner owner, Event event) {\n    State newState = getStateAfter(event);\n    mState = min(mState, newState);\n    mLifecycleObserver.onStateChanged(owner, event);\n    mState = newState;\n}\n```\n\n哈哈， 又是一个方法进入了我们的视线 `onStateChanged(owner, event)`，再次点击去后，发现是一个接口。查询可以看到有很多实现类，困惑吗？？？？\n\n但我们只需要关注 `ReflectiveGenericLifecycleObserver` , 想知道为什么吗？ 我也是看了源码才总结出来的。\n\n#### `ReflectiveGenericLifecycleObserver`\n\n```java\n/**\n * An internal implementation of {@link LifecycleObserver} that relies on reflection.\n */\nclass ReflectiveGenericLifecycleObserver implements LifecycleEventObserver {\n    private final Object mWrapped;\n    private final CallbackInfo mInfo;\n\n    ReflectiveGenericLifecycleObserver(Object wrapped) {\n        mWrapped = wrapped;\n        mInfo = ClassesInfoCache.sInstance.getInfo(mWrapped.getClass());\n    }\n\n    @Override\n    public void onStateChanged(LifecycleOwner source, Event event) {\n        mInfo.invokeCallbacks(source, event, mWrapped);\n    }\n}\n```\n\n哎，`mInfo.invokeCallbacks(source,event,mWrapped);` 这又是什么，捋下来还从没见过，我们也没见过这个类的初始化和加载过程，对不对😨😨😨\n\n既然是类嘛，那肯定是要创建的，那就看下构造器呗。\n\n`wrapped` 这东西，经过了缓存，Emmm ，我也是点进去 `ClassesInfoCache` 之后，都了它的注释才明白的。\n\n那 `wrapped` 又是什么呢？通过 `ClassesInfoCache` 和我们追踪 `ReflectiveGenericLifecycleObserver` 可以看出， `ClassesInfoCache` 缓存了 `LifecycleObserver` 的类对象，`ReflectiveGenericLifecycleObserver` 也是向下传递一个 `LifecycleObserver`。由此我们可以判断出，其实这个 `LifecycleObserver` 就是我们自己定义的观察者。\n\n而系统帮我做的事儿，就是使用反射技术，通过我们自己标注的注解，并根据当前生命周期的状态，反射执行我们的方法 `mInfo.invokeCallback(source event, mWrapped);`\n\n#### `reflect invoke method`\n\n```java\nvoid invokeCallback(LifecycleOwner source, Lifecycle.Event event, Object target) {\n    //noinspection TryWithIdenticalCatches\n    try {\n        switch (mCallType) {\n            case CALL_TYPE_NO_ARG:\n                mMethod.invoke(target);\n                break;\n            case CALL_TYPE_PROVIDER:\n                mMethod.invoke(target, source);\n                break;\n            case CALL_TYPE_PROVIDER_WITH_EVENT:\n                mMethod.invoke(target, source, event);\n                break;\n        }\n    } catch (InvocationTargetException e) {\n        throw new RuntimeException(\"Failed to call observer method\", e.getCause());\n    } catch (IllegalAccessException e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n\n还记得文章开头对 `Lifecycle` 注解的翻译吗？ 这里的判断就是依据其注解标注，并回调对应的参数方法\n\n至此，似乎我们已经不能再追下去了，代码执行到这里已经结束了。\n\n但是！！！！！！！！！！！！！！！！\n\n我们还有一大块没有分析！！！！！！！！！！！！！！！！！！！！！！！！\n\n#### `addObserver()`\n\n前面我们说了一大堆，都是对 `Lifecycle` 如何处理，并监听我们的生命周期的方法，也就是 `Lifecycle`是如何处理监听的。那么我们前面一直都没有说过，观察者那里来的？？？？？？？？？\n\n好，我们继续观察 `LifecycleRegister` 中的 `addObserver(LifecycleObserver)` 这个也是我们自定义观察者后，需要调用的方法\n\n```java\n@Override\npublic void addObserver(@NonNull LifecycleObserver observer) {\n    State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;\n    ObserverWithState statefulObserver = new ObserverWithState(observer, initialState);\n    ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);\n\n    if (previous != null) {\n        return;\n    }\n    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();\n    if (lifecycleOwner == null) {\n        // it is null we should be destroyed. Fallback quickly\n        return;\n    }\n\n    boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent;\n    State targetState = calculateTargetState(observer);\n    mAddingObserverCounter++;\n    while ((statefulObserver.mState.compareTo(targetState) < 0\n            && mObserverMap.contains(observer))) {\n        pushParentState(statefulObserver.mState);\n        statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));\n        popParentState();\n        // mState / subling may have been changed recalculate\n        targetState = calculateTargetState(observer);\n    }\n\n    if (!isReentrance) {\n        // we do sync only on the top level.\n        sync();\n    }\n    mAddingObserverCounter--;\n}\n```\n\n哈哈，看起来代码并不是很多丫！！！！   哼，天真的你！但它就是这么多\n\n我们这里要逐行清点\n\n`State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;` 嗯，一上来就初始化了一个 `INITIALIZED` 状态的状态，哈哈哈，好拗口。\n\n随后创建了一个 `ObserverWithState` ，这是一个有状态的观察者，从名字上我们就可以看出来。两个参数分别是我们传入的观察者和我们刚刚创建好的状态。这是个装饰器模式，目的是给原对象，增加一个新属性，但又不改变原数据结构的方案。\n\n紧接着又把这个观察者和带有状态的观察者，放进了事先已经创建好的 `Map` 中，也就是 `mObserverMap` 然后返回了个东西， 阅读后发现，又和 `Lifecycle` 的注释对上了。\n\n之后，计算出当前 `Activity` 或 `Fragment` 的状态，并判断，如果当前观察者的状态落后于 `Activity` 或 `Fragment` 的状态，则立即执行`dispatchEvent()` 方法，执行回调。\n\n\n\n## 总结\n\n认真阅读源码后，我们能够看出，其实 `Lifecycle` 的技术很简单，只有**反射**，**观察者**，**装饰器**，它将这三个东西应用的很神。\n\n总结一下，分析源码我们从两方面入手\n\n1. `addObserver()`\n\n    这个方法是对用户最直接的内容，当我们创建一个 `Observer` 后，都会通过 `add` 的方式，将我们自己定义的观察者传入，那么从这个突破口我们进入源码分析观察到\n\n   1. 给要添加的`Observer` 一个初始的状态（装饰器模式，包装数据）\n   2. 将数据存储再本地缓存中 （`mObserverMap`）\n   3. 立即进行状态判断，决定是否处理生命周期变化\n\n2. `ReportFragment`\n\n   作用是，附着再 `Activity` 上，用来感知 `Activity` 的生命周期变化，也起到将业务从 `Activity` 中分离出来。通过生命感知生命周期的变化，执行 `dispatch()` 方法，将生命周期事件分发给它所有的观察者去处理消息 `handleLifecycleEvent`\n\n3. **反射**\n\n   这里的东西比较抽象，没有任何内容是能看出来和我们有什么关系的， 只要你熟悉反射，那么你就能明白它再做什么。\n\n4. `sync()`\n\n   这个方法是用来快速同步观察者状态与 `Activity` 和 `Fragment`  ，目的也是能够让观察者执行到它所有观察的数据。两个方法 `forwardPass()` 和 `backwardPass()`  是其实现的原理。\n\n","slug":"Jetpack/Lifecycle 源码分析","published":1,"date":"2021-01-29T15:54:28.314Z","updated":"2021-01-29T16:04:30.610Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8fa001xsz5q5dzf05il","content":"<h2 id=\"开始是废话（翻译自源码）\"><a href=\"#开始是废话（翻译自源码）\" class=\"headerlink\" title=\"开始是废话（翻译自源码）\"></a>开始是废话（翻译自源码）</h2><p>定义了一个 Android 生命周期的对象。 <code>Fragment</code>和<code>FragmentActivity</code>类实现<code>LifecycleOwner</code>接口， 并可以通过 <code>getLifecycle()</code> 方法来访问生命周期。 我们也可以实现<code>LifecycleOwner</code>在自己的类。<br><a id=\"more\"></a></p>\n<pre class=\" language-Java\"><code class=\"language-Java\">// 在此类事件后分发 LifecycleOwner 的相关方法的返回时。 \nLifecycle.Event.ON_CREATE ， Lifecycle.Event.ON_START ， Lifecycle.Event.ON_RESUME\n// 在此类事件在之前分派LifecycleOwner被称为的相关方法。 例如， Lifecycle.Event.ON_START后会被分派onStart回报， Lifecycle.Event.ON_STOP之前将派出onStop被调用。 这给你一定的保证在其国家的主人在不在。\nLifecycle.Event.ON_PAUSE ， Lifecycle.Event.ON_STOP ， Lifecycle.Event.ON_DESTROY\n</code></pre>\n<p>如果您使用Java 8 语言 ，然后使用<code>DefaultLifecycleObserver</code> 观察事件。 需要将<code>&quot;androidx.lifecycle:common-java8:&lt;version&gt;&quot;</code> 增加到你的 <code>build.gradle</code> 文件中。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">TestObserver</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">DefaultLifecycleObserver</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onCreate</span><span class=\"token punctuation\">(</span>LifecycleOwner owner<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// your code</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>如果你使用的Java 7 语言 ，使用的注解观察生命周期事件。 一旦Java的8语言成为在Android上的主流，注释将被弃用，所以<code>DefaultLifecycleObserver</code>和注释之间，则须偏向 <code>DefaultLifecycleObserver</code>。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">TestObserver</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">LifecycleObserver</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@OnLifecycleEvent</span><span class=\"token punctuation\">(</span>ON_STOP<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">onStopped</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>观测方法可以接收零个或一个参数。 如果使用，第一个参数的类型必须为<code>LifecycleOwner</code> 。 带注释的方法<code>Lifecycle.Event.ON_ANY</code> 可以接收第二个参数，它必须是类型的<code>Lifecycle.Event</code>。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">TestObserver</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">LifecycleObserver</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@OnLifecycleEvent</span><span class=\"token punctuation\">(</span>ON_CREATE<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">onCreated</span><span class=\"token punctuation\">(</span>LifecycleOwner source<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token annotation punctuation\">@OnLifecycleEvent</span><span class=\"token punctuation\">(</span>ON_ANY<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">onAny</span><span class=\"token punctuation\">(</span>LifecycleOwner source<span class=\"token punctuation\">,</span> Event event<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>提供这些额外的参数可以让您方便地观察到多个供应商和事件，而无需手动跟踪他们。</p>\n<h2 id=\"那我能做什么呢\"><a href=\"#那我能做什么呢\" class=\"headerlink\" title=\"那我能做什么呢\"></a>那我能做什么呢</h2><p>说到这里，我们就应该想到一些在开发中常常不被我们忽视，但又不怎么使用的东西 <strong>友盟统计</strong></p>\n<p>在友盟统计中，我们经常会在 <code>BaseActivity</code> 中插入友盟对页面流转的统计, <code>onStart()</code> <code>onResume()</code> <code>onPause()</code> <code>onStop()</code> 等，然而这里有一点不好的是，我们的业务和公共组件耦合在了一起。</p>\n<p>干货~~~来了</p>\n<p>那么解决上述问题的方案就来了，我们通过实现 <code>LifecycleObserver</code> ，通过标识声明周期方法之后，仅需一句 <code>addObserver(this)</code> ，就可以将 <code>Activity</code> 或 <code>Fragment</code> 的声明周期方法与我们定义的 <code>Observer</code> 方法关联起来。通过感知 <code>Activity</code> 或 <code>Fragment</code> 的声明周期方法，实现友盟统计，此时就将业务整体与 <code>BaseActivity</code> 抽离开，是的公共组件变得更简洁一些。</p>\n<p>当然，这只是 <code>Lifecycle</code> 的一种简单应用，其他的使用方法还是需要我们不断的去探索。</p>\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><h3 id=\"Lifecycle-UML\"><a href=\"#Lifecycle-UML\" class=\"headerlink\" title=\"Lifecycle UML\"></a><strong><code>Lifecycle UML</code></strong></h3><p><img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/Lifecycle%20UML.png?raw=true\" alt=\"Lifecycle UML\"></p>\n<p><strong>想理解一个东西，最好的方式就是去阅读它</strong>， 这是开发多年总结出的一句话。</p>\n<p>那么通过上面的 UML 类图关系，我们能够看出， <code>Lifecycle</code> 的内容并不是很多。但它怎么就会这么强大呢。</p>\n<h3 id=\"ComponentActivity-amp-ReportFragment\"><a href=\"#ComponentActivity-amp-ReportFragment\" class=\"headerlink\" title=\"ComponentActivity &amp; ReportFragment\"></a><strong><code>ComponentActivity</code> &amp; <code>ReportFragment</code></strong></h3><p>就算没看过源码，知道<code>Lifecycle</code> 的人，也应该听说个，这是要给声明周期监控类，那么既然和生命周期有关，那自然是和 <code>Activity</code> 有关，通过<code>AppCompatActivity</code> 类，我们向上查找，我们可以看到 <code>ComponentActivity</code> 这个类，实现了 <code>LifecycleOwner</code> 接口，并返回了一个 <code>mLifecycleRegistry</code></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// ComponentActivity 类初始化是，创建了一个 LifecycleRegistry，并将自己传入过去</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> LifecycleRegistry mLifecycleRegistry <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LifecycleRegistry</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// LifecycleOwner 接口，提供了一个 getLifecycle() 方法</span>\n<span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">public</span> Lifecycle <span class=\"token function\">getLifecycle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> mLifecycleRegistry<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>在 <code>ComponentActivity</code> 的构造方法里，适配了不同的平台版本。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token function\">ComponentActivity</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Lifecycle lifecycle <span class=\"token operator\">=</span> <span class=\"token function\">getLifecycle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//noinspection ConstantConditions</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>lifecycle <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalStateException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"getLifecycle() returned null in ComponentActivity's \"</span>\n                                        <span class=\"token operator\">+</span> <span class=\"token string\">\"constructor. Please make sure you are lazily constructing your Lifecycle \"</span>\n                                        <span class=\"token operator\">+</span> <span class=\"token string\">\"in the first call to getLifecycle() rather than relying on field \"</span>\n                                        <span class=\"token operator\">+</span> <span class=\"token string\">\"initialization.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Build<span class=\"token punctuation\">.</span>VERSION<span class=\"token punctuation\">.</span>SDK_INT <span class=\"token operator\">>=</span> <span class=\"token number\">19</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">getLifecycle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addObserver</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">LifecycleEventObserver</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onStateChanged</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@NonNull</span> LifecycleOwner source<span class=\"token punctuation\">,</span>\n                                       <span class=\"token annotation punctuation\">@NonNull</span> Lifecycle<span class=\"token punctuation\">.</span>Event event<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>event <span class=\"token operator\">==</span> Lifecycle<span class=\"token punctuation\">.</span>Event<span class=\"token punctuation\">.</span>ON_STOP<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    Window window <span class=\"token operator\">=</span> <span class=\"token function\">getWindow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">final</span> View decor <span class=\"token operator\">=</span> window <span class=\"token operator\">!=</span> null <span class=\"token operator\">?</span> window<span class=\"token punctuation\">.</span><span class=\"token function\">peekDecorView</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> null<span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>decor <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        decor<span class=\"token punctuation\">.</span><span class=\"token function\">cancelPendingInputEvents</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">getLifecycle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addObserver</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">LifecycleEventObserver</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onStateChanged</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@NonNull</span> LifecycleOwner source<span class=\"token punctuation\">,</span>\n                                   <span class=\"token annotation punctuation\">@NonNull</span> Lifecycle<span class=\"token punctuation\">.</span>Event event<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>event <span class=\"token operator\">==</span> Lifecycle<span class=\"token punctuation\">.</span>Event<span class=\"token punctuation\">.</span>ON_DESTROY<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">isChangingConfigurations</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">getViewModelStore</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token number\">19</span> <span class=\"token operator\">&lt;=</span> SDK_INT <span class=\"token operator\">&amp;&amp;</span> SDK_INT <span class=\"token operator\">&lt;=</span> <span class=\"token number\">23</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">getLifecycle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addObserver</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ImmLeaksCleaner</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>通过构造方法，有没有发现一个很重要的信息， <code>addObserver()</code>， 由此，我们不难看出 ，<code>LifecycleRegister</code> 的一个重要的方法就是 <code>addObserver()</code> 。翻阅类结构了解到 <code>LifecycleRegister</code> 是 <code>Lifecycle</code> 派生的一个子类，有关所有和声明周期有关的内容，都和这个类有关。</p>\n<p>我们先不着急看 <code>LifecycleRegister</code>，继续看 <code>CompontentActivity</code> 类，既然是个 <code>Activity</code> 那么一定会有创建过程，回看 <code>onCreate()</code> 方法，我们可以观察到一个有趣的东西：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/**\n     * {@inheritDoc}\n     *\n     * If your ComponentActivity is annotated with {@link ContentView}, this will\n     * call {@link #setContentView(int)} for you.\n     */</span>\n<span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onCreate</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@Nullable</span> Bundle savedInstanceState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">onCreate</span><span class=\"token punctuation\">(</span>savedInstanceState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    mSavedStateRegistryController<span class=\"token punctuation\">.</span><span class=\"token function\">performRestore</span><span class=\"token punctuation\">(</span>savedInstanceState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ReportFragment<span class=\"token punctuation\">.</span><span class=\"token function\">injectIfNeededIn</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mContentLayoutId <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">setContentView</span><span class=\"token punctuation\">(</span>mContentLayoutId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><code>ReportFragment.injectIfNeededIn(this)</code> 咦？？？？？？？？？？？ 你是谁，你在这儿做什么。</p>\n<p>别慌，进去看。</p>\n<h4 id=\"ReportFragment\"><a href=\"#ReportFragment\" class=\"headerlink\" title=\"ReportFragment\"></a><code>ReportFragment</code></h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">injectIfNeededIn</span><span class=\"token punctuation\">(</span>Activity activity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ProcessLifecycleOwner should always correctly work and some activities may not extend</span>\n    <span class=\"token comment\" spellcheck=\"true\">// FragmentActivity from support lib, so we use framework fragments for activities</span>\n    android<span class=\"token punctuation\">.</span>app<span class=\"token punctuation\">.</span>FragmentManager manager <span class=\"token operator\">=</span> activity<span class=\"token punctuation\">.</span><span class=\"token function\">getFragmentManager</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>manager<span class=\"token punctuation\">.</span><span class=\"token function\">findFragmentByTag</span><span class=\"token punctuation\">(</span>REPORT_FRAGMENT_TAG<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        manager<span class=\"token punctuation\">.</span><span class=\"token function\">beginTransaction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ReportFragment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> REPORT_FRAGMENT_TAG<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// Hopefully, we are the first to make a transaction.</span>\n        manager<span class=\"token punctuation\">.</span><span class=\"token function\">executePendingTransactions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>咦？？？？为什么要在我的 <code>Activity</code> 上添加一个 <code>Fragment</code>， 翻遍代码，我们也未见到任何布局，你是一个<strong>空的</strong> ，😱😱😱， 太可怕了！</p>\n<p>按照 <code>Fragment</code> 的生命周期，我们继续看</p>\n<h5 id=\"dispatch\"><a href=\"#dispatch\" class=\"headerlink\" title=\"dispatch()\"></a><code>dispatch()</code></h5><pre class=\" language-java\"><code class=\"language-java\">\n<span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onActivityCreated</span><span class=\"token punctuation\">(</span>Bundle savedInstanceState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">onActivityCreated</span><span class=\"token punctuation\">(</span>savedInstanceState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">dispatchCreate</span><span class=\"token punctuation\">(</span>mProcessListener<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span>Lifecycle<span class=\"token punctuation\">.</span>Event<span class=\"token punctuation\">.</span>ON_CREATE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onStart</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">onStart</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">dispatchStart</span><span class=\"token punctuation\">(</span>mProcessListener<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span>Lifecycle<span class=\"token punctuation\">.</span>Event<span class=\"token punctuation\">.</span>ON_START<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onResume</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">onResume</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">dispatchResume</span><span class=\"token punctuation\">(</span>mProcessListener<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span>Lifecycle<span class=\"token punctuation\">.</span>Event<span class=\"token punctuation\">.</span>ON_RESUME<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onPause</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">onPause</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span>Lifecycle<span class=\"token punctuation\">.</span>Event<span class=\"token punctuation\">.</span>ON_PAUSE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onStop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">onStop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span>Lifecycle<span class=\"token punctuation\">.</span>Event<span class=\"token punctuation\">.</span>ON_STOP<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onDestroy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">onDestroy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span>Lifecycle<span class=\"token punctuation\">.</span>Event<span class=\"token punctuation\">.</span>ON_DESTROY<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// just want to be sure that we won't leak reference to an activity</span>\n    mProcessListener <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>有没有发现， 又有一个方法被重复的利用，没错，就是<code>dispatch(Lifecycle.Event event)</code> 而且传入的参数，又和 <code>Activity</code> 的生命周期一致。那么我们来看看它.</p>\n<h5 id=\"handleLifecycleEvent\"><a href=\"#handleLifecycleEvent\" class=\"headerlink\" title=\"handleLifecycleEvent()\"></a><code>handleLifecycleEvent()</code></h5><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span>Lifecycle<span class=\"token punctuation\">.</span>Event event<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Activity activity <span class=\"token operator\">=</span> <span class=\"token function\">getActivity</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>activity <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">LifecycleRegistryOwner</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>LifecycleRegistryOwner<span class=\"token punctuation\">)</span> activity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getLifecycle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">handleLifecycleEvent</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>activity <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">LifecycleOwner</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Lifecycle lifecycle <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>LifecycleOwner<span class=\"token punctuation\">)</span> activity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getLifecycle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>lifecycle <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">LifecycleRegistry</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>LifecycleRegistry<span class=\"token punctuation\">)</span> lifecycle<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">handleLifecycleEvent</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>虽然经过了两个判断，但这没关系，因为这是系统帮助我们做的适配工作，无论如何，他们队中都调用了 <code>handleLifecycleEvent(event)</code> 方法，又蒙蔽了不，这里啥也没干，就跑了。</p>\n<p>你跑，那我就追！</p>\n<h3 id=\"LifecycleRegister\"><a href=\"#LifecycleRegister\" class=\"headerlink\" title=\"LifecycleRegister\"></a><strong><code>LifecycleRegister</code></strong></h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/**\n     * Sets the current state and notifies the observers.\n     * &lt;p>\n     * Note that if the {@code currentState} is the same state as the last call to this method,\n     * calling this method has no effect.\n     *\n     * @param event The event that was received\n     */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">handleLifecycleEvent</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@NonNull</span> Lifecycle<span class=\"token punctuation\">.</span>Event event<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    State next <span class=\"token operator\">=</span> <span class=\"token function\">getStateAfter</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">moveToState</span><span class=\"token punctuation\">(</span>next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">moveToState</span><span class=\"token punctuation\">(</span>State next<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mState <span class=\"token operator\">==</span> next<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    mState <span class=\"token operator\">=</span> next<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mHandlingEvent <span class=\"token operator\">||</span> mAddingObserverCounter <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        mNewEventOccurred <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// we will figure out what to do on upper level.</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    mHandlingEvent <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">sync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    mHandlingEvent <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>两个方法，我们翻译下注释</p>\n<blockquote>\n<p>设置当前状态，并通知观察者</p>\n<p>注意，如果当前状态和上一次方法调用时相同，那么这次调用则无效</p>\n</blockquote>\n<h4 id=\"getStateAfter\"><a href=\"#getStateAfter\" class=\"headerlink\" title=\"getStateAfter()\"></a><code>getStateAfter()</code></h4><p>现在我们来分析源码，<code>getStateAfter(event)</code> 这个方法，我们先进去看下做了什么：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">static</span> State <span class=\"token function\">getStateAfter</span><span class=\"token punctuation\">(</span>Event event<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">case</span> ON_CREATE<span class=\"token operator\">:</span>\n        <span class=\"token keyword\">case</span> ON_STOP<span class=\"token operator\">:</span>\n            <span class=\"token keyword\">return</span> CREATED<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> ON_START<span class=\"token operator\">:</span>\n        <span class=\"token keyword\">case</span> ON_PAUSE<span class=\"token operator\">:</span>\n            <span class=\"token keyword\">return</span> STARTED<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> ON_RESUME<span class=\"token operator\">:</span>\n            <span class=\"token keyword\">return</span> RESUMED<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> ON_DESTROY<span class=\"token operator\">:</span>\n            <span class=\"token keyword\">return</span> DESTROYED<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> ON_ANY<span class=\"token operator\">:</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Unexpected event value \"</span> <span class=\"token operator\">+</span> event<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>原来是一个静态方法，通过传入的 <code>Event</code> 事件，找到当前事件对应的下一个生命周期状态 <code>State</code></p>\n<p>我们还有一个方法没有分析 <code>moveToState(State next)</code>, 从函数名上，可以看出，这是一个状态移动的方法，具体是什么呢，我们进入方法内可以看到 </p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mState <span class=\"token operator\">==</span> next<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>如果当前状态和下一个（操作后的）状态一致，则直接 <code>return</code> 这也映照了注释中的那句话。</p>\n<h4 id=\"sync\"><a href=\"#sync\" class=\"headerlink\" title=\"sync()\"></a><code>sync()</code></h4><p>继续就是将操作的下一个状态做了一次记录，中间的一些判断条件我们不看，顺序的会看到一个 <code>sync()</code> 方法，咦，这又是什么呢？===&gt; 状态同步</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/**\n     * Custom list that keeps observers and can handle removals / additions during traversal.\n     *\n     * Invariant: at any moment of time for observer1 &amp; observer2:\n     * if addition_order(observer1) &lt; addition_order(observer2), then\n     * state(observer1) >= state(observer2),\n     */</span>\n<span class=\"token keyword\">private</span> FastSafeIterableMap<span class=\"token operator\">&lt;</span>LifecycleObserver<span class=\"token punctuation\">,</span> ObserverWithState<span class=\"token operator\">></span> mObserverMap <span class=\"token operator\">=</span>\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">FastSafeIterableMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// happens only on the top of stack (never in reentrance),</span>\n<span class=\"token comment\" spellcheck=\"true\">// so it doesn't have to take in account parents</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">sync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    LifecycleOwner lifecycleOwner <span class=\"token operator\">=</span> mLifecycleOwner<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>lifecycleOwner <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalStateException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"LifecycleOwner of this LifecycleRegistry is already\"</span>\n                                        <span class=\"token operator\">+</span> <span class=\"token string\">\"garbage collected. It is too late to change lifecycle state.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">isSynced</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        mNewEventOccurred <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// no need to check eldest for nullability, because isSynced does it for us.</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mState<span class=\"token punctuation\">.</span><span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span>mObserverMap<span class=\"token punctuation\">.</span><span class=\"token function\">eldest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>mState<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">backwardPass</span><span class=\"token punctuation\">(</span>lifecycleOwner<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        Entry<span class=\"token operator\">&lt;</span>LifecycleObserver<span class=\"token punctuation\">,</span> ObserverWithState<span class=\"token operator\">></span> newest <span class=\"token operator\">=</span> mObserverMap<span class=\"token punctuation\">.</span><span class=\"token function\">newest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>mNewEventOccurred <span class=\"token operator\">&amp;&amp;</span> newest <span class=\"token operator\">!=</span> null\n            <span class=\"token operator\">&amp;&amp;</span> mState<span class=\"token punctuation\">.</span><span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span>newest<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>mState<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">forwardPass</span><span class=\"token punctuation\">(</span>lifecycleOwner<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    mNewEventOccurred <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>这里出现了一个新东西 <code>mObserverMap</code> 向上我们找他的它类型，这里对数据结构不做研究，简单说一下，它是一个双向链表，并提供了一个 map 做缓冲区，且提供了一个可以快速迭代的结构。</p>\n<p>继续分析源码</p>\n<p><code>mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; 0</code> 从缓存的观察者中拿出最旧的状态，与当前状态进行比较，如果小于 0， 说明观察者的状态提前于当前状态，那么就执行一个<code>backwardPass(lifecycleOwner)</code> 方法，让观察者的状态回退到当前状态上</p>\n<p><code>mState.compareTo(newest.getValue().mState) &gt; 0</code> 这个判断正好和上面相反，说明当前的观察者状态落后于当前状态，那么就让观察者的状态追上当前状态，执行 <code>forwardPass(lifecycleOwner)</code></p>\n<h4 id=\"Lifecycle-State-Sequence\"><a href=\"#Lifecycle-State-Sequence\" class=\"headerlink\" title=\"Lifecycle State Sequence\"></a><strong><code>Lifecycle State Sequence</code></strong></h4><p>通过分析 <code>forwardPass</code> 和 <code>backwardPass</code> 方法，我们看到其内部又调用了两个方法, <code>downEvent</code> 和 <code>upEvent</code>，我们称呼为升级事件和降级事件</p>\n<pre class=\" language-java\"><code class=\"language-java\"> <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> Event <span class=\"token function\">downEvent</span><span class=\"token punctuation\">(</span>State state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">case</span> INITIALIZED<span class=\"token operator\">:</span>\n                <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">case</span> CREATED<span class=\"token operator\">:</span>\n                <span class=\"token keyword\">return</span> ON_DESTROY<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">case</span> STARTED<span class=\"token operator\">:</span>\n                <span class=\"token keyword\">return</span> ON_STOP<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">case</span> RESUMED<span class=\"token operator\">:</span>\n                <span class=\"token keyword\">return</span> ON_PAUSE<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">case</span> DESTROYED<span class=\"token operator\">:</span>\n                <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Unexpected state value \"</span> <span class=\"token operator\">+</span> state<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> Event <span class=\"token function\">upEvent</span><span class=\"token punctuation\">(</span>State state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">case</span> INITIALIZED<span class=\"token operator\">:</span>\n            <span class=\"token keyword\">case</span> DESTROYED<span class=\"token operator\">:</span>\n                <span class=\"token keyword\">return</span> ON_CREATE<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">case</span> CREATED<span class=\"token operator\">:</span>\n                <span class=\"token keyword\">return</span> ON_START<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">case</span> STARTED<span class=\"token operator\">:</span>\n                <span class=\"token keyword\">return</span> ON_RESUME<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">case</span> RESUMED<span class=\"token operator\">:</span>\n                <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Unexpected state value \"</span> <span class=\"token operator\">+</span> state<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>通过上面两个方法，我们总结出 <code>Lifecycle</code> 中 <code>State</code> 和 <code>Event</code> 的时序关系，如下图</p>\n<p><img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/Lifecycle%20State%20secquece.png?raw=true\" alt=\"Lifecycle State Sequence\"></p>\n<p>同时我们也回顾一下，<code>getStateAfter()</code> 方法，对事件和状态的判断，也就明白了状态和事件的关系。</p>\n<h4 id=\"dispatchEvent\"><a href=\"#dispatchEvent\" class=\"headerlink\" title=\"dispatchEvent\"></a><code>dispatchEvent</code></h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">forwardPass</span><span class=\"token punctuation\">(</span>LifecycleOwner lifecycleOwner<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Iterator<span class=\"token operator\">&lt;</span>Entry<span class=\"token operator\">&lt;</span>LifecycleObserver<span class=\"token punctuation\">,</span> ObserverWithState<span class=\"token operator\">>></span> ascendingIterator <span class=\"token operator\">=</span>\n        mObserverMap<span class=\"token punctuation\">.</span><span class=\"token function\">iteratorWithAdditions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>ascendingIterator<span class=\"token punctuation\">.</span><span class=\"token function\">hasNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>mNewEventOccurred<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Entry<span class=\"token operator\">&lt;</span>LifecycleObserver<span class=\"token punctuation\">,</span> ObserverWithState<span class=\"token operator\">></span> entry <span class=\"token operator\">=</span> ascendingIterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        ObserverWithState observer <span class=\"token operator\">=</span> entry<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>observer<span class=\"token punctuation\">.</span>mState<span class=\"token punctuation\">.</span><span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span>mState<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>mNewEventOccurred\n                <span class=\"token operator\">&amp;&amp;</span> mObserverMap<span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span>entry<span class=\"token punctuation\">.</span><span class=\"token function\">getKey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">pushParentState</span><span class=\"token punctuation\">(</span>observer<span class=\"token punctuation\">.</span>mState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            observer<span class=\"token punctuation\">.</span><span class=\"token function\">dispatchEvent</span><span class=\"token punctuation\">(</span>lifecycleOwner<span class=\"token punctuation\">,</span> <span class=\"token function\">upEvent</span><span class=\"token punctuation\">(</span>observer<span class=\"token punctuation\">.</span>mState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">popParentState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">backwardPass</span><span class=\"token punctuation\">(</span>LifecycleOwner lifecycleOwner<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Iterator<span class=\"token operator\">&lt;</span>Entry<span class=\"token operator\">&lt;</span>LifecycleObserver<span class=\"token punctuation\">,</span> ObserverWithState<span class=\"token operator\">>></span> descendingIterator <span class=\"token operator\">=</span>\n        mObserverMap<span class=\"token punctuation\">.</span><span class=\"token function\">descendingIterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>descendingIterator<span class=\"token punctuation\">.</span><span class=\"token function\">hasNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>mNewEventOccurred<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Entry<span class=\"token operator\">&lt;</span>LifecycleObserver<span class=\"token punctuation\">,</span> ObserverWithState<span class=\"token operator\">></span> entry <span class=\"token operator\">=</span> descendingIterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        ObserverWithState observer <span class=\"token operator\">=</span> entry<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>observer<span class=\"token punctuation\">.</span>mState<span class=\"token punctuation\">.</span><span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span>mState<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>mNewEventOccurred\n                <span class=\"token operator\">&amp;&amp;</span> mObserverMap<span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span>entry<span class=\"token punctuation\">.</span><span class=\"token function\">getKey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            Event event <span class=\"token operator\">=</span> <span class=\"token function\">downEvent</span><span class=\"token punctuation\">(</span>observer<span class=\"token punctuation\">.</span>mState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">pushParentState</span><span class=\"token punctuation\">(</span><span class=\"token function\">getStateAfter</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            observer<span class=\"token punctuation\">.</span><span class=\"token function\">dispatchEvent</span><span class=\"token punctuation\">(</span>lifecycleOwner<span class=\"token punctuation\">,</span> event<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">popParentState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>迟到的两个方法终于来了，这里也没有什么可以复杂的。只是通过循环找到所有的观察者，并进行事件的分发<code>observer.dispatchEvent(lifecycleOwner, event)</code></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">void</span> <span class=\"token function\">dispatchEvent</span><span class=\"token punctuation\">(</span>LifecycleOwner owner<span class=\"token punctuation\">,</span> Event event<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    State newState <span class=\"token operator\">=</span> <span class=\"token function\">getStateAfter</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    mState <span class=\"token operator\">=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>mState<span class=\"token punctuation\">,</span> newState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    mLifecycleObserver<span class=\"token punctuation\">.</span><span class=\"token function\">onStateChanged</span><span class=\"token punctuation\">(</span>owner<span class=\"token punctuation\">,</span> event<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    mState <span class=\"token operator\">=</span> newState<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>哈哈， 又是一个方法进入了我们的视线 <code>onStateChanged(owner, event)</code>，再次点击去后，发现是一个接口。查询可以看到有很多实现类，困惑吗？？？？</p>\n<p>但我们只需要关注 <code>ReflectiveGenericLifecycleObserver</code> , 想知道为什么吗？ 我也是看了源码才总结出来的。</p>\n<h4 id=\"ReflectiveGenericLifecycleObserver\"><a href=\"#ReflectiveGenericLifecycleObserver\" class=\"headerlink\" title=\"ReflectiveGenericLifecycleObserver\"></a><code>ReflectiveGenericLifecycleObserver</code></h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/**\n * An internal implementation of {@link LifecycleObserver} that relies on reflection.\n */</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ReflectiveGenericLifecycleObserver</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">LifecycleEventObserver</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> Object mWrapped<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> CallbackInfo mInfo<span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">ReflectiveGenericLifecycleObserver</span><span class=\"token punctuation\">(</span>Object wrapped<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        mWrapped <span class=\"token operator\">=</span> wrapped<span class=\"token punctuation\">;</span>\n        mInfo <span class=\"token operator\">=</span> ClassesInfoCache<span class=\"token punctuation\">.</span>sInstance<span class=\"token punctuation\">.</span><span class=\"token function\">getInfo</span><span class=\"token punctuation\">(</span>mWrapped<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onStateChanged</span><span class=\"token punctuation\">(</span>LifecycleOwner source<span class=\"token punctuation\">,</span> Event event<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        mInfo<span class=\"token punctuation\">.</span><span class=\"token function\">invokeCallbacks</span><span class=\"token punctuation\">(</span>source<span class=\"token punctuation\">,</span> event<span class=\"token punctuation\">,</span> mWrapped<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>哎，<code>mInfo.invokeCallbacks(source,event,mWrapped);</code> 这又是什么，捋下来还从没见过，我们也没见过这个类的初始化和加载过程，对不对😨😨😨</p>\n<p>既然是类嘛，那肯定是要创建的，那就看下构造器呗。</p>\n<p><code>wrapped</code> 这东西，经过了缓存，Emmm ，我也是点进去 <code>ClassesInfoCache</code> 之后，都了它的注释才明白的。</p>\n<p>那 <code>wrapped</code> 又是什么呢？通过 <code>ClassesInfoCache</code> 和我们追踪 <code>ReflectiveGenericLifecycleObserver</code> 可以看出， <code>ClassesInfoCache</code> 缓存了 <code>LifecycleObserver</code> 的类对象，<code>ReflectiveGenericLifecycleObserver</code> 也是向下传递一个 <code>LifecycleObserver</code>。由此我们可以判断出，其实这个 <code>LifecycleObserver</code> 就是我们自己定义的观察者。</p>\n<p>而系统帮我做的事儿，就是使用反射技术，通过我们自己标注的注解，并根据当前生命周期的状态，反射执行我们的方法 <code>mInfo.invokeCallback(source event, mWrapped);</code></p>\n<h4 id=\"reflect-invoke-method\"><a href=\"#reflect-invoke-method\" class=\"headerlink\" title=\"reflect invoke method\"></a><code>reflect invoke method</code></h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">void</span> <span class=\"token function\">invokeCallback</span><span class=\"token punctuation\">(</span>LifecycleOwner source<span class=\"token punctuation\">,</span> Lifecycle<span class=\"token punctuation\">.</span>Event event<span class=\"token punctuation\">,</span> Object target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//noinspection TryWithIdenticalCatches</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>mCallType<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">case</span> CALL_TYPE_NO_ARG<span class=\"token operator\">:</span>\n                mMethod<span class=\"token punctuation\">.</span><span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">case</span> CALL_TYPE_PROVIDER<span class=\"token operator\">:</span>\n                mMethod<span class=\"token punctuation\">.</span><span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> source<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">case</span> CALL_TYPE_PROVIDER_WITH_EVENT<span class=\"token operator\">:</span>\n                mMethod<span class=\"token punctuation\">.</span><span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> source<span class=\"token punctuation\">,</span> event<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InvocationTargetException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Failed to call observer method\"</span><span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">.</span><span class=\"token function\">getCause</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IllegalAccessException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>还记得文章开头对 <code>Lifecycle</code> 注解的翻译吗？ 这里的判断就是依据其注解标注，并回调对应的参数方法</p>\n<p>至此，似乎我们已经不能再追下去了，代码执行到这里已经结束了。</p>\n<p>但是！！！！！！！！！！！！！！！！</p>\n<p>我们还有一大块没有分析！！！！！！！！！！！！！！！！！！！！！！！！</p>\n<h4 id=\"addObserver\"><a href=\"#addObserver\" class=\"headerlink\" title=\"addObserver()\"></a><code>addObserver()</code></h4><p>前面我们说了一大堆，都是对 <code>Lifecycle</code> 如何处理，并监听我们的生命周期的方法，也就是 <code>Lifecycle</code>是如何处理监听的。那么我们前面一直都没有说过，观察者那里来的？？？？？？？？？</p>\n<p>好，我们继续观察 <code>LifecycleRegister</code> 中的 <code>addObserver(LifecycleObserver)</code> 这个也是我们自定义观察者后，需要调用的方法</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">addObserver</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@NonNull</span> LifecycleObserver observer<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    State initialState <span class=\"token operator\">=</span> mState <span class=\"token operator\">==</span> DESTROYED <span class=\"token operator\">?</span> DESTROYED <span class=\"token operator\">:</span> INITIALIZED<span class=\"token punctuation\">;</span>\n    ObserverWithState statefulObserver <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ObserverWithState</span><span class=\"token punctuation\">(</span>observer<span class=\"token punctuation\">,</span> initialState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ObserverWithState previous <span class=\"token operator\">=</span> mObserverMap<span class=\"token punctuation\">.</span><span class=\"token function\">putIfAbsent</span><span class=\"token punctuation\">(</span>observer<span class=\"token punctuation\">,</span> statefulObserver<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>previous <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    LifecycleOwner lifecycleOwner <span class=\"token operator\">=</span> mLifecycleOwner<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>lifecycleOwner <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// it is null we should be destroyed. Fallback quickly</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">boolean</span> isReentrance <span class=\"token operator\">=</span> mAddingObserverCounter <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> mHandlingEvent<span class=\"token punctuation\">;</span>\n    State targetState <span class=\"token operator\">=</span> <span class=\"token function\">calculateTargetState</span><span class=\"token punctuation\">(</span>observer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    mAddingObserverCounter<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>statefulObserver<span class=\"token punctuation\">.</span>mState<span class=\"token punctuation\">.</span><span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span>targetState<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span>\n            <span class=\"token operator\">&amp;&amp;</span> mObserverMap<span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span>observer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">pushParentState</span><span class=\"token punctuation\">(</span>statefulObserver<span class=\"token punctuation\">.</span>mState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        statefulObserver<span class=\"token punctuation\">.</span><span class=\"token function\">dispatchEvent</span><span class=\"token punctuation\">(</span>lifecycleOwner<span class=\"token punctuation\">,</span> <span class=\"token function\">upEvent</span><span class=\"token punctuation\">(</span>statefulObserver<span class=\"token punctuation\">.</span>mState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">popParentState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// mState / subling may have been changed recalculate</span>\n        targetState <span class=\"token operator\">=</span> <span class=\"token function\">calculateTargetState</span><span class=\"token punctuation\">(</span>observer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>isReentrance<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// we do sync only on the top level.</span>\n        <span class=\"token function\">sync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    mAddingObserverCounter<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>哈哈，看起来代码并不是很多丫！！！！   哼，天真的你！但它就是这么多</p>\n<p>我们这里要逐行清点</p>\n<p><code>State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</code> 嗯，一上来就初始化了一个 <code>INITIALIZED</code> 状态的状态，哈哈哈，好拗口。</p>\n<p>随后创建了一个 <code>ObserverWithState</code> ，这是一个有状态的观察者，从名字上我们就可以看出来。两个参数分别是我们传入的观察者和我们刚刚创建好的状态。这是个装饰器模式，目的是给原对象，增加一个新属性，但又不改变原数据结构的方案。</p>\n<p>紧接着又把这个观察者和带有状态的观察者，放进了事先已经创建好的 <code>Map</code> 中，也就是 <code>mObserverMap</code> 然后返回了个东西， 阅读后发现，又和 <code>Lifecycle</code> 的注释对上了。</p>\n<p>之后，计算出当前 <code>Activity</code> 或 <code>Fragment</code> 的状态，并判断，如果当前观察者的状态落后于 <code>Activity</code> 或 <code>Fragment</code> 的状态，则立即执行<code>dispatchEvent()</code> 方法，执行回调。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>认真阅读源码后，我们能够看出，其实 <code>Lifecycle</code> 的技术很简单，只有<strong>反射</strong>，<strong>观察者</strong>，<strong>装饰器</strong>，它将这三个东西应用的很神。</p>\n<p>总结一下，分析源码我们从两方面入手</p>\n<ol>\n<li><p><code>addObserver()</code></p>\n<p> 这个方法是对用户最直接的内容，当我们创建一个 <code>Observer</code> 后，都会通过 <code>add</code> 的方式，将我们自己定义的观察者传入，那么从这个突破口我们进入源码分析观察到</p>\n<ol>\n<li>给要添加的<code>Observer</code> 一个初始的状态（装饰器模式，包装数据）</li>\n<li>将数据存储再本地缓存中 （<code>mObserverMap</code>）</li>\n<li>立即进行状态判断，决定是否处理生命周期变化</li>\n</ol>\n</li>\n<li><p><code>ReportFragment</code></p>\n<p>作用是，附着再 <code>Activity</code> 上，用来感知 <code>Activity</code> 的生命周期变化，也起到将业务从 <code>Activity</code> 中分离出来。通过生命感知生命周期的变化，执行 <code>dispatch()</code> 方法，将生命周期事件分发给它所有的观察者去处理消息 <code>handleLifecycleEvent</code></p>\n</li>\n<li><p><strong>反射</strong></p>\n<p>这里的东西比较抽象，没有任何内容是能看出来和我们有什么关系的， 只要你熟悉反射，那么你就能明白它再做什么。</p>\n</li>\n<li><p><code>sync()</code></p>\n<p>这个方法是用来快速同步观察者状态与 <code>Activity</code> 和 <code>Fragment</code>  ，目的也是能够让观察者执行到它所有观察的数据。两个方法 <code>forwardPass()</code> 和 <code>backwardPass()</code>  是其实现的原理。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"开始是废话（翻译自源码）\"><a href=\"#开始是废话（翻译自源码）\" class=\"headerlink\" title=\"开始是废话（翻译自源码）\"></a>开始是废话（翻译自源码）</h2><p>定义了一个 Android 生命周期的对象。 <code>Fragment</code>和<code>FragmentActivity</code>类实现<code>LifecycleOwner</code>接口， 并可以通过 <code>getLifecycle()</code> 方法来访问生命周期。 我们也可以实现<code>LifecycleOwner</code>在自己的类。<br>","more":"</p>\n<pre><code class=\"Java\">// 在此类事件后分发 LifecycleOwner 的相关方法的返回时。 \nLifecycle.Event.ON_CREATE ， Lifecycle.Event.ON_START ， Lifecycle.Event.ON_RESUME\n// 在此类事件在之前分派LifecycleOwner被称为的相关方法。 例如， Lifecycle.Event.ON_START后会被分派onStart回报， Lifecycle.Event.ON_STOP之前将派出onStop被调用。 这给你一定的保证在其国家的主人在不在。\nLifecycle.Event.ON_PAUSE ， Lifecycle.Event.ON_STOP ， Lifecycle.Event.ON_DESTROY\n</code></pre>\n<p>如果您使用Java 8 语言 ，然后使用<code>DefaultLifecycleObserver</code> 观察事件。 需要将<code>&quot;androidx.lifecycle:common-java8:&lt;version&gt;&quot;</code> 增加到你的 <code>build.gradle</code> 文件中。</p>\n<pre><code class=\"java\">class TestObserver implements DefaultLifecycleObserver {\n    @Override\n    public void onCreate(LifecycleOwner owner) {\n        // your code\n    }\n}\n</code></pre>\n<p>如果你使用的Java 7 语言 ，使用的注解观察生命周期事件。 一旦Java的8语言成为在Android上的主流，注释将被弃用，所以<code>DefaultLifecycleObserver</code>和注释之间，则须偏向 <code>DefaultLifecycleObserver</code>。</p>\n<pre><code class=\"java\">class TestObserver implements LifecycleObserver {\n    @OnLifecycleEvent(ON_STOP)\n    void onStopped() {}\n}\n</code></pre>\n<p>观测方法可以接收零个或一个参数。 如果使用，第一个参数的类型必须为<code>LifecycleOwner</code> 。 带注释的方法<code>Lifecycle.Event.ON_ANY</code> 可以接收第二个参数，它必须是类型的<code>Lifecycle.Event</code>。</p>\n<pre><code class=\"java\">class TestObserver implements LifecycleObserver {\n    @OnLifecycleEvent(ON_CREATE)\n    void onCreated(LifecycleOwner source) {}\n    @OnLifecycleEvent(ON_ANY)\n    void onAny(LifecycleOwner source, Event event) {}\n}\n</code></pre>\n<p>提供这些额外的参数可以让您方便地观察到多个供应商和事件，而无需手动跟踪他们。</p>\n<h2 id=\"那我能做什么呢\"><a href=\"#那我能做什么呢\" class=\"headerlink\" title=\"那我能做什么呢\"></a>那我能做什么呢</h2><p>说到这里，我们就应该想到一些在开发中常常不被我们忽视，但又不怎么使用的东西 <strong>友盟统计</strong></p>\n<p>在友盟统计中，我们经常会在 <code>BaseActivity</code> 中插入友盟对页面流转的统计, <code>onStart()</code> <code>onResume()</code> <code>onPause()</code> <code>onStop()</code> 等，然而这里有一点不好的是，我们的业务和公共组件耦合在了一起。</p>\n<p>干货~~~来了</p>\n<p>那么解决上述问题的方案就来了，我们通过实现 <code>LifecycleObserver</code> ，通过标识声明周期方法之后，仅需一句 <code>addObserver(this)</code> ，就可以将 <code>Activity</code> 或 <code>Fragment</code> 的声明周期方法与我们定义的 <code>Observer</code> 方法关联起来。通过感知 <code>Activity</code> 或 <code>Fragment</code> 的声明周期方法，实现友盟统计，此时就将业务整体与 <code>BaseActivity</code> 抽离开，是的公共组件变得更简洁一些。</p>\n<p>当然，这只是 <code>Lifecycle</code> 的一种简单应用，其他的使用方法还是需要我们不断的去探索。</p>\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><h3 id=\"Lifecycle-UML\"><a href=\"#Lifecycle-UML\" class=\"headerlink\" title=\"Lifecycle UML\"></a><strong><code>Lifecycle UML</code></strong></h3><p><img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/Lifecycle%20UML.png?raw=true\" alt=\"Lifecycle UML\"></p>\n<p><strong>想理解一个东西，最好的方式就是去阅读它</strong>， 这是开发多年总结出的一句话。</p>\n<p>那么通过上面的 UML 类图关系，我们能够看出， <code>Lifecycle</code> 的内容并不是很多。但它怎么就会这么强大呢。</p>\n<h3 id=\"ComponentActivity-amp-ReportFragment\"><a href=\"#ComponentActivity-amp-ReportFragment\" class=\"headerlink\" title=\"ComponentActivity &amp; ReportFragment\"></a><strong><code>ComponentActivity</code> &amp; <code>ReportFragment</code></strong></h3><p>就算没看过源码，知道<code>Lifecycle</code> 的人，也应该听说个，这是要给声明周期监控类，那么既然和生命周期有关，那自然是和 <code>Activity</code> 有关，通过<code>AppCompatActivity</code> 类，我们向上查找，我们可以看到 <code>ComponentActivity</code> 这个类，实现了 <code>LifecycleOwner</code> 接口，并返回了一个 <code>mLifecycleRegistry</code></p>\n<pre><code class=\"java\">// ComponentActivity 类初始化是，创建了一个 LifecycleRegistry，并将自己传入过去\nprivate final LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);\n\n// LifecycleOwner 接口，提供了一个 getLifecycle() 方法\n@Override\npublic Lifecycle getLifecycle(){\n    return mLifecycleRegistry;\n}\n</code></pre>\n<p>在 <code>ComponentActivity</code> 的构造方法里，适配了不同的平台版本。</p>\n<pre><code class=\"java\">public ComponentActivity() {\n    Lifecycle lifecycle = getLifecycle();\n    //noinspection ConstantConditions\n    if (lifecycle == null) {\n        throw new IllegalStateException(&quot;getLifecycle() returned null in ComponentActivity&#39;s &quot;\n                                        + &quot;constructor. Please make sure you are lazily constructing your Lifecycle &quot;\n                                        + &quot;in the first call to getLifecycle() rather than relying on field &quot;\n                                        + &quot;initialization.&quot;);\n    }\n    if (Build.VERSION.SDK_INT &gt;= 19) {\n        getLifecycle().addObserver(new LifecycleEventObserver() {\n            @Override\n            public void onStateChanged(@NonNull LifecycleOwner source,\n                                       @NonNull Lifecycle.Event event) {\n                if (event == Lifecycle.Event.ON_STOP) {\n                    Window window = getWindow();\n                    final View decor = window != null ? window.peekDecorView() : null;\n                    if (decor != null) {\n                        decor.cancelPendingInputEvents();\n                    }\n                }\n            }\n        });\n    }\n    getLifecycle().addObserver(new LifecycleEventObserver() {\n        @Override\n        public void onStateChanged(@NonNull LifecycleOwner source,\n                                   @NonNull Lifecycle.Event event) {\n            if (event == Lifecycle.Event.ON_DESTROY) {\n                if (!isChangingConfigurations()) {\n                    getViewModelStore().clear();\n                }\n            }\n        }\n    });\n\n    if (19 &lt;= SDK_INT &amp;&amp; SDK_INT &lt;= 23) {\n        getLifecycle().addObserver(new ImmLeaksCleaner(this));\n    }\n}\n</code></pre>\n<p>通过构造方法，有没有发现一个很重要的信息， <code>addObserver()</code>， 由此，我们不难看出 ，<code>LifecycleRegister</code> 的一个重要的方法就是 <code>addObserver()</code> 。翻阅类结构了解到 <code>LifecycleRegister</code> 是 <code>Lifecycle</code> 派生的一个子类，有关所有和声明周期有关的内容，都和这个类有关。</p>\n<p>我们先不着急看 <code>LifecycleRegister</code>，继续看 <code>CompontentActivity</code> 类，既然是个 <code>Activity</code> 那么一定会有创建过程，回看 <code>onCreate()</code> 方法，我们可以观察到一个有趣的东西：</p>\n<pre><code class=\"java\">/**\n     * {@inheritDoc}\n     *\n     * If your ComponentActivity is annotated with {@link ContentView}, this will\n     * call {@link #setContentView(int)} for you.\n     */\n@Override\nprotected void onCreate(@Nullable Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    mSavedStateRegistryController.performRestore(savedInstanceState);\n    ReportFragment.injectIfNeededIn(this);\n    if (mContentLayoutId != 0) {\n        setContentView(mContentLayoutId);\n    }\n}\n</code></pre>\n<p><code>ReportFragment.injectIfNeededIn(this)</code> 咦？？？？？？？？？？？ 你是谁，你在这儿做什么。</p>\n<p>别慌，进去看。</p>\n<h4 id=\"ReportFragment\"><a href=\"#ReportFragment\" class=\"headerlink\" title=\"ReportFragment\"></a><code>ReportFragment</code></h4><pre><code class=\"java\">public static void injectIfNeededIn(Activity activity) {\n    // ProcessLifecycleOwner should always correctly work and some activities may not extend\n    // FragmentActivity from support lib, so we use framework fragments for activities\n    android.app.FragmentManager manager = activity.getFragmentManager();\n    if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) {\n        manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit();\n        // Hopefully, we are the first to make a transaction.\n        manager.executePendingTransactions();\n    }\n}\n</code></pre>\n<p>咦？？？？为什么要在我的 <code>Activity</code> 上添加一个 <code>Fragment</code>， 翻遍代码，我们也未见到任何布局，你是一个<strong>空的</strong> ，😱😱😱， 太可怕了！</p>\n<p>按照 <code>Fragment</code> 的生命周期，我们继续看</p>\n<h5 id=\"dispatch\"><a href=\"#dispatch\" class=\"headerlink\" title=\"dispatch()\"></a><code>dispatch()</code></h5><pre><code class=\"java\">\n@Override\npublic void onActivityCreated(Bundle savedInstanceState) {\n    super.onActivityCreated(savedInstanceState);\n    dispatchCreate(mProcessListener);\n    dispatch(Lifecycle.Event.ON_CREATE);\n}\n\n@Override\npublic void onStart() {\n    super.onStart();\n    dispatchStart(mProcessListener);\n    dispatch(Lifecycle.Event.ON_START);\n}\n\n@Override\npublic void onResume() {\n    super.onResume();\n    dispatchResume(mProcessListener);\n    dispatch(Lifecycle.Event.ON_RESUME);\n}\n\n@Override\npublic void onPause() {\n    super.onPause();\n    dispatch(Lifecycle.Event.ON_PAUSE);\n}\n\n@Override\npublic void onStop() {\n    super.onStop();\n    dispatch(Lifecycle.Event.ON_STOP);\n}\n\n@Override\npublic void onDestroy() {\n    super.onDestroy();\n    dispatch(Lifecycle.Event.ON_DESTROY);\n    // just want to be sure that we won&#39;t leak reference to an activity\n    mProcessListener = null;\n}\n</code></pre>\n<p>有没有发现， 又有一个方法被重复的利用，没错，就是<code>dispatch(Lifecycle.Event event)</code> 而且传入的参数，又和 <code>Activity</code> 的生命周期一致。那么我们来看看它.</p>\n<h5 id=\"handleLifecycleEvent\"><a href=\"#handleLifecycleEvent\" class=\"headerlink\" title=\"handleLifecycleEvent()\"></a><code>handleLifecycleEvent()</code></h5><pre><code class=\"java\">private void dispatch(Lifecycle.Event event) {\n    Activity activity = getActivity();\n    if (activity instanceof LifecycleRegistryOwner) {\n        ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);\n        return;\n    }\n\n    if (activity instanceof LifecycleOwner) {\n        Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();\n        if (lifecycle instanceof LifecycleRegistry) {\n            ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);\n        }\n    }\n}\n</code></pre>\n<p>虽然经过了两个判断，但这没关系，因为这是系统帮助我们做的适配工作，无论如何，他们队中都调用了 <code>handleLifecycleEvent(event)</code> 方法，又蒙蔽了不，这里啥也没干，就跑了。</p>\n<p>你跑，那我就追！</p>\n<h3 id=\"LifecycleRegister\"><a href=\"#LifecycleRegister\" class=\"headerlink\" title=\"LifecycleRegister\"></a><strong><code>LifecycleRegister</code></strong></h3><pre><code class=\"java\">/**\n     * Sets the current state and notifies the observers.\n     * &lt;p&gt;\n     * Note that if the {@code currentState} is the same state as the last call to this method,\n     * calling this method has no effect.\n     *\n     * @param event The event that was received\n     */\npublic void handleLifecycleEvent(@NonNull Lifecycle.Event event) {\n    State next = getStateAfter(event);\n    moveToState(next);\n}\n\nprivate void moveToState(State next) {\n    if (mState == next) {\n        return;\n    }\n    mState = next;\n    if (mHandlingEvent || mAddingObserverCounter != 0) {\n        mNewEventOccurred = true;\n        // we will figure out what to do on upper level.\n        return;\n    }\n    mHandlingEvent = true;\n    sync();\n    mHandlingEvent = false;\n}\n</code></pre>\n<p>两个方法，我们翻译下注释</p>\n<blockquote>\n<p>设置当前状态，并通知观察者</p>\n<p>注意，如果当前状态和上一次方法调用时相同，那么这次调用则无效</p>\n</blockquote>\n<h4 id=\"getStateAfter\"><a href=\"#getStateAfter\" class=\"headerlink\" title=\"getStateAfter()\"></a><code>getStateAfter()</code></h4><p>现在我们来分析源码，<code>getStateAfter(event)</code> 这个方法，我们先进去看下做了什么：</p>\n<pre><code class=\"java\">static State getStateAfter(Event event) {\n    switch (event) {\n        case ON_CREATE:\n        case ON_STOP:\n            return CREATED;\n        case ON_START:\n        case ON_PAUSE:\n            return STARTED;\n        case ON_RESUME:\n            return RESUMED;\n        case ON_DESTROY:\n            return DESTROYED;\n        case ON_ANY:\n            break;\n    }\n    throw new IllegalArgumentException(&quot;Unexpected event value &quot; + event);\n}\n</code></pre>\n<p>原来是一个静态方法，通过传入的 <code>Event</code> 事件，找到当前事件对应的下一个生命周期状态 <code>State</code></p>\n<p>我们还有一个方法没有分析 <code>moveToState(State next)</code>, 从函数名上，可以看出，这是一个状态移动的方法，具体是什么呢，我们进入方法内可以看到 </p>\n<pre><code class=\"java\">if (mState == next) {\n    return;\n}\n</code></pre>\n<p>如果当前状态和下一个（操作后的）状态一致，则直接 <code>return</code> 这也映照了注释中的那句话。</p>\n<h4 id=\"sync\"><a href=\"#sync\" class=\"headerlink\" title=\"sync()\"></a><code>sync()</code></h4><p>继续就是将操作的下一个状态做了一次记录，中间的一些判断条件我们不看，顺序的会看到一个 <code>sync()</code> 方法，咦，这又是什么呢？===&gt; 状态同步</p>\n<pre><code class=\"java\">/**\n     * Custom list that keeps observers and can handle removals / additions during traversal.\n     *\n     * Invariant: at any moment of time for observer1 &amp; observer2:\n     * if addition_order(observer1) &lt; addition_order(observer2), then\n     * state(observer1) &gt;= state(observer2),\n     */\nprivate FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap =\n    new FastSafeIterableMap&lt;&gt;();\n// happens only on the top of stack (never in reentrance),\n// so it doesn&#39;t have to take in account parents\nprivate void sync() {\n    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();\n    if (lifecycleOwner == null) {\n        throw new IllegalStateException(&quot;LifecycleOwner of this LifecycleRegistry is already&quot;\n                                        + &quot;garbage collected. It is too late to change lifecycle state.&quot;);\n    }\n    while (!isSynced()) {\n        mNewEventOccurred = false;\n        // no need to check eldest for nullability, because isSynced does it for us.\n        if (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; 0) {\n            backwardPass(lifecycleOwner);\n        }\n        Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest();\n        if (!mNewEventOccurred &amp;&amp; newest != null\n            &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; 0) {\n            forwardPass(lifecycleOwner);\n        }\n    }\n    mNewEventOccurred = false;\n}\n</code></pre>\n<p>这里出现了一个新东西 <code>mObserverMap</code> 向上我们找他的它类型，这里对数据结构不做研究，简单说一下，它是一个双向链表，并提供了一个 map 做缓冲区，且提供了一个可以快速迭代的结构。</p>\n<p>继续分析源码</p>\n<p><code>mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; 0</code> 从缓存的观察者中拿出最旧的状态，与当前状态进行比较，如果小于 0， 说明观察者的状态提前于当前状态，那么就执行一个<code>backwardPass(lifecycleOwner)</code> 方法，让观察者的状态回退到当前状态上</p>\n<p><code>mState.compareTo(newest.getValue().mState) &gt; 0</code> 这个判断正好和上面相反，说明当前的观察者状态落后于当前状态，那么就让观察者的状态追上当前状态，执行 <code>forwardPass(lifecycleOwner)</code></p>\n<h4 id=\"Lifecycle-State-Sequence\"><a href=\"#Lifecycle-State-Sequence\" class=\"headerlink\" title=\"Lifecycle State Sequence\"></a><strong><code>Lifecycle State Sequence</code></strong></h4><p>通过分析 <code>forwardPass</code> 和 <code>backwardPass</code> 方法，我们看到其内部又调用了两个方法, <code>downEvent</code> 和 <code>upEvent</code>，我们称呼为升级事件和降级事件</p>\n<pre><code class=\"java\"> private static Event downEvent(State state) {\n        switch (state) {\n            case INITIALIZED:\n                throw new IllegalArgumentException();\n            case CREATED:\n                return ON_DESTROY;\n            case STARTED:\n                return ON_STOP;\n            case RESUMED:\n                return ON_PAUSE;\n            case DESTROYED:\n                throw new IllegalArgumentException();\n        }\n        throw new IllegalArgumentException(&quot;Unexpected state value &quot; + state);\n    }\n\n    private static Event upEvent(State state) {\n        switch (state) {\n            case INITIALIZED:\n            case DESTROYED:\n                return ON_CREATE;\n            case CREATED:\n                return ON_START;\n            case STARTED:\n                return ON_RESUME;\n            case RESUMED:\n                throw new IllegalArgumentException();\n        }\n        throw new IllegalArgumentException(&quot;Unexpected state value &quot; + state);\n    }\n</code></pre>\n<p>通过上面两个方法，我们总结出 <code>Lifecycle</code> 中 <code>State</code> 和 <code>Event</code> 的时序关系，如下图</p>\n<p><img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/Lifecycle%20State%20secquece.png?raw=true\" alt=\"Lifecycle State Sequence\"></p>\n<p>同时我们也回顾一下，<code>getStateAfter()</code> 方法，对事件和状态的判断，也就明白了状态和事件的关系。</p>\n<h4 id=\"dispatchEvent\"><a href=\"#dispatchEvent\" class=\"headerlink\" title=\"dispatchEvent\"></a><code>dispatchEvent</code></h4><pre><code class=\"java\">private void forwardPass(LifecycleOwner lifecycleOwner) {\n    Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; ascendingIterator =\n        mObserverMap.iteratorWithAdditions();\n    while (ascendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) {\n        Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = ascendingIterator.next();\n        ObserverWithState observer = entry.getValue();\n        while ((observer.mState.compareTo(mState) &lt; 0 &amp;&amp; !mNewEventOccurred\n                &amp;&amp; mObserverMap.contains(entry.getKey()))) {\n            pushParentState(observer.mState);\n            observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState));\n            popParentState();\n        }\n    }\n}\n\nprivate void backwardPass(LifecycleOwner lifecycleOwner) {\n    Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; descendingIterator =\n        mObserverMap.descendingIterator();\n    while (descendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) {\n        Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = descendingIterator.next();\n        ObserverWithState observer = entry.getValue();\n        while ((observer.mState.compareTo(mState) &gt; 0 &amp;&amp; !mNewEventOccurred\n                &amp;&amp; mObserverMap.contains(entry.getKey()))) {\n            Event event = downEvent(observer.mState);\n            pushParentState(getStateAfter(event));\n            observer.dispatchEvent(lifecycleOwner, event);\n            popParentState();\n        }\n    }\n}\n</code></pre>\n<p>迟到的两个方法终于来了，这里也没有什么可以复杂的。只是通过循环找到所有的观察者，并进行事件的分发<code>observer.dispatchEvent(lifecycleOwner, event)</code></p>\n<pre><code class=\"java\">void dispatchEvent(LifecycleOwner owner, Event event) {\n    State newState = getStateAfter(event);\n    mState = min(mState, newState);\n    mLifecycleObserver.onStateChanged(owner, event);\n    mState = newState;\n}\n</code></pre>\n<p>哈哈， 又是一个方法进入了我们的视线 <code>onStateChanged(owner, event)</code>，再次点击去后，发现是一个接口。查询可以看到有很多实现类，困惑吗？？？？</p>\n<p>但我们只需要关注 <code>ReflectiveGenericLifecycleObserver</code> , 想知道为什么吗？ 我也是看了源码才总结出来的。</p>\n<h4 id=\"ReflectiveGenericLifecycleObserver\"><a href=\"#ReflectiveGenericLifecycleObserver\" class=\"headerlink\" title=\"ReflectiveGenericLifecycleObserver\"></a><code>ReflectiveGenericLifecycleObserver</code></h4><pre><code class=\"java\">/**\n * An internal implementation of {@link LifecycleObserver} that relies on reflection.\n */\nclass ReflectiveGenericLifecycleObserver implements LifecycleEventObserver {\n    private final Object mWrapped;\n    private final CallbackInfo mInfo;\n\n    ReflectiveGenericLifecycleObserver(Object wrapped) {\n        mWrapped = wrapped;\n        mInfo = ClassesInfoCache.sInstance.getInfo(mWrapped.getClass());\n    }\n\n    @Override\n    public void onStateChanged(LifecycleOwner source, Event event) {\n        mInfo.invokeCallbacks(source, event, mWrapped);\n    }\n}\n</code></pre>\n<p>哎，<code>mInfo.invokeCallbacks(source,event,mWrapped);</code> 这又是什么，捋下来还从没见过，我们也没见过这个类的初始化和加载过程，对不对😨😨😨</p>\n<p>既然是类嘛，那肯定是要创建的，那就看下构造器呗。</p>\n<p><code>wrapped</code> 这东西，经过了缓存，Emmm ，我也是点进去 <code>ClassesInfoCache</code> 之后，都了它的注释才明白的。</p>\n<p>那 <code>wrapped</code> 又是什么呢？通过 <code>ClassesInfoCache</code> 和我们追踪 <code>ReflectiveGenericLifecycleObserver</code> 可以看出， <code>ClassesInfoCache</code> 缓存了 <code>LifecycleObserver</code> 的类对象，<code>ReflectiveGenericLifecycleObserver</code> 也是向下传递一个 <code>LifecycleObserver</code>。由此我们可以判断出，其实这个 <code>LifecycleObserver</code> 就是我们自己定义的观察者。</p>\n<p>而系统帮我做的事儿，就是使用反射技术，通过我们自己标注的注解，并根据当前生命周期的状态，反射执行我们的方法 <code>mInfo.invokeCallback(source event, mWrapped);</code></p>\n<h4 id=\"reflect-invoke-method\"><a href=\"#reflect-invoke-method\" class=\"headerlink\" title=\"reflect invoke method\"></a><code>reflect invoke method</code></h4><pre><code class=\"java\">void invokeCallback(LifecycleOwner source, Lifecycle.Event event, Object target) {\n    //noinspection TryWithIdenticalCatches\n    try {\n        switch (mCallType) {\n            case CALL_TYPE_NO_ARG:\n                mMethod.invoke(target);\n                break;\n            case CALL_TYPE_PROVIDER:\n                mMethod.invoke(target, source);\n                break;\n            case CALL_TYPE_PROVIDER_WITH_EVENT:\n                mMethod.invoke(target, source, event);\n                break;\n        }\n    } catch (InvocationTargetException e) {\n        throw new RuntimeException(&quot;Failed to call observer method&quot;, e.getCause());\n    } catch (IllegalAccessException e) {\n        throw new RuntimeException(e);\n    }\n}\n</code></pre>\n<p>还记得文章开头对 <code>Lifecycle</code> 注解的翻译吗？ 这里的判断就是依据其注解标注，并回调对应的参数方法</p>\n<p>至此，似乎我们已经不能再追下去了，代码执行到这里已经结束了。</p>\n<p>但是！！！！！！！！！！！！！！！！</p>\n<p>我们还有一大块没有分析！！！！！！！！！！！！！！！！！！！！！！！！</p>\n<h4 id=\"addObserver\"><a href=\"#addObserver\" class=\"headerlink\" title=\"addObserver()\"></a><code>addObserver()</code></h4><p>前面我们说了一大堆，都是对 <code>Lifecycle</code> 如何处理，并监听我们的生命周期的方法，也就是 <code>Lifecycle</code>是如何处理监听的。那么我们前面一直都没有说过，观察者那里来的？？？？？？？？？</p>\n<p>好，我们继续观察 <code>LifecycleRegister</code> 中的 <code>addObserver(LifecycleObserver)</code> 这个也是我们自定义观察者后，需要调用的方法</p>\n<pre><code class=\"java\">@Override\npublic void addObserver(@NonNull LifecycleObserver observer) {\n    State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;\n    ObserverWithState statefulObserver = new ObserverWithState(observer, initialState);\n    ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);\n\n    if (previous != null) {\n        return;\n    }\n    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();\n    if (lifecycleOwner == null) {\n        // it is null we should be destroyed. Fallback quickly\n        return;\n    }\n\n    boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent;\n    State targetState = calculateTargetState(observer);\n    mAddingObserverCounter++;\n    while ((statefulObserver.mState.compareTo(targetState) &lt; 0\n            &amp;&amp; mObserverMap.contains(observer))) {\n        pushParentState(statefulObserver.mState);\n        statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));\n        popParentState();\n        // mState / subling may have been changed recalculate\n        targetState = calculateTargetState(observer);\n    }\n\n    if (!isReentrance) {\n        // we do sync only on the top level.\n        sync();\n    }\n    mAddingObserverCounter--;\n}\n</code></pre>\n<p>哈哈，看起来代码并不是很多丫！！！！   哼，天真的你！但它就是这么多</p>\n<p>我们这里要逐行清点</p>\n<p><code>State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</code> 嗯，一上来就初始化了一个 <code>INITIALIZED</code> 状态的状态，哈哈哈，好拗口。</p>\n<p>随后创建了一个 <code>ObserverWithState</code> ，这是一个有状态的观察者，从名字上我们就可以看出来。两个参数分别是我们传入的观察者和我们刚刚创建好的状态。这是个装饰器模式，目的是给原对象，增加一个新属性，但又不改变原数据结构的方案。</p>\n<p>紧接着又把这个观察者和带有状态的观察者，放进了事先已经创建好的 <code>Map</code> 中，也就是 <code>mObserverMap</code> 然后返回了个东西， 阅读后发现，又和 <code>Lifecycle</code> 的注释对上了。</p>\n<p>之后，计算出当前 <code>Activity</code> 或 <code>Fragment</code> 的状态，并判断，如果当前观察者的状态落后于 <code>Activity</code> 或 <code>Fragment</code> 的状态，则立即执行<code>dispatchEvent()</code> 方法，执行回调。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>认真阅读源码后，我们能够看出，其实 <code>Lifecycle</code> 的技术很简单，只有<strong>反射</strong>，<strong>观察者</strong>，<strong>装饰器</strong>，它将这三个东西应用的很神。</p>\n<p>总结一下，分析源码我们从两方面入手</p>\n<ol>\n<li><p><code>addObserver()</code></p>\n<p> 这个方法是对用户最直接的内容，当我们创建一个 <code>Observer</code> 后，都会通过 <code>add</code> 的方式，将我们自己定义的观察者传入，那么从这个突破口我们进入源码分析观察到</p>\n<ol>\n<li>给要添加的<code>Observer</code> 一个初始的状态（装饰器模式，包装数据）</li>\n<li>将数据存储再本地缓存中 （<code>mObserverMap</code>）</li>\n<li>立即进行状态判断，决定是否处理生命周期变化</li>\n</ol>\n</li>\n<li><p><code>ReportFragment</code></p>\n<p>作用是，附着再 <code>Activity</code> 上，用来感知 <code>Activity</code> 的生命周期变化，也起到将业务从 <code>Activity</code> 中分离出来。通过生命感知生命周期的变化，执行 <code>dispatch()</code> 方法，将生命周期事件分发给它所有的观察者去处理消息 <code>handleLifecycleEvent</code></p>\n</li>\n<li><p><strong>反射</strong></p>\n<p>这里的东西比较抽象，没有任何内容是能看出来和我们有什么关系的， 只要你熟悉反射，那么你就能明白它再做什么。</p>\n</li>\n<li><p><code>sync()</code></p>\n<p>这个方法是用来快速同步观察者状态与 <code>Activity</code> 和 <code>Fragment</code>  ，目的也是能够让观察者执行到它所有观察的数据。两个方法 <code>forwardPass()</code> 和 <code>backwardPass()</code>  是其实现的原理。</p>\n</li>\n</ol>"},{"title":"Android 常用工具和插件","date":"2020-02-20T09:04:13.000Z","_content":"# Android 开发必备插件和工具\n\n## Android Studio 插件\n\n\n<!-- more-->\n| 插件名  | 注释 |\n| --- | --- |\n| Alibaba Java Coding Guidelines | 阿里的代码规范检查插件，用来检查代码中是否符合驼峰命名、if else, switch els default 等语法糖的健壮性；以及单方法行数不超过 80 行，提醒”单一职责原则“等； |\n| Android Parcelable code generator | 序列化 Po 类时，可以快速生成序列化代码 |\n| CodeGlance | 代码预览图，在编辑窗口右侧有一个当前代码的缩略图，可以当做滚动条使用，可以快速定位代码 |\n| DataBase Navigator | 支持 Oracle、MySQL、SQLite、PostgreSQL 以及任何符合 JDBC 的数据库；增强我们对数据库数据的读取，定位问题 |\n| FindBugs-IDEA | 可以分析现存代码中容易引起异常的部分，并提供修改建议|\n| GsonFormater |将 xml 和 json 转换位 pojo 类，可以快速生成数据源 |\n| Markdown |    语言工具，通过语法糖，可以快速生成 HTML 的预览窗，写出 GitHub 风格的技术文档|\n| Markdown Navigator | Markdown 预览工具，可以观察实时渲染的 HTML 文档 |\n| Android Resource Tools | 1. 可以为 layout.xml 中 带 id 的 View 生成变量及 findViewById 代码</br>2. 使用 Google 对 strings.xml 进行翻译（需要配置镜像）    </br>3. 颜色渲染器支持 RGB 和 ARGB，方便配置透明度|\n| Codota | 模版代码查找器，可以输入关键词，搜索出相关的业务代码，比如，搜索 FileOutputSrteam 则会有     以及在编译时，会给予相关的代码块提示 |\n| GoodFormatter | 保证大家代码格式化风格一致，避免因不同，导致 git 合并是出现大量修改； |\n| ButterknifePlugin |   快速生成 butternkife 的注入代码，前提需要引入 butterknife |\n| JsonViewer | 可以替换 postman 的插件，用来调试接口 |\n|Git Commit Template|Git 提交记录模版工具|\n|Sql Android |数据库查询插件，有了 Jetpack 后，room 数据库被广泛应用，此时这个工具，就显得很方便|\n| --- | --- |\n<!--more-->\n\n\n**codata**\n\n``` java    \n    public void zipFile(File srcFile, File zipFile) throws IOException {\n        try (FileInputStream fis = new FileInputStream(srcFile);\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile))) {\n          zos.putNextEntry(new ZipEntry(srcFile.getName()));\n          int len;\n          byte[] buffer = new byte[1024];\n          while ((len = fis.read(buffer)) > 0) {\n            zos.write(buffer, 0, len);\n          }\n          zos.closeEntry();\n        }\n    }   \n```\n\n**AndroidResourceTools**\n![](https://github.com/xiaomanwong/static_file/blob/master/images/android_resource_tool_variables.png?raw=true)\n\n![](https://github.com/xiaomanwong/static_file/blob/master/images/android_resource_tools_code.png?raw=true)\n\n\n **JsonViewer**\n\n ![](https://github.com/xiaomanwong/static_file/blob/master/images/WX20200220-145420.png?raw=true)\n\n## 开发工具\n\n除必要 AS 之外，需要以下工具, Mac 用户可以通过 [XClient](https://xclient.info/) 下载破解版软件\n\n| 工具 | 注释 |\n| --- | --- |\n|Sublime Text 3|文本编辑器，除正常的编辑功能外，丰富的插件库让它比 editplus、plus++等文本编辑更强大；<br>**PrettyJson** 插件可以快速将字符串格式化为 JSON 格式，无需再去在线找 json 格式化；也可以校验 json 的合法性；<br>支持列编辑，快速修改<br> **Markdown** 可以用来写 Markdown 文件，但不支持渲染<br>[Sublime Text 3 下载地址](https://www.sublimetext.com/3)|\n|Postman| 接口调试工具，也可以用上面推荐的 **JsonViewer**<br>[Postman 下载地址](https://www.postman.com/)|\n|Fiddler、Charles| 抓包调试工具，可抓包，修改参数调试接口，任选<br>[Fiddler 下载地址](https://www.telerik.com/fiddler)<br>[Charles 下载地址](https://www.charlesproxy.com/download/)|\n|Markdown|Windows 可使用 Typora, Mac 可以使用 MWeb Pro，生成技术类文档使用，马克飞象双平台都可以（Chrome 插件，需要友好访问）<br>[Typora 下载地址](https://typora.io/)<br>[MWeb Pro 下载地址](https://www.mweb.im/)|\n|Vysor|Android 设备同屏工具，可将设备同步到电脑上，方便截图，分享屏幕等，需要友好访问<br>[Vysor 下载地址](https://www.vysor.io/)|\n|XMind|脑图工具，用来写结构<br>[XMind 下载地址](https://setapp.com/apps/xmind?campaign=setapp_search_vendor_xmind_abn_brand_en&ci=737183467&adgroupid=41332915427&adpos=1t1&ck=xminds&targetid=kwd-642237838482&match=p&gnetwork=g&creative=204109085004&placement=&placecat=&accname=setapp&gclid=Cj0KCQiA-bjyBRCcARIsAFboWg0rXap6WScthL_2Ft6oHTKmQorcfJduEcko1hDR0byUxsdFGubEsBQaAotvEALw_wcB)|\n|Beyond Compare|文件比较器，比较两组文件的差异<br>[BeyondCompare 下载地址](https://www.scootersoftware.com/download.php)|\n|Dash| 源码查看器， 也可以使用在线的 [Android 社区](http://androidos.net.cn/sourcecode)|\n|PxCook|云协作设计工具，可生成相应的前端代码，自动测量尺寸等，支持 Photoshop、Sketch、Adobe XD。[PxCook 下载地址](https://www.fancynode.com.cn/pxcook)|\n|---|---|\n\n","source":"_posts/Tools/Android-常用工具和插件.md","raw":"---\ntitle: Android 常用工具和插件\ndate: 2020-02-20 17:04:13\ntags: Tools\n---\n# Android 开发必备插件和工具\n\n## Android Studio 插件\n\n\n<!-- more-->\n| 插件名  | 注释 |\n| --- | --- |\n| Alibaba Java Coding Guidelines | 阿里的代码规范检查插件，用来检查代码中是否符合驼峰命名、if else, switch els default 等语法糖的健壮性；以及单方法行数不超过 80 行，提醒”单一职责原则“等； |\n| Android Parcelable code generator | 序列化 Po 类时，可以快速生成序列化代码 |\n| CodeGlance | 代码预览图，在编辑窗口右侧有一个当前代码的缩略图，可以当做滚动条使用，可以快速定位代码 |\n| DataBase Navigator | 支持 Oracle、MySQL、SQLite、PostgreSQL 以及任何符合 JDBC 的数据库；增强我们对数据库数据的读取，定位问题 |\n| FindBugs-IDEA | 可以分析现存代码中容易引起异常的部分，并提供修改建议|\n| GsonFormater |将 xml 和 json 转换位 pojo 类，可以快速生成数据源 |\n| Markdown |    语言工具，通过语法糖，可以快速生成 HTML 的预览窗，写出 GitHub 风格的技术文档|\n| Markdown Navigator | Markdown 预览工具，可以观察实时渲染的 HTML 文档 |\n| Android Resource Tools | 1. 可以为 layout.xml 中 带 id 的 View 生成变量及 findViewById 代码</br>2. 使用 Google 对 strings.xml 进行翻译（需要配置镜像）    </br>3. 颜色渲染器支持 RGB 和 ARGB，方便配置透明度|\n| Codota | 模版代码查找器，可以输入关键词，搜索出相关的业务代码，比如，搜索 FileOutputSrteam 则会有     以及在编译时，会给予相关的代码块提示 |\n| GoodFormatter | 保证大家代码格式化风格一致，避免因不同，导致 git 合并是出现大量修改； |\n| ButterknifePlugin |   快速生成 butternkife 的注入代码，前提需要引入 butterknife |\n| JsonViewer | 可以替换 postman 的插件，用来调试接口 |\n|Git Commit Template|Git 提交记录模版工具|\n|Sql Android |数据库查询插件，有了 Jetpack 后，room 数据库被广泛应用，此时这个工具，就显得很方便|\n| --- | --- |\n<!--more-->\n\n\n**codata**\n\n``` java    \n    public void zipFile(File srcFile, File zipFile) throws IOException {\n        try (FileInputStream fis = new FileInputStream(srcFile);\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile))) {\n          zos.putNextEntry(new ZipEntry(srcFile.getName()));\n          int len;\n          byte[] buffer = new byte[1024];\n          while ((len = fis.read(buffer)) > 0) {\n            zos.write(buffer, 0, len);\n          }\n          zos.closeEntry();\n        }\n    }   \n```\n\n**AndroidResourceTools**\n![](https://github.com/xiaomanwong/static_file/blob/master/images/android_resource_tool_variables.png?raw=true)\n\n![](https://github.com/xiaomanwong/static_file/blob/master/images/android_resource_tools_code.png?raw=true)\n\n\n **JsonViewer**\n\n ![](https://github.com/xiaomanwong/static_file/blob/master/images/WX20200220-145420.png?raw=true)\n\n## 开发工具\n\n除必要 AS 之外，需要以下工具, Mac 用户可以通过 [XClient](https://xclient.info/) 下载破解版软件\n\n| 工具 | 注释 |\n| --- | --- |\n|Sublime Text 3|文本编辑器，除正常的编辑功能外，丰富的插件库让它比 editplus、plus++等文本编辑更强大；<br>**PrettyJson** 插件可以快速将字符串格式化为 JSON 格式，无需再去在线找 json 格式化；也可以校验 json 的合法性；<br>支持列编辑，快速修改<br> **Markdown** 可以用来写 Markdown 文件，但不支持渲染<br>[Sublime Text 3 下载地址](https://www.sublimetext.com/3)|\n|Postman| 接口调试工具，也可以用上面推荐的 **JsonViewer**<br>[Postman 下载地址](https://www.postman.com/)|\n|Fiddler、Charles| 抓包调试工具，可抓包，修改参数调试接口，任选<br>[Fiddler 下载地址](https://www.telerik.com/fiddler)<br>[Charles 下载地址](https://www.charlesproxy.com/download/)|\n|Markdown|Windows 可使用 Typora, Mac 可以使用 MWeb Pro，生成技术类文档使用，马克飞象双平台都可以（Chrome 插件，需要友好访问）<br>[Typora 下载地址](https://typora.io/)<br>[MWeb Pro 下载地址](https://www.mweb.im/)|\n|Vysor|Android 设备同屏工具，可将设备同步到电脑上，方便截图，分享屏幕等，需要友好访问<br>[Vysor 下载地址](https://www.vysor.io/)|\n|XMind|脑图工具，用来写结构<br>[XMind 下载地址](https://setapp.com/apps/xmind?campaign=setapp_search_vendor_xmind_abn_brand_en&ci=737183467&adgroupid=41332915427&adpos=1t1&ck=xminds&targetid=kwd-642237838482&match=p&gnetwork=g&creative=204109085004&placement=&placecat=&accname=setapp&gclid=Cj0KCQiA-bjyBRCcARIsAFboWg0rXap6WScthL_2Ft6oHTKmQorcfJduEcko1hDR0byUxsdFGubEsBQaAotvEALw_wcB)|\n|Beyond Compare|文件比较器，比较两组文件的差异<br>[BeyondCompare 下载地址](https://www.scootersoftware.com/download.php)|\n|Dash| 源码查看器， 也可以使用在线的 [Android 社区](http://androidos.net.cn/sourcecode)|\n|PxCook|云协作设计工具，可生成相应的前端代码，自动测量尺寸等，支持 Photoshop、Sketch、Adobe XD。[PxCook 下载地址](https://www.fancynode.com.cn/pxcook)|\n|---|---|\n\n","slug":"Tools/Android-常用工具和插件","published":1,"updated":"2021-01-29T16:05:12.097Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8fc001zsz5qhpzc15fe","content":"<h1 id=\"Android-开发必备插件和工具\"><a href=\"#Android-开发必备插件和工具\" class=\"headerlink\" title=\"Android 开发必备插件和工具\"></a>Android 开发必备插件和工具</h1><h2 id=\"Android-Studio-插件\"><a href=\"#Android-Studio-插件\" class=\"headerlink\" title=\"Android Studio 插件\"></a>Android Studio 插件</h2><a id=\"more\"></a>\n<table>\n<thead>\n<tr>\n<th>插件名</th>\n<th>注释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Alibaba Java Coding Guidelines</td>\n<td>阿里的代码规范检查插件，用来检查代码中是否符合驼峰命名、if else, switch els default 等语法糖的健壮性；以及单方法行数不超过 80 行，提醒”单一职责原则“等；</td>\n</tr>\n<tr>\n<td>Android Parcelable code generator</td>\n<td>序列化 Po 类时，可以快速生成序列化代码</td>\n</tr>\n<tr>\n<td>CodeGlance</td>\n<td>代码预览图，在编辑窗口右侧有一个当前代码的缩略图，可以当做滚动条使用，可以快速定位代码</td>\n</tr>\n<tr>\n<td>DataBase Navigator</td>\n<td>支持 Oracle、MySQL、SQLite、PostgreSQL 以及任何符合 JDBC 的数据库；增强我们对数据库数据的读取，定位问题</td>\n</tr>\n<tr>\n<td>FindBugs-IDEA</td>\n<td>可以分析现存代码中容易引起异常的部分，并提供修改建议</td>\n</tr>\n<tr>\n<td>GsonFormater</td>\n<td>将 xml 和 json 转换位 pojo 类，可以快速生成数据源</td>\n</tr>\n<tr>\n<td>Markdown</td>\n<td>语言工具，通过语法糖，可以快速生成 HTML 的预览窗，写出 GitHub 风格的技术文档</td>\n</tr>\n<tr>\n<td>Markdown Navigator</td>\n<td>Markdown 预览工具，可以观察实时渲染的 HTML 文档</td>\n</tr>\n<tr>\n<td>Android Resource Tools</td>\n<td>1. 可以为 layout.xml 中 带 id 的 View 生成变量及 findViewById 代码<br>2. 使用 Google 对 strings.xml 进行翻译（需要配置镜像）    <br>3. 颜色渲染器支持 RGB 和 ARGB，方便配置透明度</td>\n</tr>\n<tr>\n<td>Codota</td>\n<td>模版代码查找器，可以输入关键词，搜索出相关的业务代码，比如，搜索 FileOutputSrteam 则会有     以及在编译时，会给予相关的代码块提示</td>\n</tr>\n<tr>\n<td>GoodFormatter</td>\n<td>保证大家代码格式化风格一致，避免因不同，导致 git 合并是出现大量修改；</td>\n</tr>\n<tr>\n<td>ButterknifePlugin</td>\n<td>快速生成 butternkife 的注入代码，前提需要引入 butterknife</td>\n</tr>\n<tr>\n<td>JsonViewer</td>\n<td>可以替换 postman 的插件，用来调试接口</td>\n</tr>\n<tr>\n<td>Git Commit Template</td>\n<td>Git 提交记录模版工具</td>\n</tr>\n<tr>\n<td>Sql Android</td>\n<td>数据库查询插件，有了 Jetpack 后，room 数据库被广泛应用，此时这个工具，就显得很方便</td>\n</tr>\n<tr>\n<td>—</td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<!--more-->\n<p><strong>codata</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">zipFile</span><span class=\"token punctuation\">(</span>File srcFile<span class=\"token punctuation\">,</span> File zipFile<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> IOException <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">(</span>FileInputStream fis <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileInputStream</span><span class=\"token punctuation\">(</span>srcFile<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            ZipOutputStream zos <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ZipOutputStream</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">FileOutputStream</span><span class=\"token punctuation\">(</span>zipFile<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          zos<span class=\"token punctuation\">.</span><span class=\"token function\">putNextEntry</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ZipEntry</span><span class=\"token punctuation\">(</span>srcFile<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">int</span> len<span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> buffer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">1024</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>len <span class=\"token operator\">=</span> fis<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            zos<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n          zos<span class=\"token punctuation\">.</span><span class=\"token function\">closeEntry</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>   \n</code></pre>\n<p><strong>AndroidResourceTools</strong><br><img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/android_resource_tool_variables.png?raw=true\" alt></p>\n<p><img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/android_resource_tools_code.png?raw=true\" alt></p>\n<p> <strong>JsonViewer</strong></p>\n<p> <img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/WX20200220-145420.png?raw=true\" alt></p>\n<h2 id=\"开发工具\"><a href=\"#开发工具\" class=\"headerlink\" title=\"开发工具\"></a>开发工具</h2><p>除必要 AS 之外，需要以下工具, Mac 用户可以通过 <span class=\"exturl\" data-url=\"aHR0cHM6Ly94Y2xpZW50LmluZm8v\" title=\"https://xclient.info/\">XClient<i class=\"fa fa-external-link\"></i></span> 下载破解版软件</p>\n<table>\n<thead>\n<tr>\n<th>工具</th>\n<th>注释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Sublime Text 3</td>\n<td>文本编辑器，除正常的编辑功能外，丰富的插件库让它比 editplus、plus++等文本编辑更强大；<br><strong>PrettyJson</strong> 插件可以快速将字符串格式化为 JSON 格式，无需再去在线找 json 格式化；也可以校验 json 的合法性；<br>支持列编辑，快速修改<br> <strong>Markdown</strong> 可以用来写 Markdown 文件，但不支持渲染<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc3VibGltZXRleHQuY29tLzM=\" title=\"https://www.sublimetext.com/3\">Sublime Text 3 下载地址<i class=\"fa fa-external-link\"></i></span></td>\n</tr>\n<tr>\n<td>Postman</td>\n<td>接口调试工具，也可以用上面推荐的 <strong>JsonViewer</strong><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucG9zdG1hbi5jb20v\" title=\"https://www.postman.com/\">Postman 下载地址<i class=\"fa fa-external-link\"></i></span></td>\n</tr>\n<tr>\n<td>Fiddler、Charles</td>\n<td>抓包调试工具，可抓包，修改参数调试接口，任选<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudGVsZXJpay5jb20vZmlkZGxlcg==\" title=\"https://www.telerik.com/fiddler\">Fiddler 下载地址<i class=\"fa fa-external-link\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY2hhcmxlc3Byb3h5LmNvbS9kb3dubG9hZC8=\" title=\"https://www.charlesproxy.com/download/\">Charles 下载地址<i class=\"fa fa-external-link\"></i></span></td>\n</tr>\n<tr>\n<td>Markdown</td>\n<td>Windows 可使用 Typora, Mac 可以使用 MWeb Pro，生成技术类文档使用，马克飞象双平台都可以（Chrome 插件，需要友好访问）<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly90eXBvcmEuaW8v\" title=\"https://typora.io/\">Typora 下载地址<i class=\"fa fa-external-link\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubXdlYi5pbS8=\" title=\"https://www.mweb.im/\">MWeb Pro 下载地址<i class=\"fa fa-external-link\"></i></span></td>\n</tr>\n<tr>\n<td>Vysor</td>\n<td>Android 设备同屏工具，可将设备同步到电脑上，方便截图，分享屏幕等，需要友好访问<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudnlzb3IuaW8v\" title=\"https://www.vysor.io/\">Vysor 下载地址<i class=\"fa fa-external-link\"></i></span></td>\n</tr>\n<tr>\n<td>XMind</td>\n<td>脑图工具，用来写结构<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZXRhcHAuY29tL2FwcHMveG1pbmQ/Y2FtcGFpZ249c2V0YXBwX3NlYXJjaF92ZW5kb3JfeG1pbmRfYWJuX2JyYW5kX2VuJmFtcDtjaT03MzcxODM0NjcmYW1wO2FkZ3JvdXBpZD00MTMzMjkxNTQyNyZhbXA7YWRwb3M9MXQxJmFtcDtjaz14bWluZHMmYW1wO3RhcmdldGlkPWt3ZC02NDIyMzc4Mzg0ODImYW1wO21hdGNoPXAmYW1wO2duZXR3b3JrPWcmYW1wO2NyZWF0aXZlPTIwNDEwOTA4NTAwNCZhbXA7cGxhY2VtZW50PSZhbXA7cGxhY2VjYXQ9JmFtcDthY2NuYW1lPXNldGFwcCZhbXA7Z2NsaWQ9Q2owS0NRaUEtYmp5QlJDY0FSSXNBRmJvV2cwclhhcDZXU2N0aExfMkZ0Nm9IVEttUW9yY2ZKZHVFY2tvMWhEUjBieVV4c2RGR3ViRXNCUWFBb3R2RUFMd193Y0I=\" title=\"https://setapp.com/apps/xmind?campaign=setapp_search_vendor_xmind_abn_brand_en&amp;ci=737183467&amp;adgroupid=41332915427&amp;adpos=1t1&amp;ck=xminds&amp;targetid=kwd-642237838482&amp;match=p&amp;gnetwork=g&amp;creative=204109085004&amp;placement=&amp;placecat=&amp;accname=setapp&amp;gclid=Cj0KCQiA-bjyBRCcARIsAFboWg0rXap6WScthL_2Ft6oHTKmQorcfJduEcko1hDR0byUxsdFGubEsBQaAotvEALw_wcB\">XMind 下载地址<i class=\"fa fa-external-link\"></i></span></td>\n</tr>\n<tr>\n<td>Beyond Compare</td>\n<td>文件比较器，比较两组文件的差异<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc2Nvb3RlcnNvZnR3YXJlLmNvbS9kb3dubG9hZC5waHA=\" title=\"https://www.scootersoftware.com/download.php\">BeyondCompare 下载地址<i class=\"fa fa-external-link\"></i></span></td>\n</tr>\n<tr>\n<td>Dash</td>\n<td>源码查看器， 也可以使用在线的 <span class=\"exturl\" data-url=\"aHR0cDovL2FuZHJvaWRvcy5uZXQuY24vc291cmNlY29kZQ==\" title=\"http://androidos.net.cn/sourcecode\">Android 社区<i class=\"fa fa-external-link\"></i></span></td>\n</tr>\n<tr>\n<td>PxCook</td>\n<td>云协作设计工具，可生成相应的前端代码，自动测量尺寸等，支持 Photoshop、Sketch、Adobe XD。<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZmFuY3lub2RlLmNvbS5jbi9weGNvb2s=\" title=\"https://www.fancynode.com.cn/pxcook\">PxCook 下载地址<i class=\"fa fa-external-link\"></i></span></td>\n</tr>\n<tr>\n<td>—</td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"<h1 id=\"Android-开发必备插件和工具\"><a href=\"#Android-开发必备插件和工具\" class=\"headerlink\" title=\"Android 开发必备插件和工具\"></a>Android 开发必备插件和工具</h1><h2 id=\"Android-Studio-插件\"><a href=\"#Android-Studio-插件\" class=\"headerlink\" title=\"Android Studio 插件\"></a>Android Studio 插件</h2>","more":"<table>\n<thead>\n<tr>\n<th>插件名</th>\n<th>注释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Alibaba Java Coding Guidelines</td>\n<td>阿里的代码规范检查插件，用来检查代码中是否符合驼峰命名、if else, switch els default 等语法糖的健壮性；以及单方法行数不超过 80 行，提醒”单一职责原则“等；</td>\n</tr>\n<tr>\n<td>Android Parcelable code generator</td>\n<td>序列化 Po 类时，可以快速生成序列化代码</td>\n</tr>\n<tr>\n<td>CodeGlance</td>\n<td>代码预览图，在编辑窗口右侧有一个当前代码的缩略图，可以当做滚动条使用，可以快速定位代码</td>\n</tr>\n<tr>\n<td>DataBase Navigator</td>\n<td>支持 Oracle、MySQL、SQLite、PostgreSQL 以及任何符合 JDBC 的数据库；增强我们对数据库数据的读取，定位问题</td>\n</tr>\n<tr>\n<td>FindBugs-IDEA</td>\n<td>可以分析现存代码中容易引起异常的部分，并提供修改建议</td>\n</tr>\n<tr>\n<td>GsonFormater</td>\n<td>将 xml 和 json 转换位 pojo 类，可以快速生成数据源</td>\n</tr>\n<tr>\n<td>Markdown</td>\n<td>语言工具，通过语法糖，可以快速生成 HTML 的预览窗，写出 GitHub 风格的技术文档</td>\n</tr>\n<tr>\n<td>Markdown Navigator</td>\n<td>Markdown 预览工具，可以观察实时渲染的 HTML 文档</td>\n</tr>\n<tr>\n<td>Android Resource Tools</td>\n<td>1. 可以为 layout.xml 中 带 id 的 View 生成变量及 findViewById 代码<br>2. 使用 Google 对 strings.xml 进行翻译（需要配置镜像）    <br>3. 颜色渲染器支持 RGB 和 ARGB，方便配置透明度</td>\n</tr>\n<tr>\n<td>Codota</td>\n<td>模版代码查找器，可以输入关键词，搜索出相关的业务代码，比如，搜索 FileOutputSrteam 则会有     以及在编译时，会给予相关的代码块提示</td>\n</tr>\n<tr>\n<td>GoodFormatter</td>\n<td>保证大家代码格式化风格一致，避免因不同，导致 git 合并是出现大量修改；</td>\n</tr>\n<tr>\n<td>ButterknifePlugin</td>\n<td>快速生成 butternkife 的注入代码，前提需要引入 butterknife</td>\n</tr>\n<tr>\n<td>JsonViewer</td>\n<td>可以替换 postman 的插件，用来调试接口</td>\n</tr>\n<tr>\n<td>Git Commit Template</td>\n<td>Git 提交记录模版工具</td>\n</tr>\n<tr>\n<td>Sql Android</td>\n<td>数据库查询插件，有了 Jetpack 后，room 数据库被广泛应用，此时这个工具，就显得很方便</td>\n</tr>\n<tr>\n<td>—</td>\n<td>—</td>\n</tr>\n</tbody>\n</table>\n<!--more-->\n<p><strong>codata</strong></p>\n<pre><code class=\"java\">    public void zipFile(File srcFile, File zipFile) throws IOException {\n        try (FileInputStream fis = new FileInputStream(srcFile);\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFile))) {\n          zos.putNextEntry(new ZipEntry(srcFile.getName()));\n          int len;\n          byte[] buffer = new byte[1024];\n          while ((len = fis.read(buffer)) &gt; 0) {\n            zos.write(buffer, 0, len);\n          }\n          zos.closeEntry();\n        }\n    }   \n</code></pre>\n<p><strong>AndroidResourceTools</strong><br><img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/android_resource_tool_variables.png?raw=true\" alt></p>\n<p><img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/android_resource_tools_code.png?raw=true\" alt></p>\n<p> <strong>JsonViewer</strong></p>\n<p> <img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/WX20200220-145420.png?raw=true\" alt></p>\n<h2 id=\"开发工具\"><a href=\"#开发工具\" class=\"headerlink\" title=\"开发工具\"></a>开发工具</h2><p>除必要 AS 之外，需要以下工具, Mac 用户可以通过 <span class=\"exturl\" data-url=\"aHR0cHM6Ly94Y2xpZW50LmluZm8v\" title=\"https://xclient.info/\">XClient<i class=\"fa fa-external-link\"></i></span> 下载破解版软件</p>\n<table>\n<thead>\n<tr>\n<th>工具</th>\n<th>注释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Sublime Text 3</td>\n<td>文本编辑器，除正常的编辑功能外，丰富的插件库让它比 editplus、plus++等文本编辑更强大；<br><strong>PrettyJson</strong> 插件可以快速将字符串格式化为 JSON 格式，无需再去在线找 json 格式化；也可以校验 json 的合法性；<br>支持列编辑，快速修改<br> <strong>Markdown</strong> 可以用来写 Markdown 文件，但不支持渲染<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc3VibGltZXRleHQuY29tLzM=\" title=\"https://www.sublimetext.com/3\">Sublime Text 3 下载地址<i class=\"fa fa-external-link\"></i></span></td>\n</tr>\n<tr>\n<td>Postman</td>\n<td>接口调试工具，也可以用上面推荐的 <strong>JsonViewer</strong><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucG9zdG1hbi5jb20v\" title=\"https://www.postman.com/\">Postman 下载地址<i class=\"fa fa-external-link\"></i></span></td>\n</tr>\n<tr>\n<td>Fiddler、Charles</td>\n<td>抓包调试工具，可抓包，修改参数调试接口，任选<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudGVsZXJpay5jb20vZmlkZGxlcg==\" title=\"https://www.telerik.com/fiddler\">Fiddler 下载地址<i class=\"fa fa-external-link\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY2hhcmxlc3Byb3h5LmNvbS9kb3dubG9hZC8=\" title=\"https://www.charlesproxy.com/download/\">Charles 下载地址<i class=\"fa fa-external-link\"></i></span></td>\n</tr>\n<tr>\n<td>Markdown</td>\n<td>Windows 可使用 Typora, Mac 可以使用 MWeb Pro，生成技术类文档使用，马克飞象双平台都可以（Chrome 插件，需要友好访问）<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly90eXBvcmEuaW8v\" title=\"https://typora.io/\">Typora 下载地址<i class=\"fa fa-external-link\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubXdlYi5pbS8=\" title=\"https://www.mweb.im/\">MWeb Pro 下载地址<i class=\"fa fa-external-link\"></i></span></td>\n</tr>\n<tr>\n<td>Vysor</td>\n<td>Android 设备同屏工具，可将设备同步到电脑上，方便截图，分享屏幕等，需要友好访问<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudnlzb3IuaW8v\" title=\"https://www.vysor.io/\">Vysor 下载地址<i class=\"fa fa-external-link\"></i></span></td>\n</tr>\n<tr>\n<td>XMind</td>\n<td>脑图工具，用来写结构<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZXRhcHAuY29tL2FwcHMveG1pbmQ/Y2FtcGFpZ249c2V0YXBwX3NlYXJjaF92ZW5kb3JfeG1pbmRfYWJuX2JyYW5kX2VuJmFtcDtjaT03MzcxODM0NjcmYW1wO2FkZ3JvdXBpZD00MTMzMjkxNTQyNyZhbXA7YWRwb3M9MXQxJmFtcDtjaz14bWluZHMmYW1wO3RhcmdldGlkPWt3ZC02NDIyMzc4Mzg0ODImYW1wO21hdGNoPXAmYW1wO2duZXR3b3JrPWcmYW1wO2NyZWF0aXZlPTIwNDEwOTA4NTAwNCZhbXA7cGxhY2VtZW50PSZhbXA7cGxhY2VjYXQ9JmFtcDthY2NuYW1lPXNldGFwcCZhbXA7Z2NsaWQ9Q2owS0NRaUEtYmp5QlJDY0FSSXNBRmJvV2cwclhhcDZXU2N0aExfMkZ0Nm9IVEttUW9yY2ZKZHVFY2tvMWhEUjBieVV4c2RGR3ViRXNCUWFBb3R2RUFMd193Y0I=\" title=\"https://setapp.com/apps/xmind?campaign=setapp_search_vendor_xmind_abn_brand_en&amp;ci=737183467&amp;adgroupid=41332915427&amp;adpos=1t1&amp;ck=xminds&amp;targetid=kwd-642237838482&amp;match=p&amp;gnetwork=g&amp;creative=204109085004&amp;placement=&amp;placecat=&amp;accname=setapp&amp;gclid=Cj0KCQiA-bjyBRCcARIsAFboWg0rXap6WScthL_2Ft6oHTKmQorcfJduEcko1hDR0byUxsdFGubEsBQaAotvEALw_wcB\">XMind 下载地址<i class=\"fa fa-external-link\"></i></span></td>\n</tr>\n<tr>\n<td>Beyond Compare</td>\n<td>文件比较器，比较两组文件的差异<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc2Nvb3RlcnNvZnR3YXJlLmNvbS9kb3dubG9hZC5waHA=\" title=\"https://www.scootersoftware.com/download.php\">BeyondCompare 下载地址<i class=\"fa fa-external-link\"></i></span></td>\n</tr>\n<tr>\n<td>Dash</td>\n<td>源码查看器， 也可以使用在线的 <span class=\"exturl\" data-url=\"aHR0cDovL2FuZHJvaWRvcy5uZXQuY24vc291cmNlY29kZQ==\" title=\"http://androidos.net.cn/sourcecode\">Android 社区<i class=\"fa fa-external-link\"></i></span></td>\n</tr>\n<tr>\n<td>PxCook</td>\n<td>云协作设计工具，可生成相应的前端代码，自动测量尺寸等，支持 Photoshop、Sketch、Adobe XD。<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZmFuY3lub2RlLmNvbS5jbi9weGNvb2s=\" title=\"https://www.fancynode.com.cn/pxcook\">PxCook 下载地址<i class=\"fa fa-external-link\"></i></span></td>\n</tr>\n<tr>\n<td>—</td>\n<td>—</td>\n</tr>\n</tbody>\n</table>"},{"title":"Markdown 数学公式编辑","_content":"\n\n\n# Markdown中公式编辑教程\n\n# markdown中公式编辑教程\n\n标签： Mathjax 公式编辑 markdown\n\n一般公式分为两种形式，行内公式和行间公式。\n\n- 行内公式：![\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.](https://math.jianshu.com/math?formula=\\Gamma(z) %3D \\int_0^\\infty t^{z-1}e^{-t}dt\\%2C.)\n- 行间公式：![\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.](https://math.jianshu.com/math?formula=\\Gamma(z) %3D \\int_0^\\infty t^{z-1}e^{-t}dt\\%2C.)\n<!-- more-->\n  对应的代码块为：\n\n```ruby\n$ \\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,. $\n$$\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.$$\n```\n\n  行内公式是在公式代码块的基础上前面加上**$** ，后面加上**$** 组成的，而行间公式则是在公式代码块前后使用**$$** 和**$$** 。\n  下面主要介绍数学公式中常用的一些符号。\n\n## **希腊字母**\n\n|  名称   | 大写 |  code   |   小写   |   code   |\n| :-----: | :--: | :-----: | :------: | :------: |\n|  alpha  |  A   |    A    |    α     |  \\alpha  |\n|  beta   |  B   |    B    |    β     |  \\beta   |\n|  gamma  |  Γ   | \\Gamma  |    γ     |  \\gamma  |\n|  delta  |  Δ   | \\Delta  |    δ     |  \\delta  |\n| epsilon |  E   |    E    |    ϵ     | \\epsilon |\n|  zeta   |  Z   |    Z    |    ζ     |  \\zeta   |\n|   eta   |  H   |    H    |    η     |   \\eta   |\n|  theta  |  Θ   | \\Theta  |    θ     |  \\theta  |\n|  iota   |  I   |    I    |    ι     |  \\iota   |\n|  kappa  |  K   |    K    |    κ     |  \\kappa  |\n| lambda  |  Λ   | \\Lambda |    λ     | \\lambda  |\n|   mu    |  M   |    M    |    μ     |   \\mu    |\n|   nu    |  N   |    N    |    ν     |   \\nu    |\n|   xi    |  Ξ   |   \\Xi   |    ξ     |   \\xi    |\n| omicron |  O   |    O    |    ο     | \\omicron |\n|   pi    |  Π   |   \\Pi   |    π     |   \\pi    |\n|   rho   |  P   |    P    |    ρ     |   \\rho   |\n|  sigma  |  Σ   | \\Sigma  |    σ     |  \\sigma  |\n|   tau   |  T   |    T    |    τ     |   \\tau   |\n| upsilon |  Υ   |    υ    | \\upsilon |          |\n|   phi   |  Φ   |  \\Phi   |    ϕ     |   \\phi   |\n|   chi   |  X   |    X    |    χ     |   \\chi   |\n|   psi   |  Ψ   |  \\Psi   |    ψ     |   \\psi   |\n|  omega  |  Ω   | \\Omega  |    ω     |  \\omega  |\n\n## **上标与下标**\n\n  上标和下标分别使用`^` 与`_` ，例如`$x_i^2$`表示的是：![x_i^2](https://math.jianshu.com/math?formula=x_i^2)。\n  默认情况下，上、下标符号仅仅对下一个组起作用。一个组即单个字符或者使用`{..}` 包裹起来的内容。如果使用`$10^10$` 表示的是![10^10](https://math.jianshu.com/math?formula=10^10)，而`$10^{10}$` 才是![10^{10}](https://math.jianshu.com/math?formula=10^{10})。同时，大括号还能消除二义性，如`x^5^6` 将得到一个错误，必须使用大括号来界定^的结合性，如`${x^5}^6$` ：![{x^5}^6](https://math.jianshu.com/math?formula={x^5}^6)或者`$x^{5^6}$` ：![x^{5^6}](https://math.jianshu.com/math?formula=x^{5^6})。\n\n## **括号**\n\n### 小括号与方括号\n\n  使用原始的`( )` ，`[ ]` 即可，如`$(2+3)[4+4]$` ：![(2+3)](https://math.jianshu.com/math?formula=(2%2B3)) ![[4+4]](https://math.jianshu.com/math?formula=[4%2B4])\n  使用\\left(或\\right)使符号大小与邻近的公式相适应（该语句适用于所有括号类型），如`$\\left(\\frac{x}{y}\\right)$` ：![\\left(\\frac{x}{y}\\right)](https://math.jianshu.com/math?formula=\\left(\\frac{x}{y}\\right))\n\n### 大括号\n\n  由于大括号`{}` 被用于分组，因此需要使用`\\{`和`\\}`表示大括号，也可以使用`\\lbrace` 和`\\rbrace`来表示。如`$\\{a\\*b\\}:a\\∗b$` 或`$\\lbrace a\\*b\\rbrace :a\\*b$` 表示![\\{a*b\\}:a∗b](https://math.jianshu.com/math?formula=\\{a*b\\}%3Aa∗b)。\n\n### 尖括号\n\n  区分于小于号和大于号，使用`\\langle` 和`\\rangle` 表示左尖括号和右尖括号。如`$\\langle x \\rangle$` 表示：![\\langle x \\rangle](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/math)。\n\n### 上取整\n\n  使用`\\lceil` 和 `\\rceil` 表示。 如，`$\\lceil x \\rceil$`：![\\lceil x \\rceil](https://math.jianshu.com/math?formula=\\lceil x \\rceil)。\n\n### 下取整\n\n  使用`\\lfloor` 和 `\\rfloor` 表示。如，`$\\lfloor x \\rfloor$`：![\\lfloor x \\rfloor](https://math.jianshu.com/math?formula=\\lfloor x \\rfloor)。\n\n## **求和与积分**\n\n### 求和\n\n  `\\sum` 用来表示求和符号，其下标表示求和下限，上标表示上限。如:\n  `$\\sum_{r=1}^n$`表示：![\\sum_{r=1}^n](https://math.jianshu.com/math?formula=\\sum_{r%3D1}^n)。\n  `$$\\sum_{r=1}^n$$`表示：![\\sum_{r=1}^n](https://math.jianshu.com/math?formula=%5Csum_%7Br%3D1%7D%5En)\n\n### 积分\n\n  `\\int` 用来表示积分符号，同样地，其上下标表示积分的上下限。如，`$\\int_{r=1}^\\infty$`：![\\int_{r=1}^\\infty](https://math.jianshu.com/math?formula=\\int_{r%3D1}^\\infty)。\n  多重积分同样使用 **int** ，通过 **i** 的数量表示积分导数：\n  `$\\iint$` ：![\\iint](https://math.jianshu.com/math?formula=\\iint)\n  `$\\iiint$` ：![\\iiint](https://math.jianshu.com/math?formula=\\iiint)\n  `$\\iiiint$` ：![\\iiiint](https://math.jianshu.com/math?formula=\\iiiint)\n\n### 连乘\n\n  `$\\prod {a+b}$`，输出：![\\prod {a+b}](https://math.jianshu.com/math?formula=\\prod {a%2Bb})。\n  `$\\prod_{i=1}^{K}$`，输出：![\\prod_{i=1}^{K}](https://math.jianshu.com/math?formula=\\prod_{i%3D1}^{K})。\n  `$$\\prod_{i=1}^{K}$$`，输出：![\\prod_{i=1}^{K}](https://math.jianshu.com/math?formula=%5Cprod_%7Bi%3D1%7D%5E%7BK%7D)。\n\n### 其他\n\n  与此类似的符号还有，\n  `$\\prod$` ：![\\prod](https://math.jianshu.com/math?formula=\\prod)\n  `$\\bigcup$` ：![\\bigcup](https://math.jianshu.com/math?formula=\\bigcup)\n  `$\\bigcap$` ：![\\bigcap](https://math.jianshu.com/math?formula=\\bigcap)\n  `$arg\\,\\max_{c_k}$`：![arg\\,\\max_{c_k}](https://math.jianshu.com/math?formula=arg\\%2C\\max_{c_k})\n  `$arg\\,\\min_{c_k}$`：![arg\\,\\min_{c_k}](https://math.jianshu.com/math?formula=arg\\%2C\\min_{c_k})\n  `$\\mathop {argmin}_{c_k}$`：![\\mathop {argmin}_{c_k}](https://math.jianshu.com/math?formula=\\mathop {argmin}_{c_k})\n  `$\\mathop {argmax}_{c_k}$`：![\\mathop {argmax}_{c_k}](https://math.jianshu.com/math?formula=\\mathop {argmax}_{c_k})\n  `$\\max_{c_k}$`：![\\max_{c_k}](https://math.jianshu.com/math?formula=\\max_{c_k})\n  `$\\min_{c_k}$`：![\\min_{c_k}](https://math.jianshu.com/math?formula=\\min_{c_k})\n\n## **分式与根式**\n\n### 分式\n\n- 第一种，使用`\\frac ab`，`\\frac`作用于其后的两个组`a` ，`b` ，结果为![\\frac ab](https://math.jianshu.com/math?formula=\\frac ab)。如果你的分子或分母不是单个字符，请使用`{..}`来分组，比如`$\\frac {a+c+1}{b+c+2}$`表示![\\frac {a+c+1}{b+c+2}](https://math.jianshu.com/math?formula=\\frac {a%2Bc%2B1}{b%2Bc%2B2})。\n- 第二种，使用`\\over`来分隔一个组的前后两部分，如`{a+1\\over b+1}`：![{a+1\\over b+1}](https://math.jianshu.com/math?formula={a%2B1\\over b%2B1})\n\n### 连分数\n\n  书写连分数表达式时，请使用`\\cfrac`代替`\\frac`或者`\\over`两者效果对比如下：\n  `\\frac` 表示如下：\n\n\n\n```ruby\n$$x=a_0 + \\frac {1^2}{a_1 + \\frac {2^2}{a_2 + \\frac {3^2}{a_3 + \\frac {4^2}{a_4 + ...}}}}$$\n```\n\n  显示如下：\n![x=a_0 + \\frac {1^2}{a_1 + \\frac {2^2}{a_2 + \\frac {3^2}{a_3 + \\frac {4^2}{a_4 + ...}}}}](https://math.jianshu.com/math?formula=x%3Da_0 %2B \\frac {1^2}{a_1 %2B \\frac {2^2}{a_2 %2B \\frac {3^2}{a_3 %2B \\frac {4^2}{a_4 %2B ...}}}})\n  `\\cfrac` 表示如下：\n\n\n\n```ruby\n$$x=a_0 + \\cfrac {1^2}{a_1 + \\cfrac {2^2}{a_2 + \\cfrac {3^2}{a_3 + \\cfrac {4^2}{a_4 + ...}}}}$$\n```\n\n  显示如下：\n![x=a_0 + \\cfrac {1^2}{a_1 + \\cfrac {2^2}{a_2 + \\cfrac {3^2}{a_3 + \\cfrac {4^2}{a_4 + ...}}}}](https://math.jianshu.com/math?formula=x%3Da_0 %2B \\cfrac {1^2}{a_1 %2B \\cfrac {2^2}{a_2 %2B \\cfrac {3^2}{a_3 %2B \\cfrac {4^2}{a_4 %2B ...}}}})\n\n### 根式\n\n  根式使用`\\sqrt` 来表示。\n  如开4次方：`$\\sqrt[4]{\\frac xy}$` ：![\\sqrt[4]{\\frac xy}](https://math.jianshu.com/math?formula=\\sqrt[4]{\\frac xy})。\n  开平方：`$\\sqrt {a+b}$`：![\\sqrt {a+b}](https://math.jianshu.com/math?formula=\\sqrt {a%2Bb})。\n\n## **多行表达式**\n\n### 分类表达式\n\n  定义函数的时候经常需要分情况给出表达式，使用`\\begin{cases}…\\end{cases}` 。其中：\n\n-   使用`\\\\` 来分类，\n-   使用`&` 指示需要对齐的位置，\n-   使用`\\` +`空格`表示空格。\n\n\n\n```ruby\n$$\nf(n)\n\\begin{cases}\n\\cfrac n2, &if\\ n\\ is\\ even\\\\\n3n + 1, &if\\  n\\ is\\ odd\n\\end{cases}\n$$\n```\n\n  表示:\n![f(n) \\begin{cases} \\cfrac n2, &if\\ n\\ is\\ even\\\\ 3n + 1, &if\\ n\\ is\\ odd \\end{cases}](https://math.jianshu.com/math?formula=f(n) \\begin{cases} \\cfrac n2%2C %26if\\ n\\ is\\ even\\\\ 3n %2B 1%2C %26if\\ n\\ is\\ odd \\end{cases})\n\n\n\n```ruby\n$$\nL(Y,f(X)) =\n\\begin{cases}\n0, & \\text{Y = f(X)}  \\\\\n1, & \\text{Y $\\neq$ f(X)}\n\\end{cases}\n$$\n```\n\n  表示:\n![L(Y,f(X)) = \\begin{cases} 0, & \\text{Y = f(X)} \\\\ 1, & \\text{Y $\\neq$ f(X)} \\end{cases}](https://math.jianshu.com/math?formula=L(Y%2Cf(X))%20%3D%20%5Cbegin%7Bcases%7D%200%2C%20%26%20%5Ctext%7BY%20%3D%20f(X)%7D%20%5C%5C%201%2C%20%26%20%5Ctext%7BY%20%24%5Cneq%24%20f(X)%7D%20%5Cend%7Bcases%7D)\n  如果想分类之间的垂直间隔变大，可以使用`\\\\[2ex]` 代替`\\\\` 来分隔不同的情况。(`3ex,4ex` 也可以用，`1ex` 相当于原始距离）。如下所示：\n\n\n\n```ruby\n$$\nL(Y,f(X)) =\n\\begin{cases}\n0, & \\text{Y = f(X)} \\\\[5ex]\n1, & \\text{Y $\\neq$ f(X)}\n\\end{cases}\n$$\n```\n\n  表示：\n![L(Y,f(X)) = \\begin{cases} 0, & \\text{Y = f(X)} \\\\[5ex] 1, & \\text{Y $\\neq$ f(X)} \\end{cases}](https://math.jianshu.com/math?formula=L(Y%2Cf(X))%20%3D%20%5Cbegin%7Bcases%7D%200%2C%20%26%20%5Ctext%7BY%20%3D%20f(X)%7D%20%5C%5C%5B5ex%5D%201%2C%20%26%20%5Ctext%7BY%20%24%5Cneq%24%20f(X)%7D%20%5Cend%7Bcases%7D)\n\n### 多行表达式\n\n  有时候需要将一行公式分多行进行显示。\n\n\n\n```ruby\n$$\n\\begin{equation}\\begin{split} \na&=b+c-d \\\\ \n&\\quad +e-f\\\\ \n&=g+h\\\\ \n& =i \n\\end{split}\\end{equation}\n$$\n```\n\n  表示：\n![\\begin{equation}\\begin{split} a&=b+c-d \\\\ &\\quad +e-f\\\\ &=g+h\\\\ & =i \\end{split}\\end{equation}](https://math.jianshu.com/math?formula=\\begin{equation}\\begin{split} a%26%3Db%2Bc-d \\\\ %26\\quad %2Be-f\\\\ %26%3Dg%2Bh\\\\ %26 %3Di \\end{split}\\end{equation})\n  其中`begin{equation}` 表示开始方程，`end{equation}` 表示方程结束；`begin{split}` 表示开始多行公式，`end{split}` 表示结束；公式中用`\\\\` 表示回车到下一行，`&` 表示对齐的位置。\n\n### 方程组\n\n  使用`\\begin{array}...\\end{array}` 与`\\left \\{` 与`\\right.` 配合表示方程组:\n\n\n\n```ruby\n$$\n\\left \\{ \n\\begin{array}{c}\na_1x+b_1y+c_1z=d_1 \\\\ \na_2x+b_2y+c_2z=d_2 \\\\ \na_3x+b_3y+c_3z=d_3\n\\end{array}\n\\right.\n$$\n```\n\n  表示：\n![\\left \\{ \\begin{array}{c} a_1x+b_1y+c_1z=d_1 \\\\ a_2x+b_2y+c_2z=d_2 \\\\ a_3x+b_3y+c_3z=d_3 \\end{array} \\right.](https://math.jianshu.com/math?formula=\\left \\{ \\begin{array}{c} a_1x%2Bb_1y%2Bc_1z%3Dd_1 \\\\ a_2x%2Bb_2y%2Bc_2z%3Dd_2 \\\\ a_3x%2Bb_3y%2Bc_3z%3Dd_3 \\end{array} \\right.)\n  注意：通常MathJax通过内部策略自己管理公式内部的空间，因此`a…b` 与`a…….b` （`.`表示空格）都会显示为`ab` 。可以通过在`ab` 间加入`\\` ,增加些许间隙，`\\;` 增加较宽的间隙，`\\quad` 与`\\qquad` 会增加更大的间隙。\n\n## **特殊函数与符号**\n\n### 三角函数\n\n  `\\snx$` : ![sinx](https://math.jianshu.com/math?formula=sinx)\n  `\\arctanx` : ![arctanx](https://math.jianshu.com/math?formula=arctanx)\n\n### 比较运算符\n\n  小于(`\\lt` )：![\\lt](https://math.jianshu.com/math?formula=\\lt)\n  大于(`\\gt` )：![\\gt](https://math.jianshu.com/math?formula=\\gt)\n  小于等于(`\\le` )：![\\le](https://math.jianshu.com/math?formula=\\le)\n  大于等于(`\\ge` )：![\\ge](https://math.jianshu.com/math?formula=\\ge)\n  不等于(`\\ne` ) : ![\\ne](https://math.jianshu.com/math?formula=\\ne)\n  可以在这些运算符前面加上`\\not` ，如`\\not\\lt` : ![\\not\\lt`](https://math.jianshu.com/math?formula=\\not\\lt`)\n\n### 集合关系与运算\n\n  并集(`\\cup` ): ![\\cup](https://math.jianshu.com/math?formula=\\cup)\n  交集(`\\cap` ): ![\\cap](https://math.jianshu.com/math?formula=\\cap)\n  差集(`\\setminus` ): ![\\setminus](https://math.jianshu.com/math?formula=\\setminus)\n  子集(`\\subset` ): ![\\subset](https://math.jianshu.com/math?formula=\\subset)\n  子集(`\\subseteq` ): ![\\subseteq](https://math.jianshu.com/math?formula=\\subseteq)\n  非子集(`\\subsetneq` ): ![\\subsetneq](https://math.jianshu.com/math?formula=\\subsetneq)\n  父集(`\\supset` ): ![\\supset](https://math.jianshu.com/math?formula=\\supset)\n  属于(`\\in` ): ![\\in](https://math.jianshu.com/math?formula=\\in)\n  不属于(`\\notin` ): ![\\notin](https://math.jianshu.com/math?formula=\\notin)\n  空集(`\\emptyset` ): ![\\emptyset](https://math.jianshu.com/math?formula=\\emptyset)\n  空(`\\varnothing` ): ![\\varnothing](https://math.jianshu.com/math?formula=\\varnothing)\n\n### 排列\n\n  `\\binom{n+1}{2k}` : ![\\binom{n+1}{2k}](https://math.jianshu.com/math?formula=\\binom{n%2B1}{2k})\n  `{n+1 \\choose 2k}` : ![{n+1 \\choose 2k}](https://math.jianshu.com/math?formula={n%2B1 \\choose 2k})\n\n### 箭头\n\n  (`\\to` ):![\\to](https://math.jianshu.com/math?formula=\\to)\n  (`\\rightarrow` ): ![\\rightarrow](https://math.jianshu.com/math?formula=\\rightarrow)\n  (`\\leftarrow` ): ![\\leftarrow](https://math.jianshu.com/math?formula=\\leftarrow)\n  (`\\Rightarrow` ): ![\\Rightarrow](https://math.jianshu.com/math?formula=\\Rightarrow)\n  (`\\Leftarrow` ): ![\\Leftarrow](https://math.jianshu.com/math?formula=\\Leftarrow)\n  (`\\mapsto` ): ![\\mapsto](https://math.jianshu.com/math?formula=\\mapsto)\n\n### 逻辑运算符\n\n  (`\\land` ): ![\\land](https://math.jianshu.com/math?formula=\\land)\n  (`\\lor` ): ![\\lor](https://math.jianshu.com/math?formula=\\lor)\n  (`\\lnot` ): ![\\lnot](https://math.jianshu.com/math?formula=\\lnot)\n  (`\\forall` ): ![\\forall](https://math.jianshu.com/math?formula=\\forall)\n  (`\\exists` ): ![\\exists](https://math.jianshu.com/math?formula=\\exists)\n  (`\\top` ): ![\\top](https://math.jianshu.com/math?formula=\\top)\n  (`\\bot` ): ![\\bot](https://math.jianshu.com/math?formula=\\bot)\n  (`\\vdash` ): ![\\vdash](https://math.jianshu.com/math?formula=\\vdash)\n  (`\\vDash` ): ![\\vDash](https://math.jianshu.com/math?formula=\\vDash)\n\n### 操作符\n\n  (`\\star` ): ![\\star](https://math.jianshu.com/math?formula=\\star)\n  (`\\ast` ): ![\\ast](https://math.jianshu.com/math?formula=\\ast)\n  (`\\oplus` ): ![\\oplus](https://math.jianshu.com/math?formula=\\oplus)\n  (`\\circ` ): ![\\circ](https://math.jianshu.com/math?formula=\\circ)\n  (`\\bullet` ): ![\\bullet](https://math.jianshu.com/math?formula=\\bullet)\n\n### 等于\n\n  (`\\approx` ): ![\\approx](https://math.jianshu.com/math?formula=\\approx)\n  (`\\sim` ): ![\\sim](https://math.jianshu.com/math?formula=\\sim)\n  (`\\equiv` ): ![\\equiv](https://math.jianshu.com/math?formula=\\equiv)\n  (`\\prec` ): ![\\prec](https://math.jianshu.com/math?formula=\\prec)\n\n### 范围\n\n  (`\\infty` ): ![\\infty](https://math.jianshu.com/math?formula=\\infty)\n  (`\\aleph_o` ): ![\\aleph_o](https://math.jianshu.com/math?formula=\\aleph_o)\n  (`\\nabla` ): ![\\nabla](https://math.jianshu.com/math?formula=\\nabla)\n  (`\\Im` ): ![\\Im](https://math.jianshu.com/math?formula=\\Im)\n  (`\\Re` ): ![\\Re](https://math.jianshu.com/math?formula=\\Re)\n\n### 模运算\n\n  (`\\pmod` ): ![b \\pmod n](https://math.jianshu.com/math?formula=b \\pmod n)\n  如`a \\equiv b \\pmod n` : ![a \\equiv b \\pmod n](https://math.jianshu.com/math?formula=a \\equiv b \\pmod n)\n\n### 点\n\n  (`\\ldots` ): ![\\ldots](https://math.jianshu.com/math?formula=\\ldots)\n  (`\\cdots` ): ![\\cdots](https://math.jianshu.com/math?formula=\\cdots)\n  (`\\cdot` ): ![\\cdot](https://math.jianshu.com/math?formula=\\cdot)\n  其区别是点的位置不同，`\\ldots` 位置稍低，`\\cdots` 位置居中。\n\n\n\n```ruby\n$$\n\\begin{equation}\na_1+a_2+\\ldots+a_n \\\\ \na_1+a_2+\\cdots+a_n\n\\end{equation}\n$$\n```\n\n  表示：\n![\\begin{equation} a_1+a_2+\\ldots+a_n \\\\ a_1+a_2+\\cdots+a_n \\end{equation}](https://math.jianshu.com/math?formula=\\begin{equation} a_1%2Ba_2%2B\\ldots%2Ba_n \\\\ a_1%2Ba_2%2B\\cdots%2Ba_n \\end{equation})\n\n## **顶部符号**\n\n  对于单字符，`\\hat x` ：![\\hat x](https://math.jianshu.com/math?formula=\\hat x)\n  多字符可以使用`\\widehat {xy}` ：![\\widehat {xy}](https://math.jianshu.com/math?formula=\\widehat {xy})\n  类似的还有:\n  (`\\overline x` ): ![\\overline x](https://math.jianshu.com/math?formula=\\overline x)\n  矢量(`\\vec` ): ![\\vec x](https://math.jianshu.com/math?formula=\\vec x)\n  向量(`\\overrightarrow {xy}` ): ![\\overrightarrow {xy}](https://math.jianshu.com/math?formula=\\overrightarrow {xy})\n  (`\\dot x` ): ![\\dot x](https://math.jianshu.com/math?formula=\\dot x)\n  (`\\ddot x` ): ![\\ddot x](https://math.jianshu.com/math?formula=\\ddot x)\n  (`\\dot {\\dot x}` ): ![\\dot {\\dot x}](https://math.jianshu.com/math?formula=\\dot {\\dot x})\n\n## **表格**\n\n  使用`\\begin{array}{列样式}…\\end{array}` 这样的形式来创建表格，列样式可以是`clr` 表示居中，左，右对齐，还可以使用`|` 表示一条竖线。表格中各行使用`\\\\` 分隔，各列使用`&` 分隔。使用`\\hline` 在本行前加入一条直线。 例如:\n\n\n\n```ruby\n$$\n\\begin{array}{c|lcr}\nn & \\text{Left} & \\text{Center} & \\text{Right} \\\\\n\\hline\n1 & 0.24 & 1 & 125 \\\\\n2 & -1 & 189 & -8 \\\\\n3 & -20 & 2000 & 1+10i \\\\\n\\end{array}\n$$\n```\n\n  得到：\n![\\begin{array}{c|lcr} n & \\text{Left} & \\text{Center} & \\text{Right} \\\\ \\hline 1 & 0.24 & 1 & 125 \\\\ 2 & -1 & 189 & -8 \\\\ 3 & -20 & 2000 & 1+10i \\\\ \\end{array}](https://math.jianshu.com/math?formula=\\begin{array}{c|lcr} n %26 \\text{Left} %26 \\text{Center} %26 \\text{Right} \\\\ \\hline 1 %26 0.24 %26 1 %26 125 \\\\ 2 %26 -1 %26 189 %26 -8 \\\\ 3 %26 -20 %26 2000 %26 1%2B10i \\\\ \\end{array})\n\n## **矩阵**\n\n### 基本内容\n\n  使用`\\begin{matrix}…\\end{matrix}` 这样的形式来表示矩阵，在`\\begin` 与`\\end` 之间加入矩阵中的元素即可。矩阵的行之间使用`\\\\` 分隔，列之间使用`&` 分隔，例如:\n\n\n\n```ruby\n$$\n\\begin{matrix}\n1 & x & x^2 \\\\\n1 & y & y^2 \\\\\n1 & z & z^2 \\\\\n\\end{matrix}\n$$\n```\n\n  得到：\n![\\begin{matrix} 1 & x & x^2 \\\\ 1 & y & y^2 \\\\ 1 & z & z^2 \\\\ \\end{matrix}](https://math.jianshu.com/math?formula=\\begin{matrix} 1 %26 x %26 x^2 \\\\ 1 %26 y %26 y^2 \\\\ 1 %26 z %26 z^2 \\\\ \\end{matrix})\n\n### 括号\n\n  如果要对矩阵加括号，可以像上文中提到的一样，使用`\\left` 与`\\right` 配合表示括号符号。也可以使用特殊的`matrix` 。即替换`\\begin{matrix}…\\end{matrix}` 中`matrix` 为`pmatrix` ，`bmatrix` ，`Bmatrix` ，`vmatrix` , `Vmatrix` 。\n\n1. pmatrix`$\\begin{pmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{pmatrix}$` : ![\\begin{pmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{pmatrix}](https://math.jianshu.com/math?formula=\\begin{pmatrix}1 %26 2 \\\\ 3 %26 4\\\\ \\end{pmatrix})\n2. bmatrix`$\\begin{bmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{bmatrix}$` : ![\\begin{bmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{bmatrix}](https://math.jianshu.com/math?formula=\\begin{bmatrix}1 %26 2 \\\\ 3 %26 4\\\\ \\end{bmatrix})\n3. Bmatrix`$\\begin{Bmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{Bmatrix}$` : ![\\begin{Bmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{Bmatrix}](https://math.jianshu.com/math?formula=\\begin{Bmatrix}1 %26 2 \\\\ 3 %26 4\\\\ \\end{Bmatrix})\n4. vmatrix`$\\begin{vmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{vmatrix}$` : ![\\begin{vmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{vmatrix}](https://math.jianshu.com/math?formula=\\begin{vmatrix}1 %26 2 \\\\ 3 %26 4\\\\ \\end{vmatrix})\n5. Vmatrix`$\\begin{Vmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{Vmatrix}$` : ![\\begin{Vmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{Vmatrix}](https://math.jianshu.com/math?formula=\\begin{Vmatrix}1 %26 2 \\\\ 3 %26 4\\\\ \\end{Vmatrix})\n\n### 元素省略\n\n  可以使用`\\cdots` ：⋯，`\\ddots`：⋱ ，`\\vdots`：⋮ 来省略矩阵中的元素，如：\n\n\n\n```ruby\n$$\n\\begin{pmatrix}\n1&a_1&a_1^2&\\cdots&a_1^n\\\\\n1&a_2&a_2^2&\\cdots&a_2^n\\\\\n\\vdots&\\vdots&\\vdots&\\ddots&\\vdots\\\\\n1&a_m&a_m^2&\\cdots&a_m^n\\\\\n\\end{pmatrix}\n$$\n```\n\n  表示：\n![\\begin{pmatrix} 1&a_1&a_1^2&\\cdots&a_1^n\\\\ 1&a_2&a_2^2&\\cdots&a_2^n\\\\ \\vdots&\\vdots&\\vdots&\\ddots&\\vdots\\\\ 1&a_m&a_m^2&\\cdots&a_m^n\\\\ \\end{pmatrix}](https://math.jianshu.com/math?formula=\\begin{pmatrix} 1%26a_1%26a_1^2%26\\cdots%26a_1^n\\\\ 1%26a_2%26a_2^2%26\\cdots%26a_2^n\\\\ \\vdots%26\\vdots%26\\vdots%26\\ddots%26\\vdots\\\\ 1%26a_m%26a_m^2%26\\cdots%26a_m^n\\\\ \\end{pmatrix})\n\n### 增广矩阵\n\n  增广矩阵需要使用前面的表格中使用到的`\\begin{array} ... \\end{array}` 来实现。\n\n\n\n```swift\n$$\n\\left[  \\begin{array}  {c c | c} %这里的c表示数组中元素对其方式：c居中、r右对齐、l左对齐，竖线表示2、3列间插入竖线\n1 & 2 & 3 \\\\\n\\hline %插入横线，如果去掉\\hline就是增广矩阵\n4 & 5 & 6\n\\end{array}  \\right]\n$$\n```\n\n显示为：\n![\\left[ \\begin{array} {c c | c} 1 & 2 & 3 \\\\ \\hline 4 & 5 & 6 \\end{array} \\right]](https://math.jianshu.com/math?formula=\\left[ \\begin{array} {c c | c} 1 %26 2 %26 3 \\\\ \\hline 4 %26 5 %26 6 \\end{array} \\right])\n\n## **公式标记与引用**\n\n  使用`\\tag{yourtag}` 来标记公式，如果想在之后引用该公式，则还需要加上`\\label{yourlabel}` 在`\\tag` 之后，如`$$a = x^2 - y^3 \\tag{1}\\label{1}$$` 显示为：\n![a := x^2 - y^3 \\tag{1}\\label{311}](https://math.jianshu.com/math?formula=a %3A%3D x^2 - y^3 \\tag{1}\\label{311})\n  如果不需要被引用，只使用`\\tag{yourtag}` ，`$$x+y=z\\tag{1.1}$$`显示为：\n![x+y=z\\tag{1.1}](https://math.jianshu.com/math?formula=x%2By%3Dz\\tag{1.1})\n  `\\tab{yourtab}` 中的内容用于显示公式后面的标记。公式之间通过`\\label{}` 设置的内容来引用。为了引用公式，可以使用`\\eqref{yourlabel}` ，如`$$a + y^3 \\stackrel{\\eqref{1}}= x^2$$` 显示为：\n![a + y^3 \\stackrel{\\eqref{1}}= x^2](https://math.jianshu.com/math?formula=a %2B y^3 \\stackrel{\\eqref{1}}%3D x^2)\n\n或者使用`\\ref{yourlabel}` 不带括号引用，如`$$a + y^3 \\stackrel{\\ref{111}}= x^2$$` 显示为:\n![a + y^3 \\stackrel{\\ref{1}}= x^2](https://math.jianshu.com/math?formula=a %2B y^3 \\stackrel{\\ref{1}}%3D x^2)\n\n## **字体**\n\n### 黑板粗体字\n\n此字体经常用来表示代表实数、整数、有理数、复数的大写字母。\n`$\\mathbb ABCDEF$`：![\\mathbb ABCDEF](https://math.jianshu.com/math?formula=\\mathbb ABCDEF)\n`$\\Bbb ABCDEF$`：![\\Bbb ABCDEF](https://math.jianshu.com/math?formula=\\Bbb ABCDEF)\n\n### 黑体字\n\n`$\\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ$` :![\\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ](https://math.jianshu.com/math?formula=\\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ)\n`$\\mathbf abcdefghijklmnopqrstuvwxyz$` :![\\mathbf abcdefghijklmnopqrstuvwxyz](https://math.jianshu.com/math?formula=\\mathbf abcdefghijklmnopqrstuvwxyz)\n\n### 打印机字体\n\n`$\\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ$` :![\\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ](https://math.jianshu.com/math?formula=\\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ)\n\n## **参考文档**\n\n| #    | 链接地址                                          | 文档名称                                                     |\n| ---- | ------------------------------------------------- | ------------------------------------------------------------ |\n| 1    | `blog.csdn.net/dabokele/article/details/79577072` | [Mathjax公式教程](https://blog.csdn.net/dabokele/article/details/79577072) |\n| 2    | `blog.csdn.net/ethmery/article/details/50670297`  | [基本数学公式语法](https://blog.csdn.net/ethmery/article/details/50670297) |\n| 3    | `blog.csdn.net/lilongsy/article/details/79378620` | [常用数学符号的LaTeX表示方法](https://blog.csdn.net/lilongsy/article/details/79378620) |\n| 4    | `www.mathjax.org`                                 | [Beautiful math in all browsers](https://www.mathjax.org/)   |\n\n","source":"_posts/Tools/Markdown 公式.md","raw":"---\ntitle: Markdown 数学公式编辑\ntag: Tools\n\n\n---\n\n\n\n# Markdown中公式编辑教程\n\n# markdown中公式编辑教程\n\n标签： Mathjax 公式编辑 markdown\n\n一般公式分为两种形式，行内公式和行间公式。\n\n- 行内公式：![\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.](https://math.jianshu.com/math?formula=\\Gamma(z) %3D \\int_0^\\infty t^{z-1}e^{-t}dt\\%2C.)\n- 行间公式：![\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.](https://math.jianshu.com/math?formula=\\Gamma(z) %3D \\int_0^\\infty t^{z-1}e^{-t}dt\\%2C.)\n<!-- more-->\n  对应的代码块为：\n\n```ruby\n$ \\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,. $\n$$\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.$$\n```\n\n  行内公式是在公式代码块的基础上前面加上**$** ，后面加上**$** 组成的，而行间公式则是在公式代码块前后使用**$$** 和**$$** 。\n  下面主要介绍数学公式中常用的一些符号。\n\n## **希腊字母**\n\n|  名称   | 大写 |  code   |   小写   |   code   |\n| :-----: | :--: | :-----: | :------: | :------: |\n|  alpha  |  A   |    A    |    α     |  \\alpha  |\n|  beta   |  B   |    B    |    β     |  \\beta   |\n|  gamma  |  Γ   | \\Gamma  |    γ     |  \\gamma  |\n|  delta  |  Δ   | \\Delta  |    δ     |  \\delta  |\n| epsilon |  E   |    E    |    ϵ     | \\epsilon |\n|  zeta   |  Z   |    Z    |    ζ     |  \\zeta   |\n|   eta   |  H   |    H    |    η     |   \\eta   |\n|  theta  |  Θ   | \\Theta  |    θ     |  \\theta  |\n|  iota   |  I   |    I    |    ι     |  \\iota   |\n|  kappa  |  K   |    K    |    κ     |  \\kappa  |\n| lambda  |  Λ   | \\Lambda |    λ     | \\lambda  |\n|   mu    |  M   |    M    |    μ     |   \\mu    |\n|   nu    |  N   |    N    |    ν     |   \\nu    |\n|   xi    |  Ξ   |   \\Xi   |    ξ     |   \\xi    |\n| omicron |  O   |    O    |    ο     | \\omicron |\n|   pi    |  Π   |   \\Pi   |    π     |   \\pi    |\n|   rho   |  P   |    P    |    ρ     |   \\rho   |\n|  sigma  |  Σ   | \\Sigma  |    σ     |  \\sigma  |\n|   tau   |  T   |    T    |    τ     |   \\tau   |\n| upsilon |  Υ   |    υ    | \\upsilon |          |\n|   phi   |  Φ   |  \\Phi   |    ϕ     |   \\phi   |\n|   chi   |  X   |    X    |    χ     |   \\chi   |\n|   psi   |  Ψ   |  \\Psi   |    ψ     |   \\psi   |\n|  omega  |  Ω   | \\Omega  |    ω     |  \\omega  |\n\n## **上标与下标**\n\n  上标和下标分别使用`^` 与`_` ，例如`$x_i^2$`表示的是：![x_i^2](https://math.jianshu.com/math?formula=x_i^2)。\n  默认情况下，上、下标符号仅仅对下一个组起作用。一个组即单个字符或者使用`{..}` 包裹起来的内容。如果使用`$10^10$` 表示的是![10^10](https://math.jianshu.com/math?formula=10^10)，而`$10^{10}$` 才是![10^{10}](https://math.jianshu.com/math?formula=10^{10})。同时，大括号还能消除二义性，如`x^5^6` 将得到一个错误，必须使用大括号来界定^的结合性，如`${x^5}^6$` ：![{x^5}^6](https://math.jianshu.com/math?formula={x^5}^6)或者`$x^{5^6}$` ：![x^{5^6}](https://math.jianshu.com/math?formula=x^{5^6})。\n\n## **括号**\n\n### 小括号与方括号\n\n  使用原始的`( )` ，`[ ]` 即可，如`$(2+3)[4+4]$` ：![(2+3)](https://math.jianshu.com/math?formula=(2%2B3)) ![[4+4]](https://math.jianshu.com/math?formula=[4%2B4])\n  使用\\left(或\\right)使符号大小与邻近的公式相适应（该语句适用于所有括号类型），如`$\\left(\\frac{x}{y}\\right)$` ：![\\left(\\frac{x}{y}\\right)](https://math.jianshu.com/math?formula=\\left(\\frac{x}{y}\\right))\n\n### 大括号\n\n  由于大括号`{}` 被用于分组，因此需要使用`\\{`和`\\}`表示大括号，也可以使用`\\lbrace` 和`\\rbrace`来表示。如`$\\{a\\*b\\}:a\\∗b$` 或`$\\lbrace a\\*b\\rbrace :a\\*b$` 表示![\\{a*b\\}:a∗b](https://math.jianshu.com/math?formula=\\{a*b\\}%3Aa∗b)。\n\n### 尖括号\n\n  区分于小于号和大于号，使用`\\langle` 和`\\rangle` 表示左尖括号和右尖括号。如`$\\langle x \\rangle$` 表示：![\\langle x \\rangle](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/math)。\n\n### 上取整\n\n  使用`\\lceil` 和 `\\rceil` 表示。 如，`$\\lceil x \\rceil$`：![\\lceil x \\rceil](https://math.jianshu.com/math?formula=\\lceil x \\rceil)。\n\n### 下取整\n\n  使用`\\lfloor` 和 `\\rfloor` 表示。如，`$\\lfloor x \\rfloor$`：![\\lfloor x \\rfloor](https://math.jianshu.com/math?formula=\\lfloor x \\rfloor)。\n\n## **求和与积分**\n\n### 求和\n\n  `\\sum` 用来表示求和符号，其下标表示求和下限，上标表示上限。如:\n  `$\\sum_{r=1}^n$`表示：![\\sum_{r=1}^n](https://math.jianshu.com/math?formula=\\sum_{r%3D1}^n)。\n  `$$\\sum_{r=1}^n$$`表示：![\\sum_{r=1}^n](https://math.jianshu.com/math?formula=%5Csum_%7Br%3D1%7D%5En)\n\n### 积分\n\n  `\\int` 用来表示积分符号，同样地，其上下标表示积分的上下限。如，`$\\int_{r=1}^\\infty$`：![\\int_{r=1}^\\infty](https://math.jianshu.com/math?formula=\\int_{r%3D1}^\\infty)。\n  多重积分同样使用 **int** ，通过 **i** 的数量表示积分导数：\n  `$\\iint$` ：![\\iint](https://math.jianshu.com/math?formula=\\iint)\n  `$\\iiint$` ：![\\iiint](https://math.jianshu.com/math?formula=\\iiint)\n  `$\\iiiint$` ：![\\iiiint](https://math.jianshu.com/math?formula=\\iiiint)\n\n### 连乘\n\n  `$\\prod {a+b}$`，输出：![\\prod {a+b}](https://math.jianshu.com/math?formula=\\prod {a%2Bb})。\n  `$\\prod_{i=1}^{K}$`，输出：![\\prod_{i=1}^{K}](https://math.jianshu.com/math?formula=\\prod_{i%3D1}^{K})。\n  `$$\\prod_{i=1}^{K}$$`，输出：![\\prod_{i=1}^{K}](https://math.jianshu.com/math?formula=%5Cprod_%7Bi%3D1%7D%5E%7BK%7D)。\n\n### 其他\n\n  与此类似的符号还有，\n  `$\\prod$` ：![\\prod](https://math.jianshu.com/math?formula=\\prod)\n  `$\\bigcup$` ：![\\bigcup](https://math.jianshu.com/math?formula=\\bigcup)\n  `$\\bigcap$` ：![\\bigcap](https://math.jianshu.com/math?formula=\\bigcap)\n  `$arg\\,\\max_{c_k}$`：![arg\\,\\max_{c_k}](https://math.jianshu.com/math?formula=arg\\%2C\\max_{c_k})\n  `$arg\\,\\min_{c_k}$`：![arg\\,\\min_{c_k}](https://math.jianshu.com/math?formula=arg\\%2C\\min_{c_k})\n  `$\\mathop {argmin}_{c_k}$`：![\\mathop {argmin}_{c_k}](https://math.jianshu.com/math?formula=\\mathop {argmin}_{c_k})\n  `$\\mathop {argmax}_{c_k}$`：![\\mathop {argmax}_{c_k}](https://math.jianshu.com/math?formula=\\mathop {argmax}_{c_k})\n  `$\\max_{c_k}$`：![\\max_{c_k}](https://math.jianshu.com/math?formula=\\max_{c_k})\n  `$\\min_{c_k}$`：![\\min_{c_k}](https://math.jianshu.com/math?formula=\\min_{c_k})\n\n## **分式与根式**\n\n### 分式\n\n- 第一种，使用`\\frac ab`，`\\frac`作用于其后的两个组`a` ，`b` ，结果为![\\frac ab](https://math.jianshu.com/math?formula=\\frac ab)。如果你的分子或分母不是单个字符，请使用`{..}`来分组，比如`$\\frac {a+c+1}{b+c+2}$`表示![\\frac {a+c+1}{b+c+2}](https://math.jianshu.com/math?formula=\\frac {a%2Bc%2B1}{b%2Bc%2B2})。\n- 第二种，使用`\\over`来分隔一个组的前后两部分，如`{a+1\\over b+1}`：![{a+1\\over b+1}](https://math.jianshu.com/math?formula={a%2B1\\over b%2B1})\n\n### 连分数\n\n  书写连分数表达式时，请使用`\\cfrac`代替`\\frac`或者`\\over`两者效果对比如下：\n  `\\frac` 表示如下：\n\n\n\n```ruby\n$$x=a_0 + \\frac {1^2}{a_1 + \\frac {2^2}{a_2 + \\frac {3^2}{a_3 + \\frac {4^2}{a_4 + ...}}}}$$\n```\n\n  显示如下：\n![x=a_0 + \\frac {1^2}{a_1 + \\frac {2^2}{a_2 + \\frac {3^2}{a_3 + \\frac {4^2}{a_4 + ...}}}}](https://math.jianshu.com/math?formula=x%3Da_0 %2B \\frac {1^2}{a_1 %2B \\frac {2^2}{a_2 %2B \\frac {3^2}{a_3 %2B \\frac {4^2}{a_4 %2B ...}}}})\n  `\\cfrac` 表示如下：\n\n\n\n```ruby\n$$x=a_0 + \\cfrac {1^2}{a_1 + \\cfrac {2^2}{a_2 + \\cfrac {3^2}{a_3 + \\cfrac {4^2}{a_4 + ...}}}}$$\n```\n\n  显示如下：\n![x=a_0 + \\cfrac {1^2}{a_1 + \\cfrac {2^2}{a_2 + \\cfrac {3^2}{a_3 + \\cfrac {4^2}{a_4 + ...}}}}](https://math.jianshu.com/math?formula=x%3Da_0 %2B \\cfrac {1^2}{a_1 %2B \\cfrac {2^2}{a_2 %2B \\cfrac {3^2}{a_3 %2B \\cfrac {4^2}{a_4 %2B ...}}}})\n\n### 根式\n\n  根式使用`\\sqrt` 来表示。\n  如开4次方：`$\\sqrt[4]{\\frac xy}$` ：![\\sqrt[4]{\\frac xy}](https://math.jianshu.com/math?formula=\\sqrt[4]{\\frac xy})。\n  开平方：`$\\sqrt {a+b}$`：![\\sqrt {a+b}](https://math.jianshu.com/math?formula=\\sqrt {a%2Bb})。\n\n## **多行表达式**\n\n### 分类表达式\n\n  定义函数的时候经常需要分情况给出表达式，使用`\\begin{cases}…\\end{cases}` 。其中：\n\n-   使用`\\\\` 来分类，\n-   使用`&` 指示需要对齐的位置，\n-   使用`\\` +`空格`表示空格。\n\n\n\n```ruby\n$$\nf(n)\n\\begin{cases}\n\\cfrac n2, &if\\ n\\ is\\ even\\\\\n3n + 1, &if\\  n\\ is\\ odd\n\\end{cases}\n$$\n```\n\n  表示:\n![f(n) \\begin{cases} \\cfrac n2, &if\\ n\\ is\\ even\\\\ 3n + 1, &if\\ n\\ is\\ odd \\end{cases}](https://math.jianshu.com/math?formula=f(n) \\begin{cases} \\cfrac n2%2C %26if\\ n\\ is\\ even\\\\ 3n %2B 1%2C %26if\\ n\\ is\\ odd \\end{cases})\n\n\n\n```ruby\n$$\nL(Y,f(X)) =\n\\begin{cases}\n0, & \\text{Y = f(X)}  \\\\\n1, & \\text{Y $\\neq$ f(X)}\n\\end{cases}\n$$\n```\n\n  表示:\n![L(Y,f(X)) = \\begin{cases} 0, & \\text{Y = f(X)} \\\\ 1, & \\text{Y $\\neq$ f(X)} \\end{cases}](https://math.jianshu.com/math?formula=L(Y%2Cf(X))%20%3D%20%5Cbegin%7Bcases%7D%200%2C%20%26%20%5Ctext%7BY%20%3D%20f(X)%7D%20%5C%5C%201%2C%20%26%20%5Ctext%7BY%20%24%5Cneq%24%20f(X)%7D%20%5Cend%7Bcases%7D)\n  如果想分类之间的垂直间隔变大，可以使用`\\\\[2ex]` 代替`\\\\` 来分隔不同的情况。(`3ex,4ex` 也可以用，`1ex` 相当于原始距离）。如下所示：\n\n\n\n```ruby\n$$\nL(Y,f(X)) =\n\\begin{cases}\n0, & \\text{Y = f(X)} \\\\[5ex]\n1, & \\text{Y $\\neq$ f(X)}\n\\end{cases}\n$$\n```\n\n  表示：\n![L(Y,f(X)) = \\begin{cases} 0, & \\text{Y = f(X)} \\\\[5ex] 1, & \\text{Y $\\neq$ f(X)} \\end{cases}](https://math.jianshu.com/math?formula=L(Y%2Cf(X))%20%3D%20%5Cbegin%7Bcases%7D%200%2C%20%26%20%5Ctext%7BY%20%3D%20f(X)%7D%20%5C%5C%5B5ex%5D%201%2C%20%26%20%5Ctext%7BY%20%24%5Cneq%24%20f(X)%7D%20%5Cend%7Bcases%7D)\n\n### 多行表达式\n\n  有时候需要将一行公式分多行进行显示。\n\n\n\n```ruby\n$$\n\\begin{equation}\\begin{split} \na&=b+c-d \\\\ \n&\\quad +e-f\\\\ \n&=g+h\\\\ \n& =i \n\\end{split}\\end{equation}\n$$\n```\n\n  表示：\n![\\begin{equation}\\begin{split} a&=b+c-d \\\\ &\\quad +e-f\\\\ &=g+h\\\\ & =i \\end{split}\\end{equation}](https://math.jianshu.com/math?formula=\\begin{equation}\\begin{split} a%26%3Db%2Bc-d \\\\ %26\\quad %2Be-f\\\\ %26%3Dg%2Bh\\\\ %26 %3Di \\end{split}\\end{equation})\n  其中`begin{equation}` 表示开始方程，`end{equation}` 表示方程结束；`begin{split}` 表示开始多行公式，`end{split}` 表示结束；公式中用`\\\\` 表示回车到下一行，`&` 表示对齐的位置。\n\n### 方程组\n\n  使用`\\begin{array}...\\end{array}` 与`\\left \\{` 与`\\right.` 配合表示方程组:\n\n\n\n```ruby\n$$\n\\left \\{ \n\\begin{array}{c}\na_1x+b_1y+c_1z=d_1 \\\\ \na_2x+b_2y+c_2z=d_2 \\\\ \na_3x+b_3y+c_3z=d_3\n\\end{array}\n\\right.\n$$\n```\n\n  表示：\n![\\left \\{ \\begin{array}{c} a_1x+b_1y+c_1z=d_1 \\\\ a_2x+b_2y+c_2z=d_2 \\\\ a_3x+b_3y+c_3z=d_3 \\end{array} \\right.](https://math.jianshu.com/math?formula=\\left \\{ \\begin{array}{c} a_1x%2Bb_1y%2Bc_1z%3Dd_1 \\\\ a_2x%2Bb_2y%2Bc_2z%3Dd_2 \\\\ a_3x%2Bb_3y%2Bc_3z%3Dd_3 \\end{array} \\right.)\n  注意：通常MathJax通过内部策略自己管理公式内部的空间，因此`a…b` 与`a…….b` （`.`表示空格）都会显示为`ab` 。可以通过在`ab` 间加入`\\` ,增加些许间隙，`\\;` 增加较宽的间隙，`\\quad` 与`\\qquad` 会增加更大的间隙。\n\n## **特殊函数与符号**\n\n### 三角函数\n\n  `\\snx$` : ![sinx](https://math.jianshu.com/math?formula=sinx)\n  `\\arctanx` : ![arctanx](https://math.jianshu.com/math?formula=arctanx)\n\n### 比较运算符\n\n  小于(`\\lt` )：![\\lt](https://math.jianshu.com/math?formula=\\lt)\n  大于(`\\gt` )：![\\gt](https://math.jianshu.com/math?formula=\\gt)\n  小于等于(`\\le` )：![\\le](https://math.jianshu.com/math?formula=\\le)\n  大于等于(`\\ge` )：![\\ge](https://math.jianshu.com/math?formula=\\ge)\n  不等于(`\\ne` ) : ![\\ne](https://math.jianshu.com/math?formula=\\ne)\n  可以在这些运算符前面加上`\\not` ，如`\\not\\lt` : ![\\not\\lt`](https://math.jianshu.com/math?formula=\\not\\lt`)\n\n### 集合关系与运算\n\n  并集(`\\cup` ): ![\\cup](https://math.jianshu.com/math?formula=\\cup)\n  交集(`\\cap` ): ![\\cap](https://math.jianshu.com/math?formula=\\cap)\n  差集(`\\setminus` ): ![\\setminus](https://math.jianshu.com/math?formula=\\setminus)\n  子集(`\\subset` ): ![\\subset](https://math.jianshu.com/math?formula=\\subset)\n  子集(`\\subseteq` ): ![\\subseteq](https://math.jianshu.com/math?formula=\\subseteq)\n  非子集(`\\subsetneq` ): ![\\subsetneq](https://math.jianshu.com/math?formula=\\subsetneq)\n  父集(`\\supset` ): ![\\supset](https://math.jianshu.com/math?formula=\\supset)\n  属于(`\\in` ): ![\\in](https://math.jianshu.com/math?formula=\\in)\n  不属于(`\\notin` ): ![\\notin](https://math.jianshu.com/math?formula=\\notin)\n  空集(`\\emptyset` ): ![\\emptyset](https://math.jianshu.com/math?formula=\\emptyset)\n  空(`\\varnothing` ): ![\\varnothing](https://math.jianshu.com/math?formula=\\varnothing)\n\n### 排列\n\n  `\\binom{n+1}{2k}` : ![\\binom{n+1}{2k}](https://math.jianshu.com/math?formula=\\binom{n%2B1}{2k})\n  `{n+1 \\choose 2k}` : ![{n+1 \\choose 2k}](https://math.jianshu.com/math?formula={n%2B1 \\choose 2k})\n\n### 箭头\n\n  (`\\to` ):![\\to](https://math.jianshu.com/math?formula=\\to)\n  (`\\rightarrow` ): ![\\rightarrow](https://math.jianshu.com/math?formula=\\rightarrow)\n  (`\\leftarrow` ): ![\\leftarrow](https://math.jianshu.com/math?formula=\\leftarrow)\n  (`\\Rightarrow` ): ![\\Rightarrow](https://math.jianshu.com/math?formula=\\Rightarrow)\n  (`\\Leftarrow` ): ![\\Leftarrow](https://math.jianshu.com/math?formula=\\Leftarrow)\n  (`\\mapsto` ): ![\\mapsto](https://math.jianshu.com/math?formula=\\mapsto)\n\n### 逻辑运算符\n\n  (`\\land` ): ![\\land](https://math.jianshu.com/math?formula=\\land)\n  (`\\lor` ): ![\\lor](https://math.jianshu.com/math?formula=\\lor)\n  (`\\lnot` ): ![\\lnot](https://math.jianshu.com/math?formula=\\lnot)\n  (`\\forall` ): ![\\forall](https://math.jianshu.com/math?formula=\\forall)\n  (`\\exists` ): ![\\exists](https://math.jianshu.com/math?formula=\\exists)\n  (`\\top` ): ![\\top](https://math.jianshu.com/math?formula=\\top)\n  (`\\bot` ): ![\\bot](https://math.jianshu.com/math?formula=\\bot)\n  (`\\vdash` ): ![\\vdash](https://math.jianshu.com/math?formula=\\vdash)\n  (`\\vDash` ): ![\\vDash](https://math.jianshu.com/math?formula=\\vDash)\n\n### 操作符\n\n  (`\\star` ): ![\\star](https://math.jianshu.com/math?formula=\\star)\n  (`\\ast` ): ![\\ast](https://math.jianshu.com/math?formula=\\ast)\n  (`\\oplus` ): ![\\oplus](https://math.jianshu.com/math?formula=\\oplus)\n  (`\\circ` ): ![\\circ](https://math.jianshu.com/math?formula=\\circ)\n  (`\\bullet` ): ![\\bullet](https://math.jianshu.com/math?formula=\\bullet)\n\n### 等于\n\n  (`\\approx` ): ![\\approx](https://math.jianshu.com/math?formula=\\approx)\n  (`\\sim` ): ![\\sim](https://math.jianshu.com/math?formula=\\sim)\n  (`\\equiv` ): ![\\equiv](https://math.jianshu.com/math?formula=\\equiv)\n  (`\\prec` ): ![\\prec](https://math.jianshu.com/math?formula=\\prec)\n\n### 范围\n\n  (`\\infty` ): ![\\infty](https://math.jianshu.com/math?formula=\\infty)\n  (`\\aleph_o` ): ![\\aleph_o](https://math.jianshu.com/math?formula=\\aleph_o)\n  (`\\nabla` ): ![\\nabla](https://math.jianshu.com/math?formula=\\nabla)\n  (`\\Im` ): ![\\Im](https://math.jianshu.com/math?formula=\\Im)\n  (`\\Re` ): ![\\Re](https://math.jianshu.com/math?formula=\\Re)\n\n### 模运算\n\n  (`\\pmod` ): ![b \\pmod n](https://math.jianshu.com/math?formula=b \\pmod n)\n  如`a \\equiv b \\pmod n` : ![a \\equiv b \\pmod n](https://math.jianshu.com/math?formula=a \\equiv b \\pmod n)\n\n### 点\n\n  (`\\ldots` ): ![\\ldots](https://math.jianshu.com/math?formula=\\ldots)\n  (`\\cdots` ): ![\\cdots](https://math.jianshu.com/math?formula=\\cdots)\n  (`\\cdot` ): ![\\cdot](https://math.jianshu.com/math?formula=\\cdot)\n  其区别是点的位置不同，`\\ldots` 位置稍低，`\\cdots` 位置居中。\n\n\n\n```ruby\n$$\n\\begin{equation}\na_1+a_2+\\ldots+a_n \\\\ \na_1+a_2+\\cdots+a_n\n\\end{equation}\n$$\n```\n\n  表示：\n![\\begin{equation} a_1+a_2+\\ldots+a_n \\\\ a_1+a_2+\\cdots+a_n \\end{equation}](https://math.jianshu.com/math?formula=\\begin{equation} a_1%2Ba_2%2B\\ldots%2Ba_n \\\\ a_1%2Ba_2%2B\\cdots%2Ba_n \\end{equation})\n\n## **顶部符号**\n\n  对于单字符，`\\hat x` ：![\\hat x](https://math.jianshu.com/math?formula=\\hat x)\n  多字符可以使用`\\widehat {xy}` ：![\\widehat {xy}](https://math.jianshu.com/math?formula=\\widehat {xy})\n  类似的还有:\n  (`\\overline x` ): ![\\overline x](https://math.jianshu.com/math?formula=\\overline x)\n  矢量(`\\vec` ): ![\\vec x](https://math.jianshu.com/math?formula=\\vec x)\n  向量(`\\overrightarrow {xy}` ): ![\\overrightarrow {xy}](https://math.jianshu.com/math?formula=\\overrightarrow {xy})\n  (`\\dot x` ): ![\\dot x](https://math.jianshu.com/math?formula=\\dot x)\n  (`\\ddot x` ): ![\\ddot x](https://math.jianshu.com/math?formula=\\ddot x)\n  (`\\dot {\\dot x}` ): ![\\dot {\\dot x}](https://math.jianshu.com/math?formula=\\dot {\\dot x})\n\n## **表格**\n\n  使用`\\begin{array}{列样式}…\\end{array}` 这样的形式来创建表格，列样式可以是`clr` 表示居中，左，右对齐，还可以使用`|` 表示一条竖线。表格中各行使用`\\\\` 分隔，各列使用`&` 分隔。使用`\\hline` 在本行前加入一条直线。 例如:\n\n\n\n```ruby\n$$\n\\begin{array}{c|lcr}\nn & \\text{Left} & \\text{Center} & \\text{Right} \\\\\n\\hline\n1 & 0.24 & 1 & 125 \\\\\n2 & -1 & 189 & -8 \\\\\n3 & -20 & 2000 & 1+10i \\\\\n\\end{array}\n$$\n```\n\n  得到：\n![\\begin{array}{c|lcr} n & \\text{Left} & \\text{Center} & \\text{Right} \\\\ \\hline 1 & 0.24 & 1 & 125 \\\\ 2 & -1 & 189 & -8 \\\\ 3 & -20 & 2000 & 1+10i \\\\ \\end{array}](https://math.jianshu.com/math?formula=\\begin{array}{c|lcr} n %26 \\text{Left} %26 \\text{Center} %26 \\text{Right} \\\\ \\hline 1 %26 0.24 %26 1 %26 125 \\\\ 2 %26 -1 %26 189 %26 -8 \\\\ 3 %26 -20 %26 2000 %26 1%2B10i \\\\ \\end{array})\n\n## **矩阵**\n\n### 基本内容\n\n  使用`\\begin{matrix}…\\end{matrix}` 这样的形式来表示矩阵，在`\\begin` 与`\\end` 之间加入矩阵中的元素即可。矩阵的行之间使用`\\\\` 分隔，列之间使用`&` 分隔，例如:\n\n\n\n```ruby\n$$\n\\begin{matrix}\n1 & x & x^2 \\\\\n1 & y & y^2 \\\\\n1 & z & z^2 \\\\\n\\end{matrix}\n$$\n```\n\n  得到：\n![\\begin{matrix} 1 & x & x^2 \\\\ 1 & y & y^2 \\\\ 1 & z & z^2 \\\\ \\end{matrix}](https://math.jianshu.com/math?formula=\\begin{matrix} 1 %26 x %26 x^2 \\\\ 1 %26 y %26 y^2 \\\\ 1 %26 z %26 z^2 \\\\ \\end{matrix})\n\n### 括号\n\n  如果要对矩阵加括号，可以像上文中提到的一样，使用`\\left` 与`\\right` 配合表示括号符号。也可以使用特殊的`matrix` 。即替换`\\begin{matrix}…\\end{matrix}` 中`matrix` 为`pmatrix` ，`bmatrix` ，`Bmatrix` ，`vmatrix` , `Vmatrix` 。\n\n1. pmatrix`$\\begin{pmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{pmatrix}$` : ![\\begin{pmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{pmatrix}](https://math.jianshu.com/math?formula=\\begin{pmatrix}1 %26 2 \\\\ 3 %26 4\\\\ \\end{pmatrix})\n2. bmatrix`$\\begin{bmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{bmatrix}$` : ![\\begin{bmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{bmatrix}](https://math.jianshu.com/math?formula=\\begin{bmatrix}1 %26 2 \\\\ 3 %26 4\\\\ \\end{bmatrix})\n3. Bmatrix`$\\begin{Bmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{Bmatrix}$` : ![\\begin{Bmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{Bmatrix}](https://math.jianshu.com/math?formula=\\begin{Bmatrix}1 %26 2 \\\\ 3 %26 4\\\\ \\end{Bmatrix})\n4. vmatrix`$\\begin{vmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{vmatrix}$` : ![\\begin{vmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{vmatrix}](https://math.jianshu.com/math?formula=\\begin{vmatrix}1 %26 2 \\\\ 3 %26 4\\\\ \\end{vmatrix})\n5. Vmatrix`$\\begin{Vmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{Vmatrix}$` : ![\\begin{Vmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{Vmatrix}](https://math.jianshu.com/math?formula=\\begin{Vmatrix}1 %26 2 \\\\ 3 %26 4\\\\ \\end{Vmatrix})\n\n### 元素省略\n\n  可以使用`\\cdots` ：⋯，`\\ddots`：⋱ ，`\\vdots`：⋮ 来省略矩阵中的元素，如：\n\n\n\n```ruby\n$$\n\\begin{pmatrix}\n1&a_1&a_1^2&\\cdots&a_1^n\\\\\n1&a_2&a_2^2&\\cdots&a_2^n\\\\\n\\vdots&\\vdots&\\vdots&\\ddots&\\vdots\\\\\n1&a_m&a_m^2&\\cdots&a_m^n\\\\\n\\end{pmatrix}\n$$\n```\n\n  表示：\n![\\begin{pmatrix} 1&a_1&a_1^2&\\cdots&a_1^n\\\\ 1&a_2&a_2^2&\\cdots&a_2^n\\\\ \\vdots&\\vdots&\\vdots&\\ddots&\\vdots\\\\ 1&a_m&a_m^2&\\cdots&a_m^n\\\\ \\end{pmatrix}](https://math.jianshu.com/math?formula=\\begin{pmatrix} 1%26a_1%26a_1^2%26\\cdots%26a_1^n\\\\ 1%26a_2%26a_2^2%26\\cdots%26a_2^n\\\\ \\vdots%26\\vdots%26\\vdots%26\\ddots%26\\vdots\\\\ 1%26a_m%26a_m^2%26\\cdots%26a_m^n\\\\ \\end{pmatrix})\n\n### 增广矩阵\n\n  增广矩阵需要使用前面的表格中使用到的`\\begin{array} ... \\end{array}` 来实现。\n\n\n\n```swift\n$$\n\\left[  \\begin{array}  {c c | c} %这里的c表示数组中元素对其方式：c居中、r右对齐、l左对齐，竖线表示2、3列间插入竖线\n1 & 2 & 3 \\\\\n\\hline %插入横线，如果去掉\\hline就是增广矩阵\n4 & 5 & 6\n\\end{array}  \\right]\n$$\n```\n\n显示为：\n![\\left[ \\begin{array} {c c | c} 1 & 2 & 3 \\\\ \\hline 4 & 5 & 6 \\end{array} \\right]](https://math.jianshu.com/math?formula=\\left[ \\begin{array} {c c | c} 1 %26 2 %26 3 \\\\ \\hline 4 %26 5 %26 6 \\end{array} \\right])\n\n## **公式标记与引用**\n\n  使用`\\tag{yourtag}` 来标记公式，如果想在之后引用该公式，则还需要加上`\\label{yourlabel}` 在`\\tag` 之后，如`$$a = x^2 - y^3 \\tag{1}\\label{1}$$` 显示为：\n![a := x^2 - y^3 \\tag{1}\\label{311}](https://math.jianshu.com/math?formula=a %3A%3D x^2 - y^3 \\tag{1}\\label{311})\n  如果不需要被引用，只使用`\\tag{yourtag}` ，`$$x+y=z\\tag{1.1}$$`显示为：\n![x+y=z\\tag{1.1}](https://math.jianshu.com/math?formula=x%2By%3Dz\\tag{1.1})\n  `\\tab{yourtab}` 中的内容用于显示公式后面的标记。公式之间通过`\\label{}` 设置的内容来引用。为了引用公式，可以使用`\\eqref{yourlabel}` ，如`$$a + y^3 \\stackrel{\\eqref{1}}= x^2$$` 显示为：\n![a + y^3 \\stackrel{\\eqref{1}}= x^2](https://math.jianshu.com/math?formula=a %2B y^3 \\stackrel{\\eqref{1}}%3D x^2)\n\n或者使用`\\ref{yourlabel}` 不带括号引用，如`$$a + y^3 \\stackrel{\\ref{111}}= x^2$$` 显示为:\n![a + y^3 \\stackrel{\\ref{1}}= x^2](https://math.jianshu.com/math?formula=a %2B y^3 \\stackrel{\\ref{1}}%3D x^2)\n\n## **字体**\n\n### 黑板粗体字\n\n此字体经常用来表示代表实数、整数、有理数、复数的大写字母。\n`$\\mathbb ABCDEF$`：![\\mathbb ABCDEF](https://math.jianshu.com/math?formula=\\mathbb ABCDEF)\n`$\\Bbb ABCDEF$`：![\\Bbb ABCDEF](https://math.jianshu.com/math?formula=\\Bbb ABCDEF)\n\n### 黑体字\n\n`$\\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ$` :![\\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ](https://math.jianshu.com/math?formula=\\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ)\n`$\\mathbf abcdefghijklmnopqrstuvwxyz$` :![\\mathbf abcdefghijklmnopqrstuvwxyz](https://math.jianshu.com/math?formula=\\mathbf abcdefghijklmnopqrstuvwxyz)\n\n### 打印机字体\n\n`$\\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ$` :![\\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ](https://math.jianshu.com/math?formula=\\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ)\n\n## **参考文档**\n\n| #    | 链接地址                                          | 文档名称                                                     |\n| ---- | ------------------------------------------------- | ------------------------------------------------------------ |\n| 1    | `blog.csdn.net/dabokele/article/details/79577072` | [Mathjax公式教程](https://blog.csdn.net/dabokele/article/details/79577072) |\n| 2    | `blog.csdn.net/ethmery/article/details/50670297`  | [基本数学公式语法](https://blog.csdn.net/ethmery/article/details/50670297) |\n| 3    | `blog.csdn.net/lilongsy/article/details/79378620` | [常用数学符号的LaTeX表示方法](https://blog.csdn.net/lilongsy/article/details/79378620) |\n| 4    | `www.mathjax.org`                                 | [Beautiful math in all browsers](https://www.mathjax.org/)   |\n\n","slug":"Tools/Markdown 公式","published":1,"date":"2021-01-29T15:54:28.321Z","updated":"2021-01-29T16:05:06.644Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8fe0021sz5q1h8lfa8c","content":"<h1 id=\"Markdown中公式编辑教程\"><a href=\"#Markdown中公式编辑教程\" class=\"headerlink\" title=\"Markdown中公式编辑教程\"></a>Markdown中公式编辑教程</h1><h1 id=\"markdown中公式编辑教程\"><a href=\"#markdown中公式编辑教程\" class=\"headerlink\" title=\"markdown中公式编辑教程\"></a>markdown中公式编辑教程</h1><p>标签： Mathjax 公式编辑 markdown</p>\n<p>一般公式分为两种形式，行内公式和行间公式。</p>\n<ul>\n<li>行内公式：<img src=\"https://math.jianshu.com/math?formula=\\Gamma(z\" alt=\"\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.\"> %3D \\int_0^\\infty t^{z-1}e^{-t}dt\\%2C.)</li>\n<li>行间公式：<img src=\"https://math.jianshu.com/math?formula=\\Gamma(z\" alt=\"\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.\"> %3D \\int_0^\\infty t^{z-1}e^{-t}dt\\%2C.)<a id=\"more\"></a>\n  对应的代码块为：</li>\n</ul>\n<pre class=\" language-ruby\"><code class=\"language-ruby\">$ \\<span class=\"token function\">Gamma</span><span class=\"token punctuation\">(</span>z<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> \\int_0<span class=\"token operator\">^</span>\\infty t<span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>z<span class=\"token number\">-1</span><span class=\"token punctuation\">}</span>e<span class=\"token operator\">^</span><span class=\"token punctuation\">{</span><span class=\"token operator\">-</span>t<span class=\"token punctuation\">}</span>dt\\<span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span> $\n$$\\<span class=\"token function\">Gamma</span><span class=\"token punctuation\">(</span>z<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> \\int_0<span class=\"token operator\">^</span>\\infty t<span class=\"token operator\">^</span><span class=\"token punctuation\">{</span>z<span class=\"token number\">-1</span><span class=\"token punctuation\">}</span>e<span class=\"token operator\">^</span><span class=\"token punctuation\">{</span><span class=\"token operator\">-</span>t<span class=\"token punctuation\">}</span>dt\\<span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span>$$\n</code></pre>\n<p>  行内公式是在公式代码块的基础上前面加上<strong>$</strong> ，后面加上<strong>$</strong> 组成的，而行间公式则是在公式代码块前后使用<strong>$$</strong> 和<strong>$$</strong> 。<br>  下面主要介绍数学公式中常用的一些符号。</p>\n<h2 id=\"希腊字母\"><a href=\"#希腊字母\" class=\"headerlink\" title=\"希腊字母\"></a><strong>希腊字母</strong></h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">大写</th>\n<th style=\"text-align:center\">code</th>\n<th style=\"text-align:center\">小写</th>\n<th style=\"text-align:center\">code</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">alpha</td>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">α</td>\n<td style=\"text-align:center\">\\alpha</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">beta</td>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\">β</td>\n<td style=\"text-align:center\">\\beta</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">gamma</td>\n<td style=\"text-align:center\">Γ</td>\n<td style=\"text-align:center\">\\Gamma</td>\n<td style=\"text-align:center\">γ</td>\n<td style=\"text-align:center\">\\gamma</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">delta</td>\n<td style=\"text-align:center\">Δ</td>\n<td style=\"text-align:center\">\\Delta</td>\n<td style=\"text-align:center\">δ</td>\n<td style=\"text-align:center\">\\delta</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">epsilon</td>\n<td style=\"text-align:center\">E</td>\n<td style=\"text-align:center\">E</td>\n<td style=\"text-align:center\">ϵ</td>\n<td style=\"text-align:center\">\\epsilon</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">zeta</td>\n<td style=\"text-align:center\">Z</td>\n<td style=\"text-align:center\">Z</td>\n<td style=\"text-align:center\">ζ</td>\n<td style=\"text-align:center\">\\zeta</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">eta</td>\n<td style=\"text-align:center\">H</td>\n<td style=\"text-align:center\">H</td>\n<td style=\"text-align:center\">η</td>\n<td style=\"text-align:center\">\\eta</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">theta</td>\n<td style=\"text-align:center\">Θ</td>\n<td style=\"text-align:center\">\\Theta</td>\n<td style=\"text-align:center\">θ</td>\n<td style=\"text-align:center\">\\theta</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">iota</td>\n<td style=\"text-align:center\">I</td>\n<td style=\"text-align:center\">I</td>\n<td style=\"text-align:center\">ι</td>\n<td style=\"text-align:center\">\\iota</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">kappa</td>\n<td style=\"text-align:center\">K</td>\n<td style=\"text-align:center\">K</td>\n<td style=\"text-align:center\">κ</td>\n<td style=\"text-align:center\">\\kappa</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">lambda</td>\n<td style=\"text-align:center\">Λ</td>\n<td style=\"text-align:center\">\\Lambda</td>\n<td style=\"text-align:center\">λ</td>\n<td style=\"text-align:center\">\\lambda</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">mu</td>\n<td style=\"text-align:center\">M</td>\n<td style=\"text-align:center\">M</td>\n<td style=\"text-align:center\">μ</td>\n<td style=\"text-align:center\">\\mu</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">nu</td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">ν</td>\n<td style=\"text-align:center\">\\nu</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">xi</td>\n<td style=\"text-align:center\">Ξ</td>\n<td style=\"text-align:center\">\\Xi</td>\n<td style=\"text-align:center\">ξ</td>\n<td style=\"text-align:center\">\\xi</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">omicron</td>\n<td style=\"text-align:center\">O</td>\n<td style=\"text-align:center\">O</td>\n<td style=\"text-align:center\">ο</td>\n<td style=\"text-align:center\">\\omicron</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">pi</td>\n<td style=\"text-align:center\">Π</td>\n<td style=\"text-align:center\">\\Pi</td>\n<td style=\"text-align:center\">π</td>\n<td style=\"text-align:center\">\\pi</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">rho</td>\n<td style=\"text-align:center\">P</td>\n<td style=\"text-align:center\">P</td>\n<td style=\"text-align:center\">ρ</td>\n<td style=\"text-align:center\">\\rho</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sigma</td>\n<td style=\"text-align:center\">Σ</td>\n<td style=\"text-align:center\">\\Sigma</td>\n<td style=\"text-align:center\">σ</td>\n<td style=\"text-align:center\">\\sigma</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tau</td>\n<td style=\"text-align:center\">T</td>\n<td style=\"text-align:center\">T</td>\n<td style=\"text-align:center\">τ</td>\n<td style=\"text-align:center\">\\tau</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">upsilon</td>\n<td style=\"text-align:center\">Υ</td>\n<td style=\"text-align:center\">υ</td>\n<td style=\"text-align:center\">\\upsilon</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">phi</td>\n<td style=\"text-align:center\">Φ</td>\n<td style=\"text-align:center\">\\Phi</td>\n<td style=\"text-align:center\">ϕ</td>\n<td style=\"text-align:center\">\\phi</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chi</td>\n<td style=\"text-align:center\">X</td>\n<td style=\"text-align:center\">X</td>\n<td style=\"text-align:center\">χ</td>\n<td style=\"text-align:center\">\\chi</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">psi</td>\n<td style=\"text-align:center\">Ψ</td>\n<td style=\"text-align:center\">\\Psi</td>\n<td style=\"text-align:center\">ψ</td>\n<td style=\"text-align:center\">\\psi</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">omega</td>\n<td style=\"text-align:center\">Ω</td>\n<td style=\"text-align:center\">\\Omega</td>\n<td style=\"text-align:center\">ω</td>\n<td style=\"text-align:center\">\\omega</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"上标与下标\"><a href=\"#上标与下标\" class=\"headerlink\" title=\"上标与下标\"></a><strong>上标与下标</strong></h2><p>  上标和下标分别使用<code>^</code> 与<code>_</code> ，例如<code>$x_i^2$</code>表示的是：<img src=\"https://math.jianshu.com/math?formula=x_i^2\" alt=\"x_i^2\">。<br>  默认情况下，上、下标符号仅仅对下一个组起作用。一个组即单个字符或者使用<code>{..}</code> 包裹起来的内容。如果使用<code>$10^10$</code> 表示的是<img src=\"https://math.jianshu.com/math?formula=10^10\" alt=\"10^10\">，而<code>$10^{10}$</code> 才是<img src=\"https://math.jianshu.com/math?formula=10^{10}\" alt=\"10^{10}\">。同时，大括号还能消除二义性，如<code>x^5^6</code> 将得到一个错误，必须使用大括号来界定^的结合性，如<code>${x^5}^6$</code> ：<img src=\"https://math.jianshu.com/math?formula={x^5}^6\" alt=\"{x^5}^6\">或者<code>$x^{5^6}$</code> ：<img src=\"https://math.jianshu.com/math?formula=x^{5^6}\" alt=\"x^{5^6}\">。</p>\n<h2 id=\"括号\"><a href=\"#括号\" class=\"headerlink\" title=\"括号\"></a><strong>括号</strong></h2><h3 id=\"小括号与方括号\"><a href=\"#小括号与方括号\" class=\"headerlink\" title=\"小括号与方括号\"></a>小括号与方括号</h3><p>  使用原始的<code>( )</code> ，<code>[ ]</code> 即可，如<code>$(2+3)[4+4]$</code> ：<img src=\"https://math.jianshu.com/math?formula=(2%2B3\" alt=\"(2+3)\">) <img src=\"https://math.jianshu.com/math?formula=[4%2B4]\" alt=\"[4+4]\"><br>  使用\\left(或\\right)使符号大小与邻近的公式相适应（该语句适用于所有括号类型），如<code>$\\left(\\frac{x}{y}\\right)$</code> ：<img src=\"https://math.jianshu.com/math?formula=\\left(\\frac{x}{y}\\right\" alt=\"\\left(\\frac{x}{y}\\right)\">)</p>\n<h3 id=\"大括号\"><a href=\"#大括号\" class=\"headerlink\" title=\"大括号\"></a>大括号</h3><p>  由于大括号<code>{}</code> 被用于分组，因此需要使用<code>\\{</code>和<code>\\}</code>表示大括号，也可以使用<code>\\lbrace</code> 和<code>\\rbrace</code>来表示。如<code>$\\{a\\*b\\}:a\\∗b$</code> 或<code>$\\lbrace a\\*b\\rbrace :a\\*b$</code> 表示<img src=\"https://math.jianshu.com/math?formula=\\{a*b\\}%3Aa∗b\" alt=\"\\{a*b\\}:a∗b\">。</p>\n<h3 id=\"尖括号\"><a href=\"#尖括号\" class=\"headerlink\" title=\"尖括号\"></a>尖括号</h3><p>  区分于小于号和大于号，使用<code>\\langle</code> 和<code>\\rangle</code> 表示左尖括号和右尖括号。如<code>$\\langle x \\rangle$</code> 表示：<img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/math\" alt=\"\\langle x \\rangle\">。</p>\n<h3 id=\"上取整\"><a href=\"#上取整\" class=\"headerlink\" title=\"上取整\"></a>上取整</h3><p>  使用<code>\\lceil</code> 和 <code>\\rceil</code> 表示。 如，<code>$\\lceil x \\rceil$</code>：<img src=\"https://math.jianshu.com/math?formula=\\lceil x \\rceil\" alt=\"\\lceil x \\rceil\">。</p>\n<h3 id=\"下取整\"><a href=\"#下取整\" class=\"headerlink\" title=\"下取整\"></a>下取整</h3><p>  使用<code>\\lfloor</code> 和 <code>\\rfloor</code> 表示。如，<code>$\\lfloor x \\rfloor$</code>：<img src=\"https://math.jianshu.com/math?formula=\\lfloor x \\rfloor\" alt=\"\\lfloor x \\rfloor\">。</p>\n<h2 id=\"求和与积分\"><a href=\"#求和与积分\" class=\"headerlink\" title=\"求和与积分\"></a><strong>求和与积分</strong></h2><h3 id=\"求和\"><a href=\"#求和\" class=\"headerlink\" title=\"求和\"></a>求和</h3><p>  <code>\\sum</code> 用来表示求和符号，其下标表示求和下限，上标表示上限。如:<br>  <code>$\\sum_{r=1}^n$</code>表示：<img src=\"https://math.jianshu.com/math?formula=\\sum_{r%3D1}^n\" alt=\"\\sum_{r=1}^n\">。<br>  <code>$$\\sum_{r=1}^n$$</code>表示：<img src=\"https://math.jianshu.com/math?formula=%5Csum_%7Br%3D1%7D%5En\" alt=\"\\sum_{r=1}^n\"></p>\n<h3 id=\"积分\"><a href=\"#积分\" class=\"headerlink\" title=\"积分\"></a>积分</h3><p>  <code>\\int</code> 用来表示积分符号，同样地，其上下标表示积分的上下限。如，<code>$\\int_{r=1}^\\infty$</code>：<img src=\"https://math.jianshu.com/math?formula=\\int_{r%3D1}^\\infty\" alt=\"\\int_{r=1}^\\infty\">。<br>  多重积分同样使用 <strong>int</strong> ，通过 <strong>i</strong> 的数量表示积分导数：<br>  <code>$\\iint$</code> ：<img src=\"https://math.jianshu.com/math?formula=\\iint\" alt=\"\\iint\"><br>  <code>$\\iiint$</code> ：<img src=\"https://math.jianshu.com/math?formula=\\iiint\" alt=\"\\iiint\"><br>  <code>$\\iiiint$</code> ：<img src=\"https://math.jianshu.com/math?formula=\\iiiint\" alt=\"\\iiiint\"></p>\n<h3 id=\"连乘\"><a href=\"#连乘\" class=\"headerlink\" title=\"连乘\"></a>连乘</h3><p>  <code>$\\prod {a+b}$</code>，输出：<img src=\"https://math.jianshu.com/math?formula=\\prod {a%2Bb}\" alt=\"\\prod {a+b}\">。<br>  <code>$\\prod_{i=1}^{K}$</code>，输出：<img src=\"https://math.jianshu.com/math?formula=\\prod_{i%3D1}^{K}\" alt=\"\\prod_{i=1}^{K}\">。<br>  <code>$$\\prod_{i=1}^{K}$$</code>，输出：<img src=\"https://math.jianshu.com/math?formula=%5Cprod_%7Bi%3D1%7D%5E%7BK%7D\" alt=\"\\prod_{i=1}^{K}\">。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>  与此类似的符号还有，<br>  <code>$\\prod$</code> ：<img src=\"https://math.jianshu.com/math?formula=\\prod\" alt=\"\\prod\"><br>  <code>$\\bigcup$</code> ：<img src=\"https://math.jianshu.com/math?formula=\\bigcup\" alt=\"\\bigcup\"><br>  <code>$\\bigcap$</code> ：<img src=\"https://math.jianshu.com/math?formula=\\bigcap\" alt=\"\\bigcap\"><br>  <code>$arg\\,\\max_{c_k}$</code>：<img src=\"https://math.jianshu.com/math?formula=arg\\%2C\\max_{c_k}\" alt=\"arg\\,\\max_{c_k}\"><br>  <code>$arg\\,\\min_{c_k}$</code>：<img src=\"https://math.jianshu.com/math?formula=arg\\%2C\\min_{c_k}\" alt=\"arg\\,\\min_{c_k}\"><br>  <code>$\\mathop {argmin}_{c_k}$</code>：<img src=\"https://math.jianshu.com/math?formula=\\mathop {argmin}_{c_k}\" alt=\"\\mathop {argmin}_{c_k}\"><br>  <code>$\\mathop {argmax}_{c_k}$</code>：<img src=\"https://math.jianshu.com/math?formula=\\mathop {argmax}_{c_k}\" alt=\"\\mathop {argmax}_{c_k}\"><br>  <code>$\\max_{c_k}$</code>：<img src=\"https://math.jianshu.com/math?formula=\\max_{c_k}\" alt=\"\\max_{c_k}\"><br>  <code>$\\min_{c_k}$</code>：<img src=\"https://math.jianshu.com/math?formula=\\min_{c_k}\" alt=\"\\min_{c_k}\"></p>\n<h2 id=\"分式与根式\"><a href=\"#分式与根式\" class=\"headerlink\" title=\"分式与根式\"></a><strong>分式与根式</strong></h2><h3 id=\"分式\"><a href=\"#分式\" class=\"headerlink\" title=\"分式\"></a>分式</h3><ul>\n<li>第一种，使用<code>\\frac ab</code>，<code>\\frac</code>作用于其后的两个组<code>a</code> ，<code>b</code> ，结果为<img src=\"https://math.jianshu.com/math?formula=\\frac ab\" alt=\"\\frac ab\">。如果你的分子或分母不是单个字符，请使用<code>{..}</code>来分组，比如<code>$\\frac {a+c+1}{b+c+2}$</code>表示<img src=\"https://math.jianshu.com/math?formula=\\frac {a%2Bc%2B1}{b%2Bc%2B2}\" alt=\"\\frac {a+c+1}{b+c+2}\">。</li>\n<li>第二种，使用<code>\\over</code>来分隔一个组的前后两部分，如<code>{a+1\\over b+1}</code>：<img src=\"https://math.jianshu.com/math?formula={a%2B1\\over b%2B1}\" alt=\"{a+1\\over b+1}\"></li>\n</ul>\n<h3 id=\"连分数\"><a href=\"#连分数\" class=\"headerlink\" title=\"连分数\"></a>连分数</h3><p>  书写连分数表达式时，请使用<code>\\cfrac</code>代替<code>\\frac</code>或者<code>\\over</code>两者效果对比如下：<br>  <code>\\frac</code> 表示如下：</p>\n<pre class=\" language-ruby\"><code class=\"language-ruby\"><span class=\"token variable\">$$x</span><span class=\"token operator\">=</span>a_0 <span class=\"token operator\">+</span> \\frac <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token operator\">^</span><span class=\"token number\">2</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">{</span>a_1 <span class=\"token operator\">+</span> \\frac <span class=\"token punctuation\">{</span><span class=\"token number\">2</span><span class=\"token operator\">^</span><span class=\"token number\">2</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">{</span>a_2 <span class=\"token operator\">+</span> \\frac <span class=\"token punctuation\">{</span><span class=\"token number\">3</span><span class=\"token operator\">^</span><span class=\"token number\">2</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">{</span>a_3 <span class=\"token operator\">+</span> \\frac <span class=\"token punctuation\">{</span><span class=\"token number\">4</span><span class=\"token operator\">^</span><span class=\"token number\">2</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">{</span>a_4 <span class=\"token operator\">+</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>$$\n</code></pre>\n<p>  显示如下：<br><img src=\"https://math.jianshu.com/math?formula=x%3Da_0 %2B \\frac {1^2}{a_1 %2B \\frac {2^2}{a_2 %2B \\frac {3^2}{a_3 %2B \\frac {4^2}{a_4 %2B ...}}}}\" alt=\"x=a_0 + \\frac {1^2}{a_1 + \\frac {2^2}{a_2 + \\frac {3^2}{a_3 + \\frac {4^2}{a_4 + ...}}}}\"><br>  <code>\\cfrac</code> 表示如下：</p>\n<pre class=\" language-ruby\"><code class=\"language-ruby\"><span class=\"token variable\">$$x</span><span class=\"token operator\">=</span>a_0 <span class=\"token operator\">+</span> \\cfrac <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token operator\">^</span><span class=\"token number\">2</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">{</span>a_1 <span class=\"token operator\">+</span> \\cfrac <span class=\"token punctuation\">{</span><span class=\"token number\">2</span><span class=\"token operator\">^</span><span class=\"token number\">2</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">{</span>a_2 <span class=\"token operator\">+</span> \\cfrac <span class=\"token punctuation\">{</span><span class=\"token number\">3</span><span class=\"token operator\">^</span><span class=\"token number\">2</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">{</span>a_3 <span class=\"token operator\">+</span> \\cfrac <span class=\"token punctuation\">{</span><span class=\"token number\">4</span><span class=\"token operator\">^</span><span class=\"token number\">2</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">{</span>a_4 <span class=\"token operator\">+</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>$$\n</code></pre>\n<p>  显示如下：<br><img src=\"https://math.jianshu.com/math?formula=x%3Da_0 %2B \\cfrac {1^2}{a_1 %2B \\cfrac {2^2}{a_2 %2B \\cfrac {3^2}{a_3 %2B \\cfrac {4^2}{a_4 %2B ...}}}}\" alt=\"x=a_0 + \\cfrac {1^2}{a_1 + \\cfrac {2^2}{a_2 + \\cfrac {3^2}{a_3 + \\cfrac {4^2}{a_4 + ...}}}}\"></p>\n<h3 id=\"根式\"><a href=\"#根式\" class=\"headerlink\" title=\"根式\"></a>根式</h3><p>  根式使用<code>\\sqrt</code> 来表示。<br>  如开4次方：<code>$\\sqrt[4]{\\frac xy}$</code> ：<img src=\"https://math.jianshu.com/math?formula=\\sqrt[4]{\\frac xy}\" alt=\"\\sqrt[4]{\\frac xy}\">。<br>  开平方：<code>$\\sqrt {a+b}$</code>：<img src=\"https://math.jianshu.com/math?formula=\\sqrt {a%2Bb}\" alt=\"\\sqrt {a+b}\">。</p>\n<h2 id=\"多行表达式\"><a href=\"#多行表达式\" class=\"headerlink\" title=\"多行表达式\"></a><strong>多行表达式</strong></h2><h3 id=\"分类表达式\"><a href=\"#分类表达式\" class=\"headerlink\" title=\"分类表达式\"></a>分类表达式</h3><p>  定义函数的时候经常需要分情况给出表达式，使用<code>\\begin{cases}…\\end{cases}</code> 。其中：</p>\n<ul>\n<li>  使用<code>\\\\</code> 来分类，</li>\n<li>  使用<code>&amp;</code> 指示需要对齐的位置，</li>\n<li>  使用<code>\\</code> +<code>空格</code>表示空格。</li>\n</ul>\n<pre class=\" language-ruby\"><code class=\"language-ruby\">$$\n<span class=\"token function\">f</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span>\n\\<span class=\"token keyword\">begin</span><span class=\"token punctuation\">{</span>cases<span class=\"token punctuation\">}</span>\n\\cfrac n2<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">if</span>\\ n\\ is\\ even\\\\\n3n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">if</span>\\  n\\ is\\ odd\n\\<span class=\"token keyword\">end</span><span class=\"token punctuation\">{</span>cases<span class=\"token punctuation\">}</span>\n$$\n</code></pre>\n<p>  表示:<br><img src=\"https://math.jianshu.com/math?formula=f(n\" alt=\"f(n) \\begin{cases} \\cfrac n2, &amp;if\\ n\\ is\\ even\\\\ 3n + 1, &amp;if\\ n\\ is\\ odd \\end{cases}\"> \\begin{cases} \\cfrac n2%2C %26if\\ n\\ is\\ even\\ 3n %2B 1%2C %26if\\ n\\ is\\ odd \\end{cases})</p>\n<pre class=\" language-ruby\"><code class=\"language-ruby\">$$\n<span class=\"token function\">L</span><span class=\"token punctuation\">(</span><span class=\"token constant\">Y</span><span class=\"token punctuation\">,</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token constant\">X</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span>\n\\<span class=\"token keyword\">begin</span><span class=\"token punctuation\">{</span>cases<span class=\"token punctuation\">}</span>\n<span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span> \\text<span class=\"token punctuation\">{</span><span class=\"token constant\">Y</span> <span class=\"token operator\">=</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token constant\">X</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>  \\\\\n<span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span> \\text<span class=\"token punctuation\">{</span><span class=\"token constant\">Y</span> $\\neq$ <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token constant\">X</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n\\<span class=\"token keyword\">end</span><span class=\"token punctuation\">{</span>cases<span class=\"token punctuation\">}</span>\n$$\n</code></pre>\n<p>  表示:<br><img src=\"https://math.jianshu.com/math?formula=L(Y%2Cf(X\" alt=\"L(Y,f(X)) = \\begin{cases} 0, &amp; \\text{Y = f(X)} \\\\ 1, &amp; \\text{Y $\\neq$ f(X)} \\end{cases}\">)%20%3D%20%5Cbegin%7Bcases%7D%200%2C%20%26%20%5Ctext%7BY%20%3D%20f(X)%7D%20%5C%5C%201%2C%20%26%20%5Ctext%7BY%20%24%5Cneq%24%20f(X)%7D%20%5Cend%7Bcases%7D)<br>  如果想分类之间的垂直间隔变大，可以使用<code>\\\\[2ex]</code> 代替<code>\\\\</code> 来分隔不同的情况。(<code>3ex,4ex</code> 也可以用，<code>1ex</code> 相当于原始距离）。如下所示：</p>\n<pre class=\" language-ruby\"><code class=\"language-ruby\">$$\n<span class=\"token function\">L</span><span class=\"token punctuation\">(</span><span class=\"token constant\">Y</span><span class=\"token punctuation\">,</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token constant\">X</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span>\n\\<span class=\"token keyword\">begin</span><span class=\"token punctuation\">{</span>cases<span class=\"token punctuation\">}</span>\n<span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span> \\text<span class=\"token punctuation\">{</span><span class=\"token constant\">Y</span> <span class=\"token operator\">=</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token constant\">X</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span> \\\\<span class=\"token punctuation\">[</span>5ex<span class=\"token punctuation\">]</span>\n<span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span> \\text<span class=\"token punctuation\">{</span><span class=\"token constant\">Y</span> $\\neq$ <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token constant\">X</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n\\<span class=\"token keyword\">end</span><span class=\"token punctuation\">{</span>cases<span class=\"token punctuation\">}</span>\n$$\n</code></pre>\n<p>  表示：<br><img src=\"https://math.jianshu.com/math?formula=L(Y%2Cf(X\" alt=\"L(Y,f(X)) = \\begin{cases} 0, &amp; \\text{Y = f(X)} \\\\[5ex] 1, &amp; \\text{Y $\\neq$ f(X)} \\end{cases}\">)%20%3D%20%5Cbegin%7Bcases%7D%200%2C%20%26%20%5Ctext%7BY%20%3D%20f(X)%7D%20%5C%5C%5B5ex%5D%201%2C%20%26%20%5Ctext%7BY%20%24%5Cneq%24%20f(X)%7D%20%5Cend%7Bcases%7D)</p>\n<h3 id=\"多行表达式-1\"><a href=\"#多行表达式-1\" class=\"headerlink\" title=\"多行表达式\"></a>多行表达式</h3><p>  有时候需要将一行公式分多行进行显示。</p>\n<pre class=\" language-ruby\"><code class=\"language-ruby\">$$\n\\<span class=\"token keyword\">begin</span><span class=\"token punctuation\">{</span>equation<span class=\"token punctuation\">}</span>\\<span class=\"token keyword\">begin</span><span class=\"token punctuation\">{</span>split<span class=\"token punctuation\">}</span> \na<span class=\"token operator\">&amp;</span><span class=\"token operator\">=</span>b<span class=\"token operator\">+</span>c<span class=\"token operator\">-</span>d \\\\ \n<span class=\"token operator\">&amp;</span>\\quad <span class=\"token operator\">+</span>e<span class=\"token operator\">-</span>f\\\\ \n<span class=\"token operator\">&amp;</span><span class=\"token operator\">=</span>g<span class=\"token operator\">+</span>h\\\\ \n<span class=\"token operator\">&amp;</span> <span class=\"token operator\">=</span>i \n\\<span class=\"token keyword\">end</span><span class=\"token punctuation\">{</span>split<span class=\"token punctuation\">}</span>\\<span class=\"token keyword\">end</span><span class=\"token punctuation\">{</span>equation<span class=\"token punctuation\">}</span>\n$$\n</code></pre>\n<p>  表示：<br><img src=\"https://math.jianshu.com/math?formula=\\begin{equation}\\begin{split} a%26%3Db%2Bc-d \\\\ %26\\quad %2Be-f\\\\ %26%3Dg%2Bh\\\\ %26 %3Di \\end{split}\\end{equation}\" alt=\"\\begin{equation}\\begin{split} a&amp;=b+c-d \\\\ &amp;\\quad +e-f\\\\ &amp;=g+h\\\\ &amp; =i \\end{split}\\end{equation}\"><br>  其中<code>begin{equation}</code> 表示开始方程，<code>end{equation}</code> 表示方程结束；<code>begin{split}</code> 表示开始多行公式，<code>end{split}</code> 表示结束；公式中用<code>\\\\</code> 表示回车到下一行，<code>&amp;</code> 表示对齐的位置。</p>\n<h3 id=\"方程组\"><a href=\"#方程组\" class=\"headerlink\" title=\"方程组\"></a>方程组</h3><p>  使用<code>\\begin{array}...\\end{array}</code> 与<code>\\left \\{</code> 与<code>\\right.</code> 配合表示方程组:</p>\n<pre class=\" language-ruby\"><code class=\"language-ruby\">$$\n\\left \\<span class=\"token punctuation\">{</span> \n\\<span class=\"token keyword\">begin</span><span class=\"token punctuation\">{</span>array<span class=\"token punctuation\">}</span><span class=\"token punctuation\">{</span>c<span class=\"token punctuation\">}</span>\na_1x<span class=\"token operator\">+</span>b_1y<span class=\"token operator\">+</span>c_1z<span class=\"token operator\">=</span>d_1 \\\\ \na_2x<span class=\"token operator\">+</span>b_2y<span class=\"token operator\">+</span>c_2z<span class=\"token operator\">=</span>d_2 \\\\ \na_3x<span class=\"token operator\">+</span>b_3y<span class=\"token operator\">+</span>c_3z<span class=\"token operator\">=</span>d_3\n\\<span class=\"token keyword\">end</span><span class=\"token punctuation\">{</span>array<span class=\"token punctuation\">}</span>\n\\right<span class=\"token punctuation\">.</span>\n$$\n</code></pre>\n<p>  表示：<br><img src=\"https://math.jianshu.com/math?formula=\\left \\{ \\begin{array}{c} a_1x%2Bb_1y%2Bc_1z%3Dd_1 \\\\ a_2x%2Bb_2y%2Bc_2z%3Dd_2 \\\\ a_3x%2Bb_3y%2Bc_3z%3Dd_3 \\end{array} \\right.\" alt=\"\\left \\{ \\begin{array}{c} a_1x+b_1y+c_1z=d_1 \\\\ a_2x+b_2y+c_2z=d_2 \\\\ a_3x+b_3y+c_3z=d_3 \\end{array} \\right.\"><br>  注意：通常MathJax通过内部策略自己管理公式内部的空间，因此<code>a…b</code> 与<code>a…….b</code> （<code>.</code>表示空格）都会显示为<code>ab</code> 。可以通过在<code>ab</code> 间加入<code>\\</code> ,增加些许间隙，<code>\\;</code> 增加较宽的间隙，<code>\\quad</code> 与<code>\\qquad</code> 会增加更大的间隙。</p>\n<h2 id=\"特殊函数与符号\"><a href=\"#特殊函数与符号\" class=\"headerlink\" title=\"特殊函数与符号\"></a><strong>特殊函数与符号</strong></h2><h3 id=\"三角函数\"><a href=\"#三角函数\" class=\"headerlink\" title=\"三角函数\"></a>三角函数</h3><p>  <code>\\snx$</code> : <img src=\"https://math.jianshu.com/math?formula=sinx\" alt=\"sinx\"><br>  <code>\\arctanx</code> : <img src=\"https://math.jianshu.com/math?formula=arctanx\" alt=\"arctanx\"></p>\n<h3 id=\"比较运算符\"><a href=\"#比较运算符\" class=\"headerlink\" title=\"比较运算符\"></a>比较运算符</h3><p>  小于(<code>\\lt</code> )：<img src=\"https://math.jianshu.com/math?formula=\\lt\" alt=\"\\lt\"><br>  大于(<code>\\gt</code> )：<img src=\"https://math.jianshu.com/math?formula=\\gt\" alt=\"\\gt\"><br>  小于等于(<code>\\le</code> )：<img src=\"https://math.jianshu.com/math?formula=\\le\" alt=\"\\le\"><br>  大于等于(<code>\\ge</code> )：<img src=\"https://math.jianshu.com/math?formula=\\ge\" alt=\"\\ge\"><br>  不等于(<code>\\ne</code> ) : <img src=\"https://math.jianshu.com/math?formula=\\ne\" alt=\"\\ne\"><br>  可以在这些运算符前面加上<code>\\not</code> ，如<code>\\not\\lt</code> : <img src=\"https://math.jianshu.com/math?formula=\\not\\lt`\" alt=\"\\not\\lt`\"></p>\n<h3 id=\"集合关系与运算\"><a href=\"#集合关系与运算\" class=\"headerlink\" title=\"集合关系与运算\"></a>集合关系与运算</h3><p>  并集(<code>\\cup</code> ): <img src=\"https://math.jianshu.com/math?formula=\\cup\" alt=\"\\cup\"><br>  交集(<code>\\cap</code> ): <img src=\"https://math.jianshu.com/math?formula=\\cap\" alt=\"\\cap\"><br>  差集(<code>\\setminus</code> ): <img src=\"https://math.jianshu.com/math?formula=\\setminus\" alt=\"\\setminus\"><br>  子集(<code>\\subset</code> ): <img src=\"https://math.jianshu.com/math?formula=\\subset\" alt=\"\\subset\"><br>  子集(<code>\\subseteq</code> ): <img src=\"https://math.jianshu.com/math?formula=\\subseteq\" alt=\"\\subseteq\"><br>  非子集(<code>\\subsetneq</code> ): <img src=\"https://math.jianshu.com/math?formula=\\subsetneq\" alt=\"\\subsetneq\"><br>  父集(<code>\\supset</code> ): <img src=\"https://math.jianshu.com/math?formula=\\supset\" alt=\"\\supset\"><br>  属于(<code>\\in</code> ): <img src=\"https://math.jianshu.com/math?formula=\\in\" alt=\"\\in\"><br>  不属于(<code>\\notin</code> ): <img src=\"https://math.jianshu.com/math?formula=\\notin\" alt=\"\\notin\"><br>  空集(<code>\\emptyset</code> ): <img src=\"https://math.jianshu.com/math?formula=\\emptyset\" alt=\"\\emptyset\"><br>  空(<code>\\varnothing</code> ): <img src=\"https://math.jianshu.com/math?formula=\\varnothing\" alt=\"\\varnothing\"></p>\n<h3 id=\"排列\"><a href=\"#排列\" class=\"headerlink\" title=\"排列\"></a>排列</h3><p>  <code>\\binom{n+1}{2k}</code> : <img src=\"https://math.jianshu.com/math?formula=\\binom{n%2B1}{2k}\" alt=\"\\binom{n+1}{2k}\"><br>  <code>{n+1 \\choose 2k}</code> : <img src=\"https://math.jianshu.com/math?formula={n%2B1 \\choose 2k}\" alt=\"{n+1 \\choose 2k}\"></p>\n<h3 id=\"箭头\"><a href=\"#箭头\" class=\"headerlink\" title=\"箭头\"></a>箭头</h3><p>  (<code>\\to</code> ):<img src=\"https://math.jianshu.com/math?formula=\\to\" alt=\"\\to\"><br>  (<code>\\rightarrow</code> ): <img src=\"https://math.jianshu.com/math?formula=\\rightarrow\" alt=\"\\rightarrow\"><br>  (<code>\\leftarrow</code> ): <img src=\"https://math.jianshu.com/math?formula=\\leftarrow\" alt=\"\\leftarrow\"><br>  (<code>\\Rightarrow</code> ): <img src=\"https://math.jianshu.com/math?formula=\\Rightarrow\" alt=\"\\Rightarrow\"><br>  (<code>\\Leftarrow</code> ): <img src=\"https://math.jianshu.com/math?formula=\\Leftarrow\" alt=\"\\Leftarrow\"><br>  (<code>\\mapsto</code> ): <img src=\"https://math.jianshu.com/math?formula=\\mapsto\" alt=\"\\mapsto\"></p>\n<h3 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h3><p>  (<code>\\land</code> ): <img src=\"https://math.jianshu.com/math?formula=\\land\" alt=\"\\land\"><br>  (<code>\\lor</code> ): <img src=\"https://math.jianshu.com/math?formula=\\lor\" alt=\"\\lor\"><br>  (<code>\\lnot</code> ): <img src=\"https://math.jianshu.com/math?formula=\\lnot\" alt=\"\\lnot\"><br>  (<code>\\forall</code> ): <img src=\"https://math.jianshu.com/math?formula=\\forall\" alt=\"\\forall\"><br>  (<code>\\exists</code> ): <img src=\"https://math.jianshu.com/math?formula=\\exists\" alt=\"\\exists\"><br>  (<code>\\top</code> ): <img src=\"https://math.jianshu.com/math?formula=\\top\" alt=\"\\top\"><br>  (<code>\\bot</code> ): <img src=\"https://math.jianshu.com/math?formula=\\bot\" alt=\"\\bot\"><br>  (<code>\\vdash</code> ): <img src=\"https://math.jianshu.com/math?formula=\\vdash\" alt=\"\\vdash\"><br>  (<code>\\vDash</code> ): <img src=\"https://math.jianshu.com/math?formula=\\vDash\" alt=\"\\vDash\"></p>\n<h3 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h3><p>  (<code>\\star</code> ): <img src=\"https://math.jianshu.com/math?formula=\\star\" alt=\"\\star\"><br>  (<code>\\ast</code> ): <img src=\"https://math.jianshu.com/math?formula=\\ast\" alt=\"\\ast\"><br>  (<code>\\oplus</code> ): <img src=\"https://math.jianshu.com/math?formula=\\oplus\" alt=\"\\oplus\"><br>  (<code>\\circ</code> ): <img src=\"https://math.jianshu.com/math?formula=\\circ\" alt=\"\\circ\"><br>  (<code>\\bullet</code> ): <img src=\"https://math.jianshu.com/math?formula=\\bullet\" alt=\"\\bullet\"></p>\n<h3 id=\"等于\"><a href=\"#等于\" class=\"headerlink\" title=\"等于\"></a>等于</h3><p>  (<code>\\approx</code> ): <img src=\"https://math.jianshu.com/math?formula=\\approx\" alt=\"\\approx\"><br>  (<code>\\sim</code> ): <img src=\"https://math.jianshu.com/math?formula=\\sim\" alt=\"\\sim\"><br>  (<code>\\equiv</code> ): <img src=\"https://math.jianshu.com/math?formula=\\equiv\" alt=\"\\equiv\"><br>  (<code>\\prec</code> ): <img src=\"https://math.jianshu.com/math?formula=\\prec\" alt=\"\\prec\"></p>\n<h3 id=\"范围\"><a href=\"#范围\" class=\"headerlink\" title=\"范围\"></a>范围</h3><p>  (<code>\\infty</code> ): <img src=\"https://math.jianshu.com/math?formula=\\infty\" alt=\"\\infty\"><br>  (<code>\\aleph_o</code> ): <img src=\"https://math.jianshu.com/math?formula=\\aleph_o\" alt=\"\\aleph_o\"><br>  (<code>\\nabla</code> ): <img src=\"https://math.jianshu.com/math?formula=\\nabla\" alt=\"\\nabla\"><br>  (<code>\\Im</code> ): <img src=\"https://math.jianshu.com/math?formula=\\Im\" alt=\"\\Im\"><br>  (<code>\\Re</code> ): <img src=\"https://math.jianshu.com/math?formula=\\Re\" alt=\"\\Re\"></p>\n<h3 id=\"模运算\"><a href=\"#模运算\" class=\"headerlink\" title=\"模运算\"></a>模运算</h3><p>  (<code>\\pmod</code> ): <img src=\"https://math.jianshu.com/math?formula=b \\pmod n\" alt=\"b \\pmod n\"><br>  如<code>a \\equiv b \\pmod n</code> : <img src=\"https://math.jianshu.com/math?formula=a \\equiv b \\pmod n\" alt=\"a \\equiv b \\pmod n\"></p>\n<h3 id=\"点\"><a href=\"#点\" class=\"headerlink\" title=\"点\"></a>点</h3><p>  (<code>\\ldots</code> ): <img src=\"https://math.jianshu.com/math?formula=\\ldots\" alt=\"\\ldots\"><br>  (<code>\\cdots</code> ): <img src=\"https://math.jianshu.com/math?formula=\\cdots\" alt=\"\\cdots\"><br>  (<code>\\cdot</code> ): <img src=\"https://math.jianshu.com/math?formula=\\cdot\" alt=\"\\cdot\"><br>  其区别是点的位置不同，<code>\\ldots</code> 位置稍低，<code>\\cdots</code> 位置居中。</p>\n<pre class=\" language-ruby\"><code class=\"language-ruby\">$$\n\\<span class=\"token keyword\">begin</span><span class=\"token punctuation\">{</span>equation<span class=\"token punctuation\">}</span>\na_1<span class=\"token operator\">+</span>a_2<span class=\"token operator\">+</span>\\ldots<span class=\"token operator\">+</span>a_n \\\\ \na_1<span class=\"token operator\">+</span>a_2<span class=\"token operator\">+</span>\\cdots<span class=\"token operator\">+</span>a_n\n\\<span class=\"token keyword\">end</span><span class=\"token punctuation\">{</span>equation<span class=\"token punctuation\">}</span>\n$$\n</code></pre>\n<p>  表示：<br><img src=\"https://math.jianshu.com/math?formula=\\begin{equation} a_1%2Ba_2%2B\\ldots%2Ba_n \\\\ a_1%2Ba_2%2B\\cdots%2Ba_n \\end{equation}\" alt=\"\\begin{equation} a_1+a_2+\\ldots+a_n \\\\ a_1+a_2+\\cdots+a_n \\end{equation}\"></p>\n<h2 id=\"顶部符号\"><a href=\"#顶部符号\" class=\"headerlink\" title=\"顶部符号\"></a><strong>顶部符号</strong></h2><p>  对于单字符，<code>\\hat x</code> ：<img src=\"https://math.jianshu.com/math?formula=\\hat x\" alt=\"\\hat x\"><br>  多字符可以使用<code>\\widehat {xy}</code> ：<img src=\"https://math.jianshu.com/math?formula=\\widehat {xy}\" alt=\"\\widehat {xy}\"><br>  类似的还有:<br>  (<code>\\overline x</code> ): <img src=\"https://math.jianshu.com/math?formula=\\overline x\" alt=\"\\overline x\"><br>  矢量(<code>\\vec</code> ): <img src=\"https://math.jianshu.com/math?formula=\\vec x\" alt=\"\\vec x\"><br>  向量(<code>\\overrightarrow {xy}</code> ): <img src=\"https://math.jianshu.com/math?formula=\\overrightarrow {xy}\" alt=\"\\overrightarrow {xy}\"><br>  (<code>\\dot x</code> ): <img src=\"https://math.jianshu.com/math?formula=\\dot x\" alt=\"\\dot x\"><br>  (<code>\\ddot x</code> ): <img src=\"https://math.jianshu.com/math?formula=\\ddot x\" alt=\"\\ddot x\"><br>  (<code>\\dot {\\dot x}</code> ): <img src=\"https://math.jianshu.com/math?formula=\\dot {\\dot x}\" alt=\"\\dot {\\dot x}\"></p>\n<h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a><strong>表格</strong></h2><p>  使用<code>\\begin{array}{列样式}…\\end{array}</code> 这样的形式来创建表格，列样式可以是<code>clr</code> 表示居中，左，右对齐，还可以使用<code>|</code> 表示一条竖线。表格中各行使用<code>\\\\</code> 分隔，各列使用<code>&amp;</code> 分隔。使用<code>\\hline</code> 在本行前加入一条直线。 例如:</p>\n<pre class=\" language-ruby\"><code class=\"language-ruby\">$$\n\\<span class=\"token keyword\">begin</span><span class=\"token punctuation\">{</span>array<span class=\"token punctuation\">}</span><span class=\"token punctuation\">{</span>c<span class=\"token operator\">|</span>lcr<span class=\"token punctuation\">}</span>\nn <span class=\"token operator\">&amp;</span> \\text<span class=\"token punctuation\">{</span><span class=\"token constant\">Left</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">&amp;</span> \\text<span class=\"token punctuation\">{</span><span class=\"token constant\">Center</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">&amp;</span> \\text<span class=\"token punctuation\">{</span><span class=\"token constant\">Right</span><span class=\"token punctuation\">}</span> \\\\\n\\hline\n<span class=\"token number\">1</span> <span class=\"token operator\">&amp;</span> <span class=\"token number\">0.24</span> <span class=\"token operator\">&amp;</span> <span class=\"token number\">1</span> <span class=\"token operator\">&amp;</span> <span class=\"token number\">125</span> \\\\\n<span class=\"token number\">2</span> <span class=\"token operator\">&amp;</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">&amp;</span> <span class=\"token number\">189</span> <span class=\"token operator\">&amp;</span> <span class=\"token operator\">-</span><span class=\"token number\">8</span> \\\\\n<span class=\"token number\">3</span> <span class=\"token operator\">&amp;</span> <span class=\"token operator\">-</span><span class=\"token number\">20</span> <span class=\"token operator\">&amp;</span> <span class=\"token number\">2000</span> <span class=\"token operator\">&amp;</span> <span class=\"token number\">1</span><span class=\"token operator\">+</span>10i \\\\\n\\<span class=\"token keyword\">end</span><span class=\"token punctuation\">{</span>array<span class=\"token punctuation\">}</span>\n$$\n</code></pre>\n<p>  得到：<br><img src=\"https://math.jianshu.com/math?formula=\\begin{array}{c|lcr} n %26 \\text{Left} %26 \\text{Center} %26 \\text{Right} \\\\ \\hline 1 %26 0.24 %26 1 %26 125 \\\\ 2 %26 -1 %26 189 %26 -8 \\\\ 3 %26 -20 %26 2000 %26 1%2B10i \\\\ \\end{array}\" alt=\"\\begin{array}{c|lcr} n &amp; \\text{Left} &amp; \\text{Center} &amp; \\text{Right} \\\\ \\hline 1 &amp; 0.24 &amp; 1 &amp; 125 \\\\ 2 &amp; -1 &amp; 189 &amp; -8 \\\\ 3 &amp; -20 &amp; 2000 &amp; 1+10i \\\\ \\end{array}\"></p>\n<h2 id=\"矩阵\"><a href=\"#矩阵\" class=\"headerlink\" title=\"矩阵\"></a><strong>矩阵</strong></h2><h3 id=\"基本内容\"><a href=\"#基本内容\" class=\"headerlink\" title=\"基本内容\"></a>基本内容</h3><p>  使用<code>\\begin{matrix}…\\end{matrix}</code> 这样的形式来表示矩阵，在<code>\\begin</code> 与<code>\\end</code> 之间加入矩阵中的元素即可。矩阵的行之间使用<code>\\\\</code> 分隔，列之间使用<code>&amp;</code> 分隔，例如:</p>\n<pre class=\" language-ruby\"><code class=\"language-ruby\">$$\n\\<span class=\"token keyword\">begin</span><span class=\"token punctuation\">{</span>matrix<span class=\"token punctuation\">}</span>\n<span class=\"token number\">1</span> <span class=\"token operator\">&amp;</span> x <span class=\"token operator\">&amp;</span> x<span class=\"token operator\">^</span><span class=\"token number\">2</span> \\\\\n<span class=\"token number\">1</span> <span class=\"token operator\">&amp;</span> y <span class=\"token operator\">&amp;</span> y<span class=\"token operator\">^</span><span class=\"token number\">2</span> \\\\\n<span class=\"token number\">1</span> <span class=\"token operator\">&amp;</span> z <span class=\"token operator\">&amp;</span> z<span class=\"token operator\">^</span><span class=\"token number\">2</span> \\\\\n\\<span class=\"token keyword\">end</span><span class=\"token punctuation\">{</span>matrix<span class=\"token punctuation\">}</span>\n$$\n</code></pre>\n<p>  得到：<br><img src=\"https://math.jianshu.com/math?formula=\\begin{matrix} 1 %26 x %26 x^2 \\\\ 1 %26 y %26 y^2 \\\\ 1 %26 z %26 z^2 \\\\ \\end{matrix}\" alt=\"\\begin{matrix} 1 &amp; x &amp; x^2 \\\\ 1 &amp; y &amp; y^2 \\\\ 1 &amp; z &amp; z^2 \\\\ \\end{matrix}\"></p>\n<h3 id=\"括号-1\"><a href=\"#括号-1\" class=\"headerlink\" title=\"括号\"></a>括号</h3><p>  如果要对矩阵加括号，可以像上文中提到的一样，使用<code>\\left</code> 与<code>\\right</code> 配合表示括号符号。也可以使用特殊的<code>matrix</code> 。即替换<code>\\begin{matrix}…\\end{matrix}</code> 中<code>matrix</code> 为<code>pmatrix</code> ，<code>bmatrix</code> ，<code>Bmatrix</code> ，<code>vmatrix</code> , <code>Vmatrix</code> 。</p>\n<ol>\n<li>pmatrix<code>$\\begin{pmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{pmatrix}$</code> : <img src=\"https://math.jianshu.com/math?formula=\\begin{pmatrix}1 %26 2 \\\\ 3 %26 4\\\\ \\end{pmatrix}\" alt=\"\\begin{pmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{pmatrix}\"></li>\n<li>bmatrix<code>$\\begin{bmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{bmatrix}$</code> : <img src=\"https://math.jianshu.com/math?formula=\\begin{bmatrix}1 %26 2 \\\\ 3 %26 4\\\\ \\end{bmatrix}\" alt=\"\\begin{bmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{bmatrix}\"></li>\n<li>Bmatrix<code>$\\begin{Bmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{Bmatrix}$</code> : <img src=\"https://math.jianshu.com/math?formula=\\begin{Bmatrix}1 %26 2 \\\\ 3 %26 4\\\\ \\end{Bmatrix}\" alt=\"\\begin{Bmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{Bmatrix}\"></li>\n<li>vmatrix<code>$\\begin{vmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{vmatrix}$</code> : <img src=\"https://math.jianshu.com/math?formula=\\begin{vmatrix}1 %26 2 \\\\ 3 %26 4\\\\ \\end{vmatrix}\" alt=\"\\begin{vmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{vmatrix}\"></li>\n<li>Vmatrix<code>$\\begin{Vmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{Vmatrix}$</code> : <img src=\"https://math.jianshu.com/math?formula=\\begin{Vmatrix}1 %26 2 \\\\ 3 %26 4\\\\ \\end{Vmatrix}\" alt=\"\\begin{Vmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{Vmatrix}\"></li>\n</ol>\n<h3 id=\"元素省略\"><a href=\"#元素省略\" class=\"headerlink\" title=\"元素省略\"></a>元素省略</h3><p>  可以使用<code>\\cdots</code> ：⋯，<code>\\ddots</code>：⋱ ，<code>\\vdots</code>：⋮ 来省略矩阵中的元素，如：</p>\n<pre class=\" language-ruby\"><code class=\"language-ruby\">$$\n\\<span class=\"token keyword\">begin</span><span class=\"token punctuation\">{</span>pmatrix<span class=\"token punctuation\">}</span>\n<span class=\"token number\">1</span><span class=\"token operator\">&amp;</span>a_1<span class=\"token operator\">&amp;</span>a_1<span class=\"token operator\">^</span><span class=\"token number\">2</span><span class=\"token operator\">&amp;</span>\\cdots<span class=\"token operator\">&amp;</span>a_1<span class=\"token operator\">^</span>n\\\\\n<span class=\"token number\">1</span><span class=\"token operator\">&amp;</span>a_2<span class=\"token operator\">&amp;</span>a_2<span class=\"token operator\">^</span><span class=\"token number\">2</span><span class=\"token operator\">&amp;</span>\\cdots<span class=\"token operator\">&amp;</span>a_2<span class=\"token operator\">^</span>n\\\\\n\\vdots<span class=\"token operator\">&amp;</span>\\vdots<span class=\"token operator\">&amp;</span>\\vdots<span class=\"token operator\">&amp;</span>\\ddots<span class=\"token operator\">&amp;</span>\\vdots\\\\\n<span class=\"token number\">1</span><span class=\"token operator\">&amp;</span>a_m<span class=\"token operator\">&amp;</span>a_m<span class=\"token operator\">^</span><span class=\"token number\">2</span><span class=\"token operator\">&amp;</span>\\cdots<span class=\"token operator\">&amp;</span>a_m<span class=\"token operator\">^</span>n\\\\\n\\<span class=\"token keyword\">end</span><span class=\"token punctuation\">{</span>pmatrix<span class=\"token punctuation\">}</span>\n$$\n</code></pre>\n<p>  表示：<br><img src=\"https://math.jianshu.com/math?formula=\\begin{pmatrix} 1%26a_1%26a_1^2%26\\cdots%26a_1^n\\\\ 1%26a_2%26a_2^2%26\\cdots%26a_2^n\\\\ \\vdots%26\\vdots%26\\vdots%26\\ddots%26\\vdots\\\\ 1%26a_m%26a_m^2%26\\cdots%26a_m^n\\\\ \\end{pmatrix}\" alt=\"\\begin{pmatrix} 1&amp;a_1&amp;a_1^2&amp;\\cdots&amp;a_1^n\\\\ 1&amp;a_2&amp;a_2^2&amp;\\cdots&amp;a_2^n\\\\ \\vdots&amp;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\ 1&amp;a_m&amp;a_m^2&amp;\\cdots&amp;a_m^n\\\\ \\end{pmatrix}\"></p>\n<h3 id=\"增广矩阵\"><a href=\"#增广矩阵\" class=\"headerlink\" title=\"增广矩阵\"></a>增广矩阵</h3><p>  增广矩阵需要使用前面的表格中使用到的<code>\\begin{array} ... \\end{array}</code> 来实现。</p>\n<pre class=\" language-swift\"><code class=\"language-swift\">$$\n\\<span class=\"token keyword\">left</span><span class=\"token punctuation\">[</span>  \\begin<span class=\"token punctuation\">{</span>array<span class=\"token punctuation\">}</span>  <span class=\"token punctuation\">{</span>c c <span class=\"token operator\">|</span> c<span class=\"token punctuation\">}</span> <span class=\"token operator\">%</span>这里的c表示数组中元素对其方式：c居中、r右对齐、l左对齐，竖线表示<span class=\"token number\">2</span>、<span class=\"token number\">3</span>列间插入竖线\n<span class=\"token number\">1</span> <span class=\"token operator\">&amp;</span> <span class=\"token number\">2</span> <span class=\"token operator\">&amp;</span> <span class=\"token number\">3</span> \\\\\n\\hline <span class=\"token operator\">%</span>插入横线，如果去掉\\hline就是增广矩阵\n<span class=\"token number\">4</span> <span class=\"token operator\">&amp;</span> <span class=\"token number\">5</span> <span class=\"token operator\">&amp;</span> <span class=\"token number\">6</span>\n\\end<span class=\"token punctuation\">{</span>array<span class=\"token punctuation\">}</span>  \\<span class=\"token keyword\">right</span><span class=\"token punctuation\">]</span>\n$$\n</code></pre>\n<p>显示为：<br><img src=\"https://math.jianshu.com/math?formula=\\left[ \\begin{array} {c c | c} 1 %26 2 %26 3 \\\\ \\hline 4 %26 5 %26 6 \\end{array} \\right]\" alt=\"\\left[ \\begin{array} {c c | c} 1 &amp; 2 &amp; 3 \\\\ \\hline 4 &amp; 5 &amp; 6 \\end{array} \\right]\"></p>\n<h2 id=\"公式标记与引用\"><a href=\"#公式标记与引用\" class=\"headerlink\" title=\"公式标记与引用\"></a><strong>公式标记与引用</strong></h2><p>  使用<code>\\tag{yourtag}</code> 来标记公式，如果想在之后引用该公式，则还需要加上<code>\\label{yourlabel}</code> 在<code>\\tag</code> 之后，如<code>$$a = x^2 - y^3 \\tag{1}\\label{1}$$</code> 显示为：<br><img src=\"https://math.jianshu.com/math?formula=a %3A%3D x^2 - y^3 \\tag{1}\\label{311}\" alt=\"a := x^2 - y^3 \\tag{1}\\label{311}\"><br>  如果不需要被引用，只使用<code>\\tag{yourtag}</code> ，<code>$$x+y=z\\tag{1.1}$$</code>显示为：<br><img src=\"https://math.jianshu.com/math?formula=x%2By%3Dz\\tag{1.1}\" alt=\"x+y=z\\tag{1.1}\"><br>  <code>\\tab{yourtab}</code> 中的内容用于显示公式后面的标记。公式之间通过<code>\\label{}</code> 设置的内容来引用。为了引用公式，可以使用<code>\\eqref{yourlabel}</code> ，如<code>$$a + y^3 \\stackrel{\\eqref{1}}= x^2$$</code> 显示为：<br><img src=\"https://math.jianshu.com/math?formula=a %2B y^3 \\stackrel{\\eqref{1}}%3D x^2\" alt=\"a + y^3 \\stackrel{\\eqref{1}}= x^2\"></p>\n<p>或者使用<code>\\ref{yourlabel}</code> 不带括号引用，如<code>$$a + y^3 \\stackrel{\\ref{111}}= x^2$$</code> 显示为:<br><img src=\"https://math.jianshu.com/math?formula=a %2B y^3 \\stackrel{\\ref{1}}%3D x^2\" alt=\"a + y^3 \\stackrel{\\ref{1}}= x^2\"></p>\n<h2 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a><strong>字体</strong></h2><h3 id=\"黑板粗体字\"><a href=\"#黑板粗体字\" class=\"headerlink\" title=\"黑板粗体字\"></a>黑板粗体字</h3><p>此字体经常用来表示代表实数、整数、有理数、复数的大写字母。<br><code>$\\mathbb ABCDEF$</code>：<img src=\"https://math.jianshu.com/math?formula=\\mathbb ABCDEF\" alt=\"\\mathbb ABCDEF\"><br><code>$\\Bbb ABCDEF$</code>：<img src=\"https://math.jianshu.com/math?formula=\\Bbb ABCDEF\" alt=\"\\Bbb ABCDEF\"></p>\n<h3 id=\"黑体字\"><a href=\"#黑体字\" class=\"headerlink\" title=\"黑体字\"></a>黑体字</h3><p><code>$\\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ$</code> :<img src=\"https://math.jianshu.com/math?formula=\\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ\" alt=\"\\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ\"><br><code>$\\mathbf abcdefghijklmnopqrstuvwxyz$</code> :<img src=\"https://math.jianshu.com/math?formula=\\mathbf abcdefghijklmnopqrstuvwxyz\" alt=\"\\mathbf abcdefghijklmnopqrstuvwxyz\"></p>\n<h3 id=\"打印机字体\"><a href=\"#打印机字体\" class=\"headerlink\" title=\"打印机字体\"></a>打印机字体</h3><p><code>$\\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ$</code> :<img src=\"https://math.jianshu.com/math?formula=\\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ\" alt=\"\\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ\"></p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a><strong>参考文档</strong></h2><table>\n<thead>\n<tr>\n<th>#</th>\n<th>链接地址</th>\n<th>文档名称</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td><code>blog.csdn.net/dabokele/article/details/79577072</code></td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhYm9rZWxlL2FydGljbGUvZGV0YWlscy83OTU3NzA3Mg==\" title=\"https://blog.csdn.net/dabokele/article/details/79577072\">Mathjax公式教程<i class=\"fa fa-external-link\"></i></span></td>\n</tr>\n<tr>\n<td>2</td>\n<td><code>blog.csdn.net/ethmery/article/details/50670297</code></td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2V0aG1lcnkvYXJ0aWNsZS9kZXRhaWxzLzUwNjcwMjk3\" title=\"https://blog.csdn.net/ethmery/article/details/50670297\">基本数学公式语法<i class=\"fa fa-external-link\"></i></span></td>\n</tr>\n<tr>\n<td>3</td>\n<td><code>blog.csdn.net/lilongsy/article/details/79378620</code></td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbG9uZ3N5L2FydGljbGUvZGV0YWlscy83OTM3ODYyMA==\" title=\"https://blog.csdn.net/lilongsy/article/details/79378620\">常用数学符号的LaTeX表示方法<i class=\"fa fa-external-link\"></i></span></td>\n</tr>\n<tr>\n<td>4</td>\n<td><code>www.mathjax.org</code></td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWF0aGpheC5vcmcv\" title=\"https://www.mathjax.org/\">Beautiful math in all browsers<i class=\"fa fa-external-link\"></i></span></td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"<h1 id=\"Markdown中公式编辑教程\"><a href=\"#Markdown中公式编辑教程\" class=\"headerlink\" title=\"Markdown中公式编辑教程\"></a>Markdown中公式编辑教程</h1><h1 id=\"markdown中公式编辑教程\"><a href=\"#markdown中公式编辑教程\" class=\"headerlink\" title=\"markdown中公式编辑教程\"></a>markdown中公式编辑教程</h1><p>标签： Mathjax 公式编辑 markdown</p>\n<p>一般公式分为两种形式，行内公式和行间公式。</p>\n<ul>\n<li>行内公式：<img src=\"https://math.jianshu.com/math?formula=\\Gamma(z\" alt=\"\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.\"> %3D \\int_0^\\infty t^{z-1}e^{-t}dt\\%2C.)</li>\n<li>行间公式：<img src=\"https://math.jianshu.com/math?formula=\\Gamma(z\" alt=\"\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.\"> %3D \\int_0^\\infty t^{z-1}e^{-t}dt\\%2C.)","more":"对应的代码块为：</li>\n</ul>\n<pre><code class=\"ruby\">$ \\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,. $\n$$\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.$$\n</code></pre>\n<p>  行内公式是在公式代码块的基础上前面加上<strong>$</strong> ，后面加上<strong>$</strong> 组成的，而行间公式则是在公式代码块前后使用<strong>$$</strong> 和<strong>$$</strong> 。<br>  下面主要介绍数学公式中常用的一些符号。</p>\n<h2 id=\"希腊字母\"><a href=\"#希腊字母\" class=\"headerlink\" title=\"希腊字母\"></a><strong>希腊字母</strong></h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">大写</th>\n<th style=\"text-align:center\">code</th>\n<th style=\"text-align:center\">小写</th>\n<th style=\"text-align:center\">code</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">alpha</td>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">α</td>\n<td style=\"text-align:center\">\\alpha</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">beta</td>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\">β</td>\n<td style=\"text-align:center\">\\beta</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">gamma</td>\n<td style=\"text-align:center\">Γ</td>\n<td style=\"text-align:center\">\\Gamma</td>\n<td style=\"text-align:center\">γ</td>\n<td style=\"text-align:center\">\\gamma</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">delta</td>\n<td style=\"text-align:center\">Δ</td>\n<td style=\"text-align:center\">\\Delta</td>\n<td style=\"text-align:center\">δ</td>\n<td style=\"text-align:center\">\\delta</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">epsilon</td>\n<td style=\"text-align:center\">E</td>\n<td style=\"text-align:center\">E</td>\n<td style=\"text-align:center\">ϵ</td>\n<td style=\"text-align:center\">\\epsilon</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">zeta</td>\n<td style=\"text-align:center\">Z</td>\n<td style=\"text-align:center\">Z</td>\n<td style=\"text-align:center\">ζ</td>\n<td style=\"text-align:center\">\\zeta</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">eta</td>\n<td style=\"text-align:center\">H</td>\n<td style=\"text-align:center\">H</td>\n<td style=\"text-align:center\">η</td>\n<td style=\"text-align:center\">\\eta</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">theta</td>\n<td style=\"text-align:center\">Θ</td>\n<td style=\"text-align:center\">\\Theta</td>\n<td style=\"text-align:center\">θ</td>\n<td style=\"text-align:center\">\\theta</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">iota</td>\n<td style=\"text-align:center\">I</td>\n<td style=\"text-align:center\">I</td>\n<td style=\"text-align:center\">ι</td>\n<td style=\"text-align:center\">\\iota</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">kappa</td>\n<td style=\"text-align:center\">K</td>\n<td style=\"text-align:center\">K</td>\n<td style=\"text-align:center\">κ</td>\n<td style=\"text-align:center\">\\kappa</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">lambda</td>\n<td style=\"text-align:center\">Λ</td>\n<td style=\"text-align:center\">\\Lambda</td>\n<td style=\"text-align:center\">λ</td>\n<td style=\"text-align:center\">\\lambda</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">mu</td>\n<td style=\"text-align:center\">M</td>\n<td style=\"text-align:center\">M</td>\n<td style=\"text-align:center\">μ</td>\n<td style=\"text-align:center\">\\mu</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">nu</td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">ν</td>\n<td style=\"text-align:center\">\\nu</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">xi</td>\n<td style=\"text-align:center\">Ξ</td>\n<td style=\"text-align:center\">\\Xi</td>\n<td style=\"text-align:center\">ξ</td>\n<td style=\"text-align:center\">\\xi</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">omicron</td>\n<td style=\"text-align:center\">O</td>\n<td style=\"text-align:center\">O</td>\n<td style=\"text-align:center\">ο</td>\n<td style=\"text-align:center\">\\omicron</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">pi</td>\n<td style=\"text-align:center\">Π</td>\n<td style=\"text-align:center\">\\Pi</td>\n<td style=\"text-align:center\">π</td>\n<td style=\"text-align:center\">\\pi</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">rho</td>\n<td style=\"text-align:center\">P</td>\n<td style=\"text-align:center\">P</td>\n<td style=\"text-align:center\">ρ</td>\n<td style=\"text-align:center\">\\rho</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sigma</td>\n<td style=\"text-align:center\">Σ</td>\n<td style=\"text-align:center\">\\Sigma</td>\n<td style=\"text-align:center\">σ</td>\n<td style=\"text-align:center\">\\sigma</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">tau</td>\n<td style=\"text-align:center\">T</td>\n<td style=\"text-align:center\">T</td>\n<td style=\"text-align:center\">τ</td>\n<td style=\"text-align:center\">\\tau</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">upsilon</td>\n<td style=\"text-align:center\">Υ</td>\n<td style=\"text-align:center\">υ</td>\n<td style=\"text-align:center\">\\upsilon</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">phi</td>\n<td style=\"text-align:center\">Φ</td>\n<td style=\"text-align:center\">\\Phi</td>\n<td style=\"text-align:center\">ϕ</td>\n<td style=\"text-align:center\">\\phi</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chi</td>\n<td style=\"text-align:center\">X</td>\n<td style=\"text-align:center\">X</td>\n<td style=\"text-align:center\">χ</td>\n<td style=\"text-align:center\">\\chi</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">psi</td>\n<td style=\"text-align:center\">Ψ</td>\n<td style=\"text-align:center\">\\Psi</td>\n<td style=\"text-align:center\">ψ</td>\n<td style=\"text-align:center\">\\psi</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">omega</td>\n<td style=\"text-align:center\">Ω</td>\n<td style=\"text-align:center\">\\Omega</td>\n<td style=\"text-align:center\">ω</td>\n<td style=\"text-align:center\">\\omega</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"上标与下标\"><a href=\"#上标与下标\" class=\"headerlink\" title=\"上标与下标\"></a><strong>上标与下标</strong></h2><p>  上标和下标分别使用<code>^</code> 与<code>_</code> ，例如<code>$x_i^2$</code>表示的是：<img src=\"https://math.jianshu.com/math?formula=x_i^2\" alt=\"x_i^2\">。<br>  默认情况下，上、下标符号仅仅对下一个组起作用。一个组即单个字符或者使用<code>{..}</code> 包裹起来的内容。如果使用<code>$10^10$</code> 表示的是<img src=\"https://math.jianshu.com/math?formula=10^10\" alt=\"10^10\">，而<code>$10^{10}$</code> 才是<img src=\"https://math.jianshu.com/math?formula=10^{10}\" alt=\"10^{10}\">。同时，大括号还能消除二义性，如<code>x^5^6</code> 将得到一个错误，必须使用大括号来界定^的结合性，如<code>${x^5}^6$</code> ：<img src=\"https://math.jianshu.com/math?formula={x^5}^6\" alt=\"{x^5}^6\">或者<code>$x^{5^6}$</code> ：<img src=\"https://math.jianshu.com/math?formula=x^{5^6}\" alt=\"x^{5^6}\">。</p>\n<h2 id=\"括号\"><a href=\"#括号\" class=\"headerlink\" title=\"括号\"></a><strong>括号</strong></h2><h3 id=\"小括号与方括号\"><a href=\"#小括号与方括号\" class=\"headerlink\" title=\"小括号与方括号\"></a>小括号与方括号</h3><p>  使用原始的<code>( )</code> ，<code>[ ]</code> 即可，如<code>$(2+3)[4+4]$</code> ：<img src=\"https://math.jianshu.com/math?formula=(2%2B3\" alt=\"(2+3)\">) <img src=\"https://math.jianshu.com/math?formula=[4%2B4]\" alt=\"[4+4]\"><br>  使用\\left(或\\right)使符号大小与邻近的公式相适应（该语句适用于所有括号类型），如<code>$\\left(\\frac{x}{y}\\right)$</code> ：<img src=\"https://math.jianshu.com/math?formula=\\left(\\frac{x}{y}\\right\" alt=\"\\left(\\frac{x}{y}\\right)\">)</p>\n<h3 id=\"大括号\"><a href=\"#大括号\" class=\"headerlink\" title=\"大括号\"></a>大括号</h3><p>  由于大括号<code>{}</code> 被用于分组，因此需要使用<code>\\{</code>和<code>\\}</code>表示大括号，也可以使用<code>\\lbrace</code> 和<code>\\rbrace</code>来表示。如<code>$\\{a\\*b\\}:a\\∗b$</code> 或<code>$\\lbrace a\\*b\\rbrace :a\\*b$</code> 表示<img src=\"https://math.jianshu.com/math?formula=\\{a*b\\}%3Aa∗b\" alt=\"\\{a*b\\}:a∗b\">。</p>\n<h3 id=\"尖括号\"><a href=\"#尖括号\" class=\"headerlink\" title=\"尖括号\"></a>尖括号</h3><p>  区分于小于号和大于号，使用<code>\\langle</code> 和<code>\\rangle</code> 表示左尖括号和右尖括号。如<code>$\\langle x \\rangle$</code> 表示：<img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/math\" alt=\"\\langle x \\rangle\">。</p>\n<h3 id=\"上取整\"><a href=\"#上取整\" class=\"headerlink\" title=\"上取整\"></a>上取整</h3><p>  使用<code>\\lceil</code> 和 <code>\\rceil</code> 表示。 如，<code>$\\lceil x \\rceil$</code>：<img src=\"https://math.jianshu.com/math?formula=\\lceil x \\rceil\" alt=\"\\lceil x \\rceil\">。</p>\n<h3 id=\"下取整\"><a href=\"#下取整\" class=\"headerlink\" title=\"下取整\"></a>下取整</h3><p>  使用<code>\\lfloor</code> 和 <code>\\rfloor</code> 表示。如，<code>$\\lfloor x \\rfloor$</code>：<img src=\"https://math.jianshu.com/math?formula=\\lfloor x \\rfloor\" alt=\"\\lfloor x \\rfloor\">。</p>\n<h2 id=\"求和与积分\"><a href=\"#求和与积分\" class=\"headerlink\" title=\"求和与积分\"></a><strong>求和与积分</strong></h2><h3 id=\"求和\"><a href=\"#求和\" class=\"headerlink\" title=\"求和\"></a>求和</h3><p>  <code>\\sum</code> 用来表示求和符号，其下标表示求和下限，上标表示上限。如:<br>  <code>$\\sum_{r=1}^n$</code>表示：<img src=\"https://math.jianshu.com/math?formula=\\sum_{r%3D1}^n\" alt=\"\\sum_{r=1}^n\">。<br>  <code>$$\\sum_{r=1}^n$$</code>表示：<img src=\"https://math.jianshu.com/math?formula=%5Csum_%7Br%3D1%7D%5En\" alt=\"\\sum_{r=1}^n\"></p>\n<h3 id=\"积分\"><a href=\"#积分\" class=\"headerlink\" title=\"积分\"></a>积分</h3><p>  <code>\\int</code> 用来表示积分符号，同样地，其上下标表示积分的上下限。如，<code>$\\int_{r=1}^\\infty$</code>：<img src=\"https://math.jianshu.com/math?formula=\\int_{r%3D1}^\\infty\" alt=\"\\int_{r=1}^\\infty\">。<br>  多重积分同样使用 <strong>int</strong> ，通过 <strong>i</strong> 的数量表示积分导数：<br>  <code>$\\iint$</code> ：<img src=\"https://math.jianshu.com/math?formula=\\iint\" alt=\"\\iint\"><br>  <code>$\\iiint$</code> ：<img src=\"https://math.jianshu.com/math?formula=\\iiint\" alt=\"\\iiint\"><br>  <code>$\\iiiint$</code> ：<img src=\"https://math.jianshu.com/math?formula=\\iiiint\" alt=\"\\iiiint\"></p>\n<h3 id=\"连乘\"><a href=\"#连乘\" class=\"headerlink\" title=\"连乘\"></a>连乘</h3><p>  <code>$\\prod {a+b}$</code>，输出：<img src=\"https://math.jianshu.com/math?formula=\\prod {a%2Bb}\" alt=\"\\prod {a+b}\">。<br>  <code>$\\prod_{i=1}^{K}$</code>，输出：<img src=\"https://math.jianshu.com/math?formula=\\prod_{i%3D1}^{K}\" alt=\"\\prod_{i=1}^{K}\">。<br>  <code>$$\\prod_{i=1}^{K}$$</code>，输出：<img src=\"https://math.jianshu.com/math?formula=%5Cprod_%7Bi%3D1%7D%5E%7BK%7D\" alt=\"\\prod_{i=1}^{K}\">。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>  与此类似的符号还有，<br>  <code>$\\prod$</code> ：<img src=\"https://math.jianshu.com/math?formula=\\prod\" alt=\"\\prod\"><br>  <code>$\\bigcup$</code> ：<img src=\"https://math.jianshu.com/math?formula=\\bigcup\" alt=\"\\bigcup\"><br>  <code>$\\bigcap$</code> ：<img src=\"https://math.jianshu.com/math?formula=\\bigcap\" alt=\"\\bigcap\"><br>  <code>$arg\\,\\max_{c_k}$</code>：<img src=\"https://math.jianshu.com/math?formula=arg\\%2C\\max_{c_k}\" alt=\"arg\\,\\max_{c_k}\"><br>  <code>$arg\\,\\min_{c_k}$</code>：<img src=\"https://math.jianshu.com/math?formula=arg\\%2C\\min_{c_k}\" alt=\"arg\\,\\min_{c_k}\"><br>  <code>$\\mathop {argmin}_{c_k}$</code>：<img src=\"https://math.jianshu.com/math?formula=\\mathop {argmin}_{c_k}\" alt=\"\\mathop {argmin}_{c_k}\"><br>  <code>$\\mathop {argmax}_{c_k}$</code>：<img src=\"https://math.jianshu.com/math?formula=\\mathop {argmax}_{c_k}\" alt=\"\\mathop {argmax}_{c_k}\"><br>  <code>$\\max_{c_k}$</code>：<img src=\"https://math.jianshu.com/math?formula=\\max_{c_k}\" alt=\"\\max_{c_k}\"><br>  <code>$\\min_{c_k}$</code>：<img src=\"https://math.jianshu.com/math?formula=\\min_{c_k}\" alt=\"\\min_{c_k}\"></p>\n<h2 id=\"分式与根式\"><a href=\"#分式与根式\" class=\"headerlink\" title=\"分式与根式\"></a><strong>分式与根式</strong></h2><h3 id=\"分式\"><a href=\"#分式\" class=\"headerlink\" title=\"分式\"></a>分式</h3><ul>\n<li>第一种，使用<code>\\frac ab</code>，<code>\\frac</code>作用于其后的两个组<code>a</code> ，<code>b</code> ，结果为<img src=\"https://math.jianshu.com/math?formula=\\frac ab\" alt=\"\\frac ab\">。如果你的分子或分母不是单个字符，请使用<code>{..}</code>来分组，比如<code>$\\frac {a+c+1}{b+c+2}$</code>表示<img src=\"https://math.jianshu.com/math?formula=\\frac {a%2Bc%2B1}{b%2Bc%2B2}\" alt=\"\\frac {a+c+1}{b+c+2}\">。</li>\n<li>第二种，使用<code>\\over</code>来分隔一个组的前后两部分，如<code>{a+1\\over b+1}</code>：<img src=\"https://math.jianshu.com/math?formula={a%2B1\\over b%2B1}\" alt=\"{a+1\\over b+1}\"></li>\n</ul>\n<h3 id=\"连分数\"><a href=\"#连分数\" class=\"headerlink\" title=\"连分数\"></a>连分数</h3><p>  书写连分数表达式时，请使用<code>\\cfrac</code>代替<code>\\frac</code>或者<code>\\over</code>两者效果对比如下：<br>  <code>\\frac</code> 表示如下：</p>\n<pre><code class=\"ruby\">$$x=a_0 + \\frac {1^2}{a_1 + \\frac {2^2}{a_2 + \\frac {3^2}{a_3 + \\frac {4^2}{a_4 + ...}}}}$$\n</code></pre>\n<p>  显示如下：<br><img src=\"https://math.jianshu.com/math?formula=x%3Da_0 %2B \\frac {1^2}{a_1 %2B \\frac {2^2}{a_2 %2B \\frac {3^2}{a_3 %2B \\frac {4^2}{a_4 %2B ...}}}}\" alt=\"x=a_0 + \\frac {1^2}{a_1 + \\frac {2^2}{a_2 + \\frac {3^2}{a_3 + \\frac {4^2}{a_4 + ...}}}}\"><br>  <code>\\cfrac</code> 表示如下：</p>\n<pre><code class=\"ruby\">$$x=a_0 + \\cfrac {1^2}{a_1 + \\cfrac {2^2}{a_2 + \\cfrac {3^2}{a_3 + \\cfrac {4^2}{a_4 + ...}}}}$$\n</code></pre>\n<p>  显示如下：<br><img src=\"https://math.jianshu.com/math?formula=x%3Da_0 %2B \\cfrac {1^2}{a_1 %2B \\cfrac {2^2}{a_2 %2B \\cfrac {3^2}{a_3 %2B \\cfrac {4^2}{a_4 %2B ...}}}}\" alt=\"x=a_0 + \\cfrac {1^2}{a_1 + \\cfrac {2^2}{a_2 + \\cfrac {3^2}{a_3 + \\cfrac {4^2}{a_4 + ...}}}}\"></p>\n<h3 id=\"根式\"><a href=\"#根式\" class=\"headerlink\" title=\"根式\"></a>根式</h3><p>  根式使用<code>\\sqrt</code> 来表示。<br>  如开4次方：<code>$\\sqrt[4]{\\frac xy}$</code> ：<img src=\"https://math.jianshu.com/math?formula=\\sqrt[4]{\\frac xy}\" alt=\"\\sqrt[4]{\\frac xy}\">。<br>  开平方：<code>$\\sqrt {a+b}$</code>：<img src=\"https://math.jianshu.com/math?formula=\\sqrt {a%2Bb}\" alt=\"\\sqrt {a+b}\">。</p>\n<h2 id=\"多行表达式\"><a href=\"#多行表达式\" class=\"headerlink\" title=\"多行表达式\"></a><strong>多行表达式</strong></h2><h3 id=\"分类表达式\"><a href=\"#分类表达式\" class=\"headerlink\" title=\"分类表达式\"></a>分类表达式</h3><p>  定义函数的时候经常需要分情况给出表达式，使用<code>\\begin{cases}…\\end{cases}</code> 。其中：</p>\n<ul>\n<li>  使用<code>\\\\</code> 来分类，</li>\n<li>  使用<code>&amp;</code> 指示需要对齐的位置，</li>\n<li>  使用<code>\\</code> +<code>空格</code>表示空格。</li>\n</ul>\n<pre><code class=\"ruby\">$$\nf(n)\n\\begin{cases}\n\\cfrac n2, &amp;if\\ n\\ is\\ even\\\\\n3n + 1, &amp;if\\  n\\ is\\ odd\n\\end{cases}\n$$\n</code></pre>\n<p>  表示:<br><img src=\"https://math.jianshu.com/math?formula=f(n\" alt=\"f(n) \\begin{cases} \\cfrac n2, &amp;if\\ n\\ is\\ even\\\\ 3n + 1, &amp;if\\ n\\ is\\ odd \\end{cases}\"> \\begin{cases} \\cfrac n2%2C %26if\\ n\\ is\\ even\\ 3n %2B 1%2C %26if\\ n\\ is\\ odd \\end{cases})</p>\n<pre><code class=\"ruby\">$$\nL(Y,f(X)) =\n\\begin{cases}\n0, &amp; \\text{Y = f(X)}  \\\\\n1, &amp; \\text{Y $\\neq$ f(X)}\n\\end{cases}\n$$\n</code></pre>\n<p>  表示:<br><img src=\"https://math.jianshu.com/math?formula=L(Y%2Cf(X\" alt=\"L(Y,f(X)) = \\begin{cases} 0, &amp; \\text{Y = f(X)} \\\\ 1, &amp; \\text{Y $\\neq$ f(X)} \\end{cases}\">)%20%3D%20%5Cbegin%7Bcases%7D%200%2C%20%26%20%5Ctext%7BY%20%3D%20f(X)%7D%20%5C%5C%201%2C%20%26%20%5Ctext%7BY%20%24%5Cneq%24%20f(X)%7D%20%5Cend%7Bcases%7D)<br>  如果想分类之间的垂直间隔变大，可以使用<code>\\\\[2ex]</code> 代替<code>\\\\</code> 来分隔不同的情况。(<code>3ex,4ex</code> 也可以用，<code>1ex</code> 相当于原始距离）。如下所示：</p>\n<pre><code class=\"ruby\">$$\nL(Y,f(X)) =\n\\begin{cases}\n0, &amp; \\text{Y = f(X)} \\\\[5ex]\n1, &amp; \\text{Y $\\neq$ f(X)}\n\\end{cases}\n$$\n</code></pre>\n<p>  表示：<br><img src=\"https://math.jianshu.com/math?formula=L(Y%2Cf(X\" alt=\"L(Y,f(X)) = \\begin{cases} 0, &amp; \\text{Y = f(X)} \\\\[5ex] 1, &amp; \\text{Y $\\neq$ f(X)} \\end{cases}\">)%20%3D%20%5Cbegin%7Bcases%7D%200%2C%20%26%20%5Ctext%7BY%20%3D%20f(X)%7D%20%5C%5C%5B5ex%5D%201%2C%20%26%20%5Ctext%7BY%20%24%5Cneq%24%20f(X)%7D%20%5Cend%7Bcases%7D)</p>\n<h3 id=\"多行表达式-1\"><a href=\"#多行表达式-1\" class=\"headerlink\" title=\"多行表达式\"></a>多行表达式</h3><p>  有时候需要将一行公式分多行进行显示。</p>\n<pre><code class=\"ruby\">$$\n\\begin{equation}\\begin{split} \na&amp;=b+c-d \\\\ \n&amp;\\quad +e-f\\\\ \n&amp;=g+h\\\\ \n&amp; =i \n\\end{split}\\end{equation}\n$$\n</code></pre>\n<p>  表示：<br><img src=\"https://math.jianshu.com/math?formula=\\begin{equation}\\begin{split} a%26%3Db%2Bc-d \\\\ %26\\quad %2Be-f\\\\ %26%3Dg%2Bh\\\\ %26 %3Di \\end{split}\\end{equation}\" alt=\"\\begin{equation}\\begin{split} a&amp;=b+c-d \\\\ &amp;\\quad +e-f\\\\ &amp;=g+h\\\\ &amp; =i \\end{split}\\end{equation}\"><br>  其中<code>begin{equation}</code> 表示开始方程，<code>end{equation}</code> 表示方程结束；<code>begin{split}</code> 表示开始多行公式，<code>end{split}</code> 表示结束；公式中用<code>\\\\</code> 表示回车到下一行，<code>&amp;</code> 表示对齐的位置。</p>\n<h3 id=\"方程组\"><a href=\"#方程组\" class=\"headerlink\" title=\"方程组\"></a>方程组</h3><p>  使用<code>\\begin{array}...\\end{array}</code> 与<code>\\left \\{</code> 与<code>\\right.</code> 配合表示方程组:</p>\n<pre><code class=\"ruby\">$$\n\\left \\{ \n\\begin{array}{c}\na_1x+b_1y+c_1z=d_1 \\\\ \na_2x+b_2y+c_2z=d_2 \\\\ \na_3x+b_3y+c_3z=d_3\n\\end{array}\n\\right.\n$$\n</code></pre>\n<p>  表示：<br><img src=\"https://math.jianshu.com/math?formula=\\left \\{ \\begin{array}{c} a_1x%2Bb_1y%2Bc_1z%3Dd_1 \\\\ a_2x%2Bb_2y%2Bc_2z%3Dd_2 \\\\ a_3x%2Bb_3y%2Bc_3z%3Dd_3 \\end{array} \\right.\" alt=\"\\left \\{ \\begin{array}{c} a_1x+b_1y+c_1z=d_1 \\\\ a_2x+b_2y+c_2z=d_2 \\\\ a_3x+b_3y+c_3z=d_3 \\end{array} \\right.\"><br>  注意：通常MathJax通过内部策略自己管理公式内部的空间，因此<code>a…b</code> 与<code>a…….b</code> （<code>.</code>表示空格）都会显示为<code>ab</code> 。可以通过在<code>ab</code> 间加入<code>\\</code> ,增加些许间隙，<code>\\;</code> 增加较宽的间隙，<code>\\quad</code> 与<code>\\qquad</code> 会增加更大的间隙。</p>\n<h2 id=\"特殊函数与符号\"><a href=\"#特殊函数与符号\" class=\"headerlink\" title=\"特殊函数与符号\"></a><strong>特殊函数与符号</strong></h2><h3 id=\"三角函数\"><a href=\"#三角函数\" class=\"headerlink\" title=\"三角函数\"></a>三角函数</h3><p>  <code>\\snx$</code> : <img src=\"https://math.jianshu.com/math?formula=sinx\" alt=\"sinx\"><br>  <code>\\arctanx</code> : <img src=\"https://math.jianshu.com/math?formula=arctanx\" alt=\"arctanx\"></p>\n<h3 id=\"比较运算符\"><a href=\"#比较运算符\" class=\"headerlink\" title=\"比较运算符\"></a>比较运算符</h3><p>  小于(<code>\\lt</code> )：<img src=\"https://math.jianshu.com/math?formula=\\lt\" alt=\"\\lt\"><br>  大于(<code>\\gt</code> )：<img src=\"https://math.jianshu.com/math?formula=\\gt\" alt=\"\\gt\"><br>  小于等于(<code>\\le</code> )：<img src=\"https://math.jianshu.com/math?formula=\\le\" alt=\"\\le\"><br>  大于等于(<code>\\ge</code> )：<img src=\"https://math.jianshu.com/math?formula=\\ge\" alt=\"\\ge\"><br>  不等于(<code>\\ne</code> ) : <img src=\"https://math.jianshu.com/math?formula=\\ne\" alt=\"\\ne\"><br>  可以在这些运算符前面加上<code>\\not</code> ，如<code>\\not\\lt</code> : <img src=\"https://math.jianshu.com/math?formula=\\not\\lt`\" alt=\"\\not\\lt`\"></p>\n<h3 id=\"集合关系与运算\"><a href=\"#集合关系与运算\" class=\"headerlink\" title=\"集合关系与运算\"></a>集合关系与运算</h3><p>  并集(<code>\\cup</code> ): <img src=\"https://math.jianshu.com/math?formula=\\cup\" alt=\"\\cup\"><br>  交集(<code>\\cap</code> ): <img src=\"https://math.jianshu.com/math?formula=\\cap\" alt=\"\\cap\"><br>  差集(<code>\\setminus</code> ): <img src=\"https://math.jianshu.com/math?formula=\\setminus\" alt=\"\\setminus\"><br>  子集(<code>\\subset</code> ): <img src=\"https://math.jianshu.com/math?formula=\\subset\" alt=\"\\subset\"><br>  子集(<code>\\subseteq</code> ): <img src=\"https://math.jianshu.com/math?formula=\\subseteq\" alt=\"\\subseteq\"><br>  非子集(<code>\\subsetneq</code> ): <img src=\"https://math.jianshu.com/math?formula=\\subsetneq\" alt=\"\\subsetneq\"><br>  父集(<code>\\supset</code> ): <img src=\"https://math.jianshu.com/math?formula=\\supset\" alt=\"\\supset\"><br>  属于(<code>\\in</code> ): <img src=\"https://math.jianshu.com/math?formula=\\in\" alt=\"\\in\"><br>  不属于(<code>\\notin</code> ): <img src=\"https://math.jianshu.com/math?formula=\\notin\" alt=\"\\notin\"><br>  空集(<code>\\emptyset</code> ): <img src=\"https://math.jianshu.com/math?formula=\\emptyset\" alt=\"\\emptyset\"><br>  空(<code>\\varnothing</code> ): <img src=\"https://math.jianshu.com/math?formula=\\varnothing\" alt=\"\\varnothing\"></p>\n<h3 id=\"排列\"><a href=\"#排列\" class=\"headerlink\" title=\"排列\"></a>排列</h3><p>  <code>\\binom{n+1}{2k}</code> : <img src=\"https://math.jianshu.com/math?formula=\\binom{n%2B1}{2k}\" alt=\"\\binom{n+1}{2k}\"><br>  <code>{n+1 \\choose 2k}</code> : <img src=\"https://math.jianshu.com/math?formula={n%2B1 \\choose 2k}\" alt=\"{n+1 \\choose 2k}\"></p>\n<h3 id=\"箭头\"><a href=\"#箭头\" class=\"headerlink\" title=\"箭头\"></a>箭头</h3><p>  (<code>\\to</code> ):<img src=\"https://math.jianshu.com/math?formula=\\to\" alt=\"\\to\"><br>  (<code>\\rightarrow</code> ): <img src=\"https://math.jianshu.com/math?formula=\\rightarrow\" alt=\"\\rightarrow\"><br>  (<code>\\leftarrow</code> ): <img src=\"https://math.jianshu.com/math?formula=\\leftarrow\" alt=\"\\leftarrow\"><br>  (<code>\\Rightarrow</code> ): <img src=\"https://math.jianshu.com/math?formula=\\Rightarrow\" alt=\"\\Rightarrow\"><br>  (<code>\\Leftarrow</code> ): <img src=\"https://math.jianshu.com/math?formula=\\Leftarrow\" alt=\"\\Leftarrow\"><br>  (<code>\\mapsto</code> ): <img src=\"https://math.jianshu.com/math?formula=\\mapsto\" alt=\"\\mapsto\"></p>\n<h3 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h3><p>  (<code>\\land</code> ): <img src=\"https://math.jianshu.com/math?formula=\\land\" alt=\"\\land\"><br>  (<code>\\lor</code> ): <img src=\"https://math.jianshu.com/math?formula=\\lor\" alt=\"\\lor\"><br>  (<code>\\lnot</code> ): <img src=\"https://math.jianshu.com/math?formula=\\lnot\" alt=\"\\lnot\"><br>  (<code>\\forall</code> ): <img src=\"https://math.jianshu.com/math?formula=\\forall\" alt=\"\\forall\"><br>  (<code>\\exists</code> ): <img src=\"https://math.jianshu.com/math?formula=\\exists\" alt=\"\\exists\"><br>  (<code>\\top</code> ): <img src=\"https://math.jianshu.com/math?formula=\\top\" alt=\"\\top\"><br>  (<code>\\bot</code> ): <img src=\"https://math.jianshu.com/math?formula=\\bot\" alt=\"\\bot\"><br>  (<code>\\vdash</code> ): <img src=\"https://math.jianshu.com/math?formula=\\vdash\" alt=\"\\vdash\"><br>  (<code>\\vDash</code> ): <img src=\"https://math.jianshu.com/math?formula=\\vDash\" alt=\"\\vDash\"></p>\n<h3 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h3><p>  (<code>\\star</code> ): <img src=\"https://math.jianshu.com/math?formula=\\star\" alt=\"\\star\"><br>  (<code>\\ast</code> ): <img src=\"https://math.jianshu.com/math?formula=\\ast\" alt=\"\\ast\"><br>  (<code>\\oplus</code> ): <img src=\"https://math.jianshu.com/math?formula=\\oplus\" alt=\"\\oplus\"><br>  (<code>\\circ</code> ): <img src=\"https://math.jianshu.com/math?formula=\\circ\" alt=\"\\circ\"><br>  (<code>\\bullet</code> ): <img src=\"https://math.jianshu.com/math?formula=\\bullet\" alt=\"\\bullet\"></p>\n<h3 id=\"等于\"><a href=\"#等于\" class=\"headerlink\" title=\"等于\"></a>等于</h3><p>  (<code>\\approx</code> ): <img src=\"https://math.jianshu.com/math?formula=\\approx\" alt=\"\\approx\"><br>  (<code>\\sim</code> ): <img src=\"https://math.jianshu.com/math?formula=\\sim\" alt=\"\\sim\"><br>  (<code>\\equiv</code> ): <img src=\"https://math.jianshu.com/math?formula=\\equiv\" alt=\"\\equiv\"><br>  (<code>\\prec</code> ): <img src=\"https://math.jianshu.com/math?formula=\\prec\" alt=\"\\prec\"></p>\n<h3 id=\"范围\"><a href=\"#范围\" class=\"headerlink\" title=\"范围\"></a>范围</h3><p>  (<code>\\infty</code> ): <img src=\"https://math.jianshu.com/math?formula=\\infty\" alt=\"\\infty\"><br>  (<code>\\aleph_o</code> ): <img src=\"https://math.jianshu.com/math?formula=\\aleph_o\" alt=\"\\aleph_o\"><br>  (<code>\\nabla</code> ): <img src=\"https://math.jianshu.com/math?formula=\\nabla\" alt=\"\\nabla\"><br>  (<code>\\Im</code> ): <img src=\"https://math.jianshu.com/math?formula=\\Im\" alt=\"\\Im\"><br>  (<code>\\Re</code> ): <img src=\"https://math.jianshu.com/math?formula=\\Re\" alt=\"\\Re\"></p>\n<h3 id=\"模运算\"><a href=\"#模运算\" class=\"headerlink\" title=\"模运算\"></a>模运算</h3><p>  (<code>\\pmod</code> ): <img src=\"https://math.jianshu.com/math?formula=b \\pmod n\" alt=\"b \\pmod n\"><br>  如<code>a \\equiv b \\pmod n</code> : <img src=\"https://math.jianshu.com/math?formula=a \\equiv b \\pmod n\" alt=\"a \\equiv b \\pmod n\"></p>\n<h3 id=\"点\"><a href=\"#点\" class=\"headerlink\" title=\"点\"></a>点</h3><p>  (<code>\\ldots</code> ): <img src=\"https://math.jianshu.com/math?formula=\\ldots\" alt=\"\\ldots\"><br>  (<code>\\cdots</code> ): <img src=\"https://math.jianshu.com/math?formula=\\cdots\" alt=\"\\cdots\"><br>  (<code>\\cdot</code> ): <img src=\"https://math.jianshu.com/math?formula=\\cdot\" alt=\"\\cdot\"><br>  其区别是点的位置不同，<code>\\ldots</code> 位置稍低，<code>\\cdots</code> 位置居中。</p>\n<pre><code class=\"ruby\">$$\n\\begin{equation}\na_1+a_2+\\ldots+a_n \\\\ \na_1+a_2+\\cdots+a_n\n\\end{equation}\n$$\n</code></pre>\n<p>  表示：<br><img src=\"https://math.jianshu.com/math?formula=\\begin{equation} a_1%2Ba_2%2B\\ldots%2Ba_n \\\\ a_1%2Ba_2%2B\\cdots%2Ba_n \\end{equation}\" alt=\"\\begin{equation} a_1+a_2+\\ldots+a_n \\\\ a_1+a_2+\\cdots+a_n \\end{equation}\"></p>\n<h2 id=\"顶部符号\"><a href=\"#顶部符号\" class=\"headerlink\" title=\"顶部符号\"></a><strong>顶部符号</strong></h2><p>  对于单字符，<code>\\hat x</code> ：<img src=\"https://math.jianshu.com/math?formula=\\hat x\" alt=\"\\hat x\"><br>  多字符可以使用<code>\\widehat {xy}</code> ：<img src=\"https://math.jianshu.com/math?formula=\\widehat {xy}\" alt=\"\\widehat {xy}\"><br>  类似的还有:<br>  (<code>\\overline x</code> ): <img src=\"https://math.jianshu.com/math?formula=\\overline x\" alt=\"\\overline x\"><br>  矢量(<code>\\vec</code> ): <img src=\"https://math.jianshu.com/math?formula=\\vec x\" alt=\"\\vec x\"><br>  向量(<code>\\overrightarrow {xy}</code> ): <img src=\"https://math.jianshu.com/math?formula=\\overrightarrow {xy}\" alt=\"\\overrightarrow {xy}\"><br>  (<code>\\dot x</code> ): <img src=\"https://math.jianshu.com/math?formula=\\dot x\" alt=\"\\dot x\"><br>  (<code>\\ddot x</code> ): <img src=\"https://math.jianshu.com/math?formula=\\ddot x\" alt=\"\\ddot x\"><br>  (<code>\\dot {\\dot x}</code> ): <img src=\"https://math.jianshu.com/math?formula=\\dot {\\dot x}\" alt=\"\\dot {\\dot x}\"></p>\n<h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a><strong>表格</strong></h2><p>  使用<code>\\begin{array}{列样式}…\\end{array}</code> 这样的形式来创建表格，列样式可以是<code>clr</code> 表示居中，左，右对齐，还可以使用<code>|</code> 表示一条竖线。表格中各行使用<code>\\\\</code> 分隔，各列使用<code>&amp;</code> 分隔。使用<code>\\hline</code> 在本行前加入一条直线。 例如:</p>\n<pre><code class=\"ruby\">$$\n\\begin{array}{c|lcr}\nn &amp; \\text{Left} &amp; \\text{Center} &amp; \\text{Right} \\\\\n\\hline\n1 &amp; 0.24 &amp; 1 &amp; 125 \\\\\n2 &amp; -1 &amp; 189 &amp; -8 \\\\\n3 &amp; -20 &amp; 2000 &amp; 1+10i \\\\\n\\end{array}\n$$\n</code></pre>\n<p>  得到：<br><img src=\"https://math.jianshu.com/math?formula=\\begin{array}{c|lcr} n %26 \\text{Left} %26 \\text{Center} %26 \\text{Right} \\\\ \\hline 1 %26 0.24 %26 1 %26 125 \\\\ 2 %26 -1 %26 189 %26 -8 \\\\ 3 %26 -20 %26 2000 %26 1%2B10i \\\\ \\end{array}\" alt=\"\\begin{array}{c|lcr} n &amp; \\text{Left} &amp; \\text{Center} &amp; \\text{Right} \\\\ \\hline 1 &amp; 0.24 &amp; 1 &amp; 125 \\\\ 2 &amp; -1 &amp; 189 &amp; -8 \\\\ 3 &amp; -20 &amp; 2000 &amp; 1+10i \\\\ \\end{array}\"></p>\n<h2 id=\"矩阵\"><a href=\"#矩阵\" class=\"headerlink\" title=\"矩阵\"></a><strong>矩阵</strong></h2><h3 id=\"基本内容\"><a href=\"#基本内容\" class=\"headerlink\" title=\"基本内容\"></a>基本内容</h3><p>  使用<code>\\begin{matrix}…\\end{matrix}</code> 这样的形式来表示矩阵，在<code>\\begin</code> 与<code>\\end</code> 之间加入矩阵中的元素即可。矩阵的行之间使用<code>\\\\</code> 分隔，列之间使用<code>&amp;</code> 分隔，例如:</p>\n<pre><code class=\"ruby\">$$\n\\begin{matrix}\n1 &amp; x &amp; x^2 \\\\\n1 &amp; y &amp; y^2 \\\\\n1 &amp; z &amp; z^2 \\\\\n\\end{matrix}\n$$\n</code></pre>\n<p>  得到：<br><img src=\"https://math.jianshu.com/math?formula=\\begin{matrix} 1 %26 x %26 x^2 \\\\ 1 %26 y %26 y^2 \\\\ 1 %26 z %26 z^2 \\\\ \\end{matrix}\" alt=\"\\begin{matrix} 1 &amp; x &amp; x^2 \\\\ 1 &amp; y &amp; y^2 \\\\ 1 &amp; z &amp; z^2 \\\\ \\end{matrix}\"></p>\n<h3 id=\"括号-1\"><a href=\"#括号-1\" class=\"headerlink\" title=\"括号\"></a>括号</h3><p>  如果要对矩阵加括号，可以像上文中提到的一样，使用<code>\\left</code> 与<code>\\right</code> 配合表示括号符号。也可以使用特殊的<code>matrix</code> 。即替换<code>\\begin{matrix}…\\end{matrix}</code> 中<code>matrix</code> 为<code>pmatrix</code> ，<code>bmatrix</code> ，<code>Bmatrix</code> ，<code>vmatrix</code> , <code>Vmatrix</code> 。</p>\n<ol>\n<li>pmatrix<code>$\\begin{pmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{pmatrix}$</code> : <img src=\"https://math.jianshu.com/math?formula=\\begin{pmatrix}1 %26 2 \\\\ 3 %26 4\\\\ \\end{pmatrix}\" alt=\"\\begin{pmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{pmatrix}\"></li>\n<li>bmatrix<code>$\\begin{bmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{bmatrix}$</code> : <img src=\"https://math.jianshu.com/math?formula=\\begin{bmatrix}1 %26 2 \\\\ 3 %26 4\\\\ \\end{bmatrix}\" alt=\"\\begin{bmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{bmatrix}\"></li>\n<li>Bmatrix<code>$\\begin{Bmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{Bmatrix}$</code> : <img src=\"https://math.jianshu.com/math?formula=\\begin{Bmatrix}1 %26 2 \\\\ 3 %26 4\\\\ \\end{Bmatrix}\" alt=\"\\begin{Bmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{Bmatrix}\"></li>\n<li>vmatrix<code>$\\begin{vmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{vmatrix}$</code> : <img src=\"https://math.jianshu.com/math?formula=\\begin{vmatrix}1 %26 2 \\\\ 3 %26 4\\\\ \\end{vmatrix}\" alt=\"\\begin{vmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{vmatrix}\"></li>\n<li>Vmatrix<code>$\\begin{Vmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{Vmatrix}$</code> : <img src=\"https://math.jianshu.com/math?formula=\\begin{Vmatrix}1 %26 2 \\\\ 3 %26 4\\\\ \\end{Vmatrix}\" alt=\"\\begin{Vmatrix}1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end{Vmatrix}\"></li>\n</ol>\n<h3 id=\"元素省略\"><a href=\"#元素省略\" class=\"headerlink\" title=\"元素省略\"></a>元素省略</h3><p>  可以使用<code>\\cdots</code> ：⋯，<code>\\ddots</code>：⋱ ，<code>\\vdots</code>：⋮ 来省略矩阵中的元素，如：</p>\n<pre><code class=\"ruby\">$$\n\\begin{pmatrix}\n1&amp;a_1&amp;a_1^2&amp;\\cdots&amp;a_1^n\\\\\n1&amp;a_2&amp;a_2^2&amp;\\cdots&amp;a_2^n\\\\\n\\vdots&amp;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\\n1&amp;a_m&amp;a_m^2&amp;\\cdots&amp;a_m^n\\\\\n\\end{pmatrix}\n$$\n</code></pre>\n<p>  表示：<br><img src=\"https://math.jianshu.com/math?formula=\\begin{pmatrix} 1%26a_1%26a_1^2%26\\cdots%26a_1^n\\\\ 1%26a_2%26a_2^2%26\\cdots%26a_2^n\\\\ \\vdots%26\\vdots%26\\vdots%26\\ddots%26\\vdots\\\\ 1%26a_m%26a_m^2%26\\cdots%26a_m^n\\\\ \\end{pmatrix}\" alt=\"\\begin{pmatrix} 1&amp;a_1&amp;a_1^2&amp;\\cdots&amp;a_1^n\\\\ 1&amp;a_2&amp;a_2^2&amp;\\cdots&amp;a_2^n\\\\ \\vdots&amp;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\ 1&amp;a_m&amp;a_m^2&amp;\\cdots&amp;a_m^n\\\\ \\end{pmatrix}\"></p>\n<h3 id=\"增广矩阵\"><a href=\"#增广矩阵\" class=\"headerlink\" title=\"增广矩阵\"></a>增广矩阵</h3><p>  增广矩阵需要使用前面的表格中使用到的<code>\\begin{array} ... \\end{array}</code> 来实现。</p>\n<pre><code class=\"swift\">$$\n\\left[  \\begin{array}  {c c | c} %这里的c表示数组中元素对其方式：c居中、r右对齐、l左对齐，竖线表示2、3列间插入竖线\n1 &amp; 2 &amp; 3 \\\\\n\\hline %插入横线，如果去掉\\hline就是增广矩阵\n4 &amp; 5 &amp; 6\n\\end{array}  \\right]\n$$\n</code></pre>\n<p>显示为：<br><img src=\"https://math.jianshu.com/math?formula=\\left[ \\begin{array} {c c | c} 1 %26 2 %26 3 \\\\ \\hline 4 %26 5 %26 6 \\end{array} \\right]\" alt=\"\\left[ \\begin{array} {c c | c} 1 &amp; 2 &amp; 3 \\\\ \\hline 4 &amp; 5 &amp; 6 \\end{array} \\right]\"></p>\n<h2 id=\"公式标记与引用\"><a href=\"#公式标记与引用\" class=\"headerlink\" title=\"公式标记与引用\"></a><strong>公式标记与引用</strong></h2><p>  使用<code>\\tag{yourtag}</code> 来标记公式，如果想在之后引用该公式，则还需要加上<code>\\label{yourlabel}</code> 在<code>\\tag</code> 之后，如<code>$$a = x^2 - y^3 \\tag{1}\\label{1}$$</code> 显示为：<br><img src=\"https://math.jianshu.com/math?formula=a %3A%3D x^2 - y^3 \\tag{1}\\label{311}\" alt=\"a := x^2 - y^3 \\tag{1}\\label{311}\"><br>  如果不需要被引用，只使用<code>\\tag{yourtag}</code> ，<code>$$x+y=z\\tag{1.1}$$</code>显示为：<br><img src=\"https://math.jianshu.com/math?formula=x%2By%3Dz\\tag{1.1}\" alt=\"x+y=z\\tag{1.1}\"><br>  <code>\\tab{yourtab}</code> 中的内容用于显示公式后面的标记。公式之间通过<code>\\label{}</code> 设置的内容来引用。为了引用公式，可以使用<code>\\eqref{yourlabel}</code> ，如<code>$$a + y^3 \\stackrel{\\eqref{1}}= x^2$$</code> 显示为：<br><img src=\"https://math.jianshu.com/math?formula=a %2B y^3 \\stackrel{\\eqref{1}}%3D x^2\" alt=\"a + y^3 \\stackrel{\\eqref{1}}= x^2\"></p>\n<p>或者使用<code>\\ref{yourlabel}</code> 不带括号引用，如<code>$$a + y^3 \\stackrel{\\ref{111}}= x^2$$</code> 显示为:<br><img src=\"https://math.jianshu.com/math?formula=a %2B y^3 \\stackrel{\\ref{1}}%3D x^2\" alt=\"a + y^3 \\stackrel{\\ref{1}}= x^2\"></p>\n<h2 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a><strong>字体</strong></h2><h3 id=\"黑板粗体字\"><a href=\"#黑板粗体字\" class=\"headerlink\" title=\"黑板粗体字\"></a>黑板粗体字</h3><p>此字体经常用来表示代表实数、整数、有理数、复数的大写字母。<br><code>$\\mathbb ABCDEF$</code>：<img src=\"https://math.jianshu.com/math?formula=\\mathbb ABCDEF\" alt=\"\\mathbb ABCDEF\"><br><code>$\\Bbb ABCDEF$</code>：<img src=\"https://math.jianshu.com/math?formula=\\Bbb ABCDEF\" alt=\"\\Bbb ABCDEF\"></p>\n<h3 id=\"黑体字\"><a href=\"#黑体字\" class=\"headerlink\" title=\"黑体字\"></a>黑体字</h3><p><code>$\\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ$</code> :<img src=\"https://math.jianshu.com/math?formula=\\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ\" alt=\"\\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ\"><br><code>$\\mathbf abcdefghijklmnopqrstuvwxyz$</code> :<img src=\"https://math.jianshu.com/math?formula=\\mathbf abcdefghijklmnopqrstuvwxyz\" alt=\"\\mathbf abcdefghijklmnopqrstuvwxyz\"></p>\n<h3 id=\"打印机字体\"><a href=\"#打印机字体\" class=\"headerlink\" title=\"打印机字体\"></a>打印机字体</h3><p><code>$\\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ$</code> :<img src=\"https://math.jianshu.com/math?formula=\\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ\" alt=\"\\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ\"></p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a><strong>参考文档</strong></h2><table>\n<thead>\n<tr>\n<th>#</th>\n<th>链接地址</th>\n<th>文档名称</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td><code>blog.csdn.net/dabokele/article/details/79577072</code></td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhYm9rZWxlL2FydGljbGUvZGV0YWlscy83OTU3NzA3Mg==\" title=\"https://blog.csdn.net/dabokele/article/details/79577072\">Mathjax公式教程<i class=\"fa fa-external-link\"></i></span></td>\n</tr>\n<tr>\n<td>2</td>\n<td><code>blog.csdn.net/ethmery/article/details/50670297</code></td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2V0aG1lcnkvYXJ0aWNsZS9kZXRhaWxzLzUwNjcwMjk3\" title=\"https://blog.csdn.net/ethmery/article/details/50670297\">基本数学公式语法<i class=\"fa fa-external-link\"></i></span></td>\n</tr>\n<tr>\n<td>3</td>\n<td><code>blog.csdn.net/lilongsy/article/details/79378620</code></td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbG9uZ3N5L2FydGljbGUvZGV0YWlscy83OTM3ODYyMA==\" title=\"https://blog.csdn.net/lilongsy/article/details/79378620\">常用数学符号的LaTeX表示方法<i class=\"fa fa-external-link\"></i></span></td>\n</tr>\n<tr>\n<td>4</td>\n<td><code>www.mathjax.org</code></td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWF0aGpheC5vcmcv\" title=\"https://www.mathjax.org/\">Beautiful math in all browsers<i class=\"fa fa-external-link\"></i></span></td>\n</tr>\n</tbody>\n</table>"},{"title":"Typora 设置图床","_content":"\n自动图床设置，在我们撰写文档时，会自动将图片保存到图库，并转化 URL 展示出来，最终我们在分享 MD 文档时，避免了本地相对目录，无法引用的情况发生。\n<!-- more-->\n```json\n{\n  \"picBed\": {\n    \"uploader\": \"github\",\n    \"github\": {\n      \"repo\": \"ximan/static_file\", // 仓库名，格式时 username/reponame\n      \"token\": \"xxxxxxxx\", // github token\n      \"path\": \"images/\", // 自定义存储路径 如： image/\n      \"branch\": \"master\" // 分支名，默认是 master\n    }\n  },\n  \"picgoPlugins\": {}\n}\n```\n\n1. 首先您要有一个 Github 账号\n\n2. 新建一个仓库\n\n   ![image-20210128140803755](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128140803755.png)\n\n3. 生成一个 token 用于 Picgo 操作您的仓库， \n\n   * 访问 https://github.com/settings/tokens\n\n   * 然后点击 `Generate new token`\n\n     ![image-20210128141003873](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128141003873.png)\n\n   * 勾选 `repo` 并记录 token\n\n4. 配置 Picgo， 如上 JSON\n\n## Typora 设置如下图\n\n![image-20210128141254331](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128141254331.png)\n\n* 下载或更新：大约 18m 的 Picgo 插件，点击安装即可\n\n* 点击打开配置文件，会出现一个 json 数据，按照 github 的配置，将数据对应的填入\n\n* 点击验证图片上传选项，验证 github 是否连通\n\n  ![image-20210128141827255](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128141827255.png)\n\n## 更多配置\n\n我们也可以配置一些插件，如上 Json 中未开发的部分，具体可参考 [Typora 文件配置](https://picgo.github.io/PicGo-Core-Doc/zh/guide/config.html#%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6) 和 [图片上传工具配置](https://support.typora.io/Upload-Image/)\n\n\n","source":"_posts/Tools/Typora 自动图床设置.md","raw":"---\ntitle: Typora 设置图床\ntag: Tools\n\n\n---\n\n自动图床设置，在我们撰写文档时，会自动将图片保存到图库，并转化 URL 展示出来，最终我们在分享 MD 文档时，避免了本地相对目录，无法引用的情况发生。\n<!-- more-->\n```json\n{\n  \"picBed\": {\n    \"uploader\": \"github\",\n    \"github\": {\n      \"repo\": \"ximan/static_file\", // 仓库名，格式时 username/reponame\n      \"token\": \"xxxxxxxx\", // github token\n      \"path\": \"images/\", // 自定义存储路径 如： image/\n      \"branch\": \"master\" // 分支名，默认是 master\n    }\n  },\n  \"picgoPlugins\": {}\n}\n```\n\n1. 首先您要有一个 Github 账号\n\n2. 新建一个仓库\n\n   ![image-20210128140803755](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128140803755.png)\n\n3. 生成一个 token 用于 Picgo 操作您的仓库， \n\n   * 访问 https://github.com/settings/tokens\n\n   * 然后点击 `Generate new token`\n\n     ![image-20210128141003873](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128141003873.png)\n\n   * 勾选 `repo` 并记录 token\n\n4. 配置 Picgo， 如上 JSON\n\n## Typora 设置如下图\n\n![image-20210128141254331](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128141254331.png)\n\n* 下载或更新：大约 18m 的 Picgo 插件，点击安装即可\n\n* 点击打开配置文件，会出现一个 json 数据，按照 github 的配置，将数据对应的填入\n\n* 点击验证图片上传选项，验证 github 是否连通\n\n  ![image-20210128141827255](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128141827255.png)\n\n## 更多配置\n\n我们也可以配置一些插件，如上 Json 中未开发的部分，具体可参考 [Typora 文件配置](https://picgo.github.io/PicGo-Core-Doc/zh/guide/config.html#%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6) 和 [图片上传工具配置](https://support.typora.io/Upload-Image/)\n\n\n","slug":"Tools/Typora 自动图床设置","published":1,"date":"2021-01-29T15:54:28.321Z","updated":"2021-01-29T16:15:09.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8ff0024sz5qc8hf93rx","content":"<p>自动图床设置，在我们撰写文档时，会自动将图片保存到图库，并转化 URL 展示出来，最终我们在分享 MD 文档时，避免了本地相对目录，无法引用的情况发生。<br><a id=\"more\"></a></p>\n<pre class=\" language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"picBed\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"uploader\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"github\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"github\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"repo\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"ximan/static_file\"</span><span class=\"token punctuation\">,</span> // 仓库名，格式时 username/reponame\n      <span class=\"token property\">\"token\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"xxxxxxxx\"</span><span class=\"token punctuation\">,</span> // github token\n      <span class=\"token property\">\"path\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"images/\"</span><span class=\"token punctuation\">,</span> // 自定义存储路径 如： image/\n      <span class=\"token property\">\"branch\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"master\"</span> // 分支名，默认是 master\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"picgoPlugins\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<ol>\n<li><p>首先您要有一个 Github 账号</p>\n</li>\n<li><p>新建一个仓库</p>\n<p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128140803755.png\" alt=\"image-20210128140803755\"></p>\n</li>\n<li><p>生成一个 token 用于 Picgo 操作您的仓库， </p>\n<ul>\n<li><p>访问 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NldHRpbmdzL3Rva2Vucw==\" title=\"https://github.com/settings/tokens\">https://github.com/settings/tokens<i class=\"fa fa-external-link\"></i></span></p>\n</li>\n<li><p>然后点击 <code>Generate new token</code></p>\n<p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128141003873.png\" alt=\"image-20210128141003873\"></p>\n</li>\n<li><p>勾选 <code>repo</code> 并记录 token</p>\n</li>\n</ul>\n</li>\n<li><p>配置 Picgo， 如上 JSON</p>\n</li>\n</ol>\n<h2 id=\"Typora-设置如下图\"><a href=\"#Typora-设置如下图\" class=\"headerlink\" title=\"Typora 设置如下图\"></a>Typora 设置如下图</h2><p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128141254331.png\" alt=\"image-20210128141254331\"></p>\n<ul>\n<li><p>下载或更新：大约 18m 的 Picgo 插件，点击安装即可</p>\n</li>\n<li><p>点击打开配置文件，会出现一个 json 数据，按照 github 的配置，将数据对应的填入</p>\n</li>\n<li><p>点击验证图片上传选项，验证 github 是否连通</p>\n<p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128141827255.png\" alt=\"image-20210128141827255\"></p>\n</li>\n</ul>\n<h2 id=\"更多配置\"><a href=\"#更多配置\" class=\"headerlink\" title=\"更多配置\"></a>更多配置</h2><p>我们也可以配置一些插件，如上 Json 中未开发的部分，具体可参考 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9waWNnby5naXRodWIuaW8vUGljR28tQ29yZS1Eb2MvemgvZ3VpZGUvY29uZmlnLmh0bWwjJUU5JUJCJTk4JUU4JUFFJUE0JUU5JTg1JThEJUU3JUJEJUFFJUU2JTk2JTg3JUU0JUJCJUI2\" title=\"https://picgo.github.io/PicGo-Core-Doc/zh/guide/config.html#%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\">Typora 文件配置<i class=\"fa fa-external-link\"></i></span> 和 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdXBwb3J0LnR5cG9yYS5pby9VcGxvYWQtSW1hZ2Uv\" title=\"https://support.typora.io/Upload-Image/\">图片上传工具配置<i class=\"fa fa-external-link\"></i></span></p>\n","site":{"data":{}},"excerpt":"<p>自动图床设置，在我们撰写文档时，会自动将图片保存到图库，并转化 URL 展示出来，最终我们在分享 MD 文档时，避免了本地相对目录，无法引用的情况发生。<br>","more":"</p>\n<pre><code class=\"json\">{\n  &quot;picBed&quot;: {\n    &quot;uploader&quot;: &quot;github&quot;,\n    &quot;github&quot;: {\n      &quot;repo&quot;: &quot;ximan/static_file&quot;, // 仓库名，格式时 username/reponame\n      &quot;token&quot;: &quot;xxxxxxxx&quot;, // github token\n      &quot;path&quot;: &quot;images/&quot;, // 自定义存储路径 如： image/\n      &quot;branch&quot;: &quot;master&quot; // 分支名，默认是 master\n    }\n  },\n  &quot;picgoPlugins&quot;: {}\n}\n</code></pre>\n<ol>\n<li><p>首先您要有一个 Github 账号</p>\n</li>\n<li><p>新建一个仓库</p>\n<p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128140803755.png\" alt=\"image-20210128140803755\"></p>\n</li>\n<li><p>生成一个 token 用于 Picgo 操作您的仓库， </p>\n<ul>\n<li><p>访问 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NldHRpbmdzL3Rva2Vucw==\" title=\"https://github.com/settings/tokens\">https://github.com/settings/tokens<i class=\"fa fa-external-link\"></i></span></p>\n</li>\n<li><p>然后点击 <code>Generate new token</code></p>\n<p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128141003873.png\" alt=\"image-20210128141003873\"></p>\n</li>\n<li><p>勾选 <code>repo</code> 并记录 token</p>\n</li>\n</ul>\n</li>\n<li><p>配置 Picgo， 如上 JSON</p>\n</li>\n</ol>\n<h2 id=\"Typora-设置如下图\"><a href=\"#Typora-设置如下图\" class=\"headerlink\" title=\"Typora 设置如下图\"></a>Typora 设置如下图</h2><p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128141254331.png\" alt=\"image-20210128141254331\"></p>\n<ul>\n<li><p>下载或更新：大约 18m 的 Picgo 插件，点击安装即可</p>\n</li>\n<li><p>点击打开配置文件，会出现一个 json 数据，按照 github 的配置，将数据对应的填入</p>\n</li>\n<li><p>点击验证图片上传选项，验证 github 是否连通</p>\n<p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128141827255.png\" alt=\"image-20210128141827255\"></p>\n</li>\n</ul>\n<h2 id=\"更多配置\"><a href=\"#更多配置\" class=\"headerlink\" title=\"更多配置\"></a>更多配置</h2><p>我们也可以配置一些插件，如上 Json 中未开发的部分，具体可参考 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9waWNnby5naXRodWIuaW8vUGljR28tQ29yZS1Eb2MvemgvZ3VpZGUvY29uZmlnLmh0bWwjJUU5JUJCJTk4JUU4JUFFJUE0JUU5JTg1JThEJUU3JUJEJUFFJUU2JTk2JTg3JUU0JUJCJUI2\" title=\"https://picgo.github.io/PicGo-Core-Doc/zh/guide/config.html#%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\">Typora 文件配置<i class=\"fa fa-external-link\"></i></span> 和 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdXBwb3J0LnR5cG9yYS5pby9VcGxvYWQtSW1hZ2Uv\" title=\"https://support.typora.io/Upload-Image/\">图片上传工具配置<i class=\"fa fa-external-link\"></i></span></p>"},{"title":"Adb Command","date":"2019-04-16T09:38:08.000Z","_content":"\n1. 查看PID\n\n  ```\n  adb shell ps\n  ```\n\n2. 查看日志\n\n  ```\n  全部日志\n  adb logcat\n  \n  按照 PID 筛选日志\n  adb logcat | grep <PID>\n  ```\n<!-- more-->\n3. 查询链接设备\n\n  ```\n  adb devices\n  ```\n<!--more-->\n\n4. 重启机器\n\n  ```\n  adb reboot\n  ```\n\n5. 杀死进程服务\n\n  ```\n  adb kill-server\n  ```\n\n6. 重启进程服务\n\n  ```\n  adb start-server\n  ```\n\n7. 获取机器 Mac 地址\n\n  ```\n  adb shell cat /sys/class/net/wlan0/address\n  ```\n\n8. 安装 APK\n\n  ```\n  普通安装\n  adb install <file path>\n  \n  保留数据和缓存文件\n  adb install -r <file path>\n  \n  安装到 SD 卡上\n  adb install -s <file path>\n  ```\n\n9. 卸载 APK\n\n  ```\n  普通卸载\n  adb uninstall <package name>\n  \n  保留数据和缓存文件\n  adb uninstall -k <package name>\n  ```\n\n10. 启动应用\n\n    ```\n    adb shell am start -n <package name>/.<activity_class_name>\n    ```\n\n11. 查看 CPU 占用率\n\n    ```\n    adb shell top\n    \n    查看内存占用前 6 的 app\n    adb shell top -m 6\n    \n    刷新一次内存\n    adb shell top -n 1\n    ```\n\n12. 杀死进程\n\n    ```\n    adb shell kill <pid>\n    ```\n\n13. 将 System 分区重新挂在为可读写分区\n\n    ```\n    adb remount\n    ```\n\n14. 从本地复制文件到设备\n\n    ```\n    adb push <local> <remote>\n    ```\n\n15. 从设备复制文件到本地\n\n    ```\n    adb pull <remote> <local>\n    ```\n\n16. 查看 WiFi 密码\n\n    ```\n    adb shell cat /data/misc/wifi/*.conf\n    ```\n\n17. 查看 bug 报告\n\n    ```\n    adb bugreport\n    ```\n\n18. 跑 monkey\n\n    ```\n    adb shell monkey -v -p your.package.name 500\n    ```\n\n19. 截图\n\n    ```\n    adb shell screencap -p /sdcard/screenshot.png\n    ```\n\n20. 录屏\n\n    ```\n    adb shell screenrecord /sdcard/demo.mp4\n    ```\n\n21. 查看安装列表\n\n    ```\n    adb shell pm list packages\n    ```\n    \n11. 安装证书\n\n    ```\n    adb shell am start -n com.android.certinstaller/.CertInstallerMain -a android.intent.action.VIEW -t application/x-x509-ca-cert file:///sdcard/cacert.cer\n    ```\n\n22. 查看内存占用\n\n    ```\n    adb shell dumpsys meminfo <package> -d\n    ```\n\n23.  查询栈信息\n\n    ```\n    adb shell dumpsys activity\n    // 获取自己应用\n    adb shell dumpsys activity | grep <package>\n    // 获取处于栈顶的 activity\n    adb shell dumpsys activity | grep mFocusedActivity\n    ```\n\n\n","source":"_posts/Tools/adb-command.md","raw":"---\ntitle: adb command\ndate: 2019-04-16 17:38:08\ntags: Android\n\n---\n\n1. 查看PID\n\n  ```\n  adb shell ps\n  ```\n\n2. 查看日志\n\n  ```\n  全部日志\n  adb logcat\n  \n  按照 PID 筛选日志\n  adb logcat | grep <PID>\n  ```\n<!-- more-->\n3. 查询链接设备\n\n  ```\n  adb devices\n  ```\n<!--more-->\n\n4. 重启机器\n\n  ```\n  adb reboot\n  ```\n\n5. 杀死进程服务\n\n  ```\n  adb kill-server\n  ```\n\n6. 重启进程服务\n\n  ```\n  adb start-server\n  ```\n\n7. 获取机器 Mac 地址\n\n  ```\n  adb shell cat /sys/class/net/wlan0/address\n  ```\n\n8. 安装 APK\n\n  ```\n  普通安装\n  adb install <file path>\n  \n  保留数据和缓存文件\n  adb install -r <file path>\n  \n  安装到 SD 卡上\n  adb install -s <file path>\n  ```\n\n9. 卸载 APK\n\n  ```\n  普通卸载\n  adb uninstall <package name>\n  \n  保留数据和缓存文件\n  adb uninstall -k <package name>\n  ```\n\n10. 启动应用\n\n    ```\n    adb shell am start -n <package name>/.<activity_class_name>\n    ```\n\n11. 查看 CPU 占用率\n\n    ```\n    adb shell top\n    \n    查看内存占用前 6 的 app\n    adb shell top -m 6\n    \n    刷新一次内存\n    adb shell top -n 1\n    ```\n\n12. 杀死进程\n\n    ```\n    adb shell kill <pid>\n    ```\n\n13. 将 System 分区重新挂在为可读写分区\n\n    ```\n    adb remount\n    ```\n\n14. 从本地复制文件到设备\n\n    ```\n    adb push <local> <remote>\n    ```\n\n15. 从设备复制文件到本地\n\n    ```\n    adb pull <remote> <local>\n    ```\n\n16. 查看 WiFi 密码\n\n    ```\n    adb shell cat /data/misc/wifi/*.conf\n    ```\n\n17. 查看 bug 报告\n\n    ```\n    adb bugreport\n    ```\n\n18. 跑 monkey\n\n    ```\n    adb shell monkey -v -p your.package.name 500\n    ```\n\n19. 截图\n\n    ```\n    adb shell screencap -p /sdcard/screenshot.png\n    ```\n\n20. 录屏\n\n    ```\n    adb shell screenrecord /sdcard/demo.mp4\n    ```\n\n21. 查看安装列表\n\n    ```\n    adb shell pm list packages\n    ```\n    \n11. 安装证书\n\n    ```\n    adb shell am start -n com.android.certinstaller/.CertInstallerMain -a android.intent.action.VIEW -t application/x-x509-ca-cert file:///sdcard/cacert.cer\n    ```\n\n22. 查看内存占用\n\n    ```\n    adb shell dumpsys meminfo <package> -d\n    ```\n\n23.  查询栈信息\n\n    ```\n    adb shell dumpsys activity\n    // 获取自己应用\n    adb shell dumpsys activity | grep <package>\n    // 获取处于栈顶的 activity\n    adb shell dumpsys activity | grep mFocusedActivity\n    ```\n\n\n","slug":"Tools/adb-command","published":1,"updated":"2021-01-29T16:04:55.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8fh0026sz5qegkae1kr","content":"<ol>\n<li><p>查看PID</p>\n<pre><code>adb shell ps\n</code></pre></li>\n<li><p>查看日志</p>\n<pre><code>全部日志\nadb logcat\n\n按照 PID 筛选日志\nadb logcat | grep &lt;PID&gt;\n</code></pre><a id=\"more\"></a></li>\n<li><p>查询链接设备</p>\n<pre><code>adb devices\n</code></pre><!--more-->\n</li>\n<li><p>重启机器</p>\n<pre><code>adb reboot\n</code></pre></li>\n<li><p>杀死进程服务</p>\n<pre><code>adb kill-server\n</code></pre></li>\n<li><p>重启进程服务</p>\n<pre><code>adb start-server\n</code></pre></li>\n<li><p>获取机器 Mac 地址</p>\n<pre><code>adb shell cat /sys/class/net/wlan0/address\n</code></pre></li>\n<li><p>安装 APK</p>\n<pre><code>普通安装\nadb install &lt;file path&gt;\n\n保留数据和缓存文件\nadb install -r &lt;file path&gt;\n\n安装到 SD 卡上\nadb install -s &lt;file path&gt;\n</code></pre></li>\n<li><p>卸载 APK</p>\n<pre><code>普通卸载\nadb uninstall &lt;package name&gt;\n\n保留数据和缓存文件\nadb uninstall -k &lt;package name&gt;\n</code></pre></li>\n<li><p>启动应用</p>\n<pre><code>adb shell am start -n &lt;package name&gt;/.&lt;activity_class_name&gt;\n</code></pre></li>\n<li><p>查看 CPU 占用率</p>\n<pre><code>adb shell top\n\n查看内存占用前 6 的 app\nadb shell top -m 6\n\n刷新一次内存\nadb shell top -n 1\n</code></pre></li>\n<li><p>杀死进程</p>\n<pre><code>adb shell kill &lt;pid&gt;\n</code></pre></li>\n<li><p>将 System 分区重新挂在为可读写分区</p>\n<pre><code>adb remount\n</code></pre></li>\n<li><p>从本地复制文件到设备</p>\n<pre><code>adb push &lt;local&gt; &lt;remote&gt;\n</code></pre></li>\n<li><p>从设备复制文件到本地</p>\n<pre><code>adb pull &lt;remote&gt; &lt;local&gt;\n</code></pre></li>\n<li><p>查看 WiFi 密码</p>\n<pre><code>adb shell cat /data/misc/wifi/*.conf\n</code></pre></li>\n<li><p>查看 bug 报告</p>\n<pre><code>adb bugreport\n</code></pre></li>\n<li><p>跑 monkey</p>\n<pre><code>adb shell monkey -v -p your.package.name 500\n</code></pre></li>\n<li><p>截图</p>\n<pre><code>adb shell screencap -p /sdcard/screenshot.png\n</code></pre></li>\n<li><p>录屏</p>\n<pre><code>adb shell screenrecord /sdcard/demo.mp4\n</code></pre></li>\n<li><p>查看安装列表</p>\n<pre><code>adb shell pm list packages\n</code></pre></li>\n<li><p>安装证书</p>\n<pre><code>adb shell am start -n com.android.certinstaller/.CertInstallerMain -a android.intent.action.VIEW -t application/x-x509-ca-cert file:///sdcard/cacert.cer\n</code></pre></li>\n<li><p>查看内存占用</p>\n<pre><code>adb shell dumpsys meminfo &lt;package&gt; -d\n</code></pre></li>\n<li><p>查询栈信息</p>\n<pre><code>adb shell dumpsys activity\n// 获取自己应用\nadb shell dumpsys activity | grep &lt;package&gt;\n// 获取处于栈顶的 activity\nadb shell dumpsys activity | grep mFocusedActivity\n</code></pre></li>\n</ol>\n","site":{"data":{}},"excerpt":"<ol>\n<li><p>查看PID</p>\n<pre><code>adb shell ps\n</code></pre></li>\n<li><p>查看日志</p>\n<pre><code>全部日志\nadb logcat\n\n按照 PID 筛选日志\nadb logcat | grep &lt;PID&gt;\n</code></pre>","more":"</li>\n<li><p>查询链接设备</p>\n<pre><code>adb devices\n</code></pre><!--more-->\n</li>\n<li><p>重启机器</p>\n<pre><code>adb reboot\n</code></pre></li>\n<li><p>杀死进程服务</p>\n<pre><code>adb kill-server\n</code></pre></li>\n<li><p>重启进程服务</p>\n<pre><code>adb start-server\n</code></pre></li>\n<li><p>获取机器 Mac 地址</p>\n<pre><code>adb shell cat /sys/class/net/wlan0/address\n</code></pre></li>\n<li><p>安装 APK</p>\n<pre><code>普通安装\nadb install &lt;file path&gt;\n\n保留数据和缓存文件\nadb install -r &lt;file path&gt;\n\n安装到 SD 卡上\nadb install -s &lt;file path&gt;\n</code></pre></li>\n<li><p>卸载 APK</p>\n<pre><code>普通卸载\nadb uninstall &lt;package name&gt;\n\n保留数据和缓存文件\nadb uninstall -k &lt;package name&gt;\n</code></pre></li>\n<li><p>启动应用</p>\n<pre><code>adb shell am start -n &lt;package name&gt;/.&lt;activity_class_name&gt;\n</code></pre></li>\n<li><p>查看 CPU 占用率</p>\n<pre><code>adb shell top\n\n查看内存占用前 6 的 app\nadb shell top -m 6\n\n刷新一次内存\nadb shell top -n 1\n</code></pre></li>\n<li><p>杀死进程</p>\n<pre><code>adb shell kill &lt;pid&gt;\n</code></pre></li>\n<li><p>将 System 分区重新挂在为可读写分区</p>\n<pre><code>adb remount\n</code></pre></li>\n<li><p>从本地复制文件到设备</p>\n<pre><code>adb push &lt;local&gt; &lt;remote&gt;\n</code></pre></li>\n<li><p>从设备复制文件到本地</p>\n<pre><code>adb pull &lt;remote&gt; &lt;local&gt;\n</code></pre></li>\n<li><p>查看 WiFi 密码</p>\n<pre><code>adb shell cat /data/misc/wifi/*.conf\n</code></pre></li>\n<li><p>查看 bug 报告</p>\n<pre><code>adb bugreport\n</code></pre></li>\n<li><p>跑 monkey</p>\n<pre><code>adb shell monkey -v -p your.package.name 500\n</code></pre></li>\n<li><p>截图</p>\n<pre><code>adb shell screencap -p /sdcard/screenshot.png\n</code></pre></li>\n<li><p>录屏</p>\n<pre><code>adb shell screenrecord /sdcard/demo.mp4\n</code></pre></li>\n<li><p>查看安装列表</p>\n<pre><code>adb shell pm list packages\n</code></pre></li>\n<li><p>安装证书</p>\n<pre><code>adb shell am start -n com.android.certinstaller/.CertInstallerMain -a android.intent.action.VIEW -t application/x-x509-ca-cert file:///sdcard/cacert.cer\n</code></pre></li>\n<li><p>查看内存占用</p>\n<pre><code>adb shell dumpsys meminfo &lt;package&gt; -d\n</code></pre></li>\n<li><p>查询栈信息</p>\n<pre><code>adb shell dumpsys activity\n// 获取自己应用\nadb shell dumpsys activity | grep &lt;package&gt;\n// 获取处于栈顶的 activity\nadb shell dumpsys activity | grep mFocusedActivity\n</code></pre></li>\n</ol>"},{"title":"Git Command","date":"2019-04-16T09:43:58.000Z","_content":"\n# Git 命令\n\n|     修改记录     |        修改时间        |                  备注                  |\n| :--------------: | :--------------------: | :------------------------------------: |\n| 添加删除远程分支 | 2018年07月26日13:59:22 |            删除远程分支命令            |\n|   更新fork仓库   | 2018年08月10日14:16:08 | 添加fork的仓库，从主仓库更新代码的命令 |\n\n\n整理的还不够完善，以后工作中遇到了会不断补进，如有大神，有可以留言，我们一起来完善。欢迎各位留言^_^\n\n<!--more-->\n\n## Git 文件的三种状态\n\n1. 已提交：表示该文件已经被安全地保存在本地版本库中，执行过git commit。\n2. 已修改：表示修改了某个文件，但还没有提交保存\n3. 已暂存：表示把已修改的文件房子啊下次提交时要保存的清单中，也就是执行了 git add 命令。\n\n## 远程仓库与本地代码的配置\n\n将本地已经有的项目上传到远程空仓库中\n\n``` git\ncd <project path>\ngit init\ngit remote add origin <远程仓库地址>\ngit add .\ngit commit -m '提交日志'\ngit push -u origin master\n```\n\n## Git 基本配置\n\n1. 配置个人的用户名称和电子邮件地址，每次提交时，都会引用这两条信息，以用来说明是谁提交的更新。\n\n\n使用 `--global` 选项，更改的未用户主目录下的配置，如果想在某个特定的项目中使用其他的名称和邮件，只需要去掉 `--global` 选项重新配置，新的配置位于当前项目的 `.git/config` 文件中。\n\n```git\n git config --global user.name ''yourname''\n git config --global user.email  yourname@gmail.com\n```\n\n2. 基础命令\n\n> git init\n\n通过此命令会在当前目录创建一个`.git`的隐藏目录，这是`git`的第一步。\n\n> git status\n\n`git status`是最为常用的命令之一，用于检查本地项目的状态.仔细阅读红色/绿色部分，可以获得相关文件的操作信息，根据提示，判断是执行`git commit` 还是执行`git add` 操作。\n\n\n> git add\n\n将一个或多个文件添加到 `git`仓库中，只有通过 `git add` 添加的文件才会被版本控制管理。\n\n添加单个文件 `git add HelloWorld2.java`\n\n添加多个文件 `git add --a`\n\n添加当前目录所有文件 `git add .`\n\n\n> git rm --cached <file>\n\n将文件从`git`追踪列表中移除，只是逻辑删除（从版本库中移除），并不会将本地文件删除\n\n> git commit\n\n执行过 `git add` 命令后，需要将暂存的文件提交到本地仓库中，此时是真正的提交\n\n带 log 的提交： `git commit -m 'first commit'`\n\n通过编辑器提交: `git commit `\n\n带log 的提交比较方便，但当你的提交信息有一定格式或者需要提交的文字内容较多时，使用编辑器效果会更好.\n\n\n> git log\n\n查看历史提交记录， 包括**提交人**、**时间**、**信息**、**信息指纹**等.\n\n查看提交记录： `git log`\n\n单行展示记录： `git log --pretty=oneline`\n\n展示全部信息： `git log --pretty=fuller`\n\n\n> git clone <远程仓库地址>\n\n拉取远程仓库代码,此项目并不一定是你所创建\n\n例如： `git clone git@github.com:bboyfeiyu/AndroidEventBus.git`\n\n执行完成后，会在本地当前目录创建一个AndroidEventBus的目录来存放仓库代码\n\n> git remote\n\n将本地已经`init`过的工程链接到远程的空仓库中，以此来完成远程版本库的创建\n\n链接远程版本库： `git remote add origin <远程地址>`\n\n\n> git remote set-url <仓库地址>\n\nSSH 和 HTTPS 方式切换\n\n\n```git\n# ssh to https\n$ git remote set-url origin https://github.com/USERNAME/repository.git\n# https to ssh\n$ git remote set-url origin git@github.com:USERNAME/repository.git\n```\n\n可以使用 `git remote -v` 来检查当前仓库地址\n\n```\n> origin git@github.com:username/repository.git (fetch)\n> origin git@github.com:username/repository.git (push)\n```\n\nSSH 和 HTTPS 的区别：\n\n使用 SSH 方式需要在本地配置一个密钥，具体可参见[多个 SSH 公钥提交代码到不同平台](https://xiaoman.ren/2019/04/17/%E5%A4%9A%E4%B8%AA-ssh-%E5%85%AC%E9%92%A5%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%88%B0%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0/)中介绍；\n而使用 HTTPS 的方式操作简单，弊端是需要经常输入密码。\n\n\n> git branch\n\n分支是用来管理代码版本、类型的有效工具，可根据不同的服务对象、不同的上线版本等等，来做代码分离，版本管理操作\n\n查看分支： `git branch`\n\n查看带提交信息的分支信息： `git branch -v`\n\n创建分支： `git branch <分支名称>`\n\n创建并切换分支： `git branch -b <分支名称>`\n\n切换分支： `git checkout <分支名称>`\n\n推送分支： `git push origin <分支名称>`\n\n删除分支： `git branch -d <分支名称>`\n\n删除远程分支： `git push origin :<分支名称>`\n\n合并分支： `git merge <分支名称>`\n\n\n\n> git push\n\n推送本地修改到远端服务器\n\n`git push origin master`\n\n有时因两个独立的历史，会导致推送无法达成， 通常在 `git pull` 时会提示 `fatal: refusing to merge unrelated histories  // 拒绝合并无关历史`\n\n这时可是使用 `git pull origin master --allow-unrelated-histories ` 来解决。\n\n\n\n> git tag \n\n会列出所有的 `tag` 标签信息\n\n在完成了所有功能、并且经过测试之后，可以封板上线的版本，通常会打一个标签，***这是一个很重要的功能*** \n\n建议每次上线都要做一次，便于后续的版本检索与维护，通常一个标签就代表了一个正式版本。\n\n查看本地/远程 tag 标签：`git tag`\n\n查看模糊 tag 标签： `git tag -l 'v1.4.2.*'`\n\n查看备注 tag 标签： `git tag -ln`\n\n\n查看标签信息： `git show <标签名>`\n\n\n创建本地 tag 标签： `git tag -a <标签名> -m \"<标签备注信息>\"`\n\n删除本地 tag 标签： `git tag -d <标签名>`\n\n\n推送远程 tag 标签： `git push origin <标签名>`\n\n推送全部 tag 标签： `git push origin -tags`\n\n删除远程 tag 标签： `git push origin :refs/tags/<标签名>`\n\n\n**查看远程机状态**\n> git remote 用来管理， fork 的项目，与主项目的更新操作\n\n```\ngit remote -v\ngit remote add upstream git@github.com:XXX/XXX.git\ngit fetch upstream\ngit merge upstream/master\ngit push\n```\n\n## 使用中的一些技巧\n\n**命名别名**\n复杂并超长的命令，可以通过起别名的方式方便在终端中书协\n\n```\ngit config --global alias.ci commit\ngit config --global alias.ck checkout\ngit config --global alias.st status\n```\n\n然后就可以很愉快的使用git命令了。\n```\ngit st\n```\n\n","source":"_posts/Tools/git-command.md","raw":"---\ntitle: git command\ndate: 2019-04-16 17:43:58\ntags: Git\n---\n\n# Git 命令\n\n|     修改记录     |        修改时间        |                  备注                  |\n| :--------------: | :--------------------: | :------------------------------------: |\n| 添加删除远程分支 | 2018年07月26日13:59:22 |            删除远程分支命令            |\n|   更新fork仓库   | 2018年08月10日14:16:08 | 添加fork的仓库，从主仓库更新代码的命令 |\n\n\n整理的还不够完善，以后工作中遇到了会不断补进，如有大神，有可以留言，我们一起来完善。欢迎各位留言^_^\n\n<!--more-->\n\n## Git 文件的三种状态\n\n1. 已提交：表示该文件已经被安全地保存在本地版本库中，执行过git commit。\n2. 已修改：表示修改了某个文件，但还没有提交保存\n3. 已暂存：表示把已修改的文件房子啊下次提交时要保存的清单中，也就是执行了 git add 命令。\n\n## 远程仓库与本地代码的配置\n\n将本地已经有的项目上传到远程空仓库中\n\n``` git\ncd <project path>\ngit init\ngit remote add origin <远程仓库地址>\ngit add .\ngit commit -m '提交日志'\ngit push -u origin master\n```\n\n## Git 基本配置\n\n1. 配置个人的用户名称和电子邮件地址，每次提交时，都会引用这两条信息，以用来说明是谁提交的更新。\n\n\n使用 `--global` 选项，更改的未用户主目录下的配置，如果想在某个特定的项目中使用其他的名称和邮件，只需要去掉 `--global` 选项重新配置，新的配置位于当前项目的 `.git/config` 文件中。\n\n```git\n git config --global user.name ''yourname''\n git config --global user.email  yourname@gmail.com\n```\n\n2. 基础命令\n\n> git init\n\n通过此命令会在当前目录创建一个`.git`的隐藏目录，这是`git`的第一步。\n\n> git status\n\n`git status`是最为常用的命令之一，用于检查本地项目的状态.仔细阅读红色/绿色部分，可以获得相关文件的操作信息，根据提示，判断是执行`git commit` 还是执行`git add` 操作。\n\n\n> git add\n\n将一个或多个文件添加到 `git`仓库中，只有通过 `git add` 添加的文件才会被版本控制管理。\n\n添加单个文件 `git add HelloWorld2.java`\n\n添加多个文件 `git add --a`\n\n添加当前目录所有文件 `git add .`\n\n\n> git rm --cached <file>\n\n将文件从`git`追踪列表中移除，只是逻辑删除（从版本库中移除），并不会将本地文件删除\n\n> git commit\n\n执行过 `git add` 命令后，需要将暂存的文件提交到本地仓库中，此时是真正的提交\n\n带 log 的提交： `git commit -m 'first commit'`\n\n通过编辑器提交: `git commit `\n\n带log 的提交比较方便，但当你的提交信息有一定格式或者需要提交的文字内容较多时，使用编辑器效果会更好.\n\n\n> git log\n\n查看历史提交记录， 包括**提交人**、**时间**、**信息**、**信息指纹**等.\n\n查看提交记录： `git log`\n\n单行展示记录： `git log --pretty=oneline`\n\n展示全部信息： `git log --pretty=fuller`\n\n\n> git clone <远程仓库地址>\n\n拉取远程仓库代码,此项目并不一定是你所创建\n\n例如： `git clone git@github.com:bboyfeiyu/AndroidEventBus.git`\n\n执行完成后，会在本地当前目录创建一个AndroidEventBus的目录来存放仓库代码\n\n> git remote\n\n将本地已经`init`过的工程链接到远程的空仓库中，以此来完成远程版本库的创建\n\n链接远程版本库： `git remote add origin <远程地址>`\n\n\n> git remote set-url <仓库地址>\n\nSSH 和 HTTPS 方式切换\n\n\n```git\n# ssh to https\n$ git remote set-url origin https://github.com/USERNAME/repository.git\n# https to ssh\n$ git remote set-url origin git@github.com:USERNAME/repository.git\n```\n\n可以使用 `git remote -v` 来检查当前仓库地址\n\n```\n> origin git@github.com:username/repository.git (fetch)\n> origin git@github.com:username/repository.git (push)\n```\n\nSSH 和 HTTPS 的区别：\n\n使用 SSH 方式需要在本地配置一个密钥，具体可参见[多个 SSH 公钥提交代码到不同平台](https://xiaoman.ren/2019/04/17/%E5%A4%9A%E4%B8%AA-ssh-%E5%85%AC%E9%92%A5%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%88%B0%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0/)中介绍；\n而使用 HTTPS 的方式操作简单，弊端是需要经常输入密码。\n\n\n> git branch\n\n分支是用来管理代码版本、类型的有效工具，可根据不同的服务对象、不同的上线版本等等，来做代码分离，版本管理操作\n\n查看分支： `git branch`\n\n查看带提交信息的分支信息： `git branch -v`\n\n创建分支： `git branch <分支名称>`\n\n创建并切换分支： `git branch -b <分支名称>`\n\n切换分支： `git checkout <分支名称>`\n\n推送分支： `git push origin <分支名称>`\n\n删除分支： `git branch -d <分支名称>`\n\n删除远程分支： `git push origin :<分支名称>`\n\n合并分支： `git merge <分支名称>`\n\n\n\n> git push\n\n推送本地修改到远端服务器\n\n`git push origin master`\n\n有时因两个独立的历史，会导致推送无法达成， 通常在 `git pull` 时会提示 `fatal: refusing to merge unrelated histories  // 拒绝合并无关历史`\n\n这时可是使用 `git pull origin master --allow-unrelated-histories ` 来解决。\n\n\n\n> git tag \n\n会列出所有的 `tag` 标签信息\n\n在完成了所有功能、并且经过测试之后，可以封板上线的版本，通常会打一个标签，***这是一个很重要的功能*** \n\n建议每次上线都要做一次，便于后续的版本检索与维护，通常一个标签就代表了一个正式版本。\n\n查看本地/远程 tag 标签：`git tag`\n\n查看模糊 tag 标签： `git tag -l 'v1.4.2.*'`\n\n查看备注 tag 标签： `git tag -ln`\n\n\n查看标签信息： `git show <标签名>`\n\n\n创建本地 tag 标签： `git tag -a <标签名> -m \"<标签备注信息>\"`\n\n删除本地 tag 标签： `git tag -d <标签名>`\n\n\n推送远程 tag 标签： `git push origin <标签名>`\n\n推送全部 tag 标签： `git push origin -tags`\n\n删除远程 tag 标签： `git push origin :refs/tags/<标签名>`\n\n\n**查看远程机状态**\n> git remote 用来管理， fork 的项目，与主项目的更新操作\n\n```\ngit remote -v\ngit remote add upstream git@github.com:XXX/XXX.git\ngit fetch upstream\ngit merge upstream/master\ngit push\n```\n\n## 使用中的一些技巧\n\n**命名别名**\n复杂并超长的命令，可以通过起别名的方式方便在终端中书协\n\n```\ngit config --global alias.ci commit\ngit config --global alias.ck checkout\ngit config --global alias.st status\n```\n\n然后就可以很愉快的使用git命令了。\n```\ngit st\n```\n\n","slug":"Tools/git-command","published":1,"updated":"2021-01-29T15:54:28.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8fi0028sz5q4peid6fx","content":"<h1 id=\"Git-命令\"><a href=\"#Git-命令\" class=\"headerlink\" title=\"Git 命令\"></a>Git 命令</h1><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">修改记录</th>\n<th style=\"text-align:center\">修改时间</th>\n<th style=\"text-align:center\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">添加删除远程分支</td>\n<td style=\"text-align:center\">2018年07月26日13:59:22</td>\n<td style=\"text-align:center\">删除远程分支命令</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">更新fork仓库</td>\n<td style=\"text-align:center\">2018年08月10日14:16:08</td>\n<td style=\"text-align:center\">添加fork的仓库，从主仓库更新代码的命令</td>\n</tr>\n</tbody>\n</table>\n<p>整理的还不够完善，以后工作中遇到了会不断补进，如有大神，有可以留言，我们一起来完善。欢迎各位留言^_^</p>\n<a id=\"more\"></a>\n<h2 id=\"Git-文件的三种状态\"><a href=\"#Git-文件的三种状态\" class=\"headerlink\" title=\"Git 文件的三种状态\"></a>Git 文件的三种状态</h2><ol>\n<li>已提交：表示该文件已经被安全地保存在本地版本库中，执行过git commit。</li>\n<li>已修改：表示修改了某个文件，但还没有提交保存</li>\n<li>已暂存：表示把已修改的文件房子啊下次提交时要保存的清单中，也就是执行了 git add 命令。</li>\n</ol>\n<h2 id=\"远程仓库与本地代码的配置\"><a href=\"#远程仓库与本地代码的配置\" class=\"headerlink\" title=\"远程仓库与本地代码的配置\"></a>远程仓库与本地代码的配置</h2><p>将本地已经有的项目上传到远程空仓库中</p>\n<pre class=\" language-git\"><code class=\"language-git\">cd &lt;project path>\ngit init\ngit remote add origin &lt;远程仓库地址>\ngit add .\ngit commit -m <span class=\"token string\">'提交日志'</span>\ngit push -u origin master\n</code></pre>\n<h2 id=\"Git-基本配置\"><a href=\"#Git-基本配置\" class=\"headerlink\" title=\"Git 基本配置\"></a>Git 基本配置</h2><ol>\n<li>配置个人的用户名称和电子邮件地址，每次提交时，都会引用这两条信息，以用来说明是谁提交的更新。</li>\n</ol>\n<p>使用 <code>--global</code> 选项，更改的未用户主目录下的配置，如果想在某个特定的项目中使用其他的名称和邮件，只需要去掉 <code>--global</code> 选项重新配置，新的配置位于当前项目的 <code>.git/config</code> 文件中。</p>\n<pre class=\" language-git\"><code class=\"language-git\"> git config --global user.name <span class=\"token string\">''</span>yourname<span class=\"token string\">''</span>\n git config --global user.email  yourname@gmail.com\n</code></pre>\n<ol start=\"2\">\n<li>基础命令</li>\n</ol>\n<blockquote>\n<p>git init</p>\n</blockquote>\n<p>通过此命令会在当前目录创建一个<code>.git</code>的隐藏目录，这是<code>git</code>的第一步。</p>\n<blockquote>\n<p>git status</p>\n</blockquote>\n<p><code>git status</code>是最为常用的命令之一，用于检查本地项目的状态.仔细阅读红色/绿色部分，可以获得相关文件的操作信息，根据提示，判断是执行<code>git commit</code> 还是执行<code>git add</code> 操作。</p>\n<blockquote>\n<p>git add</p>\n</blockquote>\n<p>将一个或多个文件添加到 <code>git</code>仓库中，只有通过 <code>git add</code> 添加的文件才会被版本控制管理。</p>\n<p>添加单个文件 <code>git add HelloWorld2.java</code></p>\n<p>添加多个文件 <code>git add --a</code></p>\n<p>添加当前目录所有文件 <code>git add .</code></p>\n<blockquote>\n<p>git rm –cached <file></file></p>\n</blockquote>\n<p>将文件从<code>git</code>追踪列表中移除，只是逻辑删除（从版本库中移除），并不会将本地文件删除</p>\n<blockquote>\n<p>git commit</p>\n</blockquote>\n<p>执行过 <code>git add</code> 命令后，需要将暂存的文件提交到本地仓库中，此时是真正的提交</p>\n<p>带 log 的提交： <code>git commit -m &#39;first commit&#39;</code></p>\n<p>通过编辑器提交: <code>git commit</code></p>\n<p>带log 的提交比较方便，但当你的提交信息有一定格式或者需要提交的文字内容较多时，使用编辑器效果会更好.</p>\n<blockquote>\n<p>git log</p>\n</blockquote>\n<p>查看历史提交记录， 包括<strong>提交人</strong>、<strong>时间</strong>、<strong>信息</strong>、<strong>信息指纹</strong>等.</p>\n<p>查看提交记录： <code>git log</code></p>\n<p>单行展示记录： <code>git log --pretty=oneline</code></p>\n<p>展示全部信息： <code>git log --pretty=fuller</code></p>\n<blockquote>\n<p>git clone &lt;远程仓库地址&gt;</p>\n</blockquote>\n<p>拉取远程仓库代码,此项目并不一定是你所创建</p>\n<p>例如： <code>git clone git@github.com:bboyfeiyu/AndroidEventBus.git</code></p>\n<p>执行完成后，会在本地当前目录创建一个AndroidEventBus的目录来存放仓库代码</p>\n<blockquote>\n<p>git remote</p>\n</blockquote>\n<p>将本地已经<code>init</code>过的工程链接到远程的空仓库中，以此来完成远程版本库的创建</p>\n<p>链接远程版本库： <code>git remote add origin &lt;远程地址&gt;</code></p>\n<blockquote>\n<p>git remote set-url &lt;仓库地址&gt;</p>\n</blockquote>\n<p>SSH 和 HTTPS 方式切换</p>\n<pre class=\" language-git\"><code class=\"language-git\"><span class=\"token comment\" spellcheck=\"true\"># ssh to https</span>\n<span class=\"token command\">$ git remote set-url origin https://github.com/USERNAME/repository.git</span>\n<span class=\"token comment\" spellcheck=\"true\"># https to ssh</span>\n<span class=\"token command\">$ git remote set-url origin git@github.com:USERNAME/repository.git</span>\n</code></pre>\n<p>可以使用 <code>git remote -v</code> 来检查当前仓库地址</p>\n<pre><code>&gt; origin git@github.com:username/repository.git (fetch)\n&gt; origin git@github.com:username/repository.git (push)\n</code></pre><p>SSH 和 HTTPS 的区别：</p>\n<p>使用 SSH 方式需要在本地配置一个密钥，具体可参见<a href=\"https://xiaoman.ren/2019/04/17/%E5%A4%9A%E4%B8%AA-ssh-%E5%85%AC%E9%92%A5%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%88%B0%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0/\">多个 SSH 公钥提交代码到不同平台</a>中介绍；<br>而使用 HTTPS 的方式操作简单，弊端是需要经常输入密码。</p>\n<blockquote>\n<p>git branch</p>\n</blockquote>\n<p>分支是用来管理代码版本、类型的有效工具，可根据不同的服务对象、不同的上线版本等等，来做代码分离，版本管理操作</p>\n<p>查看分支： <code>git branch</code></p>\n<p>查看带提交信息的分支信息： <code>git branch -v</code></p>\n<p>创建分支： <code>git branch &lt;分支名称&gt;</code></p>\n<p>创建并切换分支： <code>git branch -b &lt;分支名称&gt;</code></p>\n<p>切换分支： <code>git checkout &lt;分支名称&gt;</code></p>\n<p>推送分支： <code>git push origin &lt;分支名称&gt;</code></p>\n<p>删除分支： <code>git branch -d &lt;分支名称&gt;</code></p>\n<p>删除远程分支： <code>git push origin :&lt;分支名称&gt;</code></p>\n<p>合并分支： <code>git merge &lt;分支名称&gt;</code></p>\n<blockquote>\n<p>git push</p>\n</blockquote>\n<p>推送本地修改到远端服务器</p>\n<p><code>git push origin master</code></p>\n<p>有时因两个独立的历史，会导致推送无法达成， 通常在 <code>git pull</code> 时会提示 <code>fatal: refusing to merge unrelated histories  // 拒绝合并无关历史</code></p>\n<p>这时可是使用 <code>git pull origin master --allow-unrelated-histories</code> 来解决。</p>\n<blockquote>\n<p>git tag </p>\n</blockquote>\n<p>会列出所有的 <code>tag</code> 标签信息</p>\n<p>在完成了所有功能、并且经过测试之后，可以封板上线的版本，通常会打一个标签，<strong><em>这是一个很重要的功能</em></strong> </p>\n<p>建议每次上线都要做一次，便于后续的版本检索与维护，通常一个标签就代表了一个正式版本。</p>\n<p>查看本地/远程 tag 标签：<code>git tag</code></p>\n<p>查看模糊 tag 标签： <code>git tag -l &#39;v1.4.2.*&#39;</code></p>\n<p>查看备注 tag 标签： <code>git tag -ln</code></p>\n<p>查看标签信息： <code>git show &lt;标签名&gt;</code></p>\n<p>创建本地 tag 标签： <code>git tag -a &lt;标签名&gt; -m &quot;&lt;标签备注信息&gt;&quot;</code></p>\n<p>删除本地 tag 标签： <code>git tag -d &lt;标签名&gt;</code></p>\n<p>推送远程 tag 标签： <code>git push origin &lt;标签名&gt;</code></p>\n<p>推送全部 tag 标签： <code>git push origin -tags</code></p>\n<p>删除远程 tag 标签： <code>git push origin :refs/tags/&lt;标签名&gt;</code></p>\n<p><strong>查看远程机状态</strong></p>\n<blockquote>\n<p>git remote 用来管理， fork 的项目，与主项目的更新操作</p>\n</blockquote>\n<pre><code>git remote -v\ngit remote add upstream git@github.com:XXX/XXX.git\ngit fetch upstream\ngit merge upstream/master\ngit push\n</code></pre><h2 id=\"使用中的一些技巧\"><a href=\"#使用中的一些技巧\" class=\"headerlink\" title=\"使用中的一些技巧\"></a>使用中的一些技巧</h2><p><strong>命名别名</strong><br>复杂并超长的命令，可以通过起别名的方式方便在终端中书协</p>\n<pre><code>git config --global alias.ci commit\ngit config --global alias.ck checkout\ngit config --global alias.st status\n</code></pre><p>然后就可以很愉快的使用git命令了。</p>\n<pre><code>git st\n</code></pre>","site":{"data":{}},"excerpt":"<h1 id=\"Git-命令\"><a href=\"#Git-命令\" class=\"headerlink\" title=\"Git 命令\"></a>Git 命令</h1><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">修改记录</th>\n<th style=\"text-align:center\">修改时间</th>\n<th style=\"text-align:center\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">添加删除远程分支</td>\n<td style=\"text-align:center\">2018年07月26日13:59:22</td>\n<td style=\"text-align:center\">删除远程分支命令</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">更新fork仓库</td>\n<td style=\"text-align:center\">2018年08月10日14:16:08</td>\n<td style=\"text-align:center\">添加fork的仓库，从主仓库更新代码的命令</td>\n</tr>\n</tbody>\n</table>\n<p>整理的还不够完善，以后工作中遇到了会不断补进，如有大神，有可以留言，我们一起来完善。欢迎各位留言^_^</p>","more":"<h2 id=\"Git-文件的三种状态\"><a href=\"#Git-文件的三种状态\" class=\"headerlink\" title=\"Git 文件的三种状态\"></a>Git 文件的三种状态</h2><ol>\n<li>已提交：表示该文件已经被安全地保存在本地版本库中，执行过git commit。</li>\n<li>已修改：表示修改了某个文件，但还没有提交保存</li>\n<li>已暂存：表示把已修改的文件房子啊下次提交时要保存的清单中，也就是执行了 git add 命令。</li>\n</ol>\n<h2 id=\"远程仓库与本地代码的配置\"><a href=\"#远程仓库与本地代码的配置\" class=\"headerlink\" title=\"远程仓库与本地代码的配置\"></a>远程仓库与本地代码的配置</h2><p>将本地已经有的项目上传到远程空仓库中</p>\n<pre><code class=\"git\">cd &lt;project path&gt;\ngit init\ngit remote add origin &lt;远程仓库地址&gt;\ngit add .\ngit commit -m &#39;提交日志&#39;\ngit push -u origin master\n</code></pre>\n<h2 id=\"Git-基本配置\"><a href=\"#Git-基本配置\" class=\"headerlink\" title=\"Git 基本配置\"></a>Git 基本配置</h2><ol>\n<li>配置个人的用户名称和电子邮件地址，每次提交时，都会引用这两条信息，以用来说明是谁提交的更新。</li>\n</ol>\n<p>使用 <code>--global</code> 选项，更改的未用户主目录下的配置，如果想在某个特定的项目中使用其他的名称和邮件，只需要去掉 <code>--global</code> 选项重新配置，新的配置位于当前项目的 <code>.git/config</code> 文件中。</p>\n<pre><code class=\"git\"> git config --global user.name &#39;&#39;yourname&#39;&#39;\n git config --global user.email  yourname@gmail.com\n</code></pre>\n<ol start=\"2\">\n<li>基础命令</li>\n</ol>\n<blockquote>\n<p>git init</p>\n</blockquote>\n<p>通过此命令会在当前目录创建一个<code>.git</code>的隐藏目录，这是<code>git</code>的第一步。</p>\n<blockquote>\n<p>git status</p>\n</blockquote>\n<p><code>git status</code>是最为常用的命令之一，用于检查本地项目的状态.仔细阅读红色/绿色部分，可以获得相关文件的操作信息，根据提示，判断是执行<code>git commit</code> 还是执行<code>git add</code> 操作。</p>\n<blockquote>\n<p>git add</p>\n</blockquote>\n<p>将一个或多个文件添加到 <code>git</code>仓库中，只有通过 <code>git add</code> 添加的文件才会被版本控制管理。</p>\n<p>添加单个文件 <code>git add HelloWorld2.java</code></p>\n<p>添加多个文件 <code>git add --a</code></p>\n<p>添加当前目录所有文件 <code>git add .</code></p>\n<blockquote>\n<p>git rm –cached <file></file></p>\n</blockquote>\n<p>将文件从<code>git</code>追踪列表中移除，只是逻辑删除（从版本库中移除），并不会将本地文件删除</p>\n<blockquote>\n<p>git commit</p>\n</blockquote>\n<p>执行过 <code>git add</code> 命令后，需要将暂存的文件提交到本地仓库中，此时是真正的提交</p>\n<p>带 log 的提交： <code>git commit -m &#39;first commit&#39;</code></p>\n<p>通过编辑器提交: <code>git commit</code></p>\n<p>带log 的提交比较方便，但当你的提交信息有一定格式或者需要提交的文字内容较多时，使用编辑器效果会更好.</p>\n<blockquote>\n<p>git log</p>\n</blockquote>\n<p>查看历史提交记录， 包括<strong>提交人</strong>、<strong>时间</strong>、<strong>信息</strong>、<strong>信息指纹</strong>等.</p>\n<p>查看提交记录： <code>git log</code></p>\n<p>单行展示记录： <code>git log --pretty=oneline</code></p>\n<p>展示全部信息： <code>git log --pretty=fuller</code></p>\n<blockquote>\n<p>git clone &lt;远程仓库地址&gt;</p>\n</blockquote>\n<p>拉取远程仓库代码,此项目并不一定是你所创建</p>\n<p>例如： <code>git clone git@github.com:bboyfeiyu/AndroidEventBus.git</code></p>\n<p>执行完成后，会在本地当前目录创建一个AndroidEventBus的目录来存放仓库代码</p>\n<blockquote>\n<p>git remote</p>\n</blockquote>\n<p>将本地已经<code>init</code>过的工程链接到远程的空仓库中，以此来完成远程版本库的创建</p>\n<p>链接远程版本库： <code>git remote add origin &lt;远程地址&gt;</code></p>\n<blockquote>\n<p>git remote set-url &lt;仓库地址&gt;</p>\n</blockquote>\n<p>SSH 和 HTTPS 方式切换</p>\n<pre><code class=\"git\"># ssh to https\n$ git remote set-url origin https://github.com/USERNAME/repository.git\n# https to ssh\n$ git remote set-url origin git@github.com:USERNAME/repository.git\n</code></pre>\n<p>可以使用 <code>git remote -v</code> 来检查当前仓库地址</p>\n<pre><code>&gt; origin git@github.com:username/repository.git (fetch)\n&gt; origin git@github.com:username/repository.git (push)\n</code></pre><p>SSH 和 HTTPS 的区别：</p>\n<p>使用 SSH 方式需要在本地配置一个密钥，具体可参见<a href=\"https://xiaoman.ren/2019/04/17/%E5%A4%9A%E4%B8%AA-ssh-%E5%85%AC%E9%92%A5%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%88%B0%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0/\">多个 SSH 公钥提交代码到不同平台</a>中介绍；<br>而使用 HTTPS 的方式操作简单，弊端是需要经常输入密码。</p>\n<blockquote>\n<p>git branch</p>\n</blockquote>\n<p>分支是用来管理代码版本、类型的有效工具，可根据不同的服务对象、不同的上线版本等等，来做代码分离，版本管理操作</p>\n<p>查看分支： <code>git branch</code></p>\n<p>查看带提交信息的分支信息： <code>git branch -v</code></p>\n<p>创建分支： <code>git branch &lt;分支名称&gt;</code></p>\n<p>创建并切换分支： <code>git branch -b &lt;分支名称&gt;</code></p>\n<p>切换分支： <code>git checkout &lt;分支名称&gt;</code></p>\n<p>推送分支： <code>git push origin &lt;分支名称&gt;</code></p>\n<p>删除分支： <code>git branch -d &lt;分支名称&gt;</code></p>\n<p>删除远程分支： <code>git push origin :&lt;分支名称&gt;</code></p>\n<p>合并分支： <code>git merge &lt;分支名称&gt;</code></p>\n<blockquote>\n<p>git push</p>\n</blockquote>\n<p>推送本地修改到远端服务器</p>\n<p><code>git push origin master</code></p>\n<p>有时因两个独立的历史，会导致推送无法达成， 通常在 <code>git pull</code> 时会提示 <code>fatal: refusing to merge unrelated histories  // 拒绝合并无关历史</code></p>\n<p>这时可是使用 <code>git pull origin master --allow-unrelated-histories</code> 来解决。</p>\n<blockquote>\n<p>git tag </p>\n</blockquote>\n<p>会列出所有的 <code>tag</code> 标签信息</p>\n<p>在完成了所有功能、并且经过测试之后，可以封板上线的版本，通常会打一个标签，<strong><em>这是一个很重要的功能</em></strong> </p>\n<p>建议每次上线都要做一次，便于后续的版本检索与维护，通常一个标签就代表了一个正式版本。</p>\n<p>查看本地/远程 tag 标签：<code>git tag</code></p>\n<p>查看模糊 tag 标签： <code>git tag -l &#39;v1.4.2.*&#39;</code></p>\n<p>查看备注 tag 标签： <code>git tag -ln</code></p>\n<p>查看标签信息： <code>git show &lt;标签名&gt;</code></p>\n<p>创建本地 tag 标签： <code>git tag -a &lt;标签名&gt; -m &quot;&lt;标签备注信息&gt;&quot;</code></p>\n<p>删除本地 tag 标签： <code>git tag -d &lt;标签名&gt;</code></p>\n<p>推送远程 tag 标签： <code>git push origin &lt;标签名&gt;</code></p>\n<p>推送全部 tag 标签： <code>git push origin -tags</code></p>\n<p>删除远程 tag 标签： <code>git push origin :refs/tags/&lt;标签名&gt;</code></p>\n<p><strong>查看远程机状态</strong></p>\n<blockquote>\n<p>git remote 用来管理， fork 的项目，与主项目的更新操作</p>\n</blockquote>\n<pre><code>git remote -v\ngit remote add upstream git@github.com:XXX/XXX.git\ngit fetch upstream\ngit merge upstream/master\ngit push\n</code></pre><h2 id=\"使用中的一些技巧\"><a href=\"#使用中的一些技巧\" class=\"headerlink\" title=\"使用中的一些技巧\"></a>使用中的一些技巧</h2><p><strong>命名别名</strong><br>复杂并超长的命令，可以通过起别名的方式方便在终端中书协</p>\n<pre><code>git config --global alias.ci commit\ngit config --global alias.ck checkout\ngit config --global alias.st status\n</code></pre><p>然后就可以很愉快的使用git命令了。</p>\n<pre><code>git st\n</code></pre>"},{"title":"Glide","_content":"\n\n\nGlide 作为广为熟知的图片加载框架，在开发工作中出现的频率非常高，同比的还有 `Picasso` 和 `ImageLoader` 两套框架。 都各有特色。这里主要还是讲一下 `Glide` 。\n<!-- more-->\n**基础用法：**\n\n```java\nGlide.with(this).load(url).into(imageView);\n```\n\n在 Android 开发中，我们通常最简单的使用 `Glide` 的 代码如上面一样，如此简单的 api, 就可以帮助我们实现加载本地图片，本地 Drawable ， Gif 图，以及 网络图片，那么在这样简单的 API 的背后，其实它帮助了我们完成了很多工作。\n\n从简单的使用我们入手，可以看到，要想加载一张图片，我们需要一个当前上下文对象，一个图片地址，一个承载图像的 ImageView 容器。那中三个要求，又同时对应着三个函数，`with` `load` 和 `into`，阅读源码，那就是从源码暴漏给我们最直观的地方进入，不然就是一只没头的苍蝇—到处乱飞。\n\n| 函数 |                           主要功能                           |\n| :--: | :----------------------------------------------------------: |\n| with | 1. 初始化Glide对象<br />2. 创建空白的 Fragment 管理生命周期机制<br />3. 创建一个 RequestManager 管理任务 |\n| load |          最终构建出 RequestBuilder ，记录传入的数据          |\n| into | 1. runRequest 运行队列/等待队列，执行队列 Reqeust 对象<br />2. 活动缓存<br />3. 内存缓存<br />4. HttpUrlConnection |\n\n## 工作流程\n\n`Glide` 通过 `with` 函数，给自己的实例化，并创建一个空白的 `Fragment` 来管理生命周期并绑定 `ReqeustManager` 。继续通过 `load() ` 函数构建一个 `RequestBuilder()` 并缓存我们的参数，继续通过 `into` 创建一个 `Request` 对象，并记录宽高、采样数据等。继续，在发起请求之前，先检查一下缓存数据, 活动缓存 `ActivityResources` 有没有数据，再检查内存缓存 `LRUResourceCache` ，如果两级缓存都未命中，则启动一个异步任务 `DecodeJob`, 去检查 `DiskCache` 中有没有本地磁盘缓存数据，如果没有，通过网络请求数据 `HttpUrlConnection` ，解析 `InputStream` 进行采样，最终拿到 `Bitmap`，将 `Bitmap` 转换成 `Drawable` 并讲数据缓存到磁盘中。\n\n## with\n\n从上面的表格中，我们可以看出来 `with` 函数，就是用来帮我创建 `Glide` 对象，并创建一个空白的 `Fragment` 来管理生命周期。其具体的工作流程如图：\n\n![Glide with 时序图](https://github.com/xiaomanwong/static_file/blob/master/images/glide_with_sequence.jpg?raw=true)\n\n由上面的时序图，我们可以顺序的分析，我们一步步去分析。\n\n**Glide.with()**\n\n`Glide.with()` 为提供了多种重构函数，目的是为我们提供它强大的作用域以及满足我们开发过程中各种复杂的情况。同时适配不同版本以及不同的应用场景。\n\n```java\n@NonNull\npublic static RequestManager with(@NonNull Context context) {\n    return getRetriever(context).get(context);\n}\n\n@NonNull\npublic static RequestManager with(@NonNull Activity activity) {\n    return getRetriever(activity).get(activity);\n}\n\n@NonNull\npublic static RequestManager with(@NonNull FragmentActivity activity) {\n    return getRetriever(activity).get(activity);\n}\n\n@NonNull\npublic static RequestManager with(@NonNull Fragment fragment) {\n    return getRetriever(fragment.getContext()).get(fragment);\n}\n\n@NonNull\npublic static RequestManager with(@NonNull android.app.Fragment fragment) {\n    return getRetriever(fragment.getActivity()).get(fragment);\n}\n\n@NonNull\npublic static RequestManager with(@NonNull View view) {\n    return getRetriever(view.getContext()).get(view);\n}\n```\n\n**getRetriever**()\n\n`getRetriever()` 通过 Glide 的 get 函数，帮我们初始化了一个 `Glide` 对象。\n\n```java\n@NonNull\nprivate static RequestManagerRetriever getRetriever(@Nullable Context context) {\n    return Glide.get(context).getRequestManagerRetriever();\n}\n```\n\n**get(context)**\n\n可以看出，Glide 是一个单例的，向下看时，我们也可看到，对 Glide 的检查很严谨。\n\n```java\nprivate static volatile Glide glide;\n@NonNull\npublic static Glide get(@NonNull Context context) {\n    if (glide == null) {\n        synchronized (Glide.class) {\n            if (glide == null) {\n                checkAndInitializeGlide(context, annotationGeneratedModule);\n            }\n        }\n    }\n    return glide;\n}\n```\n\n**checkAndInitializeGlide() & initializeGlide()**\n\n最终通过构造者模式，完成了对 `Glide` 对象的初始化，同时在构造者中，也对很多 `Glide` 工作时需要的对象进行了初始化。我们这里只研究主线业务，其它的可以私下看。\n\n```java\nprivate static void checkAndInitializeGlide(\n    if (isInitializing) {\n        throw new IllegalStateException(\n            \"You cannot call Glide.get() in registerComponents(),\"\n            + \" use the provided Glide instance instead\");\n    }\n    isInitializing = true;\n    initializeGlide(context, generatedAppGlideModule);\n    isInitializing = false;\n}\nprivate static void initializeGlide(Context context, GlideBuilder builder, GeneratedAppGlideModule annotationGeneratedModule) {\n    Glide glide = builder.build(applicationContext);\n    Glide.glide = glide;\n}\n```\n\n到这里， `Glide` 的初始化工作已经完成，具体初始化了什么信息，细节的东西，自己需要去认真的阅读源码。\n\n并且代码按照流程，`get()` 的深度代码已经完成，程序会逐步回到 `getRetriever()` 函数中，去执行 `getRequestManagerRetriever` ， `getRequestManagerRetriever` ` 是通过 `Glide 的构造器完成的初始化工作，此时直接返回已经创建好的对象。并继续执行 `with()`函数 的 `get()` 去创建 `RequestManager`\n\n**get(Fragment fragment)**\n\n这时候，我们发现，现在代码已经跳转到 `RequestManagerRetriever` 类中\n\n**RequestManagerRetriever**\n\n`RequestManagerRetriever` 是一个管理类，负责生产 `Fragment` 对象，根据我们传入的 `Context` 上下文的定义不同，最终会帮我们创建不同的生命周期管理。\n\n```java\n  @NonNull\n  public RequestManager get(@NonNull Fragment fragment) {\n    if (Util.isOnBackgroundThread()) {\n        // 创建一个全局作用域的 RequestManager，生命周期很长，容易出现内存问题\n      return get(fragment.getContext().getApplicationContext());\n    } else {\n      FragmentManager fm = fragment.getChildFragmentManager();\n      return supportFragmentGet(fragment.getContext(), fm, fragment, fragment.isVisible());\n    }\n  }\n\n  public RequestManager get(@NonNull Context context) {\n    if (context == null) {\n      throw new IllegalArgumentException(\"You cannot start a load on a null Context\");\n    } else if (Util.isOnMainThread() && !(context instanceof Application)) {\n      if (context instanceof FragmentActivity) {\n        return get((FragmentActivity) context);\n      } else if (context instanceof Activity) {\n        return get((Activity) context);\n      } else if (context instanceof ContextWrapper\n          && ((ContextWrapper) context).getBaseContext().getApplicationContext() != null) {\n        return get(((ContextWrapper) context).getBaseContext());\n      }\n    }\n         // 创建一个全局作用域的 RequestManager，生命周期很长，容易出现内存问题\n      return getApplicationManager(context);\n  }\n```\n\n> **Note:**\n>\n> 1. **如果当前任务工作在后台线程或者传入的 `Context` 对象是一个 `Application` 级别的，那 `Glide` 就会帮我们创建一个和 `Application` 同生命周期的 `RequestManager` 对象，这个对象生命周期很长， 如果我们不规范使用的话，这里很容易造成<font color=red>内存的泄漏</font>**。 因此我们使用时，尽量不要传入里类似的。\n>\n> 2. 如果我们传入的是一个 Fragment 对象， Activity 对象等等，那 `Glide` 就会帮我们创建个空白的 `Fragment`， `supportFragmentGet` 和  `fragmentGet` 两种方案是用来做 `androidX` 和 `android.app`中不同 `fragment` 的适配\n\n**supportFragmentGet**\n\n创建管理生命周期的 Fragment, `androidx` 对应的是 `supportFragmentGet()` ， `android.app` 对应的是 `fragmentGet()`， 这里以 `supportFragmentGet()` 为例：\n\n```java\n  @NonNull\n  private RequestManager supportFragmentGet(\n      @NonNull Context context,\n      @NonNull FragmentManager fm,\n      @Nullable Fragment parentHint,\n      boolean isParentVisible) {\n      // 创建/获取当前空白的 Fragment\n    SupportRequestManagerFragment current =\n        getSupportRequestManagerFragment(fm, parentHint, isParentVisible);\n      // 获取空白 Fragment 中的 RequestManager 对象\n      // 如果为空，那么就通过工厂创建一个，并绑定回空白的 Fragment 中\n    RequestManager requestManager = current.getRequestManager();\n    if (requestManager == null) {\n      Glide glide = Glide.get(context);\n      requestManager =\n          factory.build(\n              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);\n      current.setRequestManager(requestManager);\n    }\n      // 返回 reqeustManager 对象\n    return requestManager;\n  }\n\n  @NonNull\n  private SupportRequestManagerFragment getSupportRequestManagerFragment(\n      @NonNull final FragmentManager fm, @Nullable Fragment parentHint, boolean isParentVisible) {\n      // 从 FragmentManager 中获取当前已经初始化好，并添加到 Fragment/Activity 中我们空白的 SupportRequestFragment \n    SupportRequestManagerFragment current =\n        (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);\n      // 如果为空，说明空白的 Fragment 还没有被添加进去\n    if (current == null) {\n        // pendingSupportRequestManagerFragments 是一个 HashMap 集合，用来暂存空白 Fragment 对象\n        // 由于 Glide 是一个单例对象，在 Glide 的 builder 中，间接的创建了 RequestManagerRetriever 对象，\n        // 因此 RequestManagerRetriever 也是一个单例，不同的 Activity/Fragment, 会有多个，因此这里用一个 HashMap 来存储空白 Fragment，\n        // 同时，为了保证每个页面只会有一个空白 Fragment，并可以快速定位，所以使用了 HashMap\n      current = pendingSupportRequestManagerFragments.get(fm); // 第一保障\n        // 如果当前缓存的数据中，仍然没有创建好 Fragment， 那就说明当前的空白 Fragment 还没有被创建\n      if (current == null) {\n          // 创建一个新的空白 Fragment\n        current = new SupportRequestManagerFragment();\n        current.setParentFragmentHint(parentHint);\n        if (isParentVisible) {\n            // 调用生命周期方法，让所有的监听者开始任务（后面会说）\n          current.getGlideLifecycle().onStart();\n        }\n          // 将创建好的 Fragment 存入到集合中\n        pendingSupportRequestManagerFragments.put(fm, current);\n          // Handler 通知父容器，这里添加了一个 Fragment\n        fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();\n          // 发送一个 handler 消息，将数据从集合中移除，节省内存空间。（第二保障）\n        handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();\n      }\n    }\n    return current;\n  }\n```\n\n> **Note:**\n>\n> 这里有一个比较困惑的地方就是，将已经创建好的 `Fragment` 添加到集合中去后，又通过 `Handler` 消息，将这个 `Fragment` 从集合中移除，这是为什么呢？\n>\n> 其实最终的目的是节省内存空间做的一个优化，通过 Handler来处理是因为，`fragment` 的添加也是通过 `Handler` 来完成的，但 `Handler` 消息的执行时间不能保证，因此通过 `Handler` 再发一次消息，让移除操作在 `Fragment` 添加完成之后去执行，就一定能够得到保障。\n>\n> 只有当 `Fragment` 被添加进入父容器之后， `fm.findFragmentByTag` 才能获取到对象。这也是为了保证每个父容器都只有一个空白 `Fragment` 的两次保障。\n\n## 类关系图\n\n至此，with 函数的所有主线业务已经说完了，但究竟 Fragment 是如何监听生命周期变化的呢？我们来看下面这张关系图\n\n![Glide lifecycle](https://github.com/xiaomanwong/static_file/blob/master/images/glide_struct.jpg?raw=true)\n\n**SupportRequestManagerFragment** \n\n内部绑定了 `ActivityFragmentLifecycle` ，通过 Fragment 生生命周期变化，来引导 `RequestManager` 完成图片的请求和后续的显示\n\n我们查看下源码：\n\n```java\npublic class SupportRequestManagerFragment extends Fragment {\n  private static final String TAG = \"SupportRMFragment\";\n  private final ActivityFragmentLifecycle lifecycle;\n\n  @SuppressLint(\"ValidFragment\")\n  public SupportRequestManagerFragment(@NonNull ActivityFragmentLifecycle lifecycle) {\n      // 构造器创建了 ActivityFramgentLifecycle\n    this.lifecycle = lifecycle;\n  }\n    \n  // 在前面初始化 SupportRequestManagerFragment 的代码中，我们还记得他手动的调用了一下 start 方法吧\n  @Override\n  public void onStart() {\n    super.onStart();\n    lifecycle.onStart();\n  }\n\n  @Override\n  public void onStop() {\n    super.onStop();\n    lifecycle.onStop();\n  }\n\n  @Override\n  public void onDestroy() {\n    super.onDestroy();\n    lifecycle.onDestroy();\n    unregisterFragmentWithRoot();\n  }\n    \n  @NonNull\n  ActivityFragmentLifecycle getGlideLifecycle() {\n    return lifecycle;\n  }\n}\n```\n\n\n\n当 Fragment / Activity 已经不可见时，通过生命周期变化，通知业务功能类去停止请求或调用，防止内存泄漏和崩溃。\n\n\n\n## load\n\n![Glide load](https://github.com/xiaomanwong/static_file/blob/master/images/glide_load.jpg?raw=true)\n\n我们将 `Glide.with(this).load(url).into(view);` 拆分开来写，如下：\n\n```java\nRequestManager requestManager = Glide.with(this);\nRequestBuilder requestBuilder = requestManager.load(url);\nrequestBuilder.into(view);\n```\n\n可以看出， load 函数，我们传入了一个 `String` 类型的 `Url`， 最终返回给我们一个 `RequestBuilder` 对象。按照上面的时序图，我们简单分析一下可以看出，实际上 `RequestBuilder` 就是一个构造者，记录我们传入的参数，最终将我们传入的内容转化为一个 `Drawable` 。\n\n`Glide` 也为我们提供了丰富的 `load api`， 我们可以传入 `url, bitmap, byte[], Drawable, Uri, File, Integer` 等等， `RequestBuilder` 就是来记录我们传入的具体是一个什么样子的数据，并将他们在展示的时候，最终转化成一个 `Drawable` 给图片容器，也就是后面我们要说的 `into` 函数。\n\n\n\n## into\n\ninto 的流程相当复杂，流程图已经展示不下，也不清晰。这是一张不完整的时序图。并没有体现网络请求的部分，和缓存的部分。\n\n![](https://github.com/xiaomanwong/static_file/blob/master/images/glide_into.jpg?raw=true)\n\n但我们先按照这个残图先分析一下。\n\n当 `into(imageview)` 被调用后\n\n```java\npublic ViewTarget<ImageView, TranscodeType> into(@NonNull ImageView view) {\n    Util.assertMainThread();\n    Preconditions.checkNotNull(view);\n\n    BaseRequestOptions<?> requestOptions = this;\n    if (!requestOptions.isTransformationSet()\n        && requestOptions.isTransformationAllowed()\n        && view.getScaleType() != null) {\n      switch (view.getScaleType()) {\n        case CENTER_CROP:\n          requestOptions = requestOptions.clone().optionalCenterCrop();\n          break;\n        case CENTER_INSIDE:\n          requestOptions = requestOptions.clone().optionalCenterInside();\n          break;\n        case FIT_CENTER:\n        case FIT_START:\n        case FIT_END:\n          requestOptions = requestOptions.clone().optionalFitCenter();\n          break;\n        case FIT_XY:\n          requestOptions = requestOptions.clone().optionalCenterInside();\n          break;\n        case CENTER:\n        case MATRIX:\n        default:\n          // Do nothing.\n      }\n    }\n```\n\nGlide 显示对图片进行了解析，获取图片的尺寸等信息。\n\n```java\n  private <Y extends Target<TranscodeType>> Y into(\n      @NonNull Y target,\n      @Nullable RequestListener<TranscodeType> targetListener,\n      BaseRequestOptions<?> options,\n      Executor callbackExecutor) {\n    Preconditions.checkNotNull(target);\n    if (!isModelSet) {\n      throw new IllegalArgumentException(\"You must call #load() before calling #into()\");\n    }\n    Request request = buildRequest(target, targetListener, options, callbackExecutor);\n    Request previous = target.getRequest();\n    requestManager.clear(target);\n    target.setRequest(request);\n    requestManager.track(target, request);\n\n    return target;\n  }\n```\n\n继续，创建了一个 `Request` ，这个 `Request` 的真实对象是 `SingleRequest` ，并通过 `requestManager` 执行了这个请求任务。利用三层缓存策略，最终展示了一张图片。\n\n\n\n\n\n","source":"_posts/三方框架/Glide 源码分析.md","raw":"---\ntitle: Glide\ntag: 三方框架\n---\n\n\n\nGlide 作为广为熟知的图片加载框架，在开发工作中出现的频率非常高，同比的还有 `Picasso` 和 `ImageLoader` 两套框架。 都各有特色。这里主要还是讲一下 `Glide` 。\n<!-- more-->\n**基础用法：**\n\n```java\nGlide.with(this).load(url).into(imageView);\n```\n\n在 Android 开发中，我们通常最简单的使用 `Glide` 的 代码如上面一样，如此简单的 api, 就可以帮助我们实现加载本地图片，本地 Drawable ， Gif 图，以及 网络图片，那么在这样简单的 API 的背后，其实它帮助了我们完成了很多工作。\n\n从简单的使用我们入手，可以看到，要想加载一张图片，我们需要一个当前上下文对象，一个图片地址，一个承载图像的 ImageView 容器。那中三个要求，又同时对应着三个函数，`with` `load` 和 `into`，阅读源码，那就是从源码暴漏给我们最直观的地方进入，不然就是一只没头的苍蝇—到处乱飞。\n\n| 函数 |                           主要功能                           |\n| :--: | :----------------------------------------------------------: |\n| with | 1. 初始化Glide对象<br />2. 创建空白的 Fragment 管理生命周期机制<br />3. 创建一个 RequestManager 管理任务 |\n| load |          最终构建出 RequestBuilder ，记录传入的数据          |\n| into | 1. runRequest 运行队列/等待队列，执行队列 Reqeust 对象<br />2. 活动缓存<br />3. 内存缓存<br />4. HttpUrlConnection |\n\n## 工作流程\n\n`Glide` 通过 `with` 函数，给自己的实例化，并创建一个空白的 `Fragment` 来管理生命周期并绑定 `ReqeustManager` 。继续通过 `load() ` 函数构建一个 `RequestBuilder()` 并缓存我们的参数，继续通过 `into` 创建一个 `Request` 对象，并记录宽高、采样数据等。继续，在发起请求之前，先检查一下缓存数据, 活动缓存 `ActivityResources` 有没有数据，再检查内存缓存 `LRUResourceCache` ，如果两级缓存都未命中，则启动一个异步任务 `DecodeJob`, 去检查 `DiskCache` 中有没有本地磁盘缓存数据，如果没有，通过网络请求数据 `HttpUrlConnection` ，解析 `InputStream` 进行采样，最终拿到 `Bitmap`，将 `Bitmap` 转换成 `Drawable` 并讲数据缓存到磁盘中。\n\n## with\n\n从上面的表格中，我们可以看出来 `with` 函数，就是用来帮我创建 `Glide` 对象，并创建一个空白的 `Fragment` 来管理生命周期。其具体的工作流程如图：\n\n![Glide with 时序图](https://github.com/xiaomanwong/static_file/blob/master/images/glide_with_sequence.jpg?raw=true)\n\n由上面的时序图，我们可以顺序的分析，我们一步步去分析。\n\n**Glide.with()**\n\n`Glide.with()` 为提供了多种重构函数，目的是为我们提供它强大的作用域以及满足我们开发过程中各种复杂的情况。同时适配不同版本以及不同的应用场景。\n\n```java\n@NonNull\npublic static RequestManager with(@NonNull Context context) {\n    return getRetriever(context).get(context);\n}\n\n@NonNull\npublic static RequestManager with(@NonNull Activity activity) {\n    return getRetriever(activity).get(activity);\n}\n\n@NonNull\npublic static RequestManager with(@NonNull FragmentActivity activity) {\n    return getRetriever(activity).get(activity);\n}\n\n@NonNull\npublic static RequestManager with(@NonNull Fragment fragment) {\n    return getRetriever(fragment.getContext()).get(fragment);\n}\n\n@NonNull\npublic static RequestManager with(@NonNull android.app.Fragment fragment) {\n    return getRetriever(fragment.getActivity()).get(fragment);\n}\n\n@NonNull\npublic static RequestManager with(@NonNull View view) {\n    return getRetriever(view.getContext()).get(view);\n}\n```\n\n**getRetriever**()\n\n`getRetriever()` 通过 Glide 的 get 函数，帮我们初始化了一个 `Glide` 对象。\n\n```java\n@NonNull\nprivate static RequestManagerRetriever getRetriever(@Nullable Context context) {\n    return Glide.get(context).getRequestManagerRetriever();\n}\n```\n\n**get(context)**\n\n可以看出，Glide 是一个单例的，向下看时，我们也可看到，对 Glide 的检查很严谨。\n\n```java\nprivate static volatile Glide glide;\n@NonNull\npublic static Glide get(@NonNull Context context) {\n    if (glide == null) {\n        synchronized (Glide.class) {\n            if (glide == null) {\n                checkAndInitializeGlide(context, annotationGeneratedModule);\n            }\n        }\n    }\n    return glide;\n}\n```\n\n**checkAndInitializeGlide() & initializeGlide()**\n\n最终通过构造者模式，完成了对 `Glide` 对象的初始化，同时在构造者中，也对很多 `Glide` 工作时需要的对象进行了初始化。我们这里只研究主线业务，其它的可以私下看。\n\n```java\nprivate static void checkAndInitializeGlide(\n    if (isInitializing) {\n        throw new IllegalStateException(\n            \"You cannot call Glide.get() in registerComponents(),\"\n            + \" use the provided Glide instance instead\");\n    }\n    isInitializing = true;\n    initializeGlide(context, generatedAppGlideModule);\n    isInitializing = false;\n}\nprivate static void initializeGlide(Context context, GlideBuilder builder, GeneratedAppGlideModule annotationGeneratedModule) {\n    Glide glide = builder.build(applicationContext);\n    Glide.glide = glide;\n}\n```\n\n到这里， `Glide` 的初始化工作已经完成，具体初始化了什么信息，细节的东西，自己需要去认真的阅读源码。\n\n并且代码按照流程，`get()` 的深度代码已经完成，程序会逐步回到 `getRetriever()` 函数中，去执行 `getRequestManagerRetriever` ， `getRequestManagerRetriever` ` 是通过 `Glide 的构造器完成的初始化工作，此时直接返回已经创建好的对象。并继续执行 `with()`函数 的 `get()` 去创建 `RequestManager`\n\n**get(Fragment fragment)**\n\n这时候，我们发现，现在代码已经跳转到 `RequestManagerRetriever` 类中\n\n**RequestManagerRetriever**\n\n`RequestManagerRetriever` 是一个管理类，负责生产 `Fragment` 对象，根据我们传入的 `Context` 上下文的定义不同，最终会帮我们创建不同的生命周期管理。\n\n```java\n  @NonNull\n  public RequestManager get(@NonNull Fragment fragment) {\n    if (Util.isOnBackgroundThread()) {\n        // 创建一个全局作用域的 RequestManager，生命周期很长，容易出现内存问题\n      return get(fragment.getContext().getApplicationContext());\n    } else {\n      FragmentManager fm = fragment.getChildFragmentManager();\n      return supportFragmentGet(fragment.getContext(), fm, fragment, fragment.isVisible());\n    }\n  }\n\n  public RequestManager get(@NonNull Context context) {\n    if (context == null) {\n      throw new IllegalArgumentException(\"You cannot start a load on a null Context\");\n    } else if (Util.isOnMainThread() && !(context instanceof Application)) {\n      if (context instanceof FragmentActivity) {\n        return get((FragmentActivity) context);\n      } else if (context instanceof Activity) {\n        return get((Activity) context);\n      } else if (context instanceof ContextWrapper\n          && ((ContextWrapper) context).getBaseContext().getApplicationContext() != null) {\n        return get(((ContextWrapper) context).getBaseContext());\n      }\n    }\n         // 创建一个全局作用域的 RequestManager，生命周期很长，容易出现内存问题\n      return getApplicationManager(context);\n  }\n```\n\n> **Note:**\n>\n> 1. **如果当前任务工作在后台线程或者传入的 `Context` 对象是一个 `Application` 级别的，那 `Glide` 就会帮我们创建一个和 `Application` 同生命周期的 `RequestManager` 对象，这个对象生命周期很长， 如果我们不规范使用的话，这里很容易造成<font color=red>内存的泄漏</font>**。 因此我们使用时，尽量不要传入里类似的。\n>\n> 2. 如果我们传入的是一个 Fragment 对象， Activity 对象等等，那 `Glide` 就会帮我们创建个空白的 `Fragment`， `supportFragmentGet` 和  `fragmentGet` 两种方案是用来做 `androidX` 和 `android.app`中不同 `fragment` 的适配\n\n**supportFragmentGet**\n\n创建管理生命周期的 Fragment, `androidx` 对应的是 `supportFragmentGet()` ， `android.app` 对应的是 `fragmentGet()`， 这里以 `supportFragmentGet()` 为例：\n\n```java\n  @NonNull\n  private RequestManager supportFragmentGet(\n      @NonNull Context context,\n      @NonNull FragmentManager fm,\n      @Nullable Fragment parentHint,\n      boolean isParentVisible) {\n      // 创建/获取当前空白的 Fragment\n    SupportRequestManagerFragment current =\n        getSupportRequestManagerFragment(fm, parentHint, isParentVisible);\n      // 获取空白 Fragment 中的 RequestManager 对象\n      // 如果为空，那么就通过工厂创建一个，并绑定回空白的 Fragment 中\n    RequestManager requestManager = current.getRequestManager();\n    if (requestManager == null) {\n      Glide glide = Glide.get(context);\n      requestManager =\n          factory.build(\n              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);\n      current.setRequestManager(requestManager);\n    }\n      // 返回 reqeustManager 对象\n    return requestManager;\n  }\n\n  @NonNull\n  private SupportRequestManagerFragment getSupportRequestManagerFragment(\n      @NonNull final FragmentManager fm, @Nullable Fragment parentHint, boolean isParentVisible) {\n      // 从 FragmentManager 中获取当前已经初始化好，并添加到 Fragment/Activity 中我们空白的 SupportRequestFragment \n    SupportRequestManagerFragment current =\n        (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);\n      // 如果为空，说明空白的 Fragment 还没有被添加进去\n    if (current == null) {\n        // pendingSupportRequestManagerFragments 是一个 HashMap 集合，用来暂存空白 Fragment 对象\n        // 由于 Glide 是一个单例对象，在 Glide 的 builder 中，间接的创建了 RequestManagerRetriever 对象，\n        // 因此 RequestManagerRetriever 也是一个单例，不同的 Activity/Fragment, 会有多个，因此这里用一个 HashMap 来存储空白 Fragment，\n        // 同时，为了保证每个页面只会有一个空白 Fragment，并可以快速定位，所以使用了 HashMap\n      current = pendingSupportRequestManagerFragments.get(fm); // 第一保障\n        // 如果当前缓存的数据中，仍然没有创建好 Fragment， 那就说明当前的空白 Fragment 还没有被创建\n      if (current == null) {\n          // 创建一个新的空白 Fragment\n        current = new SupportRequestManagerFragment();\n        current.setParentFragmentHint(parentHint);\n        if (isParentVisible) {\n            // 调用生命周期方法，让所有的监听者开始任务（后面会说）\n          current.getGlideLifecycle().onStart();\n        }\n          // 将创建好的 Fragment 存入到集合中\n        pendingSupportRequestManagerFragments.put(fm, current);\n          // Handler 通知父容器，这里添加了一个 Fragment\n        fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();\n          // 发送一个 handler 消息，将数据从集合中移除，节省内存空间。（第二保障）\n        handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();\n      }\n    }\n    return current;\n  }\n```\n\n> **Note:**\n>\n> 这里有一个比较困惑的地方就是，将已经创建好的 `Fragment` 添加到集合中去后，又通过 `Handler` 消息，将这个 `Fragment` 从集合中移除，这是为什么呢？\n>\n> 其实最终的目的是节省内存空间做的一个优化，通过 Handler来处理是因为，`fragment` 的添加也是通过 `Handler` 来完成的，但 `Handler` 消息的执行时间不能保证，因此通过 `Handler` 再发一次消息，让移除操作在 `Fragment` 添加完成之后去执行，就一定能够得到保障。\n>\n> 只有当 `Fragment` 被添加进入父容器之后， `fm.findFragmentByTag` 才能获取到对象。这也是为了保证每个父容器都只有一个空白 `Fragment` 的两次保障。\n\n## 类关系图\n\n至此，with 函数的所有主线业务已经说完了，但究竟 Fragment 是如何监听生命周期变化的呢？我们来看下面这张关系图\n\n![Glide lifecycle](https://github.com/xiaomanwong/static_file/blob/master/images/glide_struct.jpg?raw=true)\n\n**SupportRequestManagerFragment** \n\n内部绑定了 `ActivityFragmentLifecycle` ，通过 Fragment 生生命周期变化，来引导 `RequestManager` 完成图片的请求和后续的显示\n\n我们查看下源码：\n\n```java\npublic class SupportRequestManagerFragment extends Fragment {\n  private static final String TAG = \"SupportRMFragment\";\n  private final ActivityFragmentLifecycle lifecycle;\n\n  @SuppressLint(\"ValidFragment\")\n  public SupportRequestManagerFragment(@NonNull ActivityFragmentLifecycle lifecycle) {\n      // 构造器创建了 ActivityFramgentLifecycle\n    this.lifecycle = lifecycle;\n  }\n    \n  // 在前面初始化 SupportRequestManagerFragment 的代码中，我们还记得他手动的调用了一下 start 方法吧\n  @Override\n  public void onStart() {\n    super.onStart();\n    lifecycle.onStart();\n  }\n\n  @Override\n  public void onStop() {\n    super.onStop();\n    lifecycle.onStop();\n  }\n\n  @Override\n  public void onDestroy() {\n    super.onDestroy();\n    lifecycle.onDestroy();\n    unregisterFragmentWithRoot();\n  }\n    \n  @NonNull\n  ActivityFragmentLifecycle getGlideLifecycle() {\n    return lifecycle;\n  }\n}\n```\n\n\n\n当 Fragment / Activity 已经不可见时，通过生命周期变化，通知业务功能类去停止请求或调用，防止内存泄漏和崩溃。\n\n\n\n## load\n\n![Glide load](https://github.com/xiaomanwong/static_file/blob/master/images/glide_load.jpg?raw=true)\n\n我们将 `Glide.with(this).load(url).into(view);` 拆分开来写，如下：\n\n```java\nRequestManager requestManager = Glide.with(this);\nRequestBuilder requestBuilder = requestManager.load(url);\nrequestBuilder.into(view);\n```\n\n可以看出， load 函数，我们传入了一个 `String` 类型的 `Url`， 最终返回给我们一个 `RequestBuilder` 对象。按照上面的时序图，我们简单分析一下可以看出，实际上 `RequestBuilder` 就是一个构造者，记录我们传入的参数，最终将我们传入的内容转化为一个 `Drawable` 。\n\n`Glide` 也为我们提供了丰富的 `load api`， 我们可以传入 `url, bitmap, byte[], Drawable, Uri, File, Integer` 等等， `RequestBuilder` 就是来记录我们传入的具体是一个什么样子的数据，并将他们在展示的时候，最终转化成一个 `Drawable` 给图片容器，也就是后面我们要说的 `into` 函数。\n\n\n\n## into\n\ninto 的流程相当复杂，流程图已经展示不下，也不清晰。这是一张不完整的时序图。并没有体现网络请求的部分，和缓存的部分。\n\n![](https://github.com/xiaomanwong/static_file/blob/master/images/glide_into.jpg?raw=true)\n\n但我们先按照这个残图先分析一下。\n\n当 `into(imageview)` 被调用后\n\n```java\npublic ViewTarget<ImageView, TranscodeType> into(@NonNull ImageView view) {\n    Util.assertMainThread();\n    Preconditions.checkNotNull(view);\n\n    BaseRequestOptions<?> requestOptions = this;\n    if (!requestOptions.isTransformationSet()\n        && requestOptions.isTransformationAllowed()\n        && view.getScaleType() != null) {\n      switch (view.getScaleType()) {\n        case CENTER_CROP:\n          requestOptions = requestOptions.clone().optionalCenterCrop();\n          break;\n        case CENTER_INSIDE:\n          requestOptions = requestOptions.clone().optionalCenterInside();\n          break;\n        case FIT_CENTER:\n        case FIT_START:\n        case FIT_END:\n          requestOptions = requestOptions.clone().optionalFitCenter();\n          break;\n        case FIT_XY:\n          requestOptions = requestOptions.clone().optionalCenterInside();\n          break;\n        case CENTER:\n        case MATRIX:\n        default:\n          // Do nothing.\n      }\n    }\n```\n\nGlide 显示对图片进行了解析，获取图片的尺寸等信息。\n\n```java\n  private <Y extends Target<TranscodeType>> Y into(\n      @NonNull Y target,\n      @Nullable RequestListener<TranscodeType> targetListener,\n      BaseRequestOptions<?> options,\n      Executor callbackExecutor) {\n    Preconditions.checkNotNull(target);\n    if (!isModelSet) {\n      throw new IllegalArgumentException(\"You must call #load() before calling #into()\");\n    }\n    Request request = buildRequest(target, targetListener, options, callbackExecutor);\n    Request previous = target.getRequest();\n    requestManager.clear(target);\n    target.setRequest(request);\n    requestManager.track(target, request);\n\n    return target;\n  }\n```\n\n继续，创建了一个 `Request` ，这个 `Request` 的真实对象是 `SingleRequest` ，并通过 `requestManager` 执行了这个请求任务。利用三层缓存策略，最终展示了一张图片。\n\n\n\n\n\n","slug":"三方框架/Glide 源码分析","published":1,"date":"2021-01-29T15:54:28.347Z","updated":"2021-01-29T16:02:08.236Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8fk002bsz5q8p0jykz5","content":"<p>Glide 作为广为熟知的图片加载框架，在开发工作中出现的频率非常高，同比的还有 <code>Picasso</code> 和 <code>ImageLoader</code> 两套框架。 都各有特色。这里主要还是讲一下 <code>Glide</code> 。<br><a id=\"more\"></a><br><strong>基础用法：</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\">Glide<span class=\"token punctuation\">.</span><span class=\"token function\">with</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">load</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">into</span><span class=\"token punctuation\">(</span>imageView<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>在 Android 开发中，我们通常最简单的使用 <code>Glide</code> 的 代码如上面一样，如此简单的 api, 就可以帮助我们实现加载本地图片，本地 Drawable ， Gif 图，以及 网络图片，那么在这样简单的 API 的背后，其实它帮助了我们完成了很多工作。</p>\n<p>从简单的使用我们入手，可以看到，要想加载一张图片，我们需要一个当前上下文对象，一个图片地址，一个承载图像的 ImageView 容器。那中三个要求，又同时对应着三个函数，<code>with</code> <code>load</code> 和 <code>into</code>，阅读源码，那就是从源码暴漏给我们最直观的地方进入，不然就是一只没头的苍蝇—到处乱飞。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">函数</th>\n<th style=\"text-align:center\">主要功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">with</td>\n<td style=\"text-align:center\">1. 初始化Glide对象<br>2. 创建空白的 Fragment 管理生命周期机制<br>3. 创建一个 RequestManager 管理任务</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">load</td>\n<td style=\"text-align:center\">最终构建出 RequestBuilder ，记录传入的数据</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">into</td>\n<td style=\"text-align:center\">1. runRequest 运行队列/等待队列，执行队列 Reqeust 对象<br>2. 活动缓存<br>3. 内存缓存<br>4. HttpUrlConnection</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h2><p><code>Glide</code> 通过 <code>with</code> 函数，给自己的实例化，并创建一个空白的 <code>Fragment</code> 来管理生命周期并绑定 <code>ReqeustManager</code> 。继续通过 <code>load()</code> 函数构建一个 <code>RequestBuilder()</code> 并缓存我们的参数，继续通过 <code>into</code> 创建一个 <code>Request</code> 对象，并记录宽高、采样数据等。继续，在发起请求之前，先检查一下缓存数据, 活动缓存 <code>ActivityResources</code> 有没有数据，再检查内存缓存 <code>LRUResourceCache</code> ，如果两级缓存都未命中，则启动一个异步任务 <code>DecodeJob</code>, 去检查 <code>DiskCache</code> 中有没有本地磁盘缓存数据，如果没有，通过网络请求数据 <code>HttpUrlConnection</code> ，解析 <code>InputStream</code> 进行采样，最终拿到 <code>Bitmap</code>，将 <code>Bitmap</code> 转换成 <code>Drawable</code> 并讲数据缓存到磁盘中。</p>\n<h2 id=\"with\"><a href=\"#with\" class=\"headerlink\" title=\"with\"></a>with</h2><p>从上面的表格中，我们可以看出来 <code>with</code> 函数，就是用来帮我创建 <code>Glide</code> 对象，并创建一个空白的 <code>Fragment</code> 来管理生命周期。其具体的工作流程如图：</p>\n<p><img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/glide_with_sequence.jpg?raw=true\" alt=\"Glide with 时序图\"></p>\n<p>由上面的时序图，我们可以顺序的分析，我们一步步去分析。</p>\n<p><strong>Glide.with()</strong></p>\n<p><code>Glide.with()</code> 为提供了多种重构函数，目的是为我们提供它强大的作用域以及满足我们开发过程中各种复杂的情况。同时适配不同版本以及不同的应用场景。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@NonNull</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> RequestManager <span class=\"token function\">with</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@NonNull</span> Context context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">getRetriever</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@NonNull</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> RequestManager <span class=\"token function\">with</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@NonNull</span> Activity activity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">getRetriever</span><span class=\"token punctuation\">(</span>activity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>activity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@NonNull</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> RequestManager <span class=\"token function\">with</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@NonNull</span> FragmentActivity activity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">getRetriever</span><span class=\"token punctuation\">(</span>activity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>activity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@NonNull</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> RequestManager <span class=\"token function\">with</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@NonNull</span> Fragment fragment<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">getRetriever</span><span class=\"token punctuation\">(</span>fragment<span class=\"token punctuation\">.</span><span class=\"token function\">getContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>fragment<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@NonNull</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> RequestManager <span class=\"token function\">with</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@NonNull</span> android<span class=\"token punctuation\">.</span>app<span class=\"token punctuation\">.</span>Fragment fragment<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">getRetriever</span><span class=\"token punctuation\">(</span>fragment<span class=\"token punctuation\">.</span><span class=\"token function\">getActivity</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>fragment<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@NonNull</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> RequestManager <span class=\"token function\">with</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@NonNull</span> View view<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">getRetriever</span><span class=\"token punctuation\">(</span>view<span class=\"token punctuation\">.</span><span class=\"token function\">getContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>view<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>getRetriever</strong>()</p>\n<p><code>getRetriever()</code> 通过 Glide 的 get 函数，帮我们初始化了一个 <code>Glide</code> 对象。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@NonNull</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> RequestManagerRetriever <span class=\"token function\">getRetriever</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@Nullable</span> Context context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> Glide<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getRequestManagerRetriever</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>get(context)</strong></p>\n<p>可以看出，Glide 是一个单例的，向下看时，我们也可看到，对 Glide 的检查很严谨。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">volatile</span> Glide glide<span class=\"token punctuation\">;</span>\n<span class=\"token annotation punctuation\">@NonNull</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> Glide <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@NonNull</span> Context context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>glide <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>Glide<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>glide <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">checkAndInitializeGlide</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> annotationGeneratedModule<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> glide<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>checkAndInitializeGlide() &amp; initializeGlide()</strong></p>\n<p>最终通过构造者模式，完成了对 <code>Glide</code> 对象的初始化，同时在构造者中，也对很多 <code>Glide</code> 工作时需要的对象进行了初始化。我们这里只研究主线业务，其它的可以私下看。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">checkAndInitializeGlide</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isInitializing<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalStateException</span><span class=\"token punctuation\">(</span>\n            <span class=\"token string\">\"You cannot call Glide.get() in registerComponents(),\"</span>\n            <span class=\"token operator\">+</span> <span class=\"token string\">\" use the provided Glide instance instead\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    isInitializing <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">initializeGlide</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> generatedAppGlideModule<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    isInitializing <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">initializeGlide</span><span class=\"token punctuation\">(</span>Context context<span class=\"token punctuation\">,</span> GlideBuilder builder<span class=\"token punctuation\">,</span> GeneratedAppGlideModule annotationGeneratedModule<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Glide glide <span class=\"token operator\">=</span> builder<span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span>applicationContext<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Glide<span class=\"token punctuation\">.</span>glide <span class=\"token operator\">=</span> glide<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>到这里， <code>Glide</code> 的初始化工作已经完成，具体初始化了什么信息，细节的东西，自己需要去认真的阅读源码。</p>\n<p>并且代码按照流程，<code>get()</code> 的深度代码已经完成，程序会逐步回到 <code>getRetriever()</code> 函数中，去执行 <code>getRequestManagerRetriever</code> ， <code>getRequestManagerRetriever</code> <code>是通过</code>Glide 的构造器完成的初始化工作，此时直接返回已经创建好的对象。并继续执行 <code>with()</code>函数 的 <code>get()</code> 去创建 <code>RequestManager</code></p>\n<p><strong>get(Fragment fragment)</strong></p>\n<p>这时候，我们发现，现在代码已经跳转到 <code>RequestManagerRetriever</code> 类中</p>\n<p><strong>RequestManagerRetriever</strong></p>\n<p><code>RequestManagerRetriever</code> 是一个管理类，负责生产 <code>Fragment</code> 对象，根据我们传入的 <code>Context</code> 上下文的定义不同，最终会帮我们创建不同的生命周期管理。</p>\n<pre class=\" language-java\"><code class=\"language-java\">  <span class=\"token annotation punctuation\">@NonNull</span>\n  <span class=\"token keyword\">public</span> RequestManager <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@NonNull</span> Fragment fragment<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Util<span class=\"token punctuation\">.</span><span class=\"token function\">isOnBackgroundThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 创建一个全局作用域的 RequestManager，生命周期很长，容易出现内存问题</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span>fragment<span class=\"token punctuation\">.</span><span class=\"token function\">getContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getApplicationContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      FragmentManager fm <span class=\"token operator\">=</span> fragment<span class=\"token punctuation\">.</span><span class=\"token function\">getChildFragmentManager</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">supportFragmentGet</span><span class=\"token punctuation\">(</span>fragment<span class=\"token punctuation\">.</span><span class=\"token function\">getContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> fm<span class=\"token punctuation\">,</span> fragment<span class=\"token punctuation\">,</span> fragment<span class=\"token punctuation\">.</span><span class=\"token function\">isVisible</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">public</span> RequestManager <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@NonNull</span> Context context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>context <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"You cannot start a load on a null Context\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Util<span class=\"token punctuation\">.</span><span class=\"token function\">isOnMainThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>context <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Application</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>context <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">FragmentActivity</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>FragmentActivity<span class=\"token punctuation\">)</span> context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>context <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Activity</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>Activity<span class=\"token punctuation\">)</span> context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>context <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">ContextWrapper</span>\n          <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>ContextWrapper<span class=\"token punctuation\">)</span> context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getBaseContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getApplicationContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>ContextWrapper<span class=\"token punctuation\">)</span> context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getBaseContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n         <span class=\"token comment\" spellcheck=\"true\">// 创建一个全局作用域的 RequestManager，生命周期很长，容易出现内存问题</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">getApplicationManager</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n</code></pre>\n<blockquote>\n<p><strong>Note:</strong></p>\n<ol>\n<li><p><strong>如果当前任务工作在后台线程或者传入的 <code>Context</code> 对象是一个 <code>Application</code> 级别的，那 <code>Glide</code> 就会帮我们创建一个和 <code>Application</code> 同生命周期的 <code>RequestManager</code> 对象，这个对象生命周期很长， 如果我们不规范使用的话，这里很容易造成<font color=\"red\">内存的泄漏</font></strong>。 因此我们使用时，尽量不要传入里类似的。</p>\n</li>\n<li><p>如果我们传入的是一个 Fragment 对象， Activity 对象等等，那 <code>Glide</code> 就会帮我们创建个空白的 <code>Fragment</code>， <code>supportFragmentGet</code> 和  <code>fragmentGet</code> 两种方案是用来做 <code>androidX</code> 和 <code>android.app</code>中不同 <code>fragment</code> 的适配</p>\n</li>\n</ol>\n</blockquote>\n<p><strong>supportFragmentGet</strong></p>\n<p>创建管理生命周期的 Fragment, <code>androidx</code> 对应的是 <code>supportFragmentGet()</code> ， <code>android.app</code> 对应的是 <code>fragmentGet()</code>， 这里以 <code>supportFragmentGet()</code> 为例：</p>\n<pre class=\" language-java\"><code class=\"language-java\">  <span class=\"token annotation punctuation\">@NonNull</span>\n  <span class=\"token keyword\">private</span> RequestManager <span class=\"token function\">supportFragmentGet</span><span class=\"token punctuation\">(</span>\n      <span class=\"token annotation punctuation\">@NonNull</span> Context context<span class=\"token punctuation\">,</span>\n      <span class=\"token annotation punctuation\">@NonNull</span> FragmentManager fm<span class=\"token punctuation\">,</span>\n      <span class=\"token annotation punctuation\">@Nullable</span> Fragment parentHint<span class=\"token punctuation\">,</span>\n      <span class=\"token keyword\">boolean</span> isParentVisible<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 创建/获取当前空白的 Fragment</span>\n    SupportRequestManagerFragment current <span class=\"token operator\">=</span>\n        <span class=\"token function\">getSupportRequestManagerFragment</span><span class=\"token punctuation\">(</span>fm<span class=\"token punctuation\">,</span> parentHint<span class=\"token punctuation\">,</span> isParentVisible<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 获取空白 Fragment 中的 RequestManager 对象</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 如果为空，那么就通过工厂创建一个，并绑定回空白的 Fragment 中</span>\n    RequestManager requestManager <span class=\"token operator\">=</span> current<span class=\"token punctuation\">.</span><span class=\"token function\">getRequestManager</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>requestManager <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      Glide glide <span class=\"token operator\">=</span> Glide<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      requestManager <span class=\"token operator\">=</span>\n          factory<span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span>\n              glide<span class=\"token punctuation\">,</span> current<span class=\"token punctuation\">.</span><span class=\"token function\">getGlideLifecycle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> current<span class=\"token punctuation\">.</span><span class=\"token function\">getRequestManagerTreeNode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      current<span class=\"token punctuation\">.</span><span class=\"token function\">setRequestManager</span><span class=\"token punctuation\">(</span>requestManager<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 返回 reqeustManager 对象</span>\n    <span class=\"token keyword\">return</span> requestManager<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token annotation punctuation\">@NonNull</span>\n  <span class=\"token keyword\">private</span> SupportRequestManagerFragment <span class=\"token function\">getSupportRequestManagerFragment</span><span class=\"token punctuation\">(</span>\n      <span class=\"token annotation punctuation\">@NonNull</span> <span class=\"token keyword\">final</span> FragmentManager fm<span class=\"token punctuation\">,</span> <span class=\"token annotation punctuation\">@Nullable</span> Fragment parentHint<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> isParentVisible<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 从 FragmentManager 中获取当前已经初始化好，并添加到 Fragment/Activity 中我们空白的 SupportRequestFragment </span>\n    SupportRequestManagerFragment current <span class=\"token operator\">=</span>\n        <span class=\"token punctuation\">(</span>SupportRequestManagerFragment<span class=\"token punctuation\">)</span> fm<span class=\"token punctuation\">.</span><span class=\"token function\">findFragmentByTag</span><span class=\"token punctuation\">(</span>FRAGMENT_TAG<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 如果为空，说明空白的 Fragment 还没有被添加进去</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>current <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// pendingSupportRequestManagerFragments 是一个 HashMap 集合，用来暂存空白 Fragment 对象</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 由于 Glide 是一个单例对象，在 Glide 的 builder 中，间接的创建了 RequestManagerRetriever 对象，</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 因此 RequestManagerRetriever 也是一个单例，不同的 Activity/Fragment, 会有多个，因此这里用一个 HashMap 来存储空白 Fragment，</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 同时，为了保证每个页面只会有一个空白 Fragment，并可以快速定位，所以使用了 HashMap</span>\n      current <span class=\"token operator\">=</span> pendingSupportRequestManagerFragments<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>fm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 第一保障</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 如果当前缓存的数据中，仍然没有创建好 Fragment， 那就说明当前的空白 Fragment 还没有被创建</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>current <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\" spellcheck=\"true\">// 创建一个新的空白 Fragment</span>\n        current <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SupportRequestManagerFragment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        current<span class=\"token punctuation\">.</span><span class=\"token function\">setParentFragmentHint</span><span class=\"token punctuation\">(</span>parentHint<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isParentVisible<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 调用生命周期方法，让所有的监听者开始任务（后面会说）</span>\n          current<span class=\"token punctuation\">.</span><span class=\"token function\">getGlideLifecycle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">onStart</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n          <span class=\"token comment\" spellcheck=\"true\">// 将创建好的 Fragment 存入到集合中</span>\n        pendingSupportRequestManagerFragments<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>fm<span class=\"token punctuation\">,</span> current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token comment\" spellcheck=\"true\">// Handler 通知父容器，这里添加了一个 Fragment</span>\n        fm<span class=\"token punctuation\">.</span><span class=\"token function\">beginTransaction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">,</span> FRAGMENT_TAG<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">commitAllowingStateLoss</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token comment\" spellcheck=\"true\">// 发送一个 handler 消息，将数据从集合中移除，节省内存空间。（第二保障）</span>\n        handler<span class=\"token punctuation\">.</span><span class=\"token function\">obtainMessage</span><span class=\"token punctuation\">(</span>ID_REMOVE_SUPPORT_FRAGMENT_MANAGER<span class=\"token punctuation\">,</span> fm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">sendToTarget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> current<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n</code></pre>\n<blockquote>\n<p><strong>Note:</strong></p>\n<p>这里有一个比较困惑的地方就是，将已经创建好的 <code>Fragment</code> 添加到集合中去后，又通过 <code>Handler</code> 消息，将这个 <code>Fragment</code> 从集合中移除，这是为什么呢？</p>\n<p>其实最终的目的是节省内存空间做的一个优化，通过 Handler来处理是因为，<code>fragment</code> 的添加也是通过 <code>Handler</code> 来完成的，但 <code>Handler</code> 消息的执行时间不能保证，因此通过 <code>Handler</code> 再发一次消息，让移除操作在 <code>Fragment</code> 添加完成之后去执行，就一定能够得到保障。</p>\n<p>只有当 <code>Fragment</code> 被添加进入父容器之后， <code>fm.findFragmentByTag</code> 才能获取到对象。这也是为了保证每个父容器都只有一个空白 <code>Fragment</code> 的两次保障。</p>\n</blockquote>\n<h2 id=\"类关系图\"><a href=\"#类关系图\" class=\"headerlink\" title=\"类关系图\"></a>类关系图</h2><p>至此，with 函数的所有主线业务已经说完了，但究竟 Fragment 是如何监听生命周期变化的呢？我们来看下面这张关系图</p>\n<p><img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/glide_struct.jpg?raw=true\" alt=\"Glide lifecycle\"></p>\n<p><strong>SupportRequestManagerFragment</strong> </p>\n<p>内部绑定了 <code>ActivityFragmentLifecycle</code> ，通过 Fragment 生生命周期变化，来引导 <code>RequestManager</code> 完成图片的请求和后续的显示</p>\n<p>我们查看下源码：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SupportRequestManagerFragment</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Fragment</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> String TAG <span class=\"token operator\">=</span> <span class=\"token string\">\"SupportRMFragment\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> ActivityFragmentLifecycle lifecycle<span class=\"token punctuation\">;</span>\n\n  <span class=\"token annotation punctuation\">@SuppressLint</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ValidFragment\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">public</span> <span class=\"token function\">SupportRequestManagerFragment</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@NonNull</span> ActivityFragmentLifecycle lifecycle<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 构造器创建了 ActivityFramgentLifecycle</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lifecycle <span class=\"token operator\">=</span> lifecycle<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 在前面初始化 SupportRequestManagerFragment 的代码中，我们还记得他手动的调用了一下 start 方法吧</span>\n  <span class=\"token annotation punctuation\">@Override</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onStart</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">onStart</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    lifecycle<span class=\"token punctuation\">.</span><span class=\"token function\">onStart</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token annotation punctuation\">@Override</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onStop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">onStop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    lifecycle<span class=\"token punctuation\">.</span><span class=\"token function\">onStop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token annotation punctuation\">@Override</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onDestroy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">onDestroy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    lifecycle<span class=\"token punctuation\">.</span><span class=\"token function\">onDestroy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">unregisterFragmentWithRoot</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token annotation punctuation\">@NonNull</span>\n  ActivityFragmentLifecycle <span class=\"token function\">getGlideLifecycle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> lifecycle<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>当 Fragment / Activity 已经不可见时，通过生命周期变化，通知业务功能类去停止请求或调用，防止内存泄漏和崩溃。</p>\n<h2 id=\"load\"><a href=\"#load\" class=\"headerlink\" title=\"load\"></a>load</h2><p><img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/glide_load.jpg?raw=true\" alt=\"Glide load\"></p>\n<p>我们将 <code>Glide.with(this).load(url).into(view);</code> 拆分开来写，如下：</p>\n<pre class=\" language-java\"><code class=\"language-java\">RequestManager requestManager <span class=\"token operator\">=</span> Glide<span class=\"token punctuation\">.</span><span class=\"token function\">with</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nRequestBuilder requestBuilder <span class=\"token operator\">=</span> requestManager<span class=\"token punctuation\">.</span><span class=\"token function\">load</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nrequestBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">into</span><span class=\"token punctuation\">(</span>view<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>可以看出， load 函数，我们传入了一个 <code>String</code> 类型的 <code>Url</code>， 最终返回给我们一个 <code>RequestBuilder</code> 对象。按照上面的时序图，我们简单分析一下可以看出，实际上 <code>RequestBuilder</code> 就是一个构造者，记录我们传入的参数，最终将我们传入的内容转化为一个 <code>Drawable</code> 。</p>\n<p><code>Glide</code> 也为我们提供了丰富的 <code>load api</code>， 我们可以传入 <code>url, bitmap, byte[], Drawable, Uri, File, Integer</code> 等等， <code>RequestBuilder</code> 就是来记录我们传入的具体是一个什么样子的数据，并将他们在展示的时候，最终转化成一个 <code>Drawable</code> 给图片容器，也就是后面我们要说的 <code>into</code> 函数。</p>\n<h2 id=\"into\"><a href=\"#into\" class=\"headerlink\" title=\"into\"></a>into</h2><p>into 的流程相当复杂，流程图已经展示不下，也不清晰。这是一张不完整的时序图。并没有体现网络请求的部分，和缓存的部分。</p>\n<p><img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/glide_into.jpg?raw=true\" alt></p>\n<p>但我们先按照这个残图先分析一下。</p>\n<p>当 <code>into(imageview)</code> 被调用后</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> ViewTarget<span class=\"token operator\">&lt;</span>ImageView<span class=\"token punctuation\">,</span> TranscodeType<span class=\"token operator\">></span> <span class=\"token function\">into</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@NonNull</span> ImageView view<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Util<span class=\"token punctuation\">.</span><span class=\"token function\">assertMainThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Preconditions<span class=\"token punctuation\">.</span><span class=\"token function\">checkNotNull</span><span class=\"token punctuation\">(</span>view<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    BaseRequestOptions<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> requestOptions <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>requestOptions<span class=\"token punctuation\">.</span><span class=\"token function\">isTransformationSet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token operator\">&amp;&amp;</span> requestOptions<span class=\"token punctuation\">.</span><span class=\"token function\">isTransformationAllowed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token operator\">&amp;&amp;</span> view<span class=\"token punctuation\">.</span><span class=\"token function\">getScaleType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>view<span class=\"token punctuation\">.</span><span class=\"token function\">getScaleType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">case</span> CENTER_CROP<span class=\"token operator\">:</span>\n          requestOptions <span class=\"token operator\">=</span> requestOptions<span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">optionalCenterCrop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> CENTER_INSIDE<span class=\"token operator\">:</span>\n          requestOptions <span class=\"token operator\">=</span> requestOptions<span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">optionalCenterInside</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> FIT_CENTER<span class=\"token operator\">:</span>\n        <span class=\"token keyword\">case</span> FIT_START<span class=\"token operator\">:</span>\n        <span class=\"token keyword\">case</span> FIT_END<span class=\"token operator\">:</span>\n          requestOptions <span class=\"token operator\">=</span> requestOptions<span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">optionalFitCenter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> FIT_XY<span class=\"token operator\">:</span>\n          requestOptions <span class=\"token operator\">=</span> requestOptions<span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">optionalCenterInside</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> CENTER<span class=\"token operator\">:</span>\n        <span class=\"token keyword\">case</span> MATRIX<span class=\"token operator\">:</span>\n        <span class=\"token keyword\">default</span><span class=\"token operator\">:</span>\n          <span class=\"token comment\" spellcheck=\"true\">// Do nothing.</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>Glide 显示对图片进行了解析，获取图片的尺寸等信息。</p>\n<pre class=\" language-java\"><code class=\"language-java\">  <span class=\"token keyword\">private</span> <span class=\"token operator\">&lt;</span>Y <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Target</span><span class=\"token operator\">&lt;</span>TranscodeType<span class=\"token operator\">>></span> Y <span class=\"token function\">into</span><span class=\"token punctuation\">(</span>\n      <span class=\"token annotation punctuation\">@NonNull</span> Y target<span class=\"token punctuation\">,</span>\n      <span class=\"token annotation punctuation\">@Nullable</span> RequestListener<span class=\"token operator\">&lt;</span>TranscodeType<span class=\"token operator\">></span> targetListener<span class=\"token punctuation\">,</span>\n      BaseRequestOptions<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> options<span class=\"token punctuation\">,</span>\n      Executor callbackExecutor<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Preconditions<span class=\"token punctuation\">.</span><span class=\"token function\">checkNotNull</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>isModelSet<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"You must call #load() before calling #into()\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    Request request <span class=\"token operator\">=</span> <span class=\"token function\">buildRequest</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> targetListener<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">,</span> callbackExecutor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Request previous <span class=\"token operator\">=</span> target<span class=\"token punctuation\">.</span><span class=\"token function\">getRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    requestManager<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    target<span class=\"token punctuation\">.</span><span class=\"token function\">setRequest</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    requestManager<span class=\"token punctuation\">.</span><span class=\"token function\">track</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> target<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>继续，创建了一个 <code>Request</code> ，这个 <code>Request</code> 的真实对象是 <code>SingleRequest</code> ，并通过 <code>requestManager</code> 执行了这个请求任务。利用三层缓存策略，最终展示了一张图片。</p>\n","site":{"data":{}},"excerpt":"<p>Glide 作为广为熟知的图片加载框架，在开发工作中出现的频率非常高，同比的还有 <code>Picasso</code> 和 <code>ImageLoader</code> 两套框架。 都各有特色。这里主要还是讲一下 <code>Glide</code> 。<br>","more":"<br><strong>基础用法：</strong></p>\n<pre><code class=\"java\">Glide.with(this).load(url).into(imageView);\n</code></pre>\n<p>在 Android 开发中，我们通常最简单的使用 <code>Glide</code> 的 代码如上面一样，如此简单的 api, 就可以帮助我们实现加载本地图片，本地 Drawable ， Gif 图，以及 网络图片，那么在这样简单的 API 的背后，其实它帮助了我们完成了很多工作。</p>\n<p>从简单的使用我们入手，可以看到，要想加载一张图片，我们需要一个当前上下文对象，一个图片地址，一个承载图像的 ImageView 容器。那中三个要求，又同时对应着三个函数，<code>with</code> <code>load</code> 和 <code>into</code>，阅读源码，那就是从源码暴漏给我们最直观的地方进入，不然就是一只没头的苍蝇—到处乱飞。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">函数</th>\n<th style=\"text-align:center\">主要功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">with</td>\n<td style=\"text-align:center\">1. 初始化Glide对象<br>2. 创建空白的 Fragment 管理生命周期机制<br>3. 创建一个 RequestManager 管理任务</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">load</td>\n<td style=\"text-align:center\">最终构建出 RequestBuilder ，记录传入的数据</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">into</td>\n<td style=\"text-align:center\">1. runRequest 运行队列/等待队列，执行队列 Reqeust 对象<br>2. 活动缓存<br>3. 内存缓存<br>4. HttpUrlConnection</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h2><p><code>Glide</code> 通过 <code>with</code> 函数，给自己的实例化，并创建一个空白的 <code>Fragment</code> 来管理生命周期并绑定 <code>ReqeustManager</code> 。继续通过 <code>load()</code> 函数构建一个 <code>RequestBuilder()</code> 并缓存我们的参数，继续通过 <code>into</code> 创建一个 <code>Request</code> 对象，并记录宽高、采样数据等。继续，在发起请求之前，先检查一下缓存数据, 活动缓存 <code>ActivityResources</code> 有没有数据，再检查内存缓存 <code>LRUResourceCache</code> ，如果两级缓存都未命中，则启动一个异步任务 <code>DecodeJob</code>, 去检查 <code>DiskCache</code> 中有没有本地磁盘缓存数据，如果没有，通过网络请求数据 <code>HttpUrlConnection</code> ，解析 <code>InputStream</code> 进行采样，最终拿到 <code>Bitmap</code>，将 <code>Bitmap</code> 转换成 <code>Drawable</code> 并讲数据缓存到磁盘中。</p>\n<h2 id=\"with\"><a href=\"#with\" class=\"headerlink\" title=\"with\"></a>with</h2><p>从上面的表格中，我们可以看出来 <code>with</code> 函数，就是用来帮我创建 <code>Glide</code> 对象，并创建一个空白的 <code>Fragment</code> 来管理生命周期。其具体的工作流程如图：</p>\n<p><img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/glide_with_sequence.jpg?raw=true\" alt=\"Glide with 时序图\"></p>\n<p>由上面的时序图，我们可以顺序的分析，我们一步步去分析。</p>\n<p><strong>Glide.with()</strong></p>\n<p><code>Glide.with()</code> 为提供了多种重构函数，目的是为我们提供它强大的作用域以及满足我们开发过程中各种复杂的情况。同时适配不同版本以及不同的应用场景。</p>\n<pre><code class=\"java\">@NonNull\npublic static RequestManager with(@NonNull Context context) {\n    return getRetriever(context).get(context);\n}\n\n@NonNull\npublic static RequestManager with(@NonNull Activity activity) {\n    return getRetriever(activity).get(activity);\n}\n\n@NonNull\npublic static RequestManager with(@NonNull FragmentActivity activity) {\n    return getRetriever(activity).get(activity);\n}\n\n@NonNull\npublic static RequestManager with(@NonNull Fragment fragment) {\n    return getRetriever(fragment.getContext()).get(fragment);\n}\n\n@NonNull\npublic static RequestManager with(@NonNull android.app.Fragment fragment) {\n    return getRetriever(fragment.getActivity()).get(fragment);\n}\n\n@NonNull\npublic static RequestManager with(@NonNull View view) {\n    return getRetriever(view.getContext()).get(view);\n}\n</code></pre>\n<p><strong>getRetriever</strong>()</p>\n<p><code>getRetriever()</code> 通过 Glide 的 get 函数，帮我们初始化了一个 <code>Glide</code> 对象。</p>\n<pre><code class=\"java\">@NonNull\nprivate static RequestManagerRetriever getRetriever(@Nullable Context context) {\n    return Glide.get(context).getRequestManagerRetriever();\n}\n</code></pre>\n<p><strong>get(context)</strong></p>\n<p>可以看出，Glide 是一个单例的，向下看时，我们也可看到，对 Glide 的检查很严谨。</p>\n<pre><code class=\"java\">private static volatile Glide glide;\n@NonNull\npublic static Glide get(@NonNull Context context) {\n    if (glide == null) {\n        synchronized (Glide.class) {\n            if (glide == null) {\n                checkAndInitializeGlide(context, annotationGeneratedModule);\n            }\n        }\n    }\n    return glide;\n}\n</code></pre>\n<p><strong>checkAndInitializeGlide() &amp; initializeGlide()</strong></p>\n<p>最终通过构造者模式，完成了对 <code>Glide</code> 对象的初始化，同时在构造者中，也对很多 <code>Glide</code> 工作时需要的对象进行了初始化。我们这里只研究主线业务，其它的可以私下看。</p>\n<pre><code class=\"java\">private static void checkAndInitializeGlide(\n    if (isInitializing) {\n        throw new IllegalStateException(\n            &quot;You cannot call Glide.get() in registerComponents(),&quot;\n            + &quot; use the provided Glide instance instead&quot;);\n    }\n    isInitializing = true;\n    initializeGlide(context, generatedAppGlideModule);\n    isInitializing = false;\n}\nprivate static void initializeGlide(Context context, GlideBuilder builder, GeneratedAppGlideModule annotationGeneratedModule) {\n    Glide glide = builder.build(applicationContext);\n    Glide.glide = glide;\n}\n</code></pre>\n<p>到这里， <code>Glide</code> 的初始化工作已经完成，具体初始化了什么信息，细节的东西，自己需要去认真的阅读源码。</p>\n<p>并且代码按照流程，<code>get()</code> 的深度代码已经完成，程序会逐步回到 <code>getRetriever()</code> 函数中，去执行 <code>getRequestManagerRetriever</code> ， <code>getRequestManagerRetriever</code> <code>是通过</code>Glide 的构造器完成的初始化工作，此时直接返回已经创建好的对象。并继续执行 <code>with()</code>函数 的 <code>get()</code> 去创建 <code>RequestManager</code></p>\n<p><strong>get(Fragment fragment)</strong></p>\n<p>这时候，我们发现，现在代码已经跳转到 <code>RequestManagerRetriever</code> 类中</p>\n<p><strong>RequestManagerRetriever</strong></p>\n<p><code>RequestManagerRetriever</code> 是一个管理类，负责生产 <code>Fragment</code> 对象，根据我们传入的 <code>Context</code> 上下文的定义不同，最终会帮我们创建不同的生命周期管理。</p>\n<pre><code class=\"java\">  @NonNull\n  public RequestManager get(@NonNull Fragment fragment) {\n    if (Util.isOnBackgroundThread()) {\n        // 创建一个全局作用域的 RequestManager，生命周期很长，容易出现内存问题\n      return get(fragment.getContext().getApplicationContext());\n    } else {\n      FragmentManager fm = fragment.getChildFragmentManager();\n      return supportFragmentGet(fragment.getContext(), fm, fragment, fragment.isVisible());\n    }\n  }\n\n  public RequestManager get(@NonNull Context context) {\n    if (context == null) {\n      throw new IllegalArgumentException(&quot;You cannot start a load on a null Context&quot;);\n    } else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) {\n      if (context instanceof FragmentActivity) {\n        return get((FragmentActivity) context);\n      } else if (context instanceof Activity) {\n        return get((Activity) context);\n      } else if (context instanceof ContextWrapper\n          &amp;&amp; ((ContextWrapper) context).getBaseContext().getApplicationContext() != null) {\n        return get(((ContextWrapper) context).getBaseContext());\n      }\n    }\n         // 创建一个全局作用域的 RequestManager，生命周期很长，容易出现内存问题\n      return getApplicationManager(context);\n  }\n</code></pre>\n<blockquote>\n<p><strong>Note:</strong></p>\n<ol>\n<li><p><strong>如果当前任务工作在后台线程或者传入的 <code>Context</code> 对象是一个 <code>Application</code> 级别的，那 <code>Glide</code> 就会帮我们创建一个和 <code>Application</code> 同生命周期的 <code>RequestManager</code> 对象，这个对象生命周期很长， 如果我们不规范使用的话，这里很容易造成<font color=\"red\">内存的泄漏</font></strong>。 因此我们使用时，尽量不要传入里类似的。</p>\n</li>\n<li><p>如果我们传入的是一个 Fragment 对象， Activity 对象等等，那 <code>Glide</code> 就会帮我们创建个空白的 <code>Fragment</code>， <code>supportFragmentGet</code> 和  <code>fragmentGet</code> 两种方案是用来做 <code>androidX</code> 和 <code>android.app</code>中不同 <code>fragment</code> 的适配</p>\n</li>\n</ol>\n</blockquote>\n<p><strong>supportFragmentGet</strong></p>\n<p>创建管理生命周期的 Fragment, <code>androidx</code> 对应的是 <code>supportFragmentGet()</code> ， <code>android.app</code> 对应的是 <code>fragmentGet()</code>， 这里以 <code>supportFragmentGet()</code> 为例：</p>\n<pre><code class=\"java\">  @NonNull\n  private RequestManager supportFragmentGet(\n      @NonNull Context context,\n      @NonNull FragmentManager fm,\n      @Nullable Fragment parentHint,\n      boolean isParentVisible) {\n      // 创建/获取当前空白的 Fragment\n    SupportRequestManagerFragment current =\n        getSupportRequestManagerFragment(fm, parentHint, isParentVisible);\n      // 获取空白 Fragment 中的 RequestManager 对象\n      // 如果为空，那么就通过工厂创建一个，并绑定回空白的 Fragment 中\n    RequestManager requestManager = current.getRequestManager();\n    if (requestManager == null) {\n      Glide glide = Glide.get(context);\n      requestManager =\n          factory.build(\n              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);\n      current.setRequestManager(requestManager);\n    }\n      // 返回 reqeustManager 对象\n    return requestManager;\n  }\n\n  @NonNull\n  private SupportRequestManagerFragment getSupportRequestManagerFragment(\n      @NonNull final FragmentManager fm, @Nullable Fragment parentHint, boolean isParentVisible) {\n      // 从 FragmentManager 中获取当前已经初始化好，并添加到 Fragment/Activity 中我们空白的 SupportRequestFragment \n    SupportRequestManagerFragment current =\n        (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);\n      // 如果为空，说明空白的 Fragment 还没有被添加进去\n    if (current == null) {\n        // pendingSupportRequestManagerFragments 是一个 HashMap 集合，用来暂存空白 Fragment 对象\n        // 由于 Glide 是一个单例对象，在 Glide 的 builder 中，间接的创建了 RequestManagerRetriever 对象，\n        // 因此 RequestManagerRetriever 也是一个单例，不同的 Activity/Fragment, 会有多个，因此这里用一个 HashMap 来存储空白 Fragment，\n        // 同时，为了保证每个页面只会有一个空白 Fragment，并可以快速定位，所以使用了 HashMap\n      current = pendingSupportRequestManagerFragments.get(fm); // 第一保障\n        // 如果当前缓存的数据中，仍然没有创建好 Fragment， 那就说明当前的空白 Fragment 还没有被创建\n      if (current == null) {\n          // 创建一个新的空白 Fragment\n        current = new SupportRequestManagerFragment();\n        current.setParentFragmentHint(parentHint);\n        if (isParentVisible) {\n            // 调用生命周期方法，让所有的监听者开始任务（后面会说）\n          current.getGlideLifecycle().onStart();\n        }\n          // 将创建好的 Fragment 存入到集合中\n        pendingSupportRequestManagerFragments.put(fm, current);\n          // Handler 通知父容器，这里添加了一个 Fragment\n        fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();\n          // 发送一个 handler 消息，将数据从集合中移除，节省内存空间。（第二保障）\n        handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();\n      }\n    }\n    return current;\n  }\n</code></pre>\n<blockquote>\n<p><strong>Note:</strong></p>\n<p>这里有一个比较困惑的地方就是，将已经创建好的 <code>Fragment</code> 添加到集合中去后，又通过 <code>Handler</code> 消息，将这个 <code>Fragment</code> 从集合中移除，这是为什么呢？</p>\n<p>其实最终的目的是节省内存空间做的一个优化，通过 Handler来处理是因为，<code>fragment</code> 的添加也是通过 <code>Handler</code> 来完成的，但 <code>Handler</code> 消息的执行时间不能保证，因此通过 <code>Handler</code> 再发一次消息，让移除操作在 <code>Fragment</code> 添加完成之后去执行，就一定能够得到保障。</p>\n<p>只有当 <code>Fragment</code> 被添加进入父容器之后， <code>fm.findFragmentByTag</code> 才能获取到对象。这也是为了保证每个父容器都只有一个空白 <code>Fragment</code> 的两次保障。</p>\n</blockquote>\n<h2 id=\"类关系图\"><a href=\"#类关系图\" class=\"headerlink\" title=\"类关系图\"></a>类关系图</h2><p>至此，with 函数的所有主线业务已经说完了，但究竟 Fragment 是如何监听生命周期变化的呢？我们来看下面这张关系图</p>\n<p><img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/glide_struct.jpg?raw=true\" alt=\"Glide lifecycle\"></p>\n<p><strong>SupportRequestManagerFragment</strong> </p>\n<p>内部绑定了 <code>ActivityFragmentLifecycle</code> ，通过 Fragment 生生命周期变化，来引导 <code>RequestManager</code> 完成图片的请求和后续的显示</p>\n<p>我们查看下源码：</p>\n<pre><code class=\"java\">public class SupportRequestManagerFragment extends Fragment {\n  private static final String TAG = &quot;SupportRMFragment&quot;;\n  private final ActivityFragmentLifecycle lifecycle;\n\n  @SuppressLint(&quot;ValidFragment&quot;)\n  public SupportRequestManagerFragment(@NonNull ActivityFragmentLifecycle lifecycle) {\n      // 构造器创建了 ActivityFramgentLifecycle\n    this.lifecycle = lifecycle;\n  }\n\n  // 在前面初始化 SupportRequestManagerFragment 的代码中，我们还记得他手动的调用了一下 start 方法吧\n  @Override\n  public void onStart() {\n    super.onStart();\n    lifecycle.onStart();\n  }\n\n  @Override\n  public void onStop() {\n    super.onStop();\n    lifecycle.onStop();\n  }\n\n  @Override\n  public void onDestroy() {\n    super.onDestroy();\n    lifecycle.onDestroy();\n    unregisterFragmentWithRoot();\n  }\n\n  @NonNull\n  ActivityFragmentLifecycle getGlideLifecycle() {\n    return lifecycle;\n  }\n}\n</code></pre>\n<p>当 Fragment / Activity 已经不可见时，通过生命周期变化，通知业务功能类去停止请求或调用，防止内存泄漏和崩溃。</p>\n<h2 id=\"load\"><a href=\"#load\" class=\"headerlink\" title=\"load\"></a>load</h2><p><img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/glide_load.jpg?raw=true\" alt=\"Glide load\"></p>\n<p>我们将 <code>Glide.with(this).load(url).into(view);</code> 拆分开来写，如下：</p>\n<pre><code class=\"java\">RequestManager requestManager = Glide.with(this);\nRequestBuilder requestBuilder = requestManager.load(url);\nrequestBuilder.into(view);\n</code></pre>\n<p>可以看出， load 函数，我们传入了一个 <code>String</code> 类型的 <code>Url</code>， 最终返回给我们一个 <code>RequestBuilder</code> 对象。按照上面的时序图，我们简单分析一下可以看出，实际上 <code>RequestBuilder</code> 就是一个构造者，记录我们传入的参数，最终将我们传入的内容转化为一个 <code>Drawable</code> 。</p>\n<p><code>Glide</code> 也为我们提供了丰富的 <code>load api</code>， 我们可以传入 <code>url, bitmap, byte[], Drawable, Uri, File, Integer</code> 等等， <code>RequestBuilder</code> 就是来记录我们传入的具体是一个什么样子的数据，并将他们在展示的时候，最终转化成一个 <code>Drawable</code> 给图片容器，也就是后面我们要说的 <code>into</code> 函数。</p>\n<h2 id=\"into\"><a href=\"#into\" class=\"headerlink\" title=\"into\"></a>into</h2><p>into 的流程相当复杂，流程图已经展示不下，也不清晰。这是一张不完整的时序图。并没有体现网络请求的部分，和缓存的部分。</p>\n<p><img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/glide_into.jpg?raw=true\" alt></p>\n<p>但我们先按照这个残图先分析一下。</p>\n<p>当 <code>into(imageview)</code> 被调用后</p>\n<pre><code class=\"java\">public ViewTarget&lt;ImageView, TranscodeType&gt; into(@NonNull ImageView view) {\n    Util.assertMainThread();\n    Preconditions.checkNotNull(view);\n\n    BaseRequestOptions&lt;?&gt; requestOptions = this;\n    if (!requestOptions.isTransformationSet()\n        &amp;&amp; requestOptions.isTransformationAllowed()\n        &amp;&amp; view.getScaleType() != null) {\n      switch (view.getScaleType()) {\n        case CENTER_CROP:\n          requestOptions = requestOptions.clone().optionalCenterCrop();\n          break;\n        case CENTER_INSIDE:\n          requestOptions = requestOptions.clone().optionalCenterInside();\n          break;\n        case FIT_CENTER:\n        case FIT_START:\n        case FIT_END:\n          requestOptions = requestOptions.clone().optionalFitCenter();\n          break;\n        case FIT_XY:\n          requestOptions = requestOptions.clone().optionalCenterInside();\n          break;\n        case CENTER:\n        case MATRIX:\n        default:\n          // Do nothing.\n      }\n    }\n</code></pre>\n<p>Glide 显示对图片进行了解析，获取图片的尺寸等信息。</p>\n<pre><code class=\"java\">  private &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(\n      @NonNull Y target,\n      @Nullable RequestListener&lt;TranscodeType&gt; targetListener,\n      BaseRequestOptions&lt;?&gt; options,\n      Executor callbackExecutor) {\n    Preconditions.checkNotNull(target);\n    if (!isModelSet) {\n      throw new IllegalArgumentException(&quot;You must call #load() before calling #into()&quot;);\n    }\n    Request request = buildRequest(target, targetListener, options, callbackExecutor);\n    Request previous = target.getRequest();\n    requestManager.clear(target);\n    target.setRequest(request);\n    requestManager.track(target, request);\n\n    return target;\n  }\n</code></pre>\n<p>继续，创建了一个 <code>Request</code> ，这个 <code>Request</code> 的真实对象是 <code>SingleRequest</code> ，并通过 <code>requestManager</code> 执行了这个请求任务。利用三层缓存策略，最终展示了一张图片。</p>"},{"title":"OKHttp 重定向拦截器","date":"2020-02-20T09:05:21.000Z","_content":"# 使用 OKHttp 进行重定向拦截处理\n\n\nokhttp重定向存在两个缺陷：\n\n1. okhttp处理301,302重定向时，会把请求方式设置为GET\n这样会丢失原来Post请求中的参数。\n<!-- more-->\n2. okhttp默认不支持跨协议的重定向，比如http重定向到https\n\n为了解决这两个问题写了这个拦截器\n\n\n```java\n\nclass RedirectInterceptor implements Interceptor {\n    @Override\n    public Response intercept(Chain chain) throws IOException {\n        Request request = chain.request();\n        HttpUrl beforeUrl = request.url();\n        Response response = chain.proceed(request);\n        HttpUrl afterUrl = response.request().url();\n        //1.根据url判断是否是重定向\n        if(!beforeUrl.equals(afterUrl)) {\n            //处理两种情况 1、跨协议 2、原先不是GET请求。\n            if (!beforeUrl.scheme().equals(afterUrl.scheme())||!request.method().equals(\"GET\")) {\n                //重新请求\n                Request newRequest = request.newBuilder().url(response.request().url()).build();\n                response = chain.proceed(newRequest);\n            }\n        }\n        return response;\n    }\n}\n```\n\n\n","source":"_posts/三方框架/OKHttp-重定向拦截器.md","raw":"---\ntitle: OKHttp 重定向拦截器\ndate: 2020-02-20 17:05:21\ntags: 三方框架\n---\n# 使用 OKHttp 进行重定向拦截处理\n\n\nokhttp重定向存在两个缺陷：\n\n1. okhttp处理301,302重定向时，会把请求方式设置为GET\n这样会丢失原来Post请求中的参数。\n<!-- more-->\n2. okhttp默认不支持跨协议的重定向，比如http重定向到https\n\n为了解决这两个问题写了这个拦截器\n\n\n```java\n\nclass RedirectInterceptor implements Interceptor {\n    @Override\n    public Response intercept(Chain chain) throws IOException {\n        Request request = chain.request();\n        HttpUrl beforeUrl = request.url();\n        Response response = chain.proceed(request);\n        HttpUrl afterUrl = response.request().url();\n        //1.根据url判断是否是重定向\n        if(!beforeUrl.equals(afterUrl)) {\n            //处理两种情况 1、跨协议 2、原先不是GET请求。\n            if (!beforeUrl.scheme().equals(afterUrl.scheme())||!request.method().equals(\"GET\")) {\n                //重新请求\n                Request newRequest = request.newBuilder().url(response.request().url()).build();\n                response = chain.proceed(newRequest);\n            }\n        }\n        return response;\n    }\n}\n```\n\n\n","slug":"三方框架/OKHttp-重定向拦截器","published":1,"updated":"2021-01-29T16:05:19.187Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8fm002dsz5q7qyxdbli","content":"<h1 id=\"使用-OKHttp-进行重定向拦截处理\"><a href=\"#使用-OKHttp-进行重定向拦截处理\" class=\"headerlink\" title=\"使用 OKHttp 进行重定向拦截处理\"></a>使用 OKHttp 进行重定向拦截处理</h1><p>okhttp重定向存在两个缺陷：</p>\n<ol>\n<li>okhttp处理301,302重定向时，会把请求方式设置为GET<br>这样会丢失原来Post请求中的参数。<a id=\"more\"></a></li>\n<li>okhttp默认不支持跨协议的重定向，比如http重定向到https</li>\n</ol>\n<p>为了解决这两个问题写了这个拦截器</p>\n<pre class=\" language-java\"><code class=\"language-java\">\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">RedirectInterceptor</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Interceptor</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> Response <span class=\"token function\">intercept</span><span class=\"token punctuation\">(</span>Chain chain<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> IOException <span class=\"token punctuation\">{</span>\n        Request request <span class=\"token operator\">=</span> chain<span class=\"token punctuation\">.</span><span class=\"token function\">request</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        HttpUrl beforeUrl <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span><span class=\"token function\">url</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Response response <span class=\"token operator\">=</span> chain<span class=\"token punctuation\">.</span><span class=\"token function\">proceed</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        HttpUrl afterUrl <span class=\"token operator\">=</span> response<span class=\"token punctuation\">.</span><span class=\"token function\">request</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">url</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//1.根据url判断是否是重定向</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>beforeUrl<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>afterUrl<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//处理两种情况 1、跨协议 2、原先不是GET请求。</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>beforeUrl<span class=\"token punctuation\">.</span><span class=\"token function\">scheme</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>afterUrl<span class=\"token punctuation\">.</span><span class=\"token function\">scheme</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token operator\">||</span><span class=\"token operator\">!</span>request<span class=\"token punctuation\">.</span><span class=\"token function\">method</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"GET\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">//重新请求</span>\n                Request newRequest <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span><span class=\"token function\">newBuilder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">url</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span><span class=\"token function\">request</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">url</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                response <span class=\"token operator\">=</span> chain<span class=\"token punctuation\">.</span><span class=\"token function\">proceed</span><span class=\"token punctuation\">(</span>newRequest<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> response<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n","site":{"data":{}},"excerpt":"<h1 id=\"使用-OKHttp-进行重定向拦截处理\"><a href=\"#使用-OKHttp-进行重定向拦截处理\" class=\"headerlink\" title=\"使用 OKHttp 进行重定向拦截处理\"></a>使用 OKHttp 进行重定向拦截处理</h1><p>okhttp重定向存在两个缺陷：</p>\n<ol>\n<li>okhttp处理301,302重定向时，会把请求方式设置为GET<br>这样会丢失原来Post请求中的参数。","more":"</li>\n<li>okhttp默认不支持跨协议的重定向，比如http重定向到https</li>\n</ol>\n<p>为了解决这两个问题写了这个拦截器</p>\n<pre><code class=\"java\">\nclass RedirectInterceptor implements Interceptor {\n    @Override\n    public Response intercept(Chain chain) throws IOException {\n        Request request = chain.request();\n        HttpUrl beforeUrl = request.url();\n        Response response = chain.proceed(request);\n        HttpUrl afterUrl = response.request().url();\n        //1.根据url判断是否是重定向\n        if(!beforeUrl.equals(afterUrl)) {\n            //处理两种情况 1、跨协议 2、原先不是GET请求。\n            if (!beforeUrl.scheme().equals(afterUrl.scheme())||!request.method().equals(&quot;GET&quot;)) {\n                //重新请求\n                Request newRequest = request.newBuilder().url(response.request().url()).build();\n                response = chain.proceed(newRequest);\n            }\n        }\n        return response;\n    }\n}\n</code></pre>"},{"title":"OkHttp Intercept","date":"2019-04-30T12:42:02.000Z","_content":"\n\nOKHttp 在开发中经常用到,这里介绍一下 OKHttp 的拦截器(interceptor)的几个使用例子\n\n<!-- more-->\n\n要是用拦截器很简单,我们只需要自定义一个 interceptor 类, 并实现 Interceptor 接口, 同时重写 intercept 方法.\n\n\n\n这里介绍两种 Interceptor 的实例\n\n\n<!-- more -->\n\n## Log 日志 (LogInterceptor)\n\nLog 在开发调试中的重要性, 不言而喻, 一个好的日志数据,能够为开发时提供很多帮助,可以通过 Log 来获取当前程序的执行状态, 顺序等等.\n\n\n\n这里介绍的 Log 日志拦截器,主要是负责在网络请求时,截获请求中的信息,并将请求信息以 Log 的方式输出到控制台上,可展现当前请求地址,请求参数,以及请求结果等.\n\n\n\n话不多说, 上代码.\n\n\n\n```java\n/**\n* 自定义 log 拦截器,输入请求地址,请求参,请求结果\n*/\npublic class LogInterceptor implements Interceptor {\n\n        @Override\n        public Response intercept(Chain chain) throws IOException {\n            // 拦截请求信息,获取请求地址及请求参数\n            Request request = chain.request();\n\n            long t1 = System.nanoTime();\n            // 获取请求方式\n            String method = request.method();\n            if (\"POST\".equals(method)) {\n                StringBuilder sb = new StringBuilder();\n                if (request.body() instanceof FormBody) {\n                    FormBody body = (FormBody) request.body();\n                    for (int i = 0; i < body.size(); i++) {\n                        sb.append(body.encodedName(i) + \"=\" + body.encodedValue(i) + \",\");\n                    }\n                    sb.delete(sb.length() - 1, sb.length());\n                    LogUtils.d(TAG, String.format(\"Sending request %s on %s %n%s %nRequestParams:{%s}\",\n                            request.url(), chain.connection(), request.headers(), sb.toString()));\n                }\n            } else {\n                LogUtils.d(TAG, String.format(\"Sending request %s on %s %n%s\",\n                        request.url(), chain.connection(), request.headers()));\n            }\n\t\t\t// 获取响应信息\n            Response response = chain.proceed(request);\n            long t2 = System.nanoTime();\n            LogUtils.d(TAG, String.format(\"Received response for %s in %.1fms%n%s\",\n                    response.request().url(), (t2 - t1) / 1e6d, response.headers()));\n\n            MediaType contentType = response.body().contentType();\n            String content = response.body().string();\n            LogUtils.d(TAG, content);\n            ResponseBody wrappedBody = ResponseBody.create(contentType, content);\n            return response.newBuilder().body(wrappedBody).build();\n        }\n    }\n```\n\n\n\n\n\n## 加参\n\n\n\n加参的意义在于,在请求过程中, 需要传递一些基本参数,这些参数是基本保持不变的, 而这些参数又是后台需要校验的依靠,我们俗称他们为**公参**, 如果在请求过程中在每一个接口里面都去添加这些参数,显得非常繁琐,而且麻烦,后续人员接手,又会不知所措,维护起来相当不方便.\n\n\n\n因此,在这里我们还是通过请求拦截器,通过拦截器去添加这些参数.\n\n### 公参拦截器\n\n在请求中,增加一些公共的参数.\n\n```java\npublic class CommonParamsInterceptor implements Interceptor {\n\n    private Map<String, String> queryParamsMap = new HashMap<>();\n    private Map<String, String> paramsMap = new HashMap<>();\n    private Map<String, String> headerParamsMap = new HashMap<>();\n    private List<String> headerLinesList = new ArrayList<>();\n\n    @Override\n    public Response intercept(Chain chain) throws IOException {\n\n        Request request = chain.request();\n        Request.Builder requestBuilder = request.newBuilder();\n\n        // process header params inject\n        Headers.Builder headerBuilder = request.headers().newBuilder();\n        if (headerParamsMap.size() > 0) {\n            Iterator iterator = headerParamsMap.entrySet().iterator();\n            while (iterator.hasNext()) {\n                Map.Entry entry = (Map.Entry) iterator.next();\n                headerBuilder.add((String) entry.getKey(), (String) entry.getValue());\n            }\n        }\n\n        if (headerLinesList.size() > 0) {\n            for (String line : headerLinesList) {\n                headerBuilder.add(line);\n            }\n            requestBuilder.headers(headerBuilder.build());\n        }\n        // process header params end\n\n\n        // process queryParams inject whatever it's GET or POST\n        if (queryParamsMap.size() > 0 && \"GET\".equals(request.method())) {\n//        if (queryParamsMap.size() > 0) {\n            request = injectParamsIntoUrl(request, requestBuilder, queryParamsMap);\n        }\n\n        // process post body inject\n        if (paramsMap != null && paramsMap.size() > 0 && \"POST\".equals(request.method())) {\n            if (request.body() instanceof FormBody) {\n                FormBody.Builder newFormBodyBuilder = new FormBody.Builder();\n                if (paramsMap.size() > 0) {\n                    Iterator iterator = paramsMap.entrySet().iterator();\n                    while (iterator.hasNext()) {\n                        Map.Entry entry = (Map.Entry) iterator.next();\n                        newFormBodyBuilder.add((String) entry.getKey(), (String) entry.getValue());\n                    }\n                }\n\n                FormBody oldFormBody = (FormBody) request.body();\n                int paramSize = oldFormBody.size();\n                if (paramSize > 0) {\n                    for (int i = 0; i < paramSize; i++) {\n                        newFormBodyBuilder.add(oldFormBody.name(i), oldFormBody.value(i));\n                    }\n                }\n\n                requestBuilder.post(newFormBodyBuilder.build());\n                request = requestBuilder.build();\n            } else if (request.body() instanceof MultipartBody) {\n                MultipartBody.Builder multipartBuilder = new MultipartBody.Builder().setType(MultipartBody.FORM);\n\n                Iterator iterator = paramsMap.entrySet().iterator();\n                while (iterator.hasNext()) {\n                    Map.Entry entry = (Map.Entry) iterator.next();\n                    multipartBuilder.addFormDataPart((String) entry.getKey(), (String) entry.getValue());\n                }\n\n                List<MultipartBody.Part> oldParts = ((MultipartBody) request.body()).parts();\n                if (oldParts != null && oldParts.size() > 0) {\n                    for (MultipartBody.Part part : oldParts) {\n                        multipartBuilder.addPart(part);\n                    }\n                }\n\n                requestBuilder.post(multipartBuilder.build());\n                request = requestBuilder.build();\n            }\n\n        }\n        return chain.proceed(request);\n    }\n\n    private boolean canInjectIntoBody(Request request) {\n        if (request == null) {\n            return false;\n        }\n        if (!TextUtils.equals(request.method(), \"POST\")) {\n            return false;\n        }\n        RequestBody body = request.body();\n        if (body == null) {\n            return false;\n        }\n        MediaType mediaType = body.contentType();\n        if (mediaType == null) {\n            return false;\n        }\n        if (!TextUtils.equals(mediaType.subtype(), \"x-www-form-urlencoded\")) {\n            return false;\n        }\n        return true;\n    }\n\n    // func to inject params into url\n    private Request injectParamsIntoUrl(Request request, Request.Builder requestBuilder, Map<String, String> paramsMap) {\n        HttpUrl.Builder httpUrlBuilder = request.url().newBuilder();\n        if (paramsMap.size() > 0) {\n            Iterator iterator = paramsMap.entrySet().iterator();\n            while (iterator.hasNext()) {\n                Map.Entry entry = (Map.Entry) iterator.next();\n                httpUrlBuilder.addEncodedQueryParameter((String) entry.getKey(), (String) entry.getValue());\n            }\n            requestBuilder.url(httpUrlBuilder.build());\n            return requestBuilder.build();\n        }\n\n        return request;\n    }\n\n    private static String bodyToString(final RequestBody request) {\n        try {\n            final RequestBody copy = request;\n            final Buffer buffer = new Buffer();\n            if (copy != null)\n                copy.writeTo(buffer);\n            else\n                return \"\";\n            return buffer.readUtf8();\n        } catch (final IOException e) {\n            return \"did not work\";\n        }\n    }\n\n    public static class Builder {\n\n        CommonParamsInterceptor interceptor;\n\n        public Builder() {\n            interceptor = new CommonParamsInterceptor();\n        }\n\n        public Builder addParam(String key, String value) {\n            interceptor.paramsMap.put(key, value);\n            return this;\n        }\n\n        public Builder addParamsMap(Map<String, String> paramsMap) {\n            interceptor.paramsMap.putAll(paramsMap);\n            return this;\n        }\n\n        public Builder addHeaderParam(String key, String value) {\n            interceptor.headerParamsMap.put(key, value);\n            return this;\n        }\n\n        public Builder addHeaderParamsMap(Map<String, String> headerParamsMap) {\n            interceptor.headerParamsMap.putAll(headerParamsMap);\n            return this;\n        }\n\n        public Builder addHeaderLine(String headerLine) {\n            int index = headerLine.indexOf(\":\");\n            if (index == -1) {\n                throw new IllegalArgumentException(\"Unexpected header: \" + headerLine);\n            }\n            interceptor.headerLinesList.add(headerLine);\n            return this;\n        }\n\n        public Builder addHeaderLinesList(List<String> headerLinesList) {\n            for (String headerLine : headerLinesList) {\n                int index = headerLine.indexOf(\":\");\n                if (index == -1) {\n                    throw new IllegalArgumentException(\"Unexpected header: \" + headerLine);\n                }\n                interceptor.headerLinesList.add(headerLine);\n            }\n            return this;\n        }\n\n        public Builder addQueryParam(String key, String value) {\n            interceptor.queryParamsMap.put(key, value);\n            return this;\n        }\n\n        public Builder addQueryParamsMap(Map<String, String> queryParamsMap) {\n            interceptor.queryParamsMap.putAll(queryParamsMap);\n            return this;\n        }\n\n        public CommonParamsInterceptor build() {\n            return interceptor;\n        }\n    }\n}\n```\n\n\n\n### 加签拦截器\n\n互联网是一个开放的环境,危险无处不在,加密通信是安全的基础.\n\n加密的方式又有很多,比如对称加密/非对称加密/Hash(严格的说不是加密),这里先不对加密进行介绍,我们聊聊加签;\n\n加签,其实就是给报文做一个摘要,相同的签名算法得到的摘要是相同的,比如MD5, SH1, SH256等, 简单的加签并不能防止篡改,因为攻击者可以篡改后,自己生成新的签名.服务端验签还是可以通过的,因此加签时一定要包含一些私有的东西,比如私钥.\n\n\n\n这里介绍一种加签方式,\n\n>  加密规则\n\n1.  根据请求参数 key 进行排序\n2.  按排好的顺序组装成 key=value&key=value 形式的字符串\n3.  将上述字符串拼接  ,最终形成 key=value&key=value的字符串\n4.  将字符串 md5, 生成 auth.\n\n\n\n一个简单的加签逻辑就是这样,下面代码就是对这种规则的实现,看代码↓↓↓↓\n\n```java\npublic class AuthorizeInterceptor implements Interceptor {\n\n    private static final String TAG = \"AuthorizeInterceptor\";\n\n    /**\n     * 生成 auth 的私钥\n     */\n    private String authKey;\n\n    /**\n     * 当前设备 mid,用来生成 auth\n     * 数据由 Builder 类传入\n     */\n    private String mid = \"\";\n\n    private AuthorizeInterceptor() {\n    }\n\n    @Override\n    public Response intercept(Chain chain) throws IOException {\n        Request request = chain.request();\n        Request.Builder requestBuilder = request.newBuilder();\n        String url = request.url().toString();\n        LogUtils.d(TAG, url);\n        if (\"POST\".equals(request.method())) {\n            request = injectionParamIntoBody(request, requestBuilder);\n        } else if (\"GET\".equals(request.method())) {\n            request = injectionAuthIntoUrl(request, requestBuilder);\n        }\n        return chain.proceed(request);\n    }\n\n    /**\n     * GET 请求方式, 生成授权和添加时间戳\n     *\n     * @param request\n     * @param requestBuilder\n     * @return\n     */\n    private Request injectionAuthIntoUrl(Request request, Request.Builder requestBuilder) {\n        //获取到请求地址api\n        HttpUrl newHttpUrl = request.url();\n        TreeMap<String, String> authMap = new TreeMap<>();\n        //通过请求地址(最初始的请求地址)获取到参数列表\n        Set<String> parameterNames = newHttpUrl.queryParameterNames();\n        for (String key : parameterNames) {\n            //循环参数列表,获取参数value,\n                String paramValue = newHttpUrl.queryParameter(key);\n                if (!TextUtils.isEmpty(paramValue)) {\n                    authMap.put(key, paramValue);\n                }\n            \n        }\n        HttpUrl.Builder newBuilder =\n                request.url().newBuilder()\n                        .addEncodedQueryParameter(\"auth\", assembleAuth(authMap, false));\n        requestBuilder.url(newBuilder.build());\n        return requestBuilder.build();\n    }\n\n    /**\n     * 将参数注入到 POST 请求的 body 中\n     *\n     * @param request\n     * @param requestBuilder\n     * @return\n     */\n    private Request injectionParamIntoBody(Request request, Request.Builder requestBuilder) {\n        if (request.body() instanceof FormBody) {\n            // 处理正常表单请求方式\n            FormBody oldFormBody = (FormBody) request.body();\n            return assembleFormBody(request, oldFormBody, requestBuilder);\n        } else if (request.body() instanceof MultipartBody) {\n            return assembleMultipartBody(request, requestBuilder);\n        } else {\n            return request;\n        }\n    }\n\n    /**\n     * 构建流媒体参数的 body\n     *\n     * @param request\n     * @param builder\n     * @return\n     */\n    private Request assembleMultipartBody(Request request, Request.Builder builder) {\n        // 处理流的请求方式\n        MultipartBody body = (MultipartBody) request.body();\n        TreeMap<String, String> authMap = new TreeMap<>();\n        // 获取参数 key 及 value 数据, 将数据写入到 TreeMap 中进行排序\n        if (body != null && body.parts().size() > 0) {\n            for (MultipartBody.Part part : body.parts()) {\n                // 只处理 contentType 为空,或为 text 的情况, image 上传图片的字段,不进行处理\n                if (part.body().contentType() == null\n                        || !\"image\".equals(part.body().contentType().type())\n                        || \"text\".equals(part.body().contentType().type())) {\n                    Headers headers = part.headers();\n                    // 从 header 中获取 Key, form-data; name= 的字段过滤获取key\n                    // 筛选掉 basic, 获取到当前 header,对应的 RequestBody, 通过 buffer 的方式,获取到 value\n                    // 将 key 和 value 填充到 TreeMap 中\n                    for (int i = 0; i < headers.names().size(); i++) {\n                        String headerName = headers.value(i);\n                        if (headerName.contains(\"form-data; name=\")) {\n                            String key = headerName.replace(\"form-data; name=\", \"\").replace(\"\\\"\", \"\");\n                                String value = body2String(part.body());\n                                if (!TextUtils.isEmpty(value)) {\n                                    authMap.put(key, body2String(part.body()));\n                                }\n                                                   }\n                    }\n                }\n            }\n        }\n\n        MultipartBody.Builder multipartBuilder = new MultipartBody.Builder().setType(MultipartBody.FORM);\n        multipartBuilder.addFormDataPart(\"auth\", assembleAuth(authMap, false));\n        List<MultipartBody.Part> oldParts = ((MultipartBody) request.body()).parts();\n        if (oldParts != null && oldParts.size() > 0) {\n            for (MultipartBody.Part part : oldParts) {\n                multipartBuilder.addPart(part);\n            }\n        }\n        builder.post(multipartBuilder.build());\n        return builder.build();\n    }\n\n    /**\n     * 构建 Auth 数据\n     * <p>\n     * TreeMap 数据,按照字母顺序自动排序后,遍历数据,拼接成 key=value&key=value 的形式,\n     * Map 拼接完成后,在其后需要再次拼接上\n     * <p>\n     * 最后将数据 MD5 转化为 32 位小写并返回\n     *\n     * @param treeMap      构建 Auth 的具体数据\n     * @param isNeedDecode 是否需要解码\n     * @return 返回 auth 数据 \n     */\n    private String assembleAuth(TreeMap<String, String> treeMap, boolean isNeedDecode) {\n        StringBuilder stringBuilder = new StringBuilder();\n        if (treeMap.size() > 0) {\n            for (Map.Entry<String, String> stringStringEntry : treeMap.entrySet()) {\n                try {\n                    stringBuilder.append(stringStringEntry.getKey())\n                            .append(\"=\")\n                            .append(isNeedDecode\n                                    ? URLDecoder.decode(stringStringEntry.getValue(), \"UTF-8\")\n                                    : stringStringEntry.getValue())\n                            .append(\"&\");\n                } catch (UnsupportedEncodingException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        treeMap.clear();\n        stringBuilder\n                .append(authKey);\n        Log.d(TAG, stringBuilder.toString());\n        return MD5.MD5(stringBuilder.toString());\n    }\n\n    /**\n     * body 转 string 获取实际参数值\n     *\n     * @param body Part body\n     * @return part 中写如的参数数据\n     */\n    private String body2String(RequestBody body) {\n        if (body != null) {\n            Buffer buffer = new Buffer();\n            try {\n                body.writeTo(buffer);\n                Charset charset = Charset.forName(\"UTF-8\");\n                MediaType contentType = body.contentType();\n                if (contentType != null) {\n                    charset = contentType.charset(charset);\n                }\n                assert charset != null;\n                return buffer.readString(charset);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return \"\";\n    }\n\n    /**\n     * 组装 Form 表单请求数据\n     *\n     * @param request\n     * @param oldFormBody\n     * @param requestBuilder\n     * @return\n     */\n    private Request assembleFormBody(Request request, FormBody oldFormBody, Request.Builder requestBuilder) {\n        TreeMap<String, String> authMap = new TreeMap<>();\n        // 遍历请求参数,非空参数,添加到集合中\n        for (int i = 0; i < oldFormBody.size(); i++) {\n            if (!TextUtils.isEmpty(oldFormBody.encodedValue(i))) {\n                authMap.put(oldFormBody.encodedName(i), oldFormBody.encodedValue(i));\n            }\n        }\n        if (authMap.size() != 0) {\n            // 生成 auth 数据\n            FormBody.Builder newFormBody = new FormBody.Builder();\n            for (int i = 0; i < oldFormBody.size(); i++) {\n                newFormBody.addEncoded(oldFormBody.encodedName(i), oldFormBody.encodedValue(i));\n            }\n            newFormBody.add(\"auth\", assembleAuth(authMap, true));\n            requestBuilder.method(request.method(), newFormBody.build());\n            return requestBuilder.build();\n        }\n\n        return request;\n    }\n\n\n    /**\n     * Builder 构造函数,用来设置 Authorize 的相关参数,及创建工作\n     */\n    public static class Builder {\n        AuthorizeInterceptor authorizeInterceptor;\n\n        public Builder() {\n            authorizeInterceptor = new AuthorizeInterceptor();\n        }\n\n        public Builder setMid(String mid) {\n            authorizeInterceptor.mid = mid;\n            return this;\n        }\n\n        public Builder setAuthKey(String key) {\n            authorizeInterceptor.authKey = key;\n            return this;\n        }\n\n        public AuthorizeInterceptor build() {\n            return authorizeInterceptor;\n        }\n    }\n}\n```\n\n\n\n该加签方式,讲请求参数拼接为 `key=value` 的方式, 难点在于如何从 OkHttp 中获取这些参数,在 GET 请求和 POST 的处理方式又不同,代码中 POST 请求方式,又会根据请求传递的 `contentType` 而又有所不同,这里介绍了`Form`表单提交和 `Multipart` 上传文件的参数获取方式,其他的请举一反三.\n\n","source":"_posts/三方框架/OkHttp-Intercept.md","raw":"---\ntitle: OkHttp Intercept\ndate: 2019-04-30 20:42:02\ntags: 三方框架\n---\n\n\nOKHttp 在开发中经常用到,这里介绍一下 OKHttp 的拦截器(interceptor)的几个使用例子\n\n<!-- more-->\n\n要是用拦截器很简单,我们只需要自定义一个 interceptor 类, 并实现 Interceptor 接口, 同时重写 intercept 方法.\n\n\n\n这里介绍两种 Interceptor 的实例\n\n\n<!-- more -->\n\n## Log 日志 (LogInterceptor)\n\nLog 在开发调试中的重要性, 不言而喻, 一个好的日志数据,能够为开发时提供很多帮助,可以通过 Log 来获取当前程序的执行状态, 顺序等等.\n\n\n\n这里介绍的 Log 日志拦截器,主要是负责在网络请求时,截获请求中的信息,并将请求信息以 Log 的方式输出到控制台上,可展现当前请求地址,请求参数,以及请求结果等.\n\n\n\n话不多说, 上代码.\n\n\n\n```java\n/**\n* 自定义 log 拦截器,输入请求地址,请求参,请求结果\n*/\npublic class LogInterceptor implements Interceptor {\n\n        @Override\n        public Response intercept(Chain chain) throws IOException {\n            // 拦截请求信息,获取请求地址及请求参数\n            Request request = chain.request();\n\n            long t1 = System.nanoTime();\n            // 获取请求方式\n            String method = request.method();\n            if (\"POST\".equals(method)) {\n                StringBuilder sb = new StringBuilder();\n                if (request.body() instanceof FormBody) {\n                    FormBody body = (FormBody) request.body();\n                    for (int i = 0; i < body.size(); i++) {\n                        sb.append(body.encodedName(i) + \"=\" + body.encodedValue(i) + \",\");\n                    }\n                    sb.delete(sb.length() - 1, sb.length());\n                    LogUtils.d(TAG, String.format(\"Sending request %s on %s %n%s %nRequestParams:{%s}\",\n                            request.url(), chain.connection(), request.headers(), sb.toString()));\n                }\n            } else {\n                LogUtils.d(TAG, String.format(\"Sending request %s on %s %n%s\",\n                        request.url(), chain.connection(), request.headers()));\n            }\n\t\t\t// 获取响应信息\n            Response response = chain.proceed(request);\n            long t2 = System.nanoTime();\n            LogUtils.d(TAG, String.format(\"Received response for %s in %.1fms%n%s\",\n                    response.request().url(), (t2 - t1) / 1e6d, response.headers()));\n\n            MediaType contentType = response.body().contentType();\n            String content = response.body().string();\n            LogUtils.d(TAG, content);\n            ResponseBody wrappedBody = ResponseBody.create(contentType, content);\n            return response.newBuilder().body(wrappedBody).build();\n        }\n    }\n```\n\n\n\n\n\n## 加参\n\n\n\n加参的意义在于,在请求过程中, 需要传递一些基本参数,这些参数是基本保持不变的, 而这些参数又是后台需要校验的依靠,我们俗称他们为**公参**, 如果在请求过程中在每一个接口里面都去添加这些参数,显得非常繁琐,而且麻烦,后续人员接手,又会不知所措,维护起来相当不方便.\n\n\n\n因此,在这里我们还是通过请求拦截器,通过拦截器去添加这些参数.\n\n### 公参拦截器\n\n在请求中,增加一些公共的参数.\n\n```java\npublic class CommonParamsInterceptor implements Interceptor {\n\n    private Map<String, String> queryParamsMap = new HashMap<>();\n    private Map<String, String> paramsMap = new HashMap<>();\n    private Map<String, String> headerParamsMap = new HashMap<>();\n    private List<String> headerLinesList = new ArrayList<>();\n\n    @Override\n    public Response intercept(Chain chain) throws IOException {\n\n        Request request = chain.request();\n        Request.Builder requestBuilder = request.newBuilder();\n\n        // process header params inject\n        Headers.Builder headerBuilder = request.headers().newBuilder();\n        if (headerParamsMap.size() > 0) {\n            Iterator iterator = headerParamsMap.entrySet().iterator();\n            while (iterator.hasNext()) {\n                Map.Entry entry = (Map.Entry) iterator.next();\n                headerBuilder.add((String) entry.getKey(), (String) entry.getValue());\n            }\n        }\n\n        if (headerLinesList.size() > 0) {\n            for (String line : headerLinesList) {\n                headerBuilder.add(line);\n            }\n            requestBuilder.headers(headerBuilder.build());\n        }\n        // process header params end\n\n\n        // process queryParams inject whatever it's GET or POST\n        if (queryParamsMap.size() > 0 && \"GET\".equals(request.method())) {\n//        if (queryParamsMap.size() > 0) {\n            request = injectParamsIntoUrl(request, requestBuilder, queryParamsMap);\n        }\n\n        // process post body inject\n        if (paramsMap != null && paramsMap.size() > 0 && \"POST\".equals(request.method())) {\n            if (request.body() instanceof FormBody) {\n                FormBody.Builder newFormBodyBuilder = new FormBody.Builder();\n                if (paramsMap.size() > 0) {\n                    Iterator iterator = paramsMap.entrySet().iterator();\n                    while (iterator.hasNext()) {\n                        Map.Entry entry = (Map.Entry) iterator.next();\n                        newFormBodyBuilder.add((String) entry.getKey(), (String) entry.getValue());\n                    }\n                }\n\n                FormBody oldFormBody = (FormBody) request.body();\n                int paramSize = oldFormBody.size();\n                if (paramSize > 0) {\n                    for (int i = 0; i < paramSize; i++) {\n                        newFormBodyBuilder.add(oldFormBody.name(i), oldFormBody.value(i));\n                    }\n                }\n\n                requestBuilder.post(newFormBodyBuilder.build());\n                request = requestBuilder.build();\n            } else if (request.body() instanceof MultipartBody) {\n                MultipartBody.Builder multipartBuilder = new MultipartBody.Builder().setType(MultipartBody.FORM);\n\n                Iterator iterator = paramsMap.entrySet().iterator();\n                while (iterator.hasNext()) {\n                    Map.Entry entry = (Map.Entry) iterator.next();\n                    multipartBuilder.addFormDataPart((String) entry.getKey(), (String) entry.getValue());\n                }\n\n                List<MultipartBody.Part> oldParts = ((MultipartBody) request.body()).parts();\n                if (oldParts != null && oldParts.size() > 0) {\n                    for (MultipartBody.Part part : oldParts) {\n                        multipartBuilder.addPart(part);\n                    }\n                }\n\n                requestBuilder.post(multipartBuilder.build());\n                request = requestBuilder.build();\n            }\n\n        }\n        return chain.proceed(request);\n    }\n\n    private boolean canInjectIntoBody(Request request) {\n        if (request == null) {\n            return false;\n        }\n        if (!TextUtils.equals(request.method(), \"POST\")) {\n            return false;\n        }\n        RequestBody body = request.body();\n        if (body == null) {\n            return false;\n        }\n        MediaType mediaType = body.contentType();\n        if (mediaType == null) {\n            return false;\n        }\n        if (!TextUtils.equals(mediaType.subtype(), \"x-www-form-urlencoded\")) {\n            return false;\n        }\n        return true;\n    }\n\n    // func to inject params into url\n    private Request injectParamsIntoUrl(Request request, Request.Builder requestBuilder, Map<String, String> paramsMap) {\n        HttpUrl.Builder httpUrlBuilder = request.url().newBuilder();\n        if (paramsMap.size() > 0) {\n            Iterator iterator = paramsMap.entrySet().iterator();\n            while (iterator.hasNext()) {\n                Map.Entry entry = (Map.Entry) iterator.next();\n                httpUrlBuilder.addEncodedQueryParameter((String) entry.getKey(), (String) entry.getValue());\n            }\n            requestBuilder.url(httpUrlBuilder.build());\n            return requestBuilder.build();\n        }\n\n        return request;\n    }\n\n    private static String bodyToString(final RequestBody request) {\n        try {\n            final RequestBody copy = request;\n            final Buffer buffer = new Buffer();\n            if (copy != null)\n                copy.writeTo(buffer);\n            else\n                return \"\";\n            return buffer.readUtf8();\n        } catch (final IOException e) {\n            return \"did not work\";\n        }\n    }\n\n    public static class Builder {\n\n        CommonParamsInterceptor interceptor;\n\n        public Builder() {\n            interceptor = new CommonParamsInterceptor();\n        }\n\n        public Builder addParam(String key, String value) {\n            interceptor.paramsMap.put(key, value);\n            return this;\n        }\n\n        public Builder addParamsMap(Map<String, String> paramsMap) {\n            interceptor.paramsMap.putAll(paramsMap);\n            return this;\n        }\n\n        public Builder addHeaderParam(String key, String value) {\n            interceptor.headerParamsMap.put(key, value);\n            return this;\n        }\n\n        public Builder addHeaderParamsMap(Map<String, String> headerParamsMap) {\n            interceptor.headerParamsMap.putAll(headerParamsMap);\n            return this;\n        }\n\n        public Builder addHeaderLine(String headerLine) {\n            int index = headerLine.indexOf(\":\");\n            if (index == -1) {\n                throw new IllegalArgumentException(\"Unexpected header: \" + headerLine);\n            }\n            interceptor.headerLinesList.add(headerLine);\n            return this;\n        }\n\n        public Builder addHeaderLinesList(List<String> headerLinesList) {\n            for (String headerLine : headerLinesList) {\n                int index = headerLine.indexOf(\":\");\n                if (index == -1) {\n                    throw new IllegalArgumentException(\"Unexpected header: \" + headerLine);\n                }\n                interceptor.headerLinesList.add(headerLine);\n            }\n            return this;\n        }\n\n        public Builder addQueryParam(String key, String value) {\n            interceptor.queryParamsMap.put(key, value);\n            return this;\n        }\n\n        public Builder addQueryParamsMap(Map<String, String> queryParamsMap) {\n            interceptor.queryParamsMap.putAll(queryParamsMap);\n            return this;\n        }\n\n        public CommonParamsInterceptor build() {\n            return interceptor;\n        }\n    }\n}\n```\n\n\n\n### 加签拦截器\n\n互联网是一个开放的环境,危险无处不在,加密通信是安全的基础.\n\n加密的方式又有很多,比如对称加密/非对称加密/Hash(严格的说不是加密),这里先不对加密进行介绍,我们聊聊加签;\n\n加签,其实就是给报文做一个摘要,相同的签名算法得到的摘要是相同的,比如MD5, SH1, SH256等, 简单的加签并不能防止篡改,因为攻击者可以篡改后,自己生成新的签名.服务端验签还是可以通过的,因此加签时一定要包含一些私有的东西,比如私钥.\n\n\n\n这里介绍一种加签方式,\n\n>  加密规则\n\n1.  根据请求参数 key 进行排序\n2.  按排好的顺序组装成 key=value&key=value 形式的字符串\n3.  将上述字符串拼接  ,最终形成 key=value&key=value的字符串\n4.  将字符串 md5, 生成 auth.\n\n\n\n一个简单的加签逻辑就是这样,下面代码就是对这种规则的实现,看代码↓↓↓↓\n\n```java\npublic class AuthorizeInterceptor implements Interceptor {\n\n    private static final String TAG = \"AuthorizeInterceptor\";\n\n    /**\n     * 生成 auth 的私钥\n     */\n    private String authKey;\n\n    /**\n     * 当前设备 mid,用来生成 auth\n     * 数据由 Builder 类传入\n     */\n    private String mid = \"\";\n\n    private AuthorizeInterceptor() {\n    }\n\n    @Override\n    public Response intercept(Chain chain) throws IOException {\n        Request request = chain.request();\n        Request.Builder requestBuilder = request.newBuilder();\n        String url = request.url().toString();\n        LogUtils.d(TAG, url);\n        if (\"POST\".equals(request.method())) {\n            request = injectionParamIntoBody(request, requestBuilder);\n        } else if (\"GET\".equals(request.method())) {\n            request = injectionAuthIntoUrl(request, requestBuilder);\n        }\n        return chain.proceed(request);\n    }\n\n    /**\n     * GET 请求方式, 生成授权和添加时间戳\n     *\n     * @param request\n     * @param requestBuilder\n     * @return\n     */\n    private Request injectionAuthIntoUrl(Request request, Request.Builder requestBuilder) {\n        //获取到请求地址api\n        HttpUrl newHttpUrl = request.url();\n        TreeMap<String, String> authMap = new TreeMap<>();\n        //通过请求地址(最初始的请求地址)获取到参数列表\n        Set<String> parameterNames = newHttpUrl.queryParameterNames();\n        for (String key : parameterNames) {\n            //循环参数列表,获取参数value,\n                String paramValue = newHttpUrl.queryParameter(key);\n                if (!TextUtils.isEmpty(paramValue)) {\n                    authMap.put(key, paramValue);\n                }\n            \n        }\n        HttpUrl.Builder newBuilder =\n                request.url().newBuilder()\n                        .addEncodedQueryParameter(\"auth\", assembleAuth(authMap, false));\n        requestBuilder.url(newBuilder.build());\n        return requestBuilder.build();\n    }\n\n    /**\n     * 将参数注入到 POST 请求的 body 中\n     *\n     * @param request\n     * @param requestBuilder\n     * @return\n     */\n    private Request injectionParamIntoBody(Request request, Request.Builder requestBuilder) {\n        if (request.body() instanceof FormBody) {\n            // 处理正常表单请求方式\n            FormBody oldFormBody = (FormBody) request.body();\n            return assembleFormBody(request, oldFormBody, requestBuilder);\n        } else if (request.body() instanceof MultipartBody) {\n            return assembleMultipartBody(request, requestBuilder);\n        } else {\n            return request;\n        }\n    }\n\n    /**\n     * 构建流媒体参数的 body\n     *\n     * @param request\n     * @param builder\n     * @return\n     */\n    private Request assembleMultipartBody(Request request, Request.Builder builder) {\n        // 处理流的请求方式\n        MultipartBody body = (MultipartBody) request.body();\n        TreeMap<String, String> authMap = new TreeMap<>();\n        // 获取参数 key 及 value 数据, 将数据写入到 TreeMap 中进行排序\n        if (body != null && body.parts().size() > 0) {\n            for (MultipartBody.Part part : body.parts()) {\n                // 只处理 contentType 为空,或为 text 的情况, image 上传图片的字段,不进行处理\n                if (part.body().contentType() == null\n                        || !\"image\".equals(part.body().contentType().type())\n                        || \"text\".equals(part.body().contentType().type())) {\n                    Headers headers = part.headers();\n                    // 从 header 中获取 Key, form-data; name= 的字段过滤获取key\n                    // 筛选掉 basic, 获取到当前 header,对应的 RequestBody, 通过 buffer 的方式,获取到 value\n                    // 将 key 和 value 填充到 TreeMap 中\n                    for (int i = 0; i < headers.names().size(); i++) {\n                        String headerName = headers.value(i);\n                        if (headerName.contains(\"form-data; name=\")) {\n                            String key = headerName.replace(\"form-data; name=\", \"\").replace(\"\\\"\", \"\");\n                                String value = body2String(part.body());\n                                if (!TextUtils.isEmpty(value)) {\n                                    authMap.put(key, body2String(part.body()));\n                                }\n                                                   }\n                    }\n                }\n            }\n        }\n\n        MultipartBody.Builder multipartBuilder = new MultipartBody.Builder().setType(MultipartBody.FORM);\n        multipartBuilder.addFormDataPart(\"auth\", assembleAuth(authMap, false));\n        List<MultipartBody.Part> oldParts = ((MultipartBody) request.body()).parts();\n        if (oldParts != null && oldParts.size() > 0) {\n            for (MultipartBody.Part part : oldParts) {\n                multipartBuilder.addPart(part);\n            }\n        }\n        builder.post(multipartBuilder.build());\n        return builder.build();\n    }\n\n    /**\n     * 构建 Auth 数据\n     * <p>\n     * TreeMap 数据,按照字母顺序自动排序后,遍历数据,拼接成 key=value&key=value 的形式,\n     * Map 拼接完成后,在其后需要再次拼接上\n     * <p>\n     * 最后将数据 MD5 转化为 32 位小写并返回\n     *\n     * @param treeMap      构建 Auth 的具体数据\n     * @param isNeedDecode 是否需要解码\n     * @return 返回 auth 数据 \n     */\n    private String assembleAuth(TreeMap<String, String> treeMap, boolean isNeedDecode) {\n        StringBuilder stringBuilder = new StringBuilder();\n        if (treeMap.size() > 0) {\n            for (Map.Entry<String, String> stringStringEntry : treeMap.entrySet()) {\n                try {\n                    stringBuilder.append(stringStringEntry.getKey())\n                            .append(\"=\")\n                            .append(isNeedDecode\n                                    ? URLDecoder.decode(stringStringEntry.getValue(), \"UTF-8\")\n                                    : stringStringEntry.getValue())\n                            .append(\"&\");\n                } catch (UnsupportedEncodingException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        treeMap.clear();\n        stringBuilder\n                .append(authKey);\n        Log.d(TAG, stringBuilder.toString());\n        return MD5.MD5(stringBuilder.toString());\n    }\n\n    /**\n     * body 转 string 获取实际参数值\n     *\n     * @param body Part body\n     * @return part 中写如的参数数据\n     */\n    private String body2String(RequestBody body) {\n        if (body != null) {\n            Buffer buffer = new Buffer();\n            try {\n                body.writeTo(buffer);\n                Charset charset = Charset.forName(\"UTF-8\");\n                MediaType contentType = body.contentType();\n                if (contentType != null) {\n                    charset = contentType.charset(charset);\n                }\n                assert charset != null;\n                return buffer.readString(charset);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return \"\";\n    }\n\n    /**\n     * 组装 Form 表单请求数据\n     *\n     * @param request\n     * @param oldFormBody\n     * @param requestBuilder\n     * @return\n     */\n    private Request assembleFormBody(Request request, FormBody oldFormBody, Request.Builder requestBuilder) {\n        TreeMap<String, String> authMap = new TreeMap<>();\n        // 遍历请求参数,非空参数,添加到集合中\n        for (int i = 0; i < oldFormBody.size(); i++) {\n            if (!TextUtils.isEmpty(oldFormBody.encodedValue(i))) {\n                authMap.put(oldFormBody.encodedName(i), oldFormBody.encodedValue(i));\n            }\n        }\n        if (authMap.size() != 0) {\n            // 生成 auth 数据\n            FormBody.Builder newFormBody = new FormBody.Builder();\n            for (int i = 0; i < oldFormBody.size(); i++) {\n                newFormBody.addEncoded(oldFormBody.encodedName(i), oldFormBody.encodedValue(i));\n            }\n            newFormBody.add(\"auth\", assembleAuth(authMap, true));\n            requestBuilder.method(request.method(), newFormBody.build());\n            return requestBuilder.build();\n        }\n\n        return request;\n    }\n\n\n    /**\n     * Builder 构造函数,用来设置 Authorize 的相关参数,及创建工作\n     */\n    public static class Builder {\n        AuthorizeInterceptor authorizeInterceptor;\n\n        public Builder() {\n            authorizeInterceptor = new AuthorizeInterceptor();\n        }\n\n        public Builder setMid(String mid) {\n            authorizeInterceptor.mid = mid;\n            return this;\n        }\n\n        public Builder setAuthKey(String key) {\n            authorizeInterceptor.authKey = key;\n            return this;\n        }\n\n        public AuthorizeInterceptor build() {\n            return authorizeInterceptor;\n        }\n    }\n}\n```\n\n\n\n该加签方式,讲请求参数拼接为 `key=value` 的方式, 难点在于如何从 OkHttp 中获取这些参数,在 GET 请求和 POST 的处理方式又不同,代码中 POST 请求方式,又会根据请求传递的 `contentType` 而又有所不同,这里介绍了`Form`表单提交和 `Multipart` 上传文件的参数获取方式,其他的请举一反三.\n\n","slug":"三方框架/OkHttp-Intercept","published":1,"updated":"2021-01-29T16:05:15.347Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8fn002gsz5q7rmyrisx","content":"<p>OKHttp 在开发中经常用到,这里介绍一下 OKHttp 的拦截器(interceptor)的几个使用例子</p>\n<a id=\"more\"></a>\n<p>要是用拦截器很简单,我们只需要自定义一个 interceptor 类, 并实现 Interceptor 接口, 同时重写 intercept 方法.</p>\n<p>这里介绍两种 Interceptor 的实例</p>\n<!-- more -->\n<h2 id=\"Log-日志-LogInterceptor\"><a href=\"#Log-日志-LogInterceptor\" class=\"headerlink\" title=\"Log 日志 (LogInterceptor)\"></a>Log 日志 (LogInterceptor)</h2><p>Log 在开发调试中的重要性, 不言而喻, 一个好的日志数据,能够为开发时提供很多帮助,可以通过 Log 来获取当前程序的执行状态, 顺序等等.</p>\n<p>这里介绍的 Log 日志拦截器,主要是负责在网络请求时,截获请求中的信息,并将请求信息以 Log 的方式输出到控制台上,可展现当前请求地址,请求参数,以及请求结果等.</p>\n<p>话不多说, 上代码.</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/**\n* 自定义 log 拦截器,输入请求地址,请求参,请求结果\n*/</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">LogInterceptor</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Interceptor</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> Response <span class=\"token function\">intercept</span><span class=\"token punctuation\">(</span>Chain chain<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> IOException <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 拦截请求信息,获取请求地址及请求参数</span>\n            Request request <span class=\"token operator\">=</span> chain<span class=\"token punctuation\">.</span><span class=\"token function\">request</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">long</span> t1 <span class=\"token operator\">=</span> System<span class=\"token punctuation\">.</span><span class=\"token function\">nanoTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 获取请求方式</span>\n            String method <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span><span class=\"token function\">method</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"POST\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>method<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                StringBuilder sb <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringBuilder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">.</span><span class=\"token function\">body</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">FormBody</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    FormBody body <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>FormBody<span class=\"token punctuation\">)</span> request<span class=\"token punctuation\">.</span><span class=\"token function\">body</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> body<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        sb<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>body<span class=\"token punctuation\">.</span><span class=\"token function\">encodedName</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"=\"</span> <span class=\"token operator\">+</span> body<span class=\"token punctuation\">.</span><span class=\"token function\">encodedValue</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\",\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    sb<span class=\"token punctuation\">.</span><span class=\"token function\">delete</span><span class=\"token punctuation\">(</span>sb<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> sb<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    LogUtils<span class=\"token punctuation\">.</span><span class=\"token function\">d</span><span class=\"token punctuation\">(</span>TAG<span class=\"token punctuation\">,</span> String<span class=\"token punctuation\">.</span><span class=\"token function\">format</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Sending request %s on %s %n%s %nRequestParams:{%s}\"</span><span class=\"token punctuation\">,</span>\n                            request<span class=\"token punctuation\">.</span><span class=\"token function\">url</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> chain<span class=\"token punctuation\">.</span><span class=\"token function\">connection</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> request<span class=\"token punctuation\">.</span><span class=\"token function\">headers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> sb<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                LogUtils<span class=\"token punctuation\">.</span><span class=\"token function\">d</span><span class=\"token punctuation\">(</span>TAG<span class=\"token punctuation\">,</span> String<span class=\"token punctuation\">.</span><span class=\"token function\">format</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Sending request %s on %s %n%s\"</span><span class=\"token punctuation\">,</span>\n                        request<span class=\"token punctuation\">.</span><span class=\"token function\">url</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> chain<span class=\"token punctuation\">.</span><span class=\"token function\">connection</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> request<span class=\"token punctuation\">.</span><span class=\"token function\">headers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 获取响应信息</span>\n            Response response <span class=\"token operator\">=</span> chain<span class=\"token punctuation\">.</span><span class=\"token function\">proceed</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">long</span> t2 <span class=\"token operator\">=</span> System<span class=\"token punctuation\">.</span><span class=\"token function\">nanoTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            LogUtils<span class=\"token punctuation\">.</span><span class=\"token function\">d</span><span class=\"token punctuation\">(</span>TAG<span class=\"token punctuation\">,</span> String<span class=\"token punctuation\">.</span><span class=\"token function\">format</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Received response for %s in %.1fms%n%s\"</span><span class=\"token punctuation\">,</span>\n                    response<span class=\"token punctuation\">.</span><span class=\"token function\">request</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">url</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>t2 <span class=\"token operator\">-</span> t1<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">1e6d</span><span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">.</span><span class=\"token function\">headers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            MediaType contentType <span class=\"token operator\">=</span> response<span class=\"token punctuation\">.</span><span class=\"token function\">body</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">contentType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            String content <span class=\"token operator\">=</span> response<span class=\"token punctuation\">.</span><span class=\"token function\">body</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            LogUtils<span class=\"token punctuation\">.</span><span class=\"token function\">d</span><span class=\"token punctuation\">(</span>TAG<span class=\"token punctuation\">,</span> content<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            ResponseBody wrappedBody <span class=\"token operator\">=</span> ResponseBody<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>contentType<span class=\"token punctuation\">,</span> content<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> response<span class=\"token punctuation\">.</span><span class=\"token function\">newBuilder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">body</span><span class=\"token punctuation\">(</span>wrappedBody<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"加参\"><a href=\"#加参\" class=\"headerlink\" title=\"加参\"></a>加参</h2><p>加参的意义在于,在请求过程中, 需要传递一些基本参数,这些参数是基本保持不变的, 而这些参数又是后台需要校验的依靠,我们俗称他们为<strong>公参</strong>, 如果在请求过程中在每一个接口里面都去添加这些参数,显得非常繁琐,而且麻烦,后续人员接手,又会不知所措,维护起来相当不方便.</p>\n<p>因此,在这里我们还是通过请求拦截器,通过拦截器去添加这些参数.</p>\n<h3 id=\"公参拦截器\"><a href=\"#公参拦截器\" class=\"headerlink\" title=\"公参拦截器\"></a>公参拦截器</h3><p>在请求中,增加一些公共的参数.</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CommonParamsInterceptor</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Interceptor</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">private</span> Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> String<span class=\"token operator\">></span> queryParamsMap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> String<span class=\"token operator\">></span> paramsMap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> String<span class=\"token operator\">></span> headerParamsMap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> List<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> headerLinesList <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> Response <span class=\"token function\">intercept</span><span class=\"token punctuation\">(</span>Chain chain<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> IOException <span class=\"token punctuation\">{</span>\n\n        Request request <span class=\"token operator\">=</span> chain<span class=\"token punctuation\">.</span><span class=\"token function\">request</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Request<span class=\"token punctuation\">.</span>Builder requestBuilder <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span><span class=\"token function\">newBuilder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// process header params inject</span>\n        Headers<span class=\"token punctuation\">.</span>Builder headerBuilder <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span><span class=\"token function\">headers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">newBuilder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>headerParamsMap<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            Iterator iterator <span class=\"token operator\">=</span> headerParamsMap<span class=\"token punctuation\">.</span><span class=\"token function\">entrySet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">iterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">hasNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                Map<span class=\"token punctuation\">.</span>Entry entry <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Map<span class=\"token punctuation\">.</span>Entry<span class=\"token punctuation\">)</span> iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                headerBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">)</span> entry<span class=\"token punctuation\">.</span><span class=\"token function\">getKey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">)</span> entry<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>headerLinesList<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>String line <span class=\"token operator\">:</span> headerLinesList<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                headerBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>line<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            requestBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">headers</span><span class=\"token punctuation\">(</span>headerBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">// process header params end</span>\n\n\n        <span class=\"token comment\" spellcheck=\"true\">// process queryParams inject whatever it's GET or POST</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>queryParamsMap<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token string\">\"GET\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">.</span><span class=\"token function\">method</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token comment\" spellcheck=\"true\">//        if (queryParamsMap.size() > 0) {</span>\n            request <span class=\"token operator\">=</span> <span class=\"token function\">injectParamsIntoUrl</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">,</span> requestBuilder<span class=\"token punctuation\">,</span> queryParamsMap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// process post body inject</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>paramsMap <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> paramsMap<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token string\">\"POST\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">.</span><span class=\"token function\">method</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">.</span><span class=\"token function\">body</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">FormBody</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                FormBody<span class=\"token punctuation\">.</span>Builder newFormBodyBuilder <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FormBody<span class=\"token punctuation\">.</span>Builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>paramsMap<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    Iterator iterator <span class=\"token operator\">=</span> paramsMap<span class=\"token punctuation\">.</span><span class=\"token function\">entrySet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">iterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">hasNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        Map<span class=\"token punctuation\">.</span>Entry entry <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Map<span class=\"token punctuation\">.</span>Entry<span class=\"token punctuation\">)</span> iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        newFormBodyBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">)</span> entry<span class=\"token punctuation\">.</span><span class=\"token function\">getKey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">)</span> entry<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n\n                FormBody oldFormBody <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>FormBody<span class=\"token punctuation\">)</span> request<span class=\"token punctuation\">.</span><span class=\"token function\">body</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">int</span> paramSize <span class=\"token operator\">=</span> oldFormBody<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>paramSize <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> paramSize<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        newFormBodyBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>oldFormBody<span class=\"token punctuation\">.</span><span class=\"token function\">name</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> oldFormBody<span class=\"token punctuation\">.</span><span class=\"token function\">value</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n\n                requestBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">post</span><span class=\"token punctuation\">(</span>newFormBodyBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                request <span class=\"token operator\">=</span> requestBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">.</span><span class=\"token function\">body</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">MultipartBody</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                MultipartBody<span class=\"token punctuation\">.</span>Builder multipartBuilder <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MultipartBody<span class=\"token punctuation\">.</span>Builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">setType</span><span class=\"token punctuation\">(</span>MultipartBody<span class=\"token punctuation\">.</span>FORM<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n                Iterator iterator <span class=\"token operator\">=</span> paramsMap<span class=\"token punctuation\">.</span><span class=\"token function\">entrySet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">iterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">hasNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    Map<span class=\"token punctuation\">.</span>Entry entry <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Map<span class=\"token punctuation\">.</span>Entry<span class=\"token punctuation\">)</span> iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    multipartBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">addFormDataPart</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">)</span> entry<span class=\"token punctuation\">.</span><span class=\"token function\">getKey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">)</span> entry<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n\n                List<span class=\"token operator\">&lt;</span>MultipartBody<span class=\"token punctuation\">.</span>Part<span class=\"token operator\">></span> oldParts <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>MultipartBody<span class=\"token punctuation\">)</span> request<span class=\"token punctuation\">.</span><span class=\"token function\">body</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">parts</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldParts <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> oldParts<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>MultipartBody<span class=\"token punctuation\">.</span>Part part <span class=\"token operator\">:</span> oldParts<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        multipartBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">addPart</span><span class=\"token punctuation\">(</span>part<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n\n                requestBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">post</span><span class=\"token punctuation\">(</span>multipartBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                request <span class=\"token operator\">=</span> requestBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> chain<span class=\"token punctuation\">.</span><span class=\"token function\">proceed</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">canInjectIntoBody</span><span class=\"token punctuation\">(</span>Request request<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>request <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>TextUtils<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">.</span><span class=\"token function\">method</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"POST\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        RequestBody body <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span><span class=\"token function\">body</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>body <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        MediaType mediaType <span class=\"token operator\">=</span> body<span class=\"token punctuation\">.</span><span class=\"token function\">contentType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mediaType <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>TextUtils<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>mediaType<span class=\"token punctuation\">.</span><span class=\"token function\">subtype</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"x-www-form-urlencoded\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// func to inject params into url</span>\n    <span class=\"token keyword\">private</span> Request <span class=\"token function\">injectParamsIntoUrl</span><span class=\"token punctuation\">(</span>Request request<span class=\"token punctuation\">,</span> Request<span class=\"token punctuation\">.</span>Builder requestBuilder<span class=\"token punctuation\">,</span> Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> String<span class=\"token operator\">></span> paramsMap<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        HttpUrl<span class=\"token punctuation\">.</span>Builder httpUrlBuilder <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span><span class=\"token function\">url</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">newBuilder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>paramsMap<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            Iterator iterator <span class=\"token operator\">=</span> paramsMap<span class=\"token punctuation\">.</span><span class=\"token function\">entrySet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">iterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">hasNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                Map<span class=\"token punctuation\">.</span>Entry entry <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Map<span class=\"token punctuation\">.</span>Entry<span class=\"token punctuation\">)</span> iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                httpUrlBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">addEncodedQueryParameter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">)</span> entry<span class=\"token punctuation\">.</span><span class=\"token function\">getKey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">)</span> entry<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            requestBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">url</span><span class=\"token punctuation\">(</span>httpUrlBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> requestBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">return</span> request<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> String <span class=\"token function\">bodyToString</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> RequestBody request<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">final</span> RequestBody copy <span class=\"token operator\">=</span> request<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">final</span> Buffer buffer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Buffer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>copy <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span>\n                copy<span class=\"token punctuation\">.</span><span class=\"token function\">writeTo</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span>\n                <span class=\"token keyword\">return</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> buffer<span class=\"token punctuation\">.</span><span class=\"token function\">readUtf8</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">final</span> IOException e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token string\">\"did not work\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Builder</span> <span class=\"token punctuation\">{</span>\n\n        CommonParamsInterceptor interceptor<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token function\">Builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            interceptor <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CommonParamsInterceptor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">public</span> Builder <span class=\"token function\">addParam</span><span class=\"token punctuation\">(</span>String key<span class=\"token punctuation\">,</span> String value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            interceptor<span class=\"token punctuation\">.</span>paramsMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">public</span> Builder <span class=\"token function\">addParamsMap</span><span class=\"token punctuation\">(</span>Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> String<span class=\"token operator\">></span> paramsMap<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            interceptor<span class=\"token punctuation\">.</span>paramsMap<span class=\"token punctuation\">.</span><span class=\"token function\">putAll</span><span class=\"token punctuation\">(</span>paramsMap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">public</span> Builder <span class=\"token function\">addHeaderParam</span><span class=\"token punctuation\">(</span>String key<span class=\"token punctuation\">,</span> String value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            interceptor<span class=\"token punctuation\">.</span>headerParamsMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">public</span> Builder <span class=\"token function\">addHeaderParamsMap</span><span class=\"token punctuation\">(</span>Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> String<span class=\"token operator\">></span> headerParamsMap<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            interceptor<span class=\"token punctuation\">.</span>headerParamsMap<span class=\"token punctuation\">.</span><span class=\"token function\">putAll</span><span class=\"token punctuation\">(</span>headerParamsMap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">public</span> Builder <span class=\"token function\">addHeaderLine</span><span class=\"token punctuation\">(</span>String headerLine<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> headerLine<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\":\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Unexpected header: \"</span> <span class=\"token operator\">+</span> headerLine<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            interceptor<span class=\"token punctuation\">.</span>headerLinesList<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>headerLine<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">public</span> Builder <span class=\"token function\">addHeaderLinesList</span><span class=\"token punctuation\">(</span>List<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> headerLinesList<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>String headerLine <span class=\"token operator\">:</span> headerLinesList<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> headerLine<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\":\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Unexpected header: \"</span> <span class=\"token operator\">+</span> headerLine<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                interceptor<span class=\"token punctuation\">.</span>headerLinesList<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>headerLine<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">public</span> Builder <span class=\"token function\">addQueryParam</span><span class=\"token punctuation\">(</span>String key<span class=\"token punctuation\">,</span> String value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            interceptor<span class=\"token punctuation\">.</span>queryParamsMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">public</span> Builder <span class=\"token function\">addQueryParamsMap</span><span class=\"token punctuation\">(</span>Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> String<span class=\"token operator\">></span> queryParamsMap<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            interceptor<span class=\"token punctuation\">.</span>queryParamsMap<span class=\"token punctuation\">.</span><span class=\"token function\">putAll</span><span class=\"token punctuation\">(</span>queryParamsMap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">public</span> CommonParamsInterceptor <span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> interceptor<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"加签拦截器\"><a href=\"#加签拦截器\" class=\"headerlink\" title=\"加签拦截器\"></a>加签拦截器</h3><p>互联网是一个开放的环境,危险无处不在,加密通信是安全的基础.</p>\n<p>加密的方式又有很多,比如对称加密/非对称加密/Hash(严格的说不是加密),这里先不对加密进行介绍,我们聊聊加签;</p>\n<p>加签,其实就是给报文做一个摘要,相同的签名算法得到的摘要是相同的,比如MD5, SH1, SH256等, 简单的加签并不能防止篡改,因为攻击者可以篡改后,自己生成新的签名.服务端验签还是可以通过的,因此加签时一定要包含一些私有的东西,比如私钥.</p>\n<p>这里介绍一种加签方式,</p>\n<blockquote>\n<p> 加密规则</p>\n</blockquote>\n<ol>\n<li>根据请求参数 key 进行排序</li>\n<li>按排好的顺序组装成 key=value&amp;key=value 形式的字符串</li>\n<li>将上述字符串拼接  ,最终形成 key=value&amp;key=value的字符串</li>\n<li>将字符串 md5, 生成 auth.</li>\n</ol>\n<p>一个简单的加签逻辑就是这样,下面代码就是对这种规则的实现,看代码↓↓↓↓</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AuthorizeInterceptor</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Interceptor</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> String TAG <span class=\"token operator\">=</span> <span class=\"token string\">\"AuthorizeInterceptor\"</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 生成 auth 的私钥\n     */</span>\n    <span class=\"token keyword\">private</span> String authKey<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 当前设备 mid,用来生成 auth\n     * 数据由 Builder 类传入\n     */</span>\n    <span class=\"token keyword\">private</span> String mid <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token function\">AuthorizeInterceptor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> Response <span class=\"token function\">intercept</span><span class=\"token punctuation\">(</span>Chain chain<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> IOException <span class=\"token punctuation\">{</span>\n        Request request <span class=\"token operator\">=</span> chain<span class=\"token punctuation\">.</span><span class=\"token function\">request</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Request<span class=\"token punctuation\">.</span>Builder requestBuilder <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span><span class=\"token function\">newBuilder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        String url <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span><span class=\"token function\">url</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        LogUtils<span class=\"token punctuation\">.</span><span class=\"token function\">d</span><span class=\"token punctuation\">(</span>TAG<span class=\"token punctuation\">,</span> url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"POST\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">.</span><span class=\"token function\">method</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            request <span class=\"token operator\">=</span> <span class=\"token function\">injectionParamIntoBody</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">,</span> requestBuilder<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"GET\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">.</span><span class=\"token function\">method</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            request <span class=\"token operator\">=</span> <span class=\"token function\">injectionAuthIntoUrl</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">,</span> requestBuilder<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> chain<span class=\"token punctuation\">.</span><span class=\"token function\">proceed</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * GET 请求方式, 生成授权和添加时间戳\n     *\n     * @param request\n     * @param requestBuilder\n     * @return\n     */</span>\n    <span class=\"token keyword\">private</span> Request <span class=\"token function\">injectionAuthIntoUrl</span><span class=\"token punctuation\">(</span>Request request<span class=\"token punctuation\">,</span> Request<span class=\"token punctuation\">.</span>Builder requestBuilder<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//获取到请求地址api</span>\n        HttpUrl newHttpUrl <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span><span class=\"token function\">url</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        TreeMap<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> String<span class=\"token operator\">></span> authMap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TreeMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//通过请求地址(最初始的请求地址)获取到参数列表</span>\n        Set<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> parameterNames <span class=\"token operator\">=</span> newHttpUrl<span class=\"token punctuation\">.</span><span class=\"token function\">queryParameterNames</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>String key <span class=\"token operator\">:</span> parameterNames<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//循环参数列表,获取参数value,</span>\n                String paramValue <span class=\"token operator\">=</span> newHttpUrl<span class=\"token punctuation\">.</span><span class=\"token function\">queryParameter</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>TextUtils<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span>paramValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    authMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> paramValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n\n        <span class=\"token punctuation\">}</span>\n        HttpUrl<span class=\"token punctuation\">.</span>Builder newBuilder <span class=\"token operator\">=</span>\n                request<span class=\"token punctuation\">.</span><span class=\"token function\">url</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">newBuilder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                        <span class=\"token punctuation\">.</span><span class=\"token function\">addEncodedQueryParameter</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"auth\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">assembleAuth</span><span class=\"token punctuation\">(</span>authMap<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        requestBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">url</span><span class=\"token punctuation\">(</span>newBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> requestBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 将参数注入到 POST 请求的 body 中\n     *\n     * @param request\n     * @param requestBuilder\n     * @return\n     */</span>\n    <span class=\"token keyword\">private</span> Request <span class=\"token function\">injectionParamIntoBody</span><span class=\"token punctuation\">(</span>Request request<span class=\"token punctuation\">,</span> Request<span class=\"token punctuation\">.</span>Builder requestBuilder<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">.</span><span class=\"token function\">body</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">FormBody</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 处理正常表单请求方式</span>\n            FormBody oldFormBody <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>FormBody<span class=\"token punctuation\">)</span> request<span class=\"token punctuation\">.</span><span class=\"token function\">body</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token function\">assembleFormBody</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">,</span> oldFormBody<span class=\"token punctuation\">,</span> requestBuilder<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">.</span><span class=\"token function\">body</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">MultipartBody</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token function\">assembleMultipartBody</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">,</span> requestBuilder<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> request<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 构建流媒体参数的 body\n     *\n     * @param request\n     * @param builder\n     * @return\n     */</span>\n    <span class=\"token keyword\">private</span> Request <span class=\"token function\">assembleMultipartBody</span><span class=\"token punctuation\">(</span>Request request<span class=\"token punctuation\">,</span> Request<span class=\"token punctuation\">.</span>Builder builder<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 处理流的请求方式</span>\n        MultipartBody body <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>MultipartBody<span class=\"token punctuation\">)</span> request<span class=\"token punctuation\">.</span><span class=\"token function\">body</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        TreeMap<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> String<span class=\"token operator\">></span> authMap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TreeMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 获取参数 key 及 value 数据, 将数据写入到 TreeMap 中进行排序</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>body <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> body<span class=\"token punctuation\">.</span><span class=\"token function\">parts</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>MultipartBody<span class=\"token punctuation\">.</span>Part part <span class=\"token operator\">:</span> body<span class=\"token punctuation\">.</span><span class=\"token function\">parts</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 只处理 contentType 为空,或为 text 的情况, image 上传图片的字段,不进行处理</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>part<span class=\"token punctuation\">.</span><span class=\"token function\">body</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">contentType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null\n                        <span class=\"token operator\">||</span> <span class=\"token operator\">!</span><span class=\"token string\">\"image\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>part<span class=\"token punctuation\">.</span><span class=\"token function\">body</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">contentType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">type</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                        <span class=\"token operator\">||</span> <span class=\"token string\">\"text\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>part<span class=\"token punctuation\">.</span><span class=\"token function\">body</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">contentType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">type</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    Headers headers <span class=\"token operator\">=</span> part<span class=\"token punctuation\">.</span><span class=\"token function\">headers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// 从 header 中获取 Key, form-data; name= 的字段过滤获取key</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// 筛选掉 basic, 获取到当前 header,对应的 RequestBody, 通过 buffer 的方式,获取到 value</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// 将 key 和 value 填充到 TreeMap 中</span>\n                    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> headers<span class=\"token punctuation\">.</span><span class=\"token function\">names</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        String headerName <span class=\"token operator\">=</span> headers<span class=\"token punctuation\">.</span><span class=\"token function\">value</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>headerName<span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"form-data; name=\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                            String key <span class=\"token operator\">=</span> headerName<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"form-data; name=\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                                String value <span class=\"token operator\">=</span> <span class=\"token function\">body2String</span><span class=\"token punctuation\">(</span>part<span class=\"token punctuation\">.</span><span class=\"token function\">body</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>TextUtils<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                                    authMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> <span class=\"token function\">body2String</span><span class=\"token punctuation\">(</span>part<span class=\"token punctuation\">.</span><span class=\"token function\">body</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                                <span class=\"token punctuation\">}</span>\n                                                   <span class=\"token punctuation\">}</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n\n        MultipartBody<span class=\"token punctuation\">.</span>Builder multipartBuilder <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MultipartBody<span class=\"token punctuation\">.</span>Builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">setType</span><span class=\"token punctuation\">(</span>MultipartBody<span class=\"token punctuation\">.</span>FORM<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        multipartBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">addFormDataPart</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"auth\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">assembleAuth</span><span class=\"token punctuation\">(</span>authMap<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        List<span class=\"token operator\">&lt;</span>MultipartBody<span class=\"token punctuation\">.</span>Part<span class=\"token operator\">></span> oldParts <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>MultipartBody<span class=\"token punctuation\">)</span> request<span class=\"token punctuation\">.</span><span class=\"token function\">body</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">parts</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldParts <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> oldParts<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>MultipartBody<span class=\"token punctuation\">.</span>Part part <span class=\"token operator\">:</span> oldParts<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                multipartBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">addPart</span><span class=\"token punctuation\">(</span>part<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        builder<span class=\"token punctuation\">.</span><span class=\"token function\">post</span><span class=\"token punctuation\">(</span>multipartBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> builder<span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 构建 Auth 数据\n     * &lt;p>\n     * TreeMap 数据,按照字母顺序自动排序后,遍历数据,拼接成 key=value&amp;key=value 的形式,\n     * Map 拼接完成后,在其后需要再次拼接上\n     * &lt;p>\n     * 最后将数据 MD5 转化为 32 位小写并返回\n     *\n     * @param treeMap      构建 Auth 的具体数据\n     * @param isNeedDecode 是否需要解码\n     * @return 返回 auth 数据 \n     */</span>\n    <span class=\"token keyword\">private</span> String <span class=\"token function\">assembleAuth</span><span class=\"token punctuation\">(</span>TreeMap<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> String<span class=\"token operator\">></span> treeMap<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> isNeedDecode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        StringBuilder stringBuilder <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringBuilder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>treeMap<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>Map<span class=\"token punctuation\">.</span>Entry<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> String<span class=\"token operator\">></span> stringStringEntry <span class=\"token operator\">:</span> treeMap<span class=\"token punctuation\">.</span><span class=\"token function\">entrySet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                    stringBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>stringStringEntry<span class=\"token punctuation\">.</span><span class=\"token function\">getKey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                            <span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"=\"</span><span class=\"token punctuation\">)</span>\n                            <span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>isNeedDecode\n                                    <span class=\"token operator\">?</span> URLDecoder<span class=\"token punctuation\">.</span><span class=\"token function\">decode</span><span class=\"token punctuation\">(</span>stringStringEntry<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"UTF-8\"</span><span class=\"token punctuation\">)</span>\n                                    <span class=\"token operator\">:</span> stringStringEntry<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                            <span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"&amp;\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">UnsupportedEncodingException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        treeMap<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        stringBuilder\n                <span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span>authKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Log<span class=\"token punctuation\">.</span><span class=\"token function\">d</span><span class=\"token punctuation\">(</span>TAG<span class=\"token punctuation\">,</span> stringBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> MD5<span class=\"token punctuation\">.</span><span class=\"token function\">MD5</span><span class=\"token punctuation\">(</span>stringBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * body 转 string 获取实际参数值\n     *\n     * @param body Part body\n     * @return part 中写如的参数数据\n     */</span>\n    <span class=\"token keyword\">private</span> String <span class=\"token function\">body2String</span><span class=\"token punctuation\">(</span>RequestBody body<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>body <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            Buffer buffer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Buffer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                body<span class=\"token punctuation\">.</span><span class=\"token function\">writeTo</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                Charset charset <span class=\"token operator\">=</span> Charset<span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"UTF-8\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                MediaType contentType <span class=\"token operator\">=</span> body<span class=\"token punctuation\">.</span><span class=\"token function\">contentType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>contentType <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    charset <span class=\"token operator\">=</span> contentType<span class=\"token punctuation\">.</span><span class=\"token function\">charset</span><span class=\"token punctuation\">(</span>charset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">assert</span> charset <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span> buffer<span class=\"token punctuation\">.</span><span class=\"token function\">readString</span><span class=\"token punctuation\">(</span>charset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 组装 Form 表单请求数据\n     *\n     * @param request\n     * @param oldFormBody\n     * @param requestBuilder\n     * @return\n     */</span>\n    <span class=\"token keyword\">private</span> Request <span class=\"token function\">assembleFormBody</span><span class=\"token punctuation\">(</span>Request request<span class=\"token punctuation\">,</span> FormBody oldFormBody<span class=\"token punctuation\">,</span> Request<span class=\"token punctuation\">.</span>Builder requestBuilder<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        TreeMap<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> String<span class=\"token operator\">></span> authMap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TreeMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 遍历请求参数,非空参数,添加到集合中</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> oldFormBody<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>TextUtils<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span>oldFormBody<span class=\"token punctuation\">.</span><span class=\"token function\">encodedValue</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                authMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>oldFormBody<span class=\"token punctuation\">.</span><span class=\"token function\">encodedName</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> oldFormBody<span class=\"token punctuation\">.</span><span class=\"token function\">encodedValue</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>authMap<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 生成 auth 数据</span>\n            FormBody<span class=\"token punctuation\">.</span>Builder newFormBody <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FormBody<span class=\"token punctuation\">.</span>Builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> oldFormBody<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                newFormBody<span class=\"token punctuation\">.</span><span class=\"token function\">addEncoded</span><span class=\"token punctuation\">(</span>oldFormBody<span class=\"token punctuation\">.</span><span class=\"token function\">encodedName</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> oldFormBody<span class=\"token punctuation\">.</span><span class=\"token function\">encodedValue</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            newFormBody<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"auth\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">assembleAuth</span><span class=\"token punctuation\">(</span>authMap<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            requestBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">method</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">.</span><span class=\"token function\">method</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> newFormBody<span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> requestBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">return</span> request<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * Builder 构造函数,用来设置 Authorize 的相关参数,及创建工作\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Builder</span> <span class=\"token punctuation\">{</span>\n        AuthorizeInterceptor authorizeInterceptor<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token function\">Builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            authorizeInterceptor <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AuthorizeInterceptor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">public</span> Builder <span class=\"token function\">setMid</span><span class=\"token punctuation\">(</span>String mid<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            authorizeInterceptor<span class=\"token punctuation\">.</span>mid <span class=\"token operator\">=</span> mid<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">public</span> Builder <span class=\"token function\">setAuthKey</span><span class=\"token punctuation\">(</span>String key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            authorizeInterceptor<span class=\"token punctuation\">.</span>authKey <span class=\"token operator\">=</span> key<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">public</span> AuthorizeInterceptor <span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> authorizeInterceptor<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>该加签方式,讲请求参数拼接为 <code>key=value</code> 的方式, 难点在于如何从 OkHttp 中获取这些参数,在 GET 请求和 POST 的处理方式又不同,代码中 POST 请求方式,又会根据请求传递的 <code>contentType</code> 而又有所不同,这里介绍了<code>Form</code>表单提交和 <code>Multipart</code> 上传文件的参数获取方式,其他的请举一反三.</p>\n","site":{"data":{}},"excerpt":"<p>OKHttp 在开发中经常用到,这里介绍一下 OKHttp 的拦截器(interceptor)的几个使用例子</p>","more":"<p>要是用拦截器很简单,我们只需要自定义一个 interceptor 类, 并实现 Interceptor 接口, 同时重写 intercept 方法.</p>\n<p>这里介绍两种 Interceptor 的实例</p>\n<!-- more -->\n<h2 id=\"Log-日志-LogInterceptor\"><a href=\"#Log-日志-LogInterceptor\" class=\"headerlink\" title=\"Log 日志 (LogInterceptor)\"></a>Log 日志 (LogInterceptor)</h2><p>Log 在开发调试中的重要性, 不言而喻, 一个好的日志数据,能够为开发时提供很多帮助,可以通过 Log 来获取当前程序的执行状态, 顺序等等.</p>\n<p>这里介绍的 Log 日志拦截器,主要是负责在网络请求时,截获请求中的信息,并将请求信息以 Log 的方式输出到控制台上,可展现当前请求地址,请求参数,以及请求结果等.</p>\n<p>话不多说, 上代码.</p>\n<pre><code class=\"java\">/**\n* 自定义 log 拦截器,输入请求地址,请求参,请求结果\n*/\npublic class LogInterceptor implements Interceptor {\n\n        @Override\n        public Response intercept(Chain chain) throws IOException {\n            // 拦截请求信息,获取请求地址及请求参数\n            Request request = chain.request();\n\n            long t1 = System.nanoTime();\n            // 获取请求方式\n            String method = request.method();\n            if (&quot;POST&quot;.equals(method)) {\n                StringBuilder sb = new StringBuilder();\n                if (request.body() instanceof FormBody) {\n                    FormBody body = (FormBody) request.body();\n                    for (int i = 0; i &lt; body.size(); i++) {\n                        sb.append(body.encodedName(i) + &quot;=&quot; + body.encodedValue(i) + &quot;,&quot;);\n                    }\n                    sb.delete(sb.length() - 1, sb.length());\n                    LogUtils.d(TAG, String.format(&quot;Sending request %s on %s %n%s %nRequestParams:{%s}&quot;,\n                            request.url(), chain.connection(), request.headers(), sb.toString()));\n                }\n            } else {\n                LogUtils.d(TAG, String.format(&quot;Sending request %s on %s %n%s&quot;,\n                        request.url(), chain.connection(), request.headers()));\n            }\n            // 获取响应信息\n            Response response = chain.proceed(request);\n            long t2 = System.nanoTime();\n            LogUtils.d(TAG, String.format(&quot;Received response for %s in %.1fms%n%s&quot;,\n                    response.request().url(), (t2 - t1) / 1e6d, response.headers()));\n\n            MediaType contentType = response.body().contentType();\n            String content = response.body().string();\n            LogUtils.d(TAG, content);\n            ResponseBody wrappedBody = ResponseBody.create(contentType, content);\n            return response.newBuilder().body(wrappedBody).build();\n        }\n    }\n</code></pre>\n<h2 id=\"加参\"><a href=\"#加参\" class=\"headerlink\" title=\"加参\"></a>加参</h2><p>加参的意义在于,在请求过程中, 需要传递一些基本参数,这些参数是基本保持不变的, 而这些参数又是后台需要校验的依靠,我们俗称他们为<strong>公参</strong>, 如果在请求过程中在每一个接口里面都去添加这些参数,显得非常繁琐,而且麻烦,后续人员接手,又会不知所措,维护起来相当不方便.</p>\n<p>因此,在这里我们还是通过请求拦截器,通过拦截器去添加这些参数.</p>\n<h3 id=\"公参拦截器\"><a href=\"#公参拦截器\" class=\"headerlink\" title=\"公参拦截器\"></a>公参拦截器</h3><p>在请求中,增加一些公共的参数.</p>\n<pre><code class=\"java\">public class CommonParamsInterceptor implements Interceptor {\n\n    private Map&lt;String, String&gt; queryParamsMap = new HashMap&lt;&gt;();\n    private Map&lt;String, String&gt; paramsMap = new HashMap&lt;&gt;();\n    private Map&lt;String, String&gt; headerParamsMap = new HashMap&lt;&gt;();\n    private List&lt;String&gt; headerLinesList = new ArrayList&lt;&gt;();\n\n    @Override\n    public Response intercept(Chain chain) throws IOException {\n\n        Request request = chain.request();\n        Request.Builder requestBuilder = request.newBuilder();\n\n        // process header params inject\n        Headers.Builder headerBuilder = request.headers().newBuilder();\n        if (headerParamsMap.size() &gt; 0) {\n            Iterator iterator = headerParamsMap.entrySet().iterator();\n            while (iterator.hasNext()) {\n                Map.Entry entry = (Map.Entry) iterator.next();\n                headerBuilder.add((String) entry.getKey(), (String) entry.getValue());\n            }\n        }\n\n        if (headerLinesList.size() &gt; 0) {\n            for (String line : headerLinesList) {\n                headerBuilder.add(line);\n            }\n            requestBuilder.headers(headerBuilder.build());\n        }\n        // process header params end\n\n\n        // process queryParams inject whatever it&#39;s GET or POST\n        if (queryParamsMap.size() &gt; 0 &amp;&amp; &quot;GET&quot;.equals(request.method())) {\n//        if (queryParamsMap.size() &gt; 0) {\n            request = injectParamsIntoUrl(request, requestBuilder, queryParamsMap);\n        }\n\n        // process post body inject\n        if (paramsMap != null &amp;&amp; paramsMap.size() &gt; 0 &amp;&amp; &quot;POST&quot;.equals(request.method())) {\n            if (request.body() instanceof FormBody) {\n                FormBody.Builder newFormBodyBuilder = new FormBody.Builder();\n                if (paramsMap.size() &gt; 0) {\n                    Iterator iterator = paramsMap.entrySet().iterator();\n                    while (iterator.hasNext()) {\n                        Map.Entry entry = (Map.Entry) iterator.next();\n                        newFormBodyBuilder.add((String) entry.getKey(), (String) entry.getValue());\n                    }\n                }\n\n                FormBody oldFormBody = (FormBody) request.body();\n                int paramSize = oldFormBody.size();\n                if (paramSize &gt; 0) {\n                    for (int i = 0; i &lt; paramSize; i++) {\n                        newFormBodyBuilder.add(oldFormBody.name(i), oldFormBody.value(i));\n                    }\n                }\n\n                requestBuilder.post(newFormBodyBuilder.build());\n                request = requestBuilder.build();\n            } else if (request.body() instanceof MultipartBody) {\n                MultipartBody.Builder multipartBuilder = new MultipartBody.Builder().setType(MultipartBody.FORM);\n\n                Iterator iterator = paramsMap.entrySet().iterator();\n                while (iterator.hasNext()) {\n                    Map.Entry entry = (Map.Entry) iterator.next();\n                    multipartBuilder.addFormDataPart((String) entry.getKey(), (String) entry.getValue());\n                }\n\n                List&lt;MultipartBody.Part&gt; oldParts = ((MultipartBody) request.body()).parts();\n                if (oldParts != null &amp;&amp; oldParts.size() &gt; 0) {\n                    for (MultipartBody.Part part : oldParts) {\n                        multipartBuilder.addPart(part);\n                    }\n                }\n\n                requestBuilder.post(multipartBuilder.build());\n                request = requestBuilder.build();\n            }\n\n        }\n        return chain.proceed(request);\n    }\n\n    private boolean canInjectIntoBody(Request request) {\n        if (request == null) {\n            return false;\n        }\n        if (!TextUtils.equals(request.method(), &quot;POST&quot;)) {\n            return false;\n        }\n        RequestBody body = request.body();\n        if (body == null) {\n            return false;\n        }\n        MediaType mediaType = body.contentType();\n        if (mediaType == null) {\n            return false;\n        }\n        if (!TextUtils.equals(mediaType.subtype(), &quot;x-www-form-urlencoded&quot;)) {\n            return false;\n        }\n        return true;\n    }\n\n    // func to inject params into url\n    private Request injectParamsIntoUrl(Request request, Request.Builder requestBuilder, Map&lt;String, String&gt; paramsMap) {\n        HttpUrl.Builder httpUrlBuilder = request.url().newBuilder();\n        if (paramsMap.size() &gt; 0) {\n            Iterator iterator = paramsMap.entrySet().iterator();\n            while (iterator.hasNext()) {\n                Map.Entry entry = (Map.Entry) iterator.next();\n                httpUrlBuilder.addEncodedQueryParameter((String) entry.getKey(), (String) entry.getValue());\n            }\n            requestBuilder.url(httpUrlBuilder.build());\n            return requestBuilder.build();\n        }\n\n        return request;\n    }\n\n    private static String bodyToString(final RequestBody request) {\n        try {\n            final RequestBody copy = request;\n            final Buffer buffer = new Buffer();\n            if (copy != null)\n                copy.writeTo(buffer);\n            else\n                return &quot;&quot;;\n            return buffer.readUtf8();\n        } catch (final IOException e) {\n            return &quot;did not work&quot;;\n        }\n    }\n\n    public static class Builder {\n\n        CommonParamsInterceptor interceptor;\n\n        public Builder() {\n            interceptor = new CommonParamsInterceptor();\n        }\n\n        public Builder addParam(String key, String value) {\n            interceptor.paramsMap.put(key, value);\n            return this;\n        }\n\n        public Builder addParamsMap(Map&lt;String, String&gt; paramsMap) {\n            interceptor.paramsMap.putAll(paramsMap);\n            return this;\n        }\n\n        public Builder addHeaderParam(String key, String value) {\n            interceptor.headerParamsMap.put(key, value);\n            return this;\n        }\n\n        public Builder addHeaderParamsMap(Map&lt;String, String&gt; headerParamsMap) {\n            interceptor.headerParamsMap.putAll(headerParamsMap);\n            return this;\n        }\n\n        public Builder addHeaderLine(String headerLine) {\n            int index = headerLine.indexOf(&quot;:&quot;);\n            if (index == -1) {\n                throw new IllegalArgumentException(&quot;Unexpected header: &quot; + headerLine);\n            }\n            interceptor.headerLinesList.add(headerLine);\n            return this;\n        }\n\n        public Builder addHeaderLinesList(List&lt;String&gt; headerLinesList) {\n            for (String headerLine : headerLinesList) {\n                int index = headerLine.indexOf(&quot;:&quot;);\n                if (index == -1) {\n                    throw new IllegalArgumentException(&quot;Unexpected header: &quot; + headerLine);\n                }\n                interceptor.headerLinesList.add(headerLine);\n            }\n            return this;\n        }\n\n        public Builder addQueryParam(String key, String value) {\n            interceptor.queryParamsMap.put(key, value);\n            return this;\n        }\n\n        public Builder addQueryParamsMap(Map&lt;String, String&gt; queryParamsMap) {\n            interceptor.queryParamsMap.putAll(queryParamsMap);\n            return this;\n        }\n\n        public CommonParamsInterceptor build() {\n            return interceptor;\n        }\n    }\n}\n</code></pre>\n<h3 id=\"加签拦截器\"><a href=\"#加签拦截器\" class=\"headerlink\" title=\"加签拦截器\"></a>加签拦截器</h3><p>互联网是一个开放的环境,危险无处不在,加密通信是安全的基础.</p>\n<p>加密的方式又有很多,比如对称加密/非对称加密/Hash(严格的说不是加密),这里先不对加密进行介绍,我们聊聊加签;</p>\n<p>加签,其实就是给报文做一个摘要,相同的签名算法得到的摘要是相同的,比如MD5, SH1, SH256等, 简单的加签并不能防止篡改,因为攻击者可以篡改后,自己生成新的签名.服务端验签还是可以通过的,因此加签时一定要包含一些私有的东西,比如私钥.</p>\n<p>这里介绍一种加签方式,</p>\n<blockquote>\n<p> 加密规则</p>\n</blockquote>\n<ol>\n<li>根据请求参数 key 进行排序</li>\n<li>按排好的顺序组装成 key=value&amp;key=value 形式的字符串</li>\n<li>将上述字符串拼接  ,最终形成 key=value&amp;key=value的字符串</li>\n<li>将字符串 md5, 生成 auth.</li>\n</ol>\n<p>一个简单的加签逻辑就是这样,下面代码就是对这种规则的实现,看代码↓↓↓↓</p>\n<pre><code class=\"java\">public class AuthorizeInterceptor implements Interceptor {\n\n    private static final String TAG = &quot;AuthorizeInterceptor&quot;;\n\n    /**\n     * 生成 auth 的私钥\n     */\n    private String authKey;\n\n    /**\n     * 当前设备 mid,用来生成 auth\n     * 数据由 Builder 类传入\n     */\n    private String mid = &quot;&quot;;\n\n    private AuthorizeInterceptor() {\n    }\n\n    @Override\n    public Response intercept(Chain chain) throws IOException {\n        Request request = chain.request();\n        Request.Builder requestBuilder = request.newBuilder();\n        String url = request.url().toString();\n        LogUtils.d(TAG, url);\n        if (&quot;POST&quot;.equals(request.method())) {\n            request = injectionParamIntoBody(request, requestBuilder);\n        } else if (&quot;GET&quot;.equals(request.method())) {\n            request = injectionAuthIntoUrl(request, requestBuilder);\n        }\n        return chain.proceed(request);\n    }\n\n    /**\n     * GET 请求方式, 生成授权和添加时间戳\n     *\n     * @param request\n     * @param requestBuilder\n     * @return\n     */\n    private Request injectionAuthIntoUrl(Request request, Request.Builder requestBuilder) {\n        //获取到请求地址api\n        HttpUrl newHttpUrl = request.url();\n        TreeMap&lt;String, String&gt; authMap = new TreeMap&lt;&gt;();\n        //通过请求地址(最初始的请求地址)获取到参数列表\n        Set&lt;String&gt; parameterNames = newHttpUrl.queryParameterNames();\n        for (String key : parameterNames) {\n            //循环参数列表,获取参数value,\n                String paramValue = newHttpUrl.queryParameter(key);\n                if (!TextUtils.isEmpty(paramValue)) {\n                    authMap.put(key, paramValue);\n                }\n\n        }\n        HttpUrl.Builder newBuilder =\n                request.url().newBuilder()\n                        .addEncodedQueryParameter(&quot;auth&quot;, assembleAuth(authMap, false));\n        requestBuilder.url(newBuilder.build());\n        return requestBuilder.build();\n    }\n\n    /**\n     * 将参数注入到 POST 请求的 body 中\n     *\n     * @param request\n     * @param requestBuilder\n     * @return\n     */\n    private Request injectionParamIntoBody(Request request, Request.Builder requestBuilder) {\n        if (request.body() instanceof FormBody) {\n            // 处理正常表单请求方式\n            FormBody oldFormBody = (FormBody) request.body();\n            return assembleFormBody(request, oldFormBody, requestBuilder);\n        } else if (request.body() instanceof MultipartBody) {\n            return assembleMultipartBody(request, requestBuilder);\n        } else {\n            return request;\n        }\n    }\n\n    /**\n     * 构建流媒体参数的 body\n     *\n     * @param request\n     * @param builder\n     * @return\n     */\n    private Request assembleMultipartBody(Request request, Request.Builder builder) {\n        // 处理流的请求方式\n        MultipartBody body = (MultipartBody) request.body();\n        TreeMap&lt;String, String&gt; authMap = new TreeMap&lt;&gt;();\n        // 获取参数 key 及 value 数据, 将数据写入到 TreeMap 中进行排序\n        if (body != null &amp;&amp; body.parts().size() &gt; 0) {\n            for (MultipartBody.Part part : body.parts()) {\n                // 只处理 contentType 为空,或为 text 的情况, image 上传图片的字段,不进行处理\n                if (part.body().contentType() == null\n                        || !&quot;image&quot;.equals(part.body().contentType().type())\n                        || &quot;text&quot;.equals(part.body().contentType().type())) {\n                    Headers headers = part.headers();\n                    // 从 header 中获取 Key, form-data; name= 的字段过滤获取key\n                    // 筛选掉 basic, 获取到当前 header,对应的 RequestBody, 通过 buffer 的方式,获取到 value\n                    // 将 key 和 value 填充到 TreeMap 中\n                    for (int i = 0; i &lt; headers.names().size(); i++) {\n                        String headerName = headers.value(i);\n                        if (headerName.contains(&quot;form-data; name=&quot;)) {\n                            String key = headerName.replace(&quot;form-data; name=&quot;, &quot;&quot;).replace(&quot;\\&quot;&quot;, &quot;&quot;);\n                                String value = body2String(part.body());\n                                if (!TextUtils.isEmpty(value)) {\n                                    authMap.put(key, body2String(part.body()));\n                                }\n                                                   }\n                    }\n                }\n            }\n        }\n\n        MultipartBody.Builder multipartBuilder = new MultipartBody.Builder().setType(MultipartBody.FORM);\n        multipartBuilder.addFormDataPart(&quot;auth&quot;, assembleAuth(authMap, false));\n        List&lt;MultipartBody.Part&gt; oldParts = ((MultipartBody) request.body()).parts();\n        if (oldParts != null &amp;&amp; oldParts.size() &gt; 0) {\n            for (MultipartBody.Part part : oldParts) {\n                multipartBuilder.addPart(part);\n            }\n        }\n        builder.post(multipartBuilder.build());\n        return builder.build();\n    }\n\n    /**\n     * 构建 Auth 数据\n     * &lt;p&gt;\n     * TreeMap 数据,按照字母顺序自动排序后,遍历数据,拼接成 key=value&amp;key=value 的形式,\n     * Map 拼接完成后,在其后需要再次拼接上\n     * &lt;p&gt;\n     * 最后将数据 MD5 转化为 32 位小写并返回\n     *\n     * @param treeMap      构建 Auth 的具体数据\n     * @param isNeedDecode 是否需要解码\n     * @return 返回 auth 数据 \n     */\n    private String assembleAuth(TreeMap&lt;String, String&gt; treeMap, boolean isNeedDecode) {\n        StringBuilder stringBuilder = new StringBuilder();\n        if (treeMap.size() &gt; 0) {\n            for (Map.Entry&lt;String, String&gt; stringStringEntry : treeMap.entrySet()) {\n                try {\n                    stringBuilder.append(stringStringEntry.getKey())\n                            .append(&quot;=&quot;)\n                            .append(isNeedDecode\n                                    ? URLDecoder.decode(stringStringEntry.getValue(), &quot;UTF-8&quot;)\n                                    : stringStringEntry.getValue())\n                            .append(&quot;&amp;&quot;);\n                } catch (UnsupportedEncodingException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        treeMap.clear();\n        stringBuilder\n                .append(authKey);\n        Log.d(TAG, stringBuilder.toString());\n        return MD5.MD5(stringBuilder.toString());\n    }\n\n    /**\n     * body 转 string 获取实际参数值\n     *\n     * @param body Part body\n     * @return part 中写如的参数数据\n     */\n    private String body2String(RequestBody body) {\n        if (body != null) {\n            Buffer buffer = new Buffer();\n            try {\n                body.writeTo(buffer);\n                Charset charset = Charset.forName(&quot;UTF-8&quot;);\n                MediaType contentType = body.contentType();\n                if (contentType != null) {\n                    charset = contentType.charset(charset);\n                }\n                assert charset != null;\n                return buffer.readString(charset);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return &quot;&quot;;\n    }\n\n    /**\n     * 组装 Form 表单请求数据\n     *\n     * @param request\n     * @param oldFormBody\n     * @param requestBuilder\n     * @return\n     */\n    private Request assembleFormBody(Request request, FormBody oldFormBody, Request.Builder requestBuilder) {\n        TreeMap&lt;String, String&gt; authMap = new TreeMap&lt;&gt;();\n        // 遍历请求参数,非空参数,添加到集合中\n        for (int i = 0; i &lt; oldFormBody.size(); i++) {\n            if (!TextUtils.isEmpty(oldFormBody.encodedValue(i))) {\n                authMap.put(oldFormBody.encodedName(i), oldFormBody.encodedValue(i));\n            }\n        }\n        if (authMap.size() != 0) {\n            // 生成 auth 数据\n            FormBody.Builder newFormBody = new FormBody.Builder();\n            for (int i = 0; i &lt; oldFormBody.size(); i++) {\n                newFormBody.addEncoded(oldFormBody.encodedName(i), oldFormBody.encodedValue(i));\n            }\n            newFormBody.add(&quot;auth&quot;, assembleAuth(authMap, true));\n            requestBuilder.method(request.method(), newFormBody.build());\n            return requestBuilder.build();\n        }\n\n        return request;\n    }\n\n\n    /**\n     * Builder 构造函数,用来设置 Authorize 的相关参数,及创建工作\n     */\n    public static class Builder {\n        AuthorizeInterceptor authorizeInterceptor;\n\n        public Builder() {\n            authorizeInterceptor = new AuthorizeInterceptor();\n        }\n\n        public Builder setMid(String mid) {\n            authorizeInterceptor.mid = mid;\n            return this;\n        }\n\n        public Builder setAuthKey(String key) {\n            authorizeInterceptor.authKey = key;\n            return this;\n        }\n\n        public AuthorizeInterceptor build() {\n            return authorizeInterceptor;\n        }\n    }\n}\n</code></pre>\n<p>该加签方式,讲请求参数拼接为 <code>key=value</code> 的方式, 难点在于如何从 OkHttp 中获取这些参数,在 GET 请求和 POST 的处理方式又不同,代码中 POST 请求方式,又会根据请求传递的 <code>contentType</code> 而又有所不同,这里介绍了<code>Form</code>表单提交和 <code>Multipart</code> 上传文件的参数获取方式,其他的请举一反三.</p>"},{"title":"数据结构","_content":"\n\n## 数组\n\n是一片物理上连续的大小确定的存储空间\n\n数组查询速度快，是因为其在内存上是一段连续的内存空间，因此会有一个内存地址指向，每创建一个对象（Object），也就是要存储的值，占 4 个字节，通过 index * 4，在加上初始地址，计算的来的值，可以快速的定位到目标值，获取相应数据。\n\n利用索引进行查询速度快，无法真正的删除\n<!-- more -->\n\n\n## List\n\n具有连续有序性，可重复性，可扩容性，访问比较便捷\n\n### ArrayList\n\n**原理与特点**\n\n实际上是对数组的一种封装，具备数组存储上空间连续及查找速度快的特性，并且顺序上也连续；但因为顺序上的连续，就造成了其删除和插入数据较慢的特性，因为顺序上的连续，所以在插入和删除时，为保证连续性，需要对数组的内容进行移动，大大增加了数据的操作性。\n\n```java\n    public void add(int index, E element) {\n        if (index > size || index < 0)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        // 移位操作\n        System.arraycopy(elementData, index, elementData, index + 1,\n                         size - index);\n        elementData[index] = element;\n        size++;\n    }\n \tpublic E remove(int index) {\n        if (index >= size)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n\n        modCount++;\n        E oldValue = (E) elementData[index];\n\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            // 移位操作\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n\n        return oldValue;\n    }\n```\n\n**扩容机制：**\n\n`ArrayList` 的默认长度是 10， 当数据总量超过容器时，会进行一次扩容操作，且每次扩容 50%。\n\n```java\nprivate void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    // oldCapacity >> 1 等价于  oldCapacity / 2\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    // minCapacity is usually close to size, so this is a win:\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n\n\n### LinkedList\n\n是系统为我们提供的在物理上不连续，逻辑上连续的一个假象的数据片段。其内部实现是通过链表的方式，没一个元素都被封装成一个双向 `node` 节点，并绑定前一个和下一个节点的方式，来保证物理上连续。\n\n因采用链表的结构，因此也灭有长度限制，也不存在扩容机制，可以无限长。\n\n因此，他不向数组的可以快速定位数据，当获取数据时，需要根据节点位置，遍历才能获得，因此其查询速度很慢\n\n```java\npublic E get(int index) {\n    checkElementIndex(index);\n    return node(index).item;\n}\nNode<E> node(int index) {\n    // 从前面查找\n    if (index < (size >> 1)) {\n        Node<E> x = first;\n        for (int i = 0; i < index; i++)\n            x = x.next;\n        return x;\n    } else {\n        // 从后面查找\n        Node<E> x = last;\n        for (int i = size - 1; i > index; i--)\n            x = x.prev;\n        return x;\n    }\n}\t\n```\n\n但他的插入和删除就很方便，插入和删除时，只需要断开链表，重新将新数据的头尾互相指向即可。\n\n```java\n   //插入数据\n    public void add(int index, E element) {\n        if (index == size)\n            linkLast(element);\n        else\n            // 插入时，有时也需要遍历，这里可以忽略\n            linkBefore(element, node(index));\n    }\n\n\tvoid linkLast(E e) {\n        final Node<E> l = last;\n        final Node<E> newNode = new Node<>(l, e, null);\n        last = newNode;\n        if (l == null)\n            first = newNode;\n        else\n            l.next = newNode;\n        size++;\n        modCount++;\n    }\n    void linkBefore(E e, Node<E> succ) {\n        // assert succ != null;\n        final Node<E> pred = succ.prev;\n        final Node<E> newNode = new Node<>(pred, e, succ);\n        succ.prev = newNode;\n        if (pred == null)\n            first = newNode;\n        else\n            pred.next = newNode;\n        size++;\n        modCount++;\n    }\n// 移除数据\n\tprivate E unlinkFirst(Node<E> f) {\n        // assert f == first && f != null;\n        final E element = f.item;\n        final Node<E> next = f.next;\n        f.item = null;\n        f.next = null; // help GC\n        first = next;\n        if (next == null)\n            last = null;\n        else\n            next.prev = null;\n        size--;\n        modCount++;\n        return element;\n    }\n\n    /**\n     * Unlinks non-null last node l.\n     */\n    private E unlinkLast(Node<E> l) {\n        // assert l == last && l != null;\n        final E element = l.item;\n        final Node<E> prev = l.prev;\n        l.item = null;\n        l.prev = null; // help GC\n        last = prev;\n        if (prev == null)\n            first = null;\n        else\n            prev.next = null;\n        size--;\n        modCount++;\n        return element;\n    }\n```\n\n### Vector\n\n和 ArrayList 几乎一样，区别在于 Vector 是线程安全的，在插入、删除等操作，其方法都是 `synchronized`，因此性能比 `ArrayList` 差，每次扩容申请双倍空间也可以自定义。\n\n## Set\n\n具有不可重复性，无序性，*不可查找的特点*\n\n### HashSet\n\n`HashSet` 的内部使用 `HashMap` 来存储数据，即 `add` 时，将元素当作 `HashMap ` 的 `Key` 来使用，这也符合 `Set` 集合不可重复性的特点。\n\n此类集合不可以直接获取容器中的 value， 可通过遍历 *迭代器*  来获取全部元素。但不能多线程操作，此类容器都是可快速失败的，即当我们正在遍历时，如果原数据被修改，则会立即停止，并抛出 `ConCurrentException` 。\n\n### LinkedHashSet\n\n同样根据 hashCode 来决定元素的存储位置，同时又具有 链表的特点，在迭代遍历时，可以获取到列表顺序。\n\n**List 和 Set 的区别**\n\n- 是否允许数据元素重复存在，在 List 中允许插入重复的元素，Set 集合不允许\n- 元素的先后存放顺序 List 是一个有序的集合，会保留元素的插入顺序， Set 是无序集合\n- List 可以通过下标来访问元素， 而 Set 不能\n\n\n\n## HashMap\n\n**数组** 和 **单链表** 的组合， 数组用来存储 key，链表用来存储实际的 value\n\n### put(K key, V value);\n\n当存放一个数值时，会先对 key 值进行 hash 运算得到 Hash 值，\n\n当链表为空时，通过 `resize()` 函数帮我创建一个新链表，默认长度为 16 （1 << 4，为 2 的次幂数，这里和扩容机制有关）；(由于 Hash Map 的长度机制限制，所以 table 的初始化工作，在 put 真正使用这个数据时才去创建，避免了性能上的损耗)\n\n当链表不为空，通过 hash 值，从数组中获取到对应的节点对象，如果对象为空，则创建一个新的节点；如果节点不为空，说明这个 key 被赋值过，因此将新的 value 赋值给该节点。\n\n```java\n/**\n* 装箱过程，计算 hash 值的过程。\n* \n*/\nstatic final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {\n        Node<K, V>[] tab;\n        Node<K, V> p;\n        int n, i;\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n     \t// tab[i = (n - 1) & hash] \n    \t// n 是数组的长度，经过 & 和 hash 值的位运算（模运算：求余数的运算，等价于=> （hash % n）），获得该元素在数组中的索引\n        if ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            Node<K, V> e;\n            K k;\n            if (p.hash == hash &&\n                    ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;\n            else if (p instanceof TreeNode)\n                e = ((TreeNode<K, V>) p).putTreeVal(this, tab, hash, key, value);\n            else {\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        p.next = newNode(hash, key, value, null);\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    if (e.hash == hash &&\n                            ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n```\n\n### **Hash 碰撞/冲突**\n\n在求模运算过程中，存在多对一的情况，即不同的 Hash 值，可能会计算出相同的索引值\n\n**解决方案**：\n\n**链表法：** 当发生 Hash 碰撞/冲突，即不同的 hash 值，最终计算出了相同的索引值，如果索引对应的位置数据为 null， 则直接创建新节点，如果不为 null， 则采用前插/后插的方案，插入到链表当中，当通过 `get()` 函数获取数据时，拿到一个链表，就遍历，找到 `hash` 值相同的那个节点，并返回。\n\n**避免冲突**：\n\n阈值，为保证在尽可能长的情况下，保证 hash 不会冲突。即当发生时，就扩容。\n\n**扩容方案：**\n\n加载因子：`loadFactor` 默认值是 0.75\n\n阈值：与加载因子有关，通过加载因子和 HashMap 的长度计算而来，有阈值就一定会有浪费，因此 25% 的内存内浪费掉，在 Android  使用空间换时间。\n\nHashMap 的默认长度是 16，其长度，一定是 2 的次幂，目的是为了减少 Hash 的碰撞。\n\n> 比如：\n>\n> length1 = 10，(非 2 的次幂)，对应的二进制数是 1001\n>\n> length2 = 16(2 的 4 次幂)，对应的二进制数是 1111\n>\n> 当产生一个 hash 值，为 6（0110）时， (n - 1) & hash ，length1 位运算之后的结果是 0000， length2 位运算之后的结果是 0110\n>\n> 当产生一个 hash 值，为 7（0111）时， (n - 1) & hash ，length1 位运算之后的结果是 0001， length2 位运算之后的结果是 0111\n>\n> 由此我们可以看出，影响运算结果的因素是 (1001) 中间的两位数字，而使用 (1111) 计算的结果，与四位数字都有关系（也就是说 数字 1 不会影响结果的计算），因此使用 2 的次幂为长度的目的就是为了减少 Hash 值的碰撞\n\n\n\n当链表长度，以及其他索引对应的链表总长度大于阈值时，开始扩容。\n\n当扩容发生时，HashMap 的长度就发生了变化，扩容前的数据的模运算就发生了改变，因此在扩容后，需要使用新的长度对所有的原有数据，进行 hash 计算，因此会发生性能上的损耗。因此在使用时，我们要尽量避免 HashMap 发生扩容。\n\n开发时，需要我们去尽量评估容量，当我们创建一个 HashMap，并传入一个非 2 的次幂值时，系统会帮我们寻找一个比当前值大的最近的 2 的次幂值，来给 HashMap 作为初始值。\n\n## SparseArray\n\n**原理与特点**\n\n由 **双数组** 构成，两个数组分别存储 `Key` 和  `Value` ，并一一对应。\n\n查询速度快，删除快，插入慢（随着数据越来越大，插入的性能也会提升）\n\n通过获取 key 的索引找到其对应的 value 值，也就具备了 **查询速度快** 的特点（也是数组的特点）\n\n删除元素时，仅将元素标记位 **\"DELETE\"** 状态，不发生移位等操作，因此速度上会比 `ArrayList` 快\n\n因为是标记为 \"DELETE\" ，因此算法是可以达到复用，再利用二分查找，被标记为 \"DELETE\" 的数据，可以直接复用，不会涉及到数组的位移，因此会越用越快。\n\n缺点是，Key 只能是 `int` 类型数据。\n\n```java\n    public void put(int key, E value) {\n        // 二分查找，快速定位传入的 key 所在位置\n        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);\n        // 如果存在，直接替换同位置数据\n        if (i >= 0) {\n            mValues[i] = value;\n        } else {\n            // 不存在时，如果当前位置被标记为 DELETE 状态（未被使用），则直接给 key 和 value 数组赋值\n            i = ~i;\n            if (i < mSize && mValues[i] == DELETED) {\n                mKeys[i] = key;\n                mValues[i] = value;\n                return;\n            }\n            if (mGarbage && mSize >= mKeys.length) {\n                gc();\n                // Search again because indices may have changed.\n                i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);\n            }\n            // 扩容机制，2倍\n            mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);\n            mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);\n            mSize++;\n        }\n    }\n\tpublic static int[] insert(int[] array, int currentSize, int index, int element) {\n       int[] newArray = new int[growSize(currentSize)];\n        System.arraycopy(array, 0, newArray, 0, index);\n        newArray[index] = element;\n        System.arraycopy(array, index, newArray, index + 1, array.length - index);\n        return newArray;\n    }\n \tpublic static int growSize(int currentSize) {\n        // 2 倍扩容机制\n        return currentSize <= 4 ? 8 : currentSize * 2;\n    }\n\n    // 移除数据，仅标记 DELETE 状态\n    public void delete(int key) {\n        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);\n\n        if (i >= 0) {\n            if (mValues[i] != DELETED) {\n                mValues[i] = DELETED;\n                mGarbage = true;\n            }\n        }\n    }\n\n```\n\n**扩容机制：**\n\n同样的，初始长度为 10， 每次扩容，为当前容量的 2 倍。\n\n## ArrayMap\n\n是Hash Map 和 Sparse Array 的合计，具备他们的双重特性，使用 `hashcode` 作为 key，弥补了 `SparseArray` 只能是 `int` 型。使用双数组的形式，又弥补了 `HashMap` 的对内存消耗的问题。\n\n## LinkedHashMap\n\n是 `HashMap` 的子类， `put`  和 `remove` 函数使用的就是 `HashMap` 的，没有太大却别，主要区别在于 `get` 函数， `LinkedHashMap` 在每次 `get` 出一个数据后，会将这个数据放在链表的尾部。\n\n`LinkedHashMap` 的应用，在 `LRUCache` 和 `DiskLRUCache` 中使用，其算法名称 *最少/最小使用算法* ，也就是说，利用了 `LinkedHashMap` 的 `get` 函数的特性，计算出链表头部的数据被使用的次数最少，当容器长度达到最大值时，就将链表头部的数据移除。\n\n\n\n## 队列 Queue 和 栈 Stack\n\n* 队列的特点是 *先入先出*\n* 栈的特点是 *先入后出* \n\n### 栈\n\n**特点：** 后进先出； 所有的操作都是围绕栈顶部来完成\n\n算法的基本思想：\n\n可以用一个单链表来实现\n\n只关心上一次的操作\n\n处理完上一次操作后，能在 O(1) 时间内查找到更前一次的操作\n\n```java\n// 查找下一个比自己大的数的距离\npublic void stackSwap(int[] nums) {\n    \n    // 定义一个栈，用来缓存当前的最大值的索引\n    Stack<Integer> stack = new Stack<>();\n    // 定义一个数组，用来存储对应数据的间距\n    int[] interval = new int[nums.length];\n    \n    for(int i = 0; i < nums.length; i++) {\n       \tif(!stack.empty()){\n            // 因为会对栈进行操作，长度会改变，如果不先取，会导致循环跳位\n            int size = stack.size();\n            for(int j  = 0; j < size; j++) {\n                // 拿出栈顶数据的索引\n                int topIndex = stack.peek();\n                if(nums[i] > num[topIndex]) {\n                    interval[topIndex] = i - topIndex;\n                    stack.pop();\n                }\n            }\n        }\n        // 如果为空，或者栈顶数据比但前数据大，则将数据直接压入\n        // 或找不到一个比当前数据大的数据时，将当前数据压入栈\n        stack.push(i);\n    }\n    \n}\n```\n\n### 队列\n\n和栈不同，队列的最大特点是先进先出（FIFO），就好像按顺序排队一样。对于队列的数据来说，我们只允许在队尾查看和添加数据，在队头查看和删除数据。\n\n实现：可以借助双链表来实现队列。双链表的头指针允许在队头查看和删除数据，而双链表的尾指针允许我们在队尾查看和添加数据。\n\n应用场景：直观来看，当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题。在算法面试题当中，广度优先搜索（Breadth-First Search）是运用队列最多的地方。\n\n","source":"_posts/数据结构/数据结构.md","raw":"---\ntitle: 数据结构\ntag: 数据结构和算法\ncategory: 基础知识\n---\n\n\n## 数组\n\n是一片物理上连续的大小确定的存储空间\n\n数组查询速度快，是因为其在内存上是一段连续的内存空间，因此会有一个内存地址指向，每创建一个对象（Object），也就是要存储的值，占 4 个字节，通过 index * 4，在加上初始地址，计算的来的值，可以快速的定位到目标值，获取相应数据。\n\n利用索引进行查询速度快，无法真正的删除\n<!-- more -->\n\n\n## List\n\n具有连续有序性，可重复性，可扩容性，访问比较便捷\n\n### ArrayList\n\n**原理与特点**\n\n实际上是对数组的一种封装，具备数组存储上空间连续及查找速度快的特性，并且顺序上也连续；但因为顺序上的连续，就造成了其删除和插入数据较慢的特性，因为顺序上的连续，所以在插入和删除时，为保证连续性，需要对数组的内容进行移动，大大增加了数据的操作性。\n\n```java\n    public void add(int index, E element) {\n        if (index > size || index < 0)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        // 移位操作\n        System.arraycopy(elementData, index, elementData, index + 1,\n                         size - index);\n        elementData[index] = element;\n        size++;\n    }\n \tpublic E remove(int index) {\n        if (index >= size)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n\n        modCount++;\n        E oldValue = (E) elementData[index];\n\n        int numMoved = size - index - 1;\n        if (numMoved > 0)\n            // 移位操作\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n\n        return oldValue;\n    }\n```\n\n**扩容机制：**\n\n`ArrayList` 的默认长度是 10， 当数据总量超过容器时，会进行一次扩容操作，且每次扩容 50%。\n\n```java\nprivate void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    // oldCapacity >> 1 等价于  oldCapacity / 2\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    // minCapacity is usually close to size, so this is a win:\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n\n\n### LinkedList\n\n是系统为我们提供的在物理上不连续，逻辑上连续的一个假象的数据片段。其内部实现是通过链表的方式，没一个元素都被封装成一个双向 `node` 节点，并绑定前一个和下一个节点的方式，来保证物理上连续。\n\n因采用链表的结构，因此也灭有长度限制，也不存在扩容机制，可以无限长。\n\n因此，他不向数组的可以快速定位数据，当获取数据时，需要根据节点位置，遍历才能获得，因此其查询速度很慢\n\n```java\npublic E get(int index) {\n    checkElementIndex(index);\n    return node(index).item;\n}\nNode<E> node(int index) {\n    // 从前面查找\n    if (index < (size >> 1)) {\n        Node<E> x = first;\n        for (int i = 0; i < index; i++)\n            x = x.next;\n        return x;\n    } else {\n        // 从后面查找\n        Node<E> x = last;\n        for (int i = size - 1; i > index; i--)\n            x = x.prev;\n        return x;\n    }\n}\t\n```\n\n但他的插入和删除就很方便，插入和删除时，只需要断开链表，重新将新数据的头尾互相指向即可。\n\n```java\n   //插入数据\n    public void add(int index, E element) {\n        if (index == size)\n            linkLast(element);\n        else\n            // 插入时，有时也需要遍历，这里可以忽略\n            linkBefore(element, node(index));\n    }\n\n\tvoid linkLast(E e) {\n        final Node<E> l = last;\n        final Node<E> newNode = new Node<>(l, e, null);\n        last = newNode;\n        if (l == null)\n            first = newNode;\n        else\n            l.next = newNode;\n        size++;\n        modCount++;\n    }\n    void linkBefore(E e, Node<E> succ) {\n        // assert succ != null;\n        final Node<E> pred = succ.prev;\n        final Node<E> newNode = new Node<>(pred, e, succ);\n        succ.prev = newNode;\n        if (pred == null)\n            first = newNode;\n        else\n            pred.next = newNode;\n        size++;\n        modCount++;\n    }\n// 移除数据\n\tprivate E unlinkFirst(Node<E> f) {\n        // assert f == first && f != null;\n        final E element = f.item;\n        final Node<E> next = f.next;\n        f.item = null;\n        f.next = null; // help GC\n        first = next;\n        if (next == null)\n            last = null;\n        else\n            next.prev = null;\n        size--;\n        modCount++;\n        return element;\n    }\n\n    /**\n     * Unlinks non-null last node l.\n     */\n    private E unlinkLast(Node<E> l) {\n        // assert l == last && l != null;\n        final E element = l.item;\n        final Node<E> prev = l.prev;\n        l.item = null;\n        l.prev = null; // help GC\n        last = prev;\n        if (prev == null)\n            first = null;\n        else\n            prev.next = null;\n        size--;\n        modCount++;\n        return element;\n    }\n```\n\n### Vector\n\n和 ArrayList 几乎一样，区别在于 Vector 是线程安全的，在插入、删除等操作，其方法都是 `synchronized`，因此性能比 `ArrayList` 差，每次扩容申请双倍空间也可以自定义。\n\n## Set\n\n具有不可重复性，无序性，*不可查找的特点*\n\n### HashSet\n\n`HashSet` 的内部使用 `HashMap` 来存储数据，即 `add` 时，将元素当作 `HashMap ` 的 `Key` 来使用，这也符合 `Set` 集合不可重复性的特点。\n\n此类集合不可以直接获取容器中的 value， 可通过遍历 *迭代器*  来获取全部元素。但不能多线程操作，此类容器都是可快速失败的，即当我们正在遍历时，如果原数据被修改，则会立即停止，并抛出 `ConCurrentException` 。\n\n### LinkedHashSet\n\n同样根据 hashCode 来决定元素的存储位置，同时又具有 链表的特点，在迭代遍历时，可以获取到列表顺序。\n\n**List 和 Set 的区别**\n\n- 是否允许数据元素重复存在，在 List 中允许插入重复的元素，Set 集合不允许\n- 元素的先后存放顺序 List 是一个有序的集合，会保留元素的插入顺序， Set 是无序集合\n- List 可以通过下标来访问元素， 而 Set 不能\n\n\n\n## HashMap\n\n**数组** 和 **单链表** 的组合， 数组用来存储 key，链表用来存储实际的 value\n\n### put(K key, V value);\n\n当存放一个数值时，会先对 key 值进行 hash 运算得到 Hash 值，\n\n当链表为空时，通过 `resize()` 函数帮我创建一个新链表，默认长度为 16 （1 << 4，为 2 的次幂数，这里和扩容机制有关）；(由于 Hash Map 的长度机制限制，所以 table 的初始化工作，在 put 真正使用这个数据时才去创建，避免了性能上的损耗)\n\n当链表不为空，通过 hash 值，从数组中获取到对应的节点对象，如果对象为空，则创建一个新的节点；如果节点不为空，说明这个 key 被赋值过，因此将新的 value 赋值给该节点。\n\n```java\n/**\n* 装箱过程，计算 hash 值的过程。\n* \n*/\nstatic final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {\n        Node<K, V>[] tab;\n        Node<K, V> p;\n        int n, i;\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n     \t// tab[i = (n - 1) & hash] \n    \t// n 是数组的长度，经过 & 和 hash 值的位运算（模运算：求余数的运算，等价于=> （hash % n）），获得该元素在数组中的索引\n        if ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            Node<K, V> e;\n            K k;\n            if (p.hash == hash &&\n                    ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;\n            else if (p instanceof TreeNode)\n                e = ((TreeNode<K, V>) p).putTreeVal(this, tab, hash, key, value);\n            else {\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        p.next = newNode(hash, key, value, null);\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    if (e.hash == hash &&\n                            ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n```\n\n### **Hash 碰撞/冲突**\n\n在求模运算过程中，存在多对一的情况，即不同的 Hash 值，可能会计算出相同的索引值\n\n**解决方案**：\n\n**链表法：** 当发生 Hash 碰撞/冲突，即不同的 hash 值，最终计算出了相同的索引值，如果索引对应的位置数据为 null， 则直接创建新节点，如果不为 null， 则采用前插/后插的方案，插入到链表当中，当通过 `get()` 函数获取数据时，拿到一个链表，就遍历，找到 `hash` 值相同的那个节点，并返回。\n\n**避免冲突**：\n\n阈值，为保证在尽可能长的情况下，保证 hash 不会冲突。即当发生时，就扩容。\n\n**扩容方案：**\n\n加载因子：`loadFactor` 默认值是 0.75\n\n阈值：与加载因子有关，通过加载因子和 HashMap 的长度计算而来，有阈值就一定会有浪费，因此 25% 的内存内浪费掉，在 Android  使用空间换时间。\n\nHashMap 的默认长度是 16，其长度，一定是 2 的次幂，目的是为了减少 Hash 的碰撞。\n\n> 比如：\n>\n> length1 = 10，(非 2 的次幂)，对应的二进制数是 1001\n>\n> length2 = 16(2 的 4 次幂)，对应的二进制数是 1111\n>\n> 当产生一个 hash 值，为 6（0110）时， (n - 1) & hash ，length1 位运算之后的结果是 0000， length2 位运算之后的结果是 0110\n>\n> 当产生一个 hash 值，为 7（0111）时， (n - 1) & hash ，length1 位运算之后的结果是 0001， length2 位运算之后的结果是 0111\n>\n> 由此我们可以看出，影响运算结果的因素是 (1001) 中间的两位数字，而使用 (1111) 计算的结果，与四位数字都有关系（也就是说 数字 1 不会影响结果的计算），因此使用 2 的次幂为长度的目的就是为了减少 Hash 值的碰撞\n\n\n\n当链表长度，以及其他索引对应的链表总长度大于阈值时，开始扩容。\n\n当扩容发生时，HashMap 的长度就发生了变化，扩容前的数据的模运算就发生了改变，因此在扩容后，需要使用新的长度对所有的原有数据，进行 hash 计算，因此会发生性能上的损耗。因此在使用时，我们要尽量避免 HashMap 发生扩容。\n\n开发时，需要我们去尽量评估容量，当我们创建一个 HashMap，并传入一个非 2 的次幂值时，系统会帮我们寻找一个比当前值大的最近的 2 的次幂值，来给 HashMap 作为初始值。\n\n## SparseArray\n\n**原理与特点**\n\n由 **双数组** 构成，两个数组分别存储 `Key` 和  `Value` ，并一一对应。\n\n查询速度快，删除快，插入慢（随着数据越来越大，插入的性能也会提升）\n\n通过获取 key 的索引找到其对应的 value 值，也就具备了 **查询速度快** 的特点（也是数组的特点）\n\n删除元素时，仅将元素标记位 **\"DELETE\"** 状态，不发生移位等操作，因此速度上会比 `ArrayList` 快\n\n因为是标记为 \"DELETE\" ，因此算法是可以达到复用，再利用二分查找，被标记为 \"DELETE\" 的数据，可以直接复用，不会涉及到数组的位移，因此会越用越快。\n\n缺点是，Key 只能是 `int` 类型数据。\n\n```java\n    public void put(int key, E value) {\n        // 二分查找，快速定位传入的 key 所在位置\n        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);\n        // 如果存在，直接替换同位置数据\n        if (i >= 0) {\n            mValues[i] = value;\n        } else {\n            // 不存在时，如果当前位置被标记为 DELETE 状态（未被使用），则直接给 key 和 value 数组赋值\n            i = ~i;\n            if (i < mSize && mValues[i] == DELETED) {\n                mKeys[i] = key;\n                mValues[i] = value;\n                return;\n            }\n            if (mGarbage && mSize >= mKeys.length) {\n                gc();\n                // Search again because indices may have changed.\n                i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);\n            }\n            // 扩容机制，2倍\n            mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);\n            mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);\n            mSize++;\n        }\n    }\n\tpublic static int[] insert(int[] array, int currentSize, int index, int element) {\n       int[] newArray = new int[growSize(currentSize)];\n        System.arraycopy(array, 0, newArray, 0, index);\n        newArray[index] = element;\n        System.arraycopy(array, index, newArray, index + 1, array.length - index);\n        return newArray;\n    }\n \tpublic static int growSize(int currentSize) {\n        // 2 倍扩容机制\n        return currentSize <= 4 ? 8 : currentSize * 2;\n    }\n\n    // 移除数据，仅标记 DELETE 状态\n    public void delete(int key) {\n        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);\n\n        if (i >= 0) {\n            if (mValues[i] != DELETED) {\n                mValues[i] = DELETED;\n                mGarbage = true;\n            }\n        }\n    }\n\n```\n\n**扩容机制：**\n\n同样的，初始长度为 10， 每次扩容，为当前容量的 2 倍。\n\n## ArrayMap\n\n是Hash Map 和 Sparse Array 的合计，具备他们的双重特性，使用 `hashcode` 作为 key，弥补了 `SparseArray` 只能是 `int` 型。使用双数组的形式，又弥补了 `HashMap` 的对内存消耗的问题。\n\n## LinkedHashMap\n\n是 `HashMap` 的子类， `put`  和 `remove` 函数使用的就是 `HashMap` 的，没有太大却别，主要区别在于 `get` 函数， `LinkedHashMap` 在每次 `get` 出一个数据后，会将这个数据放在链表的尾部。\n\n`LinkedHashMap` 的应用，在 `LRUCache` 和 `DiskLRUCache` 中使用，其算法名称 *最少/最小使用算法* ，也就是说，利用了 `LinkedHashMap` 的 `get` 函数的特性，计算出链表头部的数据被使用的次数最少，当容器长度达到最大值时，就将链表头部的数据移除。\n\n\n\n## 队列 Queue 和 栈 Stack\n\n* 队列的特点是 *先入先出*\n* 栈的特点是 *先入后出* \n\n### 栈\n\n**特点：** 后进先出； 所有的操作都是围绕栈顶部来完成\n\n算法的基本思想：\n\n可以用一个单链表来实现\n\n只关心上一次的操作\n\n处理完上一次操作后，能在 O(1) 时间内查找到更前一次的操作\n\n```java\n// 查找下一个比自己大的数的距离\npublic void stackSwap(int[] nums) {\n    \n    // 定义一个栈，用来缓存当前的最大值的索引\n    Stack<Integer> stack = new Stack<>();\n    // 定义一个数组，用来存储对应数据的间距\n    int[] interval = new int[nums.length];\n    \n    for(int i = 0; i < nums.length; i++) {\n       \tif(!stack.empty()){\n            // 因为会对栈进行操作，长度会改变，如果不先取，会导致循环跳位\n            int size = stack.size();\n            for(int j  = 0; j < size; j++) {\n                // 拿出栈顶数据的索引\n                int topIndex = stack.peek();\n                if(nums[i] > num[topIndex]) {\n                    interval[topIndex] = i - topIndex;\n                    stack.pop();\n                }\n            }\n        }\n        // 如果为空，或者栈顶数据比但前数据大，则将数据直接压入\n        // 或找不到一个比当前数据大的数据时，将当前数据压入栈\n        stack.push(i);\n    }\n    \n}\n```\n\n### 队列\n\n和栈不同，队列的最大特点是先进先出（FIFO），就好像按顺序排队一样。对于队列的数据来说，我们只允许在队尾查看和添加数据，在队头查看和删除数据。\n\n实现：可以借助双链表来实现队列。双链表的头指针允许在队头查看和删除数据，而双链表的尾指针允许我们在队尾查看和添加数据。\n\n应用场景：直观来看，当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题。在算法面试题当中，广度优先搜索（Breadth-First Search）是运用队列最多的地方。\n\n","slug":"数据结构/数据结构","published":1,"date":"2021-01-29T15:54:28.359Z","updated":"2021-01-30T08:30:11.009Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8fq002isz5qflofot3x","content":"<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>是一片物理上连续的大小确定的存储空间</p>\n<p>数组查询速度快，是因为其在内存上是一段连续的内存空间，因此会有一个内存地址指向，每创建一个对象（Object），也就是要存储的值，占 4 个字节，通过 index * 4，在加上初始地址，计算的来的值，可以快速的定位到目标值，获取相应数据。</p>\n<p>利用索引进行查询速度快，无法真正的删除<br><a id=\"more\"></a></p>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><p>具有连续有序性，可重复性，可扩容性，访问比较便捷</p>\n<h3 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h3><p><strong>原理与特点</strong></p>\n<p>实际上是对数组的一种封装，具备数组存储上空间连续及查找速度快的特性，并且顺序上也连续；但因为顺序上的连续，就造成了其删除和插入数据较慢的特性，因为顺序上的连续，所以在插入和删除时，为保证连续性，需要对数组的内容进行移动，大大增加了数据的操作性。</p>\n<pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> index<span class=\"token punctuation\">,</span> E element<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">></span> size <span class=\"token operator\">||</span> index <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IndexOutOfBoundsException</span><span class=\"token punctuation\">(</span><span class=\"token function\">outOfBoundsMsg</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token function\">ensureCapacityInternal</span><span class=\"token punctuation\">(</span>size <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// Increments modCount!!</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 移位操作</span>\n        System<span class=\"token punctuation\">.</span><span class=\"token function\">arraycopy</span><span class=\"token punctuation\">(</span>elementData<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">,</span> elementData<span class=\"token punctuation\">,</span> index <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n                         size <span class=\"token operator\">-</span> index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        elementData<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> element<span class=\"token punctuation\">;</span>\n        size<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n     <span class=\"token keyword\">public</span> E <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">>=</span> size<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IndexOutOfBoundsException</span><span class=\"token punctuation\">(</span><span class=\"token function\">outOfBoundsMsg</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        modCount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        E oldValue <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>E<span class=\"token punctuation\">)</span> elementData<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">int</span> numMoved <span class=\"token operator\">=</span> size <span class=\"token operator\">-</span> index <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>numMoved <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 移位操作</span>\n            System<span class=\"token punctuation\">.</span><span class=\"token function\">arraycopy</span><span class=\"token punctuation\">(</span>elementData<span class=\"token punctuation\">,</span> index<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> elementData<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">,</span>\n                             numMoved<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        elementData<span class=\"token punctuation\">[</span><span class=\"token operator\">--</span>size<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// clear to let GC do its work</span>\n\n        <span class=\"token keyword\">return</span> oldValue<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>扩容机制：</strong></p>\n<p><code>ArrayList</code> 的默认长度是 10， 当数据总量超过容器时，会进行一次扩容操作，且每次扩容 50%。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">grow</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> minCapacity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// overflow-conscious code</span>\n    <span class=\"token keyword\">int</span> oldCapacity <span class=\"token operator\">=</span> elementData<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// oldCapacity >> 1 等价于  oldCapacity / 2</span>\n    <span class=\"token keyword\">int</span> newCapacity <span class=\"token operator\">=</span> oldCapacity <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>oldCapacity <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>newCapacity <span class=\"token operator\">-</span> minCapacity <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        newCapacity <span class=\"token operator\">=</span> minCapacity<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>newCapacity <span class=\"token operator\">-</span> MAX_ARRAY_SIZE <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        newCapacity <span class=\"token operator\">=</span> <span class=\"token function\">hugeCapacity</span><span class=\"token punctuation\">(</span>minCapacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// minCapacity is usually close to size, so this is a win:</span>\n    elementData <span class=\"token operator\">=</span> Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">copyOf</span><span class=\"token punctuation\">(</span>elementData<span class=\"token punctuation\">,</span> newCapacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h3><p>是系统为我们提供的在物理上不连续，逻辑上连续的一个假象的数据片段。其内部实现是通过链表的方式，没一个元素都被封装成一个双向 <code>node</code> 节点，并绑定前一个和下一个节点的方式，来保证物理上连续。</p>\n<p>因采用链表的结构，因此也灭有长度限制，也不存在扩容机制，可以无限长。</p>\n<p>因此，他不向数组的可以快速定位数据，当获取数据时，需要根据节点位置，遍历才能获得，因此其查询速度很慢</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> E <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">checkElementIndex</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">node</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>item<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nNode<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> <span class=\"token function\">node</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 从前面查找</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">&lt;</span> <span class=\"token punctuation\">(</span>size <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Node<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> x <span class=\"token operator\">=</span> first<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> index<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            x <span class=\"token operator\">=</span> x<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 从后面查找</span>\n        Node<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> x <span class=\"token operator\">=</span> last<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> size <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">></span> index<span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>\n            x <span class=\"token operator\">=</span> x<span class=\"token punctuation\">.</span>prev<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>    \n</code></pre>\n<p>但他的插入和删除就很方便，插入和删除时，只需要断开链表，重新将新数据的头尾互相指向即可。</p>\n<pre class=\" language-java\"><code class=\"language-java\">   <span class=\"token comment\" spellcheck=\"true\">//插入数据</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> index<span class=\"token punctuation\">,</span> E element<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">==</span> size<span class=\"token punctuation\">)</span>\n            <span class=\"token function\">linkLast</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 插入时，有时也需要遍历，这里可以忽略</span>\n            <span class=\"token function\">linkBefore</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">,</span> <span class=\"token function\">node</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">linkLast</span><span class=\"token punctuation\">(</span>E e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">final</span> Node<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> l <span class=\"token operator\">=</span> last<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">final</span> Node<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> newNode <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>l<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        last <span class=\"token operator\">=</span> newNode<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span>\n            first <span class=\"token operator\">=</span> newNode<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span>\n            l<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> newNode<span class=\"token punctuation\">;</span>\n        size<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        modCount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">linkBefore</span><span class=\"token punctuation\">(</span>E e<span class=\"token punctuation\">,</span> Node<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> succ<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// assert succ != null;</span>\n        <span class=\"token keyword\">final</span> Node<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> pred <span class=\"token operator\">=</span> succ<span class=\"token punctuation\">.</span>prev<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">final</span> Node<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> newNode <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>pred<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">,</span> succ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        succ<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> newNode<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pred <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span>\n            first <span class=\"token operator\">=</span> newNode<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span>\n            pred<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> newNode<span class=\"token punctuation\">;</span>\n        size<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        modCount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// 移除数据</span>\n    <span class=\"token keyword\">private</span> E <span class=\"token function\">unlinkFirst</span><span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> f<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// assert f == first &amp;&amp; f != null;</span>\n        <span class=\"token keyword\">final</span> E element <span class=\"token operator\">=</span> f<span class=\"token punctuation\">.</span>item<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">final</span> Node<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> next <span class=\"token operator\">=</span> f<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        f<span class=\"token punctuation\">.</span>item <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n        f<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// help GC</span>\n        first <span class=\"token operator\">=</span> next<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>next <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span>\n            last <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span>\n            next<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n        size<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n        modCount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> element<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * Unlinks non-null last node l.\n     */</span>\n    <span class=\"token keyword\">private</span> E <span class=\"token function\">unlinkLast</span><span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> l<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// assert l == last &amp;&amp; l != null;</span>\n        <span class=\"token keyword\">final</span> E element <span class=\"token operator\">=</span> l<span class=\"token punctuation\">.</span>item<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">final</span> Node<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> prev <span class=\"token operator\">=</span> l<span class=\"token punctuation\">.</span>prev<span class=\"token punctuation\">;</span>\n        l<span class=\"token punctuation\">.</span>item <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n        l<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// help GC</span>\n        last <span class=\"token operator\">=</span> prev<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>prev <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span>\n            first <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span>\n            prev<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n        size<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n        modCount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> element<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h3><p>和 ArrayList 几乎一样，区别在于 Vector 是线程安全的，在插入、删除等操作，其方法都是 <code>synchronized</code>，因此性能比 <code>ArrayList</code> 差，每次扩容申请双倍空间也可以自定义。</p>\n<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><p>具有不可重复性，无序性，<em>不可查找的特点</em></p>\n<h3 id=\"HashSet\"><a href=\"#HashSet\" class=\"headerlink\" title=\"HashSet\"></a>HashSet</h3><p><code>HashSet</code> 的内部使用 <code>HashMap</code> 来存储数据，即 <code>add</code> 时，将元素当作 <code>HashMap</code> 的 <code>Key</code> 来使用，这也符合 <code>Set</code> 集合不可重复性的特点。</p>\n<p>此类集合不可以直接获取容器中的 value， 可通过遍历 <em>迭代器</em>  来获取全部元素。但不能多线程操作，此类容器都是可快速失败的，即当我们正在遍历时，如果原数据被修改，则会立即停止，并抛出 <code>ConCurrentException</code> 。</p>\n<h3 id=\"LinkedHashSet\"><a href=\"#LinkedHashSet\" class=\"headerlink\" title=\"LinkedHashSet\"></a>LinkedHashSet</h3><p>同样根据 hashCode 来决定元素的存储位置，同时又具有 链表的特点，在迭代遍历时，可以获取到列表顺序。</p>\n<p><strong>List 和 Set 的区别</strong></p>\n<ul>\n<li>是否允许数据元素重复存在，在 List 中允许插入重复的元素，Set 集合不允许</li>\n<li>元素的先后存放顺序 List 是一个有序的集合，会保留元素的插入顺序， Set 是无序集合</li>\n<li>List 可以通过下标来访问元素， 而 Set 不能</li>\n</ul>\n<h2 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h2><p><strong>数组</strong> 和 <strong>单链表</strong> 的组合， 数组用来存储 key，链表用来存储实际的 value</p>\n<h3 id=\"put-K-key-V-value\"><a href=\"#put-K-key-V-value\" class=\"headerlink\" title=\"put(K key, V value);\"></a>put(K key, V value);</h3><p>当存放一个数值时，会先对 key 值进行 hash 运算得到 Hash 值，</p>\n<p>当链表为空时，通过 <code>resize()</code> 函数帮我创建一个新链表，默认长度为 16 （1 &lt;&lt; 4，为 2 的次幂数，这里和扩容机制有关）；(由于 Hash Map 的长度机制限制，所以 table 的初始化工作，在 put 真正使用这个数据时才去创建，避免了性能上的损耗)</p>\n<p>当链表不为空，通过 hash 值，从数组中获取到对应的节点对象，如果对象为空，则创建一个新的节点；如果节点不为空，说明这个 key 被赋值过，因此将新的 value 赋值给该节点。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/**\n* 装箱过程，计算 hash 值的过程。\n* \n*/</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hash</span><span class=\"token punctuation\">(</span>Object key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> h<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token number\">0</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">=</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">^</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">>>></span> <span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">final</span> V <span class=\"token function\">putVal</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> hash<span class=\"token punctuation\">,</span> K key<span class=\"token punctuation\">,</span> V value<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> onlyIfAbsent<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> evict<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> tab<span class=\"token punctuation\">;</span>\n        Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span> p<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>tab <span class=\"token operator\">=</span> table<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">=</span> tab<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            n <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>tab <span class=\"token operator\">=</span> <span class=\"token function\">resize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n         <span class=\"token comment\" spellcheck=\"true\">// tab[i = (n - 1) &amp; hash] </span>\n        <span class=\"token comment\" spellcheck=\"true\">// n 是数组的长度，经过 &amp; 和 hash 值的位运算（模运算：求余数的运算，等价于=> （hash % n）），获得该元素在数组中的索引</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>p <span class=\"token operator\">=</span> tab<span class=\"token punctuation\">[</span>i <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> hash<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span>\n            tab<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">newNode</span><span class=\"token punctuation\">(</span>hash<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span> e<span class=\"token punctuation\">;</span>\n            K k<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span>hash <span class=\"token operator\">==</span> hash <span class=\"token operator\">&amp;&amp;</span>\n                    <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> key <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                e <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>p <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">TreeNode</span><span class=\"token punctuation\">)</span>\n                e <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">putTreeVal</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> tab<span class=\"token punctuation\">,</span> hash<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> binCount <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>binCount<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        p<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token function\">newNode</span><span class=\"token punctuation\">(</span>hash<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>binCount <span class=\"token operator\">>=</span> TREEIFY_THRESHOLD <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// -1 for 1st</span>\n                            <span class=\"token function\">treeifyBin</span><span class=\"token punctuation\">(</span>tab<span class=\"token punctuation\">,</span> hash<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>hash <span class=\"token operator\">==</span> hash <span class=\"token operator\">&amp;&amp;</span>\n                            <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> key <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                    p <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// existing mapping for key</span>\n                V oldValue <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>onlyIfAbsent <span class=\"token operator\">||</span> oldValue <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span>\n                    e<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n                <span class=\"token function\">afterNodeAccess</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span> oldValue<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token operator\">++</span>modCount<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">++</span>size <span class=\"token operator\">></span> threshold<span class=\"token punctuation\">)</span>\n            <span class=\"token function\">resize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">afterNodeInsertion</span><span class=\"token punctuation\">(</span>evict<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> null<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"Hash-碰撞-冲突\"><a href=\"#Hash-碰撞-冲突\" class=\"headerlink\" title=\"Hash 碰撞/冲突\"></a><strong>Hash 碰撞/冲突</strong></h3><p>在求模运算过程中，存在多对一的情况，即不同的 Hash 值，可能会计算出相同的索引值</p>\n<p><strong>解决方案</strong>：</p>\n<p><strong>链表法：</strong> 当发生 Hash 碰撞/冲突，即不同的 hash 值，最终计算出了相同的索引值，如果索引对应的位置数据为 null， 则直接创建新节点，如果不为 null， 则采用前插/后插的方案，插入到链表当中，当通过 <code>get()</code> 函数获取数据时，拿到一个链表，就遍历，找到 <code>hash</code> 值相同的那个节点，并返回。</p>\n<p><strong>避免冲突</strong>：</p>\n<p>阈值，为保证在尽可能长的情况下，保证 hash 不会冲突。即当发生时，就扩容。</p>\n<p><strong>扩容方案：</strong></p>\n<p>加载因子：<code>loadFactor</code> 默认值是 0.75</p>\n<p>阈值：与加载因子有关，通过加载因子和 HashMap 的长度计算而来，有阈值就一定会有浪费，因此 25% 的内存内浪费掉，在 Android  使用空间换时间。</p>\n<p>HashMap 的默认长度是 16，其长度，一定是 2 的次幂，目的是为了减少 Hash 的碰撞。</p>\n<blockquote>\n<p>比如：</p>\n<p>length1 = 10，(非 2 的次幂)，对应的二进制数是 1001</p>\n<p>length2 = 16(2 的 4 次幂)，对应的二进制数是 1111</p>\n<p>当产生一个 hash 值，为 6（0110）时， (n - 1) &amp; hash ，length1 位运算之后的结果是 0000， length2 位运算之后的结果是 0110</p>\n<p>当产生一个 hash 值，为 7（0111）时， (n - 1) &amp; hash ，length1 位运算之后的结果是 0001， length2 位运算之后的结果是 0111</p>\n<p>由此我们可以看出，影响运算结果的因素是 (1001) 中间的两位数字，而使用 (1111) 计算的结果，与四位数字都有关系（也就是说 数字 1 不会影响结果的计算），因此使用 2 的次幂为长度的目的就是为了减少 Hash 值的碰撞</p>\n</blockquote>\n<p>当链表长度，以及其他索引对应的链表总长度大于阈值时，开始扩容。</p>\n<p>当扩容发生时，HashMap 的长度就发生了变化，扩容前的数据的模运算就发生了改变，因此在扩容后，需要使用新的长度对所有的原有数据，进行 hash 计算，因此会发生性能上的损耗。因此在使用时，我们要尽量避免 HashMap 发生扩容。</p>\n<p>开发时，需要我们去尽量评估容量，当我们创建一个 HashMap，并传入一个非 2 的次幂值时，系统会帮我们寻找一个比当前值大的最近的 2 的次幂值，来给 HashMap 作为初始值。</p>\n<h2 id=\"SparseArray\"><a href=\"#SparseArray\" class=\"headerlink\" title=\"SparseArray\"></a>SparseArray</h2><p><strong>原理与特点</strong></p>\n<p>由 <strong>双数组</strong> 构成，两个数组分别存储 <code>Key</code> 和  <code>Value</code> ，并一一对应。</p>\n<p>查询速度快，删除快，插入慢（随着数据越来越大，插入的性能也会提升）</p>\n<p>通过获取 key 的索引找到其对应的 value 值，也就具备了 <strong>查询速度快</strong> 的特点（也是数组的特点）</p>\n<p>删除元素时，仅将元素标记位 <strong>“DELETE”</strong> 状态，不发生移位等操作，因此速度上会比 <code>ArrayList</code> 快</p>\n<p>因为是标记为 “DELETE” ，因此算法是可以达到复用，再利用二分查找，被标记为 “DELETE” 的数据，可以直接复用，不会涉及到数组的位移，因此会越用越快。</p>\n<p>缺点是，Key 只能是 <code>int</code> 类型数据。</p>\n<pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> key<span class=\"token punctuation\">,</span> E value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 二分查找，快速定位传入的 key 所在位置</span>\n        <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> ContainerHelpers<span class=\"token punctuation\">.</span><span class=\"token function\">binarySearch</span><span class=\"token punctuation\">(</span>mKeys<span class=\"token punctuation\">,</span> mSize<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 如果存在，直接替换同位置数据</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            mValues<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 不存在时，如果当前位置被标记为 DELETE 状态（未被使用），则直接给 key 和 value 数组赋值</span>\n            i <span class=\"token operator\">=</span> <span class=\"token operator\">~</span>i<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> mSize <span class=\"token operator\">&amp;&amp;</span> mValues<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> DELETED<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                mKeys<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> key<span class=\"token punctuation\">;</span>\n                mValues<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mGarbage <span class=\"token operator\">&amp;&amp;</span> mSize <span class=\"token operator\">>=</span> mKeys<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">gc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token comment\" spellcheck=\"true\">// Search again because indices may have changed.</span>\n                i <span class=\"token operator\">=</span> <span class=\"token operator\">~</span>ContainerHelpers<span class=\"token punctuation\">.</span><span class=\"token function\">binarySearch</span><span class=\"token punctuation\">(</span>mKeys<span class=\"token punctuation\">,</span> mSize<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 扩容机制，2倍</span>\n            mKeys <span class=\"token operator\">=</span> GrowingArrayUtils<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>mKeys<span class=\"token punctuation\">,</span> mSize<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            mValues <span class=\"token operator\">=</span> GrowingArrayUtils<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>mValues<span class=\"token punctuation\">,</span> mSize<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            mSize<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> currentSize<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> index<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> element<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> newArray <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span><span class=\"token function\">growSize</span><span class=\"token punctuation\">(</span>currentSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span><span class=\"token function\">arraycopy</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> newArray<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        newArray<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> element<span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span><span class=\"token function\">arraycopy</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">,</span> newArray<span class=\"token punctuation\">,</span> index <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> array<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> newArray<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n     <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">growSize</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> currentSize<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 2 倍扩容机制</span>\n        <span class=\"token keyword\">return</span> currentSize <span class=\"token operator\">&lt;=</span> <span class=\"token number\">4</span> <span class=\"token operator\">?</span> <span class=\"token number\">8</span> <span class=\"token operator\">:</span> currentSize <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 移除数据，仅标记 DELETE 状态</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">delete</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> ContainerHelpers<span class=\"token punctuation\">.</span><span class=\"token function\">binarySearch</span><span class=\"token punctuation\">(</span>mKeys<span class=\"token punctuation\">,</span> mSize<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mValues<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> DELETED<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                mValues<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> DELETED<span class=\"token punctuation\">;</span>\n                mGarbage <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p><strong>扩容机制：</strong></p>\n<p>同样的，初始长度为 10， 每次扩容，为当前容量的 2 倍。</p>\n<h2 id=\"ArrayMap\"><a href=\"#ArrayMap\" class=\"headerlink\" title=\"ArrayMap\"></a>ArrayMap</h2><p>是Hash Map 和 Sparse Array 的合计，具备他们的双重特性，使用 <code>hashcode</code> 作为 key，弥补了 <code>SparseArray</code> 只能是 <code>int</code> 型。使用双数组的形式，又弥补了 <code>HashMap</code> 的对内存消耗的问题。</p>\n<h2 id=\"LinkedHashMap\"><a href=\"#LinkedHashMap\" class=\"headerlink\" title=\"LinkedHashMap\"></a>LinkedHashMap</h2><p>是 <code>HashMap</code> 的子类， <code>put</code>  和 <code>remove</code> 函数使用的就是 <code>HashMap</code> 的，没有太大却别，主要区别在于 <code>get</code> 函数， <code>LinkedHashMap</code> 在每次 <code>get</code> 出一个数据后，会将这个数据放在链表的尾部。</p>\n<p><code>LinkedHashMap</code> 的应用，在 <code>LRUCache</code> 和 <code>DiskLRUCache</code> 中使用，其算法名称 <em>最少/最小使用算法</em> ，也就是说，利用了 <code>LinkedHashMap</code> 的 <code>get</code> 函数的特性，计算出链表头部的数据被使用的次数最少，当容器长度达到最大值时，就将链表头部的数据移除。</p>\n<h2 id=\"队列-Queue-和-栈-Stack\"><a href=\"#队列-Queue-和-栈-Stack\" class=\"headerlink\" title=\"队列 Queue 和 栈 Stack\"></a>队列 Queue 和 栈 Stack</h2><ul>\n<li>队列的特点是 <em>先入先出</em></li>\n<li>栈的特点是 <em>先入后出</em> </li>\n</ul>\n<h3 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h3><p><strong>特点：</strong> 后进先出； 所有的操作都是围绕栈顶部来完成</p>\n<p>算法的基本思想：</p>\n<p>可以用一个单链表来实现</p>\n<p>只关心上一次的操作</p>\n<p>处理完上一次操作后，能在 O(1) 时间内查找到更前一次的操作</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// 查找下一个比自己大的数的距离</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">stackSwap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 定义一个栈，用来缓存当前的最大值的索引</span>\n    Stack<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> stack <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Stack</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 定义一个数组，用来存储对应数据的间距</span>\n    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> interval <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span>nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n           <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>stack<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 因为会对栈进行操作，长度会改变，如果不先取，会导致循环跳位</span>\n            <span class=\"token keyword\">int</span> size <span class=\"token operator\">=</span> stack<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j  <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> size<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 拿出栈顶数据的索引</span>\n                <span class=\"token keyword\">int</span> topIndex <span class=\"token operator\">=</span> stack<span class=\"token punctuation\">.</span><span class=\"token function\">peek</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> num<span class=\"token punctuation\">[</span>topIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    interval<span class=\"token punctuation\">[</span>topIndex<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i <span class=\"token operator\">-</span> topIndex<span class=\"token punctuation\">;</span>\n                    stack<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 如果为空，或者栈顶数据比但前数据大，则将数据直接压入</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 或找不到一个比当前数据大的数据时，将当前数据压入栈</span>\n        stack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h3><p>和栈不同，队列的最大特点是先进先出（FIFO），就好像按顺序排队一样。对于队列的数据来说，我们只允许在队尾查看和添加数据，在队头查看和删除数据。</p>\n<p>实现：可以借助双链表来实现队列。双链表的头指针允许在队头查看和删除数据，而双链表的尾指针允许我们在队尾查看和添加数据。</p>\n<p>应用场景：直观来看，当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题。在算法面试题当中，广度优先搜索（Breadth-First Search）是运用队列最多的地方。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>是一片物理上连续的大小确定的存储空间</p>\n<p>数组查询速度快，是因为其在内存上是一段连续的内存空间，因此会有一个内存地址指向，每创建一个对象（Object），也就是要存储的值，占 4 个字节，通过 index * 4，在加上初始地址，计算的来的值，可以快速的定位到目标值，获取相应数据。</p>\n<p>利用索引进行查询速度快，无法真正的删除<br>","more":"</p>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><p>具有连续有序性，可重复性，可扩容性，访问比较便捷</p>\n<h3 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h3><p><strong>原理与特点</strong></p>\n<p>实际上是对数组的一种封装，具备数组存储上空间连续及查找速度快的特性，并且顺序上也连续；但因为顺序上的连续，就造成了其删除和插入数据较慢的特性，因为顺序上的连续，所以在插入和删除时，为保证连续性，需要对数组的内容进行移动，大大增加了数据的操作性。</p>\n<pre><code class=\"java\">    public void add(int index, E element) {\n        if (index &gt; size || index &lt; 0)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        // 移位操作\n        System.arraycopy(elementData, index, elementData, index + 1,\n                         size - index);\n        elementData[index] = element;\n        size++;\n    }\n     public E remove(int index) {\n        if (index &gt;= size)\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n\n        modCount++;\n        E oldValue = (E) elementData[index];\n\n        int numMoved = size - index - 1;\n        if (numMoved &gt; 0)\n            // 移位操作\n            System.arraycopy(elementData, index+1, elementData, index,\n                             numMoved);\n        elementData[--size] = null; // clear to let GC do its work\n\n        return oldValue;\n    }\n</code></pre>\n<p><strong>扩容机制：</strong></p>\n<p><code>ArrayList</code> 的默认长度是 10， 当数据总量超过容器时，会进行一次扩容操作，且每次扩容 50%。</p>\n<pre><code class=\"java\">private void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    // oldCapacity &gt;&gt; 1 等价于  oldCapacity / 2\n    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);\n    if (newCapacity - minCapacity &lt; 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)\n        newCapacity = hugeCapacity(minCapacity);\n    // minCapacity is usually close to size, so this is a win:\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n</code></pre>\n<h3 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h3><p>是系统为我们提供的在物理上不连续，逻辑上连续的一个假象的数据片段。其内部实现是通过链表的方式，没一个元素都被封装成一个双向 <code>node</code> 节点，并绑定前一个和下一个节点的方式，来保证物理上连续。</p>\n<p>因采用链表的结构，因此也灭有长度限制，也不存在扩容机制，可以无限长。</p>\n<p>因此，他不向数组的可以快速定位数据，当获取数据时，需要根据节点位置，遍历才能获得，因此其查询速度很慢</p>\n<pre><code class=\"java\">public E get(int index) {\n    checkElementIndex(index);\n    return node(index).item;\n}\nNode&lt;E&gt; node(int index) {\n    // 从前面查找\n    if (index &lt; (size &gt;&gt; 1)) {\n        Node&lt;E&gt; x = first;\n        for (int i = 0; i &lt; index; i++)\n            x = x.next;\n        return x;\n    } else {\n        // 从后面查找\n        Node&lt;E&gt; x = last;\n        for (int i = size - 1; i &gt; index; i--)\n            x = x.prev;\n        return x;\n    }\n}    \n</code></pre>\n<p>但他的插入和删除就很方便，插入和删除时，只需要断开链表，重新将新数据的头尾互相指向即可。</p>\n<pre><code class=\"java\">   //插入数据\n    public void add(int index, E element) {\n        if (index == size)\n            linkLast(element);\n        else\n            // 插入时，有时也需要遍历，这里可以忽略\n            linkBefore(element, node(index));\n    }\n\n    void linkLast(E e) {\n        final Node&lt;E&gt; l = last;\n        final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);\n        last = newNode;\n        if (l == null)\n            first = newNode;\n        else\n            l.next = newNode;\n        size++;\n        modCount++;\n    }\n    void linkBefore(E e, Node&lt;E&gt; succ) {\n        // assert succ != null;\n        final Node&lt;E&gt; pred = succ.prev;\n        final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);\n        succ.prev = newNode;\n        if (pred == null)\n            first = newNode;\n        else\n            pred.next = newNode;\n        size++;\n        modCount++;\n    }\n// 移除数据\n    private E unlinkFirst(Node&lt;E&gt; f) {\n        // assert f == first &amp;&amp; f != null;\n        final E element = f.item;\n        final Node&lt;E&gt; next = f.next;\n        f.item = null;\n        f.next = null; // help GC\n        first = next;\n        if (next == null)\n            last = null;\n        else\n            next.prev = null;\n        size--;\n        modCount++;\n        return element;\n    }\n\n    /**\n     * Unlinks non-null last node l.\n     */\n    private E unlinkLast(Node&lt;E&gt; l) {\n        // assert l == last &amp;&amp; l != null;\n        final E element = l.item;\n        final Node&lt;E&gt; prev = l.prev;\n        l.item = null;\n        l.prev = null; // help GC\n        last = prev;\n        if (prev == null)\n            first = null;\n        else\n            prev.next = null;\n        size--;\n        modCount++;\n        return element;\n    }\n</code></pre>\n<h3 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h3><p>和 ArrayList 几乎一样，区别在于 Vector 是线程安全的，在插入、删除等操作，其方法都是 <code>synchronized</code>，因此性能比 <code>ArrayList</code> 差，每次扩容申请双倍空间也可以自定义。</p>\n<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><p>具有不可重复性，无序性，<em>不可查找的特点</em></p>\n<h3 id=\"HashSet\"><a href=\"#HashSet\" class=\"headerlink\" title=\"HashSet\"></a>HashSet</h3><p><code>HashSet</code> 的内部使用 <code>HashMap</code> 来存储数据，即 <code>add</code> 时，将元素当作 <code>HashMap</code> 的 <code>Key</code> 来使用，这也符合 <code>Set</code> 集合不可重复性的特点。</p>\n<p>此类集合不可以直接获取容器中的 value， 可通过遍历 <em>迭代器</em>  来获取全部元素。但不能多线程操作，此类容器都是可快速失败的，即当我们正在遍历时，如果原数据被修改，则会立即停止，并抛出 <code>ConCurrentException</code> 。</p>\n<h3 id=\"LinkedHashSet\"><a href=\"#LinkedHashSet\" class=\"headerlink\" title=\"LinkedHashSet\"></a>LinkedHashSet</h3><p>同样根据 hashCode 来决定元素的存储位置，同时又具有 链表的特点，在迭代遍历时，可以获取到列表顺序。</p>\n<p><strong>List 和 Set 的区别</strong></p>\n<ul>\n<li>是否允许数据元素重复存在，在 List 中允许插入重复的元素，Set 集合不允许</li>\n<li>元素的先后存放顺序 List 是一个有序的集合，会保留元素的插入顺序， Set 是无序集合</li>\n<li>List 可以通过下标来访问元素， 而 Set 不能</li>\n</ul>\n<h2 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h2><p><strong>数组</strong> 和 <strong>单链表</strong> 的组合， 数组用来存储 key，链表用来存储实际的 value</p>\n<h3 id=\"put-K-key-V-value\"><a href=\"#put-K-key-V-value\" class=\"headerlink\" title=\"put(K key, V value);\"></a>put(K key, V value);</h3><p>当存放一个数值时，会先对 key 值进行 hash 运算得到 Hash 值，</p>\n<p>当链表为空时，通过 <code>resize()</code> 函数帮我创建一个新链表，默认长度为 16 （1 &lt;&lt; 4，为 2 的次幂数，这里和扩容机制有关）；(由于 Hash Map 的长度机制限制，所以 table 的初始化工作，在 put 真正使用这个数据时才去创建，避免了性能上的损耗)</p>\n<p>当链表不为空，通过 hash 值，从数组中获取到对应的节点对象，如果对象为空，则创建一个新的节点；如果节点不为空，说明这个 key 被赋值过，因此将新的 value 赋值给该节点。</p>\n<pre><code class=\"java\">/**\n* 装箱过程，计算 hash 值的过程。\n* \n*/\nstatic final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n}\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {\n        Node&lt;K, V&gt;[] tab;\n        Node&lt;K, V&gt; p;\n        int n, i;\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n         // tab[i = (n - 1) &amp; hash] \n        // n 是数组的长度，经过 &amp; 和 hash 值的位运算（模运算：求余数的运算，等价于=&gt; （hash % n）），获得该元素在数组中的索引\n        if ((p = tab[i = (n - 1) &amp; hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            Node&lt;K, V&gt; e;\n            K k;\n            if (p.hash == hash &amp;&amp;\n                    ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))\n                e = p;\n            else if (p instanceof TreeNode)\n                e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(this, tab, hash, key, value);\n            else {\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        p.next = newNode(hash, key, value, null);\n                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    if (e.hash == hash &amp;&amp;\n                            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        if (++size &gt; threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n</code></pre>\n<h3 id=\"Hash-碰撞-冲突\"><a href=\"#Hash-碰撞-冲突\" class=\"headerlink\" title=\"Hash 碰撞/冲突\"></a><strong>Hash 碰撞/冲突</strong></h3><p>在求模运算过程中，存在多对一的情况，即不同的 Hash 值，可能会计算出相同的索引值</p>\n<p><strong>解决方案</strong>：</p>\n<p><strong>链表法：</strong> 当发生 Hash 碰撞/冲突，即不同的 hash 值，最终计算出了相同的索引值，如果索引对应的位置数据为 null， 则直接创建新节点，如果不为 null， 则采用前插/后插的方案，插入到链表当中，当通过 <code>get()</code> 函数获取数据时，拿到一个链表，就遍历，找到 <code>hash</code> 值相同的那个节点，并返回。</p>\n<p><strong>避免冲突</strong>：</p>\n<p>阈值，为保证在尽可能长的情况下，保证 hash 不会冲突。即当发生时，就扩容。</p>\n<p><strong>扩容方案：</strong></p>\n<p>加载因子：<code>loadFactor</code> 默认值是 0.75</p>\n<p>阈值：与加载因子有关，通过加载因子和 HashMap 的长度计算而来，有阈值就一定会有浪费，因此 25% 的内存内浪费掉，在 Android  使用空间换时间。</p>\n<p>HashMap 的默认长度是 16，其长度，一定是 2 的次幂，目的是为了减少 Hash 的碰撞。</p>\n<blockquote>\n<p>比如：</p>\n<p>length1 = 10，(非 2 的次幂)，对应的二进制数是 1001</p>\n<p>length2 = 16(2 的 4 次幂)，对应的二进制数是 1111</p>\n<p>当产生一个 hash 值，为 6（0110）时， (n - 1) &amp; hash ，length1 位运算之后的结果是 0000， length2 位运算之后的结果是 0110</p>\n<p>当产生一个 hash 值，为 7（0111）时， (n - 1) &amp; hash ，length1 位运算之后的结果是 0001， length2 位运算之后的结果是 0111</p>\n<p>由此我们可以看出，影响运算结果的因素是 (1001) 中间的两位数字，而使用 (1111) 计算的结果，与四位数字都有关系（也就是说 数字 1 不会影响结果的计算），因此使用 2 的次幂为长度的目的就是为了减少 Hash 值的碰撞</p>\n</blockquote>\n<p>当链表长度，以及其他索引对应的链表总长度大于阈值时，开始扩容。</p>\n<p>当扩容发生时，HashMap 的长度就发生了变化，扩容前的数据的模运算就发生了改变，因此在扩容后，需要使用新的长度对所有的原有数据，进行 hash 计算，因此会发生性能上的损耗。因此在使用时，我们要尽量避免 HashMap 发生扩容。</p>\n<p>开发时，需要我们去尽量评估容量，当我们创建一个 HashMap，并传入一个非 2 的次幂值时，系统会帮我们寻找一个比当前值大的最近的 2 的次幂值，来给 HashMap 作为初始值。</p>\n<h2 id=\"SparseArray\"><a href=\"#SparseArray\" class=\"headerlink\" title=\"SparseArray\"></a>SparseArray</h2><p><strong>原理与特点</strong></p>\n<p>由 <strong>双数组</strong> 构成，两个数组分别存储 <code>Key</code> 和  <code>Value</code> ，并一一对应。</p>\n<p>查询速度快，删除快，插入慢（随着数据越来越大，插入的性能也会提升）</p>\n<p>通过获取 key 的索引找到其对应的 value 值，也就具备了 <strong>查询速度快</strong> 的特点（也是数组的特点）</p>\n<p>删除元素时，仅将元素标记位 <strong>“DELETE”</strong> 状态，不发生移位等操作，因此速度上会比 <code>ArrayList</code> 快</p>\n<p>因为是标记为 “DELETE” ，因此算法是可以达到复用，再利用二分查找，被标记为 “DELETE” 的数据，可以直接复用，不会涉及到数组的位移，因此会越用越快。</p>\n<p>缺点是，Key 只能是 <code>int</code> 类型数据。</p>\n<pre><code class=\"java\">    public void put(int key, E value) {\n        // 二分查找，快速定位传入的 key 所在位置\n        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);\n        // 如果存在，直接替换同位置数据\n        if (i &gt;= 0) {\n            mValues[i] = value;\n        } else {\n            // 不存在时，如果当前位置被标记为 DELETE 状态（未被使用），则直接给 key 和 value 数组赋值\n            i = ~i;\n            if (i &lt; mSize &amp;&amp; mValues[i] == DELETED) {\n                mKeys[i] = key;\n                mValues[i] = value;\n                return;\n            }\n            if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) {\n                gc();\n                // Search again because indices may have changed.\n                i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);\n            }\n            // 扩容机制，2倍\n            mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);\n            mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);\n            mSize++;\n        }\n    }\n    public static int[] insert(int[] array, int currentSize, int index, int element) {\n       int[] newArray = new int[growSize(currentSize)];\n        System.arraycopy(array, 0, newArray, 0, index);\n        newArray[index] = element;\n        System.arraycopy(array, index, newArray, index + 1, array.length - index);\n        return newArray;\n    }\n     public static int growSize(int currentSize) {\n        // 2 倍扩容机制\n        return currentSize &lt;= 4 ? 8 : currentSize * 2;\n    }\n\n    // 移除数据，仅标记 DELETE 状态\n    public void delete(int key) {\n        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);\n\n        if (i &gt;= 0) {\n            if (mValues[i] != DELETED) {\n                mValues[i] = DELETED;\n                mGarbage = true;\n            }\n        }\n    }\n\n</code></pre>\n<p><strong>扩容机制：</strong></p>\n<p>同样的，初始长度为 10， 每次扩容，为当前容量的 2 倍。</p>\n<h2 id=\"ArrayMap\"><a href=\"#ArrayMap\" class=\"headerlink\" title=\"ArrayMap\"></a>ArrayMap</h2><p>是Hash Map 和 Sparse Array 的合计，具备他们的双重特性，使用 <code>hashcode</code> 作为 key，弥补了 <code>SparseArray</code> 只能是 <code>int</code> 型。使用双数组的形式，又弥补了 <code>HashMap</code> 的对内存消耗的问题。</p>\n<h2 id=\"LinkedHashMap\"><a href=\"#LinkedHashMap\" class=\"headerlink\" title=\"LinkedHashMap\"></a>LinkedHashMap</h2><p>是 <code>HashMap</code> 的子类， <code>put</code>  和 <code>remove</code> 函数使用的就是 <code>HashMap</code> 的，没有太大却别，主要区别在于 <code>get</code> 函数， <code>LinkedHashMap</code> 在每次 <code>get</code> 出一个数据后，会将这个数据放在链表的尾部。</p>\n<p><code>LinkedHashMap</code> 的应用，在 <code>LRUCache</code> 和 <code>DiskLRUCache</code> 中使用，其算法名称 <em>最少/最小使用算法</em> ，也就是说，利用了 <code>LinkedHashMap</code> 的 <code>get</code> 函数的特性，计算出链表头部的数据被使用的次数最少，当容器长度达到最大值时，就将链表头部的数据移除。</p>\n<h2 id=\"队列-Queue-和-栈-Stack\"><a href=\"#队列-Queue-和-栈-Stack\" class=\"headerlink\" title=\"队列 Queue 和 栈 Stack\"></a>队列 Queue 和 栈 Stack</h2><ul>\n<li>队列的特点是 <em>先入先出</em></li>\n<li>栈的特点是 <em>先入后出</em> </li>\n</ul>\n<h3 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h3><p><strong>特点：</strong> 后进先出； 所有的操作都是围绕栈顶部来完成</p>\n<p>算法的基本思想：</p>\n<p>可以用一个单链表来实现</p>\n<p>只关心上一次的操作</p>\n<p>处理完上一次操作后，能在 O(1) 时间内查找到更前一次的操作</p>\n<pre><code class=\"java\">// 查找下一个比自己大的数的距离\npublic void stackSwap(int[] nums) {\n\n    // 定义一个栈，用来缓存当前的最大值的索引\n    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();\n    // 定义一个数组，用来存储对应数据的间距\n    int[] interval = new int[nums.length];\n\n    for(int i = 0; i &lt; nums.length; i++) {\n           if(!stack.empty()){\n            // 因为会对栈进行操作，长度会改变，如果不先取，会导致循环跳位\n            int size = stack.size();\n            for(int j  = 0; j &lt; size; j++) {\n                // 拿出栈顶数据的索引\n                int topIndex = stack.peek();\n                if(nums[i] &gt; num[topIndex]) {\n                    interval[topIndex] = i - topIndex;\n                    stack.pop();\n                }\n            }\n        }\n        // 如果为空，或者栈顶数据比但前数据大，则将数据直接压入\n        // 或找不到一个比当前数据大的数据时，将当前数据压入栈\n        stack.push(i);\n    }\n\n}\n</code></pre>\n<h3 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h3><p>和栈不同，队列的最大特点是先进先出（FIFO），就好像按顺序排队一样。对于队列的数据来说，我们只允许在队尾查看和添加数据，在队头查看和删除数据。</p>\n<p>实现：可以借助双链表来实现队列。双链表的头指针允许在队头查看和删除数据，而双链表的尾指针允许我们在队尾查看和添加数据。</p>\n<p>应用场景：直观来看，当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题。在算法面试题当中，广度优先搜索（Breadth-First Search）是运用队列最多的地方。</p>"},{"title":"算法","_content":"\n## 高频数据结构和算法\n\n\n\n## 数据结构\n\n* 数组/字符串\n* 链表\n* 栈\n* 队列\n* 双端队列\n* 树\n<!-- more-->\n### 数组\n\n优点： 可以在 O（1） 的时间里根据下标查询某个元素\n\n缺点：\n\n* 构建时必须时一段连续的空间\n* 查询某个元素是否存在时，需要遍历整个数组，耗费O(n) 的时间\n* 删除和添加某个元素时，同样需要耗费O(n) 的时间\n\n### 链表\n\n**单链表：** 链表中的每个元素实际上时一个单独的对象，而所有对象都通过每个元素中的引用字段链接在一起\n\n**双链表：** 与单链表不同的时，双链表的每个节点中都含有**两个引用字段**\n\n\n\n**优点：** \n\n* 灵活的内存空间\n* 能在 O(1) 时间内删除或添加元素\n\n**缺点：**\n\n* 查询元素需要O(n)时间\n\n**解题技巧：**\n\n1. 利用快慢指针（有时需要3个）\n2. 构建一个虚假的链表头\n\n**练习：**\n\neg: k 个一组反转链表 1->2->3->4->5->null\n\n```java\n// 假设 k = 3\nprev = null;\ncurr = head;\nn = k;\nwhile(curr && n-- > 0) {\n    next = curr.next;\n    curr.next = prev;\n    prev = curr;\n    curr = next;\n}\n```\n\n\n\n### 栈\n\n**特点：** 后进先出； 所有的操作都是围绕栈顶部来完成\n\n算法的基本思想：\n\n可以用一个单链表来实现\n\n只关心上一次的操作\n\n处理完上一次操作后，能在 O(1) 时间内查找到更前一次的操作\n\n```java\n// 查找下一个比自己大的数的距离\npublic void stackSwap(int[] nums) {\n    \n    // 定义一个栈，用来缓存当前的最大值的索引\n    Stack<Integer> stack = new Stack<>();\n    // 定义一个数组，用来存储对应数据的间距\n    int[] interval = new int[nums.length];\n    \n    for(int i = 0; i < nums.length; i++) {\n       \tif(!stack.empty()){\n            // 因为会对栈进行操作，长度会改变，如果不先取，会导致循环跳位\n            int size = stack.size();\n            for(int j  = 0; j < size; j++) {\n                // 拿出栈顶数据的索引\n                int topIndex = stack.peek();\n                if(nums[i] > num[topIndex]) {\n                    interval[topIndex] = i - topIndex;\n                    stack.pop();\n                }\n            }\n        }\n        // 如果为空，或者栈顶数据比但前数据大，则将数据直接压入\n        // 或找不到一个比当前数据大的数据时，将当前数据压入栈\n        stack.push(i);\n    }\n    \n}\n```\n\n### 队列\n\n和栈不同，队列的最大特点是先进先出（FIFO），就好像按顺序排队一样。对于队列的数据来说，我们只允许在队尾查看和添加数据，在队头查看和删除数据。\n\n实现：可以借助双链表来实现队列。双链表的头指针允许在队头查看和删除数据，而双链表的尾指针允许我们在队尾查看和添加数据。\n\n应用场景：直观来看，当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题。在算法面试题当中，广度优先搜索（Breadth-First Search）是运用队列最多的地方。\n\n\n\n### 双端队列\n\n可以利用双链表实现\n\n队列\n\n## 排序算法\n\n### 冒泡\n\n数据像鱼吐泡泡一样，从底部向上浮出\n\n```java\npublic void maopao(int[] num) {\n    for(int i = 0; i < num; i++) {\n        for(int j = 0; j < num.length - 1 - i; j++) {\n        \tif(num[j] > num[j+1]) {\n                swap(num, j, j + 1);\n            }\n        }\n    }\n}\n\npublic void swap(int[] num, int src, int des) {\n    int temp = num[src];\n    num[src] = num[des];\n    num[des] = temp;\n    System.out.println(Arrays.toString(num));\n}\n```\n\n### 插入\n\n向已排列好的数组中插入数据\n\n```java\npublic void charu(int[] num) {\n    for(int i = 1; i < num.length; i++) {\n        int k = i; // 记录当前最小值的索引\n        for(int j = (i -1); j >= 0; j--) {\n            if(num[k] < num[j]) {\n                swap(num, k, j);\n                k = j;\n            }\n        }\n    }\n}\n```\n\n### 选择\n\n先遍历找到集合中的最小值索引，并将其与已排好序的数组最大值进行比较\n\n```java\npublic void xuanze(int[] num) {\n    for (int i = 0; i < num.length; i++) {\n        int minIndex = i; // 已排序数组的最大值\n        for(int j = i + 1; j < num.length; j++) {\n            if(num[minIndex] > num[j]) {\n                minIndex = j; // 找到未排序部分的最小值索引\n            }\n        }\n        // 与已排序部分最大值比较，小则交换\n        if(num[minIndex] < num[i]){\n            swap(num, minIndex, i)\n        }\n    }\n}\n```\n\n### 归并\n\n利用递归方案/循环方案，将一个大的问题，拆分成等价的无限小的事情，最后将最小等价事情的结果合并为最终结果\n\n利用二叉树，左右两边同时排序，最后将两部分合并再一起\n\n递归的算法需要注意临界值判断（往往出现再第一行，否则代码将进入死循环，无法退出， StackOverflow）\n\n```java\npublic void guibing(int[] num, int left, int right) {\n    if (left >= right) return; // 临界点判断，终止递归\n    int mid = (right + left) >> 1; // 取中间值\n    guibing(nums, left, mid);\n    guibing(nums, mid + 1, right);\n    merge(nums, left, right, mid);\n}\n\npublic void merge(int[] nums, int start, int length, int mid) {\n    int[] copy = nums.clone();\n    // index 是合并时需要的索引值， left, right 是二叉树的左右俩个边界\n    int index = start, left = start, right = mid + 1;\n    while(index <= length) {\n\t    if (left > mid) {\n            // 表明左侧二叉树已经遍历完成，剩下的右侧数据可直接填充\n            nums[index++] = copy[right++];\n        } else if(right > length){\n            // 表明右侧二叉树已经遍历完成，剩下的左侧部分可直接填充\n            nums[index++] = copy[left++];\n        } else if(copy[right] < copy[left]){\n            // 右侧数据比左侧数据小，将右侧数据填充\n            nums[index++] = copy[right++];\n        } else {\n            // 左侧数据比右侧数据小，将左侧数据填充\n            nums[index++] = copy[left++];\n        }\n    }\n    System.out.println(Arrays.toString(nums));\n}\n```\n\n\n\n### 快排\n\n同样利用递归的思想。\n\n先随机选择一个数，然后让比它小的放在左边，大的放在右边\n\n然后左右两边同时再随机选择一个数，还是小的放左边，大的放右边\n\n```java\npublic void kuaisu(int[] num, int low, int high) {\n    if(low > high) return;\n    int p = partition(nums, low, high);\n    kuaisu(nums, low, p - 1);\n    kuaisu(nums, p + 1, high);\n}\n    // 先随机一个索引，然后将他放在最后面。\n    // 在定义两个指针\n    // i: 用来记录比随机值小的数的个数，也就是最终随机值要倍还原的位置\n    // j: 当前第一个值\npublic void partition(int[] num, int low, int high) {\n    // 先将最小值， copy 到最后一个位置\n    int random = randRang(low, high);\n   \tswap(num, random, high);\n    // i 用来记录比中间值小的数的个数，也就是最终要将 copy 到最后一个位置的随机数要还原回来的位置\n    int i, j;\n    // 从左到右用每个数和基准值进行比较，比基准值小，则放到指针 i 的位置，i++, 循环结束后， i 指针之前的数，都比基准值小\n    for(i = low, j = low, j < high, j++) {\n        if(num[j] < num[high]) {\n            // num[j] 当前值\n            // num[high] 随机数，基准值\n            swap(num, i++, j);\n        }\n    }\n    // 将基准值还原到对应位置\n    swap(num, i, j);\n    return i;\n}\nprivate int randRang(int low, int high) {\n    return new Random().nextInt(high) % (high - low + 1) + low;\n}\n```\n\n\n\n","source":"_posts/数据结构/算法.md","raw":"---\ntitle: 算法\ntag: 数据结构和算法\n---\n\n## 高频数据结构和算法\n\n\n\n## 数据结构\n\n* 数组/字符串\n* 链表\n* 栈\n* 队列\n* 双端队列\n* 树\n<!-- more-->\n### 数组\n\n优点： 可以在 O（1） 的时间里根据下标查询某个元素\n\n缺点：\n\n* 构建时必须时一段连续的空间\n* 查询某个元素是否存在时，需要遍历整个数组，耗费O(n) 的时间\n* 删除和添加某个元素时，同样需要耗费O(n) 的时间\n\n### 链表\n\n**单链表：** 链表中的每个元素实际上时一个单独的对象，而所有对象都通过每个元素中的引用字段链接在一起\n\n**双链表：** 与单链表不同的时，双链表的每个节点中都含有**两个引用字段**\n\n\n\n**优点：** \n\n* 灵活的内存空间\n* 能在 O(1) 时间内删除或添加元素\n\n**缺点：**\n\n* 查询元素需要O(n)时间\n\n**解题技巧：**\n\n1. 利用快慢指针（有时需要3个）\n2. 构建一个虚假的链表头\n\n**练习：**\n\neg: k 个一组反转链表 1->2->3->4->5->null\n\n```java\n// 假设 k = 3\nprev = null;\ncurr = head;\nn = k;\nwhile(curr && n-- > 0) {\n    next = curr.next;\n    curr.next = prev;\n    prev = curr;\n    curr = next;\n}\n```\n\n\n\n### 栈\n\n**特点：** 后进先出； 所有的操作都是围绕栈顶部来完成\n\n算法的基本思想：\n\n可以用一个单链表来实现\n\n只关心上一次的操作\n\n处理完上一次操作后，能在 O(1) 时间内查找到更前一次的操作\n\n```java\n// 查找下一个比自己大的数的距离\npublic void stackSwap(int[] nums) {\n    \n    // 定义一个栈，用来缓存当前的最大值的索引\n    Stack<Integer> stack = new Stack<>();\n    // 定义一个数组，用来存储对应数据的间距\n    int[] interval = new int[nums.length];\n    \n    for(int i = 0; i < nums.length; i++) {\n       \tif(!stack.empty()){\n            // 因为会对栈进行操作，长度会改变，如果不先取，会导致循环跳位\n            int size = stack.size();\n            for(int j  = 0; j < size; j++) {\n                // 拿出栈顶数据的索引\n                int topIndex = stack.peek();\n                if(nums[i] > num[topIndex]) {\n                    interval[topIndex] = i - topIndex;\n                    stack.pop();\n                }\n            }\n        }\n        // 如果为空，或者栈顶数据比但前数据大，则将数据直接压入\n        // 或找不到一个比当前数据大的数据时，将当前数据压入栈\n        stack.push(i);\n    }\n    \n}\n```\n\n### 队列\n\n和栈不同，队列的最大特点是先进先出（FIFO），就好像按顺序排队一样。对于队列的数据来说，我们只允许在队尾查看和添加数据，在队头查看和删除数据。\n\n实现：可以借助双链表来实现队列。双链表的头指针允许在队头查看和删除数据，而双链表的尾指针允许我们在队尾查看和添加数据。\n\n应用场景：直观来看，当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题。在算法面试题当中，广度优先搜索（Breadth-First Search）是运用队列最多的地方。\n\n\n\n### 双端队列\n\n可以利用双链表实现\n\n队列\n\n## 排序算法\n\n### 冒泡\n\n数据像鱼吐泡泡一样，从底部向上浮出\n\n```java\npublic void maopao(int[] num) {\n    for(int i = 0; i < num; i++) {\n        for(int j = 0; j < num.length - 1 - i; j++) {\n        \tif(num[j] > num[j+1]) {\n                swap(num, j, j + 1);\n            }\n        }\n    }\n}\n\npublic void swap(int[] num, int src, int des) {\n    int temp = num[src];\n    num[src] = num[des];\n    num[des] = temp;\n    System.out.println(Arrays.toString(num));\n}\n```\n\n### 插入\n\n向已排列好的数组中插入数据\n\n```java\npublic void charu(int[] num) {\n    for(int i = 1; i < num.length; i++) {\n        int k = i; // 记录当前最小值的索引\n        for(int j = (i -1); j >= 0; j--) {\n            if(num[k] < num[j]) {\n                swap(num, k, j);\n                k = j;\n            }\n        }\n    }\n}\n```\n\n### 选择\n\n先遍历找到集合中的最小值索引，并将其与已排好序的数组最大值进行比较\n\n```java\npublic void xuanze(int[] num) {\n    for (int i = 0; i < num.length; i++) {\n        int minIndex = i; // 已排序数组的最大值\n        for(int j = i + 1; j < num.length; j++) {\n            if(num[minIndex] > num[j]) {\n                minIndex = j; // 找到未排序部分的最小值索引\n            }\n        }\n        // 与已排序部分最大值比较，小则交换\n        if(num[minIndex] < num[i]){\n            swap(num, minIndex, i)\n        }\n    }\n}\n```\n\n### 归并\n\n利用递归方案/循环方案，将一个大的问题，拆分成等价的无限小的事情，最后将最小等价事情的结果合并为最终结果\n\n利用二叉树，左右两边同时排序，最后将两部分合并再一起\n\n递归的算法需要注意临界值判断（往往出现再第一行，否则代码将进入死循环，无法退出， StackOverflow）\n\n```java\npublic void guibing(int[] num, int left, int right) {\n    if (left >= right) return; // 临界点判断，终止递归\n    int mid = (right + left) >> 1; // 取中间值\n    guibing(nums, left, mid);\n    guibing(nums, mid + 1, right);\n    merge(nums, left, right, mid);\n}\n\npublic void merge(int[] nums, int start, int length, int mid) {\n    int[] copy = nums.clone();\n    // index 是合并时需要的索引值， left, right 是二叉树的左右俩个边界\n    int index = start, left = start, right = mid + 1;\n    while(index <= length) {\n\t    if (left > mid) {\n            // 表明左侧二叉树已经遍历完成，剩下的右侧数据可直接填充\n            nums[index++] = copy[right++];\n        } else if(right > length){\n            // 表明右侧二叉树已经遍历完成，剩下的左侧部分可直接填充\n            nums[index++] = copy[left++];\n        } else if(copy[right] < copy[left]){\n            // 右侧数据比左侧数据小，将右侧数据填充\n            nums[index++] = copy[right++];\n        } else {\n            // 左侧数据比右侧数据小，将左侧数据填充\n            nums[index++] = copy[left++];\n        }\n    }\n    System.out.println(Arrays.toString(nums));\n}\n```\n\n\n\n### 快排\n\n同样利用递归的思想。\n\n先随机选择一个数，然后让比它小的放在左边，大的放在右边\n\n然后左右两边同时再随机选择一个数，还是小的放左边，大的放右边\n\n```java\npublic void kuaisu(int[] num, int low, int high) {\n    if(low > high) return;\n    int p = partition(nums, low, high);\n    kuaisu(nums, low, p - 1);\n    kuaisu(nums, p + 1, high);\n}\n    // 先随机一个索引，然后将他放在最后面。\n    // 在定义两个指针\n    // i: 用来记录比随机值小的数的个数，也就是最终随机值要倍还原的位置\n    // j: 当前第一个值\npublic void partition(int[] num, int low, int high) {\n    // 先将最小值， copy 到最后一个位置\n    int random = randRang(low, high);\n   \tswap(num, random, high);\n    // i 用来记录比中间值小的数的个数，也就是最终要将 copy 到最后一个位置的随机数要还原回来的位置\n    int i, j;\n    // 从左到右用每个数和基准值进行比较，比基准值小，则放到指针 i 的位置，i++, 循环结束后， i 指针之前的数，都比基准值小\n    for(i = low, j = low, j < high, j++) {\n        if(num[j] < num[high]) {\n            // num[j] 当前值\n            // num[high] 随机数，基准值\n            swap(num, i++, j);\n        }\n    }\n    // 将基准值还原到对应位置\n    swap(num, i, j);\n    return i;\n}\nprivate int randRang(int low, int high) {\n    return new Random().nextInt(high) % (high - low + 1) + low;\n}\n```\n\n\n\n","slug":"数据结构/算法","published":1,"date":"2021-01-29T15:54:28.359Z","updated":"2021-01-30T08:24:22.228Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8fv002lsz5qd7965tae","content":"<h2 id=\"高频数据结构和算法\"><a href=\"#高频数据结构和算法\" class=\"headerlink\" title=\"高频数据结构和算法\"></a>高频数据结构和算法</h2><h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><ul>\n<li>数组/字符串</li>\n<li>链表</li>\n<li>栈</li>\n<li>队列</li>\n<li>双端队列</li>\n<li>树<a id=\"more\"></a>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3></li>\n</ul>\n<p>优点： 可以在 O（1） 的时间里根据下标查询某个元素</p>\n<p>缺点：</p>\n<ul>\n<li>构建时必须时一段连续的空间</li>\n<li>查询某个元素是否存在时，需要遍历整个数组，耗费O(n) 的时间</li>\n<li>删除和添加某个元素时，同样需要耗费O(n) 的时间</li>\n</ul>\n<h3 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h3><p><strong>单链表：</strong> 链表中的每个元素实际上时一个单独的对象，而所有对象都通过每个元素中的引用字段链接在一起</p>\n<p><strong>双链表：</strong> 与单链表不同的时，双链表的每个节点中都含有<strong>两个引用字段</strong></p>\n<p><strong>优点：</strong> </p>\n<ul>\n<li>灵活的内存空间</li>\n<li>能在 O(1) 时间内删除或添加元素</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>查询元素需要O(n)时间</li>\n</ul>\n<p><strong>解题技巧：</strong></p>\n<ol>\n<li>利用快慢指针（有时需要3个）</li>\n<li>构建一个虚假的链表头</li>\n</ol>\n<p><strong>练习：</strong></p>\n<p>eg: k 个一组反转链表 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// 假设 k = 3</span>\nprev <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\ncurr <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\nn <span class=\"token operator\">=</span> k<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>curr <span class=\"token operator\">&amp;&amp;</span> n<span class=\"token operator\">--</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    next <span class=\"token operator\">=</span> curr<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n    curr<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> prev<span class=\"token punctuation\">;</span>\n    prev <span class=\"token operator\">=</span> curr<span class=\"token punctuation\">;</span>\n    curr <span class=\"token operator\">=</span> next<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h3><p><strong>特点：</strong> 后进先出； 所有的操作都是围绕栈顶部来完成</p>\n<p>算法的基本思想：</p>\n<p>可以用一个单链表来实现</p>\n<p>只关心上一次的操作</p>\n<p>处理完上一次操作后，能在 O(1) 时间内查找到更前一次的操作</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// 查找下一个比自己大的数的距离</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">stackSwap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 定义一个栈，用来缓存当前的最大值的索引</span>\n    Stack<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> stack <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Stack</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 定义一个数组，用来存储对应数据的间距</span>\n    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> interval <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span>nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n           <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>stack<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 因为会对栈进行操作，长度会改变，如果不先取，会导致循环跳位</span>\n            <span class=\"token keyword\">int</span> size <span class=\"token operator\">=</span> stack<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j  <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> size<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 拿出栈顶数据的索引</span>\n                <span class=\"token keyword\">int</span> topIndex <span class=\"token operator\">=</span> stack<span class=\"token punctuation\">.</span><span class=\"token function\">peek</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> num<span class=\"token punctuation\">[</span>topIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    interval<span class=\"token punctuation\">[</span>topIndex<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i <span class=\"token operator\">-</span> topIndex<span class=\"token punctuation\">;</span>\n                    stack<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 如果为空，或者栈顶数据比但前数据大，则将数据直接压入</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 或找不到一个比当前数据大的数据时，将当前数据压入栈</span>\n        stack<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h3><p>和栈不同，队列的最大特点是先进先出（FIFO），就好像按顺序排队一样。对于队列的数据来说，我们只允许在队尾查看和添加数据，在队头查看和删除数据。</p>\n<p>实现：可以借助双链表来实现队列。双链表的头指针允许在队头查看和删除数据，而双链表的尾指针允许我们在队尾查看和添加数据。</p>\n<p>应用场景：直观来看，当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题。在算法面试题当中，广度优先搜索（Breadth-First Search）是运用队列最多的地方。</p>\n<h3 id=\"双端队列\"><a href=\"#双端队列\" class=\"headerlink\" title=\"双端队列\"></a>双端队列</h3><p>可以利用双链表实现</p>\n<p>队列</p>\n<h2 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h2><h3 id=\"冒泡\"><a href=\"#冒泡\" class=\"headerlink\" title=\"冒泡\"></a>冒泡</h3><p>数据像鱼吐泡泡一样，从底部向上浮出</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">maopao</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> num<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> num<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token operator\">-</span> i<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> num<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> num<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> src<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> des<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> num<span class=\"token punctuation\">[</span>src<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    num<span class=\"token punctuation\">[</span>src<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> num<span class=\"token punctuation\">[</span>des<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    num<span class=\"token punctuation\">[</span>des<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h3><p>向已排列好的数组中插入数据</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">charu</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> num<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 记录当前最小值的索引</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> num<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                k <span class=\"token operator\">=</span> j<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"选择\"><a href=\"#选择\" class=\"headerlink\" title=\"选择\"></a>选择</h3><p>先遍历找到集合中的最小值索引，并将其与已排好序的数组最大值进行比较</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">xuanze</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> num<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> minIndex <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 已排序数组的最大值</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> num<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">[</span>minIndex<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> num<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                minIndex <span class=\"token operator\">=</span> j<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 找到未排序部分的最小值索引</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 与已排序部分最大值比较，小则交换</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">[</span>minIndex<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> num<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">,</span> minIndex<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"归并\"><a href=\"#归并\" class=\"headerlink\" title=\"归并\"></a>归并</h3><p>利用递归方案/循环方案，将一个大的问题，拆分成等价的无限小的事情，最后将最小等价事情的结果合并为最终结果</p>\n<p>利用二叉树，左右两边同时排序，最后将两部分合并再一起</p>\n<p>递归的算法需要注意临界值判断（往往出现再第一行，否则代码将进入死循环，无法退出， StackOverflow）</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">guibing</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> num<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> left<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> right<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">>=</span> right<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 临界点判断，终止递归</span>\n    <span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>right <span class=\"token operator\">+</span> left<span class=\"token punctuation\">)</span> <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 取中间值</span>\n    <span class=\"token function\">guibing</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> mid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">guibing</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">,</span> mid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nums<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> start<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> length<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> mid<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> copy <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// index 是合并时需要的索引值， left, right 是二叉树的左右俩个边界</span>\n    <span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> start<span class=\"token punctuation\">,</span> left <span class=\"token operator\">=</span> start<span class=\"token punctuation\">,</span> right <span class=\"token operator\">=</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>index <span class=\"token operator\">&lt;=</span> length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">></span> mid<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 表明左侧二叉树已经遍历完成，剩下的右侧数据可直接填充</span>\n            nums<span class=\"token punctuation\">[</span>index<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> copy<span class=\"token punctuation\">[</span>right<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>right <span class=\"token operator\">></span> length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 表明右侧二叉树已经遍历完成，剩下的左侧部分可直接填充</span>\n            nums<span class=\"token punctuation\">[</span>index<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> copy<span class=\"token punctuation\">[</span>left<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>copy<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> copy<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 右侧数据比左侧数据小，将右侧数据填充</span>\n            nums<span class=\"token punctuation\">[</span>index<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> copy<span class=\"token punctuation\">[</span>right<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 左侧数据比右侧数据小，将左侧数据填充</span>\n            nums<span class=\"token punctuation\">[</span>index<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> copy<span class=\"token punctuation\">[</span>left<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"快排\"><a href=\"#快排\" class=\"headerlink\" title=\"快排\"></a>快排</h3><p>同样利用递归的思想。</p>\n<p>先随机选择一个数，然后让比它小的放在左边，大的放在右边</p>\n<p>然后左右两边同时再随机选择一个数，还是小的放左边，大的放右边</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">kuaisu</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> num<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> low<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> high<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>low <span class=\"token operator\">></span> high<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> p <span class=\"token operator\">=</span> <span class=\"token function\">partition</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> low<span class=\"token punctuation\">,</span> high<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">kuaisu</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> low<span class=\"token punctuation\">,</span> p <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">kuaisu</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> p <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> high<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 先随机一个索引，然后将他放在最后面。</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 在定义两个指针</span>\n    <span class=\"token comment\" spellcheck=\"true\">// i: 用来记录比随机值小的数的个数，也就是最终随机值要倍还原的位置</span>\n    <span class=\"token comment\" spellcheck=\"true\">// j: 当前第一个值</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">partition</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> num<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> low<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> high<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 先将最小值， copy 到最后一个位置</span>\n    <span class=\"token keyword\">int</span> random <span class=\"token operator\">=</span> <span class=\"token function\">randRang</span><span class=\"token punctuation\">(</span>low<span class=\"token punctuation\">,</span> high<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">,</span> random<span class=\"token punctuation\">,</span> high<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// i 用来记录比中间值小的数的个数，也就是最终要将 copy 到最后一个位置的随机数要还原回来的位置</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 从左到右用每个数和基准值进行比较，比基准值小，则放到指针 i 的位置，i++, 循环结束后， i 指针之前的数，都比基准值小</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> low<span class=\"token punctuation\">,</span> j <span class=\"token operator\">=</span> low<span class=\"token punctuation\">,</span> j <span class=\"token operator\">&lt;</span> high<span class=\"token punctuation\">,</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> num<span class=\"token punctuation\">[</span>high<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// num[j] 当前值</span>\n            <span class=\"token comment\" spellcheck=\"true\">// num[high] 随机数，基准值</span>\n            <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">,</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 将基准值还原到对应位置</span>\n    <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> i<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> <span class=\"token function\">randRang</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> low<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> high<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span>high<span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token punctuation\">(</span>high <span class=\"token operator\">-</span> low <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> low<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n","site":{"data":{}},"excerpt":"<h2 id=\"高频数据结构和算法\"><a href=\"#高频数据结构和算法\" class=\"headerlink\" title=\"高频数据结构和算法\"></a>高频数据结构和算法</h2><h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><ul>\n<li>数组/字符串</li>\n<li>链表</li>\n<li>栈</li>\n<li>队列</li>\n<li>双端队列</li>\n<li>树","more":"<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3></li>\n</ul>\n<p>优点： 可以在 O（1） 的时间里根据下标查询某个元素</p>\n<p>缺点：</p>\n<ul>\n<li>构建时必须时一段连续的空间</li>\n<li>查询某个元素是否存在时，需要遍历整个数组，耗费O(n) 的时间</li>\n<li>删除和添加某个元素时，同样需要耗费O(n) 的时间</li>\n</ul>\n<h3 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h3><p><strong>单链表：</strong> 链表中的每个元素实际上时一个单独的对象，而所有对象都通过每个元素中的引用字段链接在一起</p>\n<p><strong>双链表：</strong> 与单链表不同的时，双链表的每个节点中都含有<strong>两个引用字段</strong></p>\n<p><strong>优点：</strong> </p>\n<ul>\n<li>灵活的内存空间</li>\n<li>能在 O(1) 时间内删除或添加元素</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>查询元素需要O(n)时间</li>\n</ul>\n<p><strong>解题技巧：</strong></p>\n<ol>\n<li>利用快慢指针（有时需要3个）</li>\n<li>构建一个虚假的链表头</li>\n</ol>\n<p><strong>练习：</strong></p>\n<p>eg: k 个一组反转链表 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null</p>\n<pre><code class=\"java\">// 假设 k = 3\nprev = null;\ncurr = head;\nn = k;\nwhile(curr &amp;&amp; n-- &gt; 0) {\n    next = curr.next;\n    curr.next = prev;\n    prev = curr;\n    curr = next;\n}\n</code></pre>\n<h3 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h3><p><strong>特点：</strong> 后进先出； 所有的操作都是围绕栈顶部来完成</p>\n<p>算法的基本思想：</p>\n<p>可以用一个单链表来实现</p>\n<p>只关心上一次的操作</p>\n<p>处理完上一次操作后，能在 O(1) 时间内查找到更前一次的操作</p>\n<pre><code class=\"java\">// 查找下一个比自己大的数的距离\npublic void stackSwap(int[] nums) {\n\n    // 定义一个栈，用来缓存当前的最大值的索引\n    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();\n    // 定义一个数组，用来存储对应数据的间距\n    int[] interval = new int[nums.length];\n\n    for(int i = 0; i &lt; nums.length; i++) {\n           if(!stack.empty()){\n            // 因为会对栈进行操作，长度会改变，如果不先取，会导致循环跳位\n            int size = stack.size();\n            for(int j  = 0; j &lt; size; j++) {\n                // 拿出栈顶数据的索引\n                int topIndex = stack.peek();\n                if(nums[i] &gt; num[topIndex]) {\n                    interval[topIndex] = i - topIndex;\n                    stack.pop();\n                }\n            }\n        }\n        // 如果为空，或者栈顶数据比但前数据大，则将数据直接压入\n        // 或找不到一个比当前数据大的数据时，将当前数据压入栈\n        stack.push(i);\n    }\n\n}\n</code></pre>\n<h3 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h3><p>和栈不同，队列的最大特点是先进先出（FIFO），就好像按顺序排队一样。对于队列的数据来说，我们只允许在队尾查看和添加数据，在队头查看和删除数据。</p>\n<p>实现：可以借助双链表来实现队列。双链表的头指针允许在队头查看和删除数据，而双链表的尾指针允许我们在队尾查看和添加数据。</p>\n<p>应用场景：直观来看，当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题。在算法面试题当中，广度优先搜索（Breadth-First Search）是运用队列最多的地方。</p>\n<h3 id=\"双端队列\"><a href=\"#双端队列\" class=\"headerlink\" title=\"双端队列\"></a>双端队列</h3><p>可以利用双链表实现</p>\n<p>队列</p>\n<h2 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h2><h3 id=\"冒泡\"><a href=\"#冒泡\" class=\"headerlink\" title=\"冒泡\"></a>冒泡</h3><p>数据像鱼吐泡泡一样，从底部向上浮出</p>\n<pre><code class=\"java\">public void maopao(int[] num) {\n    for(int i = 0; i &lt; num; i++) {\n        for(int j = 0; j &lt; num.length - 1 - i; j++) {\n            if(num[j] &gt; num[j+1]) {\n                swap(num, j, j + 1);\n            }\n        }\n    }\n}\n\npublic void swap(int[] num, int src, int des) {\n    int temp = num[src];\n    num[src] = num[des];\n    num[des] = temp;\n    System.out.println(Arrays.toString(num));\n}\n</code></pre>\n<h3 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h3><p>向已排列好的数组中插入数据</p>\n<pre><code class=\"java\">public void charu(int[] num) {\n    for(int i = 1; i &lt; num.length; i++) {\n        int k = i; // 记录当前最小值的索引\n        for(int j = (i -1); j &gt;= 0; j--) {\n            if(num[k] &lt; num[j]) {\n                swap(num, k, j);\n                k = j;\n            }\n        }\n    }\n}\n</code></pre>\n<h3 id=\"选择\"><a href=\"#选择\" class=\"headerlink\" title=\"选择\"></a>选择</h3><p>先遍历找到集合中的最小值索引，并将其与已排好序的数组最大值进行比较</p>\n<pre><code class=\"java\">public void xuanze(int[] num) {\n    for (int i = 0; i &lt; num.length; i++) {\n        int minIndex = i; // 已排序数组的最大值\n        for(int j = i + 1; j &lt; num.length; j++) {\n            if(num[minIndex] &gt; num[j]) {\n                minIndex = j; // 找到未排序部分的最小值索引\n            }\n        }\n        // 与已排序部分最大值比较，小则交换\n        if(num[minIndex] &lt; num[i]){\n            swap(num, minIndex, i)\n        }\n    }\n}\n</code></pre>\n<h3 id=\"归并\"><a href=\"#归并\" class=\"headerlink\" title=\"归并\"></a>归并</h3><p>利用递归方案/循环方案，将一个大的问题，拆分成等价的无限小的事情，最后将最小等价事情的结果合并为最终结果</p>\n<p>利用二叉树，左右两边同时排序，最后将两部分合并再一起</p>\n<p>递归的算法需要注意临界值判断（往往出现再第一行，否则代码将进入死循环，无法退出， StackOverflow）</p>\n<pre><code class=\"java\">public void guibing(int[] num, int left, int right) {\n    if (left &gt;= right) return; // 临界点判断，终止递归\n    int mid = (right + left) &gt;&gt; 1; // 取中间值\n    guibing(nums, left, mid);\n    guibing(nums, mid + 1, right);\n    merge(nums, left, right, mid);\n}\n\npublic void merge(int[] nums, int start, int length, int mid) {\n    int[] copy = nums.clone();\n    // index 是合并时需要的索引值， left, right 是二叉树的左右俩个边界\n    int index = start, left = start, right = mid + 1;\n    while(index &lt;= length) {\n        if (left &gt; mid) {\n            // 表明左侧二叉树已经遍历完成，剩下的右侧数据可直接填充\n            nums[index++] = copy[right++];\n        } else if(right &gt; length){\n            // 表明右侧二叉树已经遍历完成，剩下的左侧部分可直接填充\n            nums[index++] = copy[left++];\n        } else if(copy[right] &lt; copy[left]){\n            // 右侧数据比左侧数据小，将右侧数据填充\n            nums[index++] = copy[right++];\n        } else {\n            // 左侧数据比右侧数据小，将左侧数据填充\n            nums[index++] = copy[left++];\n        }\n    }\n    System.out.println(Arrays.toString(nums));\n}\n</code></pre>\n<h3 id=\"快排\"><a href=\"#快排\" class=\"headerlink\" title=\"快排\"></a>快排</h3><p>同样利用递归的思想。</p>\n<p>先随机选择一个数，然后让比它小的放在左边，大的放在右边</p>\n<p>然后左右两边同时再随机选择一个数，还是小的放左边，大的放右边</p>\n<pre><code class=\"java\">public void kuaisu(int[] num, int low, int high) {\n    if(low &gt; high) return;\n    int p = partition(nums, low, high);\n    kuaisu(nums, low, p - 1);\n    kuaisu(nums, p + 1, high);\n}\n    // 先随机一个索引，然后将他放在最后面。\n    // 在定义两个指针\n    // i: 用来记录比随机值小的数的个数，也就是最终随机值要倍还原的位置\n    // j: 当前第一个值\npublic void partition(int[] num, int low, int high) {\n    // 先将最小值， copy 到最后一个位置\n    int random = randRang(low, high);\n       swap(num, random, high);\n    // i 用来记录比中间值小的数的个数，也就是最终要将 copy 到最后一个位置的随机数要还原回来的位置\n    int i, j;\n    // 从左到右用每个数和基准值进行比较，比基准值小，则放到指针 i 的位置，i++, 循环结束后， i 指针之前的数，都比基准值小\n    for(i = low, j = low, j &lt; high, j++) {\n        if(num[j] &lt; num[high]) {\n            // num[j] 当前值\n            // num[high] 随机数，基准值\n            swap(num, i++, j);\n        }\n    }\n    // 将基准值还原到对应位置\n    swap(num, i, j);\n    return i;\n}\nprivate int randRang(int low, int high) {\n    return new Random().nextInt(high) % (high - low + 1) + low;\n}\n</code></pre>"},{"title":"Android WebView","_content":"\n\n\n## **问题**：\n\n### **为什么** **WebView 的加载速度那么慢?**\n\n1. js 解析效率\n\n   如果 js 文件较多、解析比较复杂，就会导致渲染速度较慢。或者手机硬件性能比较差的花，也会导致渲染速度比较慢\n\n2. 页面资源的下载\n\n   一般加载一个 H5 页面，都会产生比较多的网络请求，如图片、js 文件、css 文件等，需要将这些资源都下载完成之后才能完成渲染，这样也会导致页面渲染速度变慢\n\n<!-- more -->\n\n### **那如何解决呢？**\n\n对于第一点，其实主要是由前端代码和手机硬件决定，因为我们这里讨论的是对于 app 的性能优化，暂时不考虑；\n\n所以我们可以从第二点做文章，主要思路就是一些资源文件都使用 App 本地资源，而不需要从网络下载，从而提高页面的打开速度\n\n1. 首先将一些资源文件放在本地的 `assets` 目录，然后重写 WebViewClient 的 `shouldInterceptRequest(WebView view, String url)` 和  `shouleInterceptRequest(WebView view, WebResourceRequest request)` 这两个方法，对访问地址进行拦截，当 `url` 地址命中本地配置的 `url` 时，使用本地资源替代，否则就使用网络上的资源。\n\n   ```Java\n   mWebView.setWebViewClient(new WebViewClient() {\n       // 设置不使用系统浏览器打开，直接显示在当前 WebView\n       @Override\n       public boolean shouldOverrideUrlLoading(WebView view, String url) {\n           view.loadUrl(url);\n           return true;\n       }\n       \n       @Override\n       public WebResourceResponse shouldIntercepteReqeuest(WebView view, String url) {\n           // 如果命中本地资源，使用本地资源替代\n           if(mDataHelper.hasLocalResource(url)){\n               WebResourceResponse response = mDataHelper.getReplaceWebResourceResponse(getApplicationContext(), url);\n               if(response != null) {\n                   return response;\n               }\n           }\n           return super.shouldInterceptRequest(view, url);\n       }\n       \n       // 兼容 5.0 以上的设备\n       @TargetApi(VERSION_CODE.LOLLIPOP)\n       @Override\n       public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) {\n           String url = request.getUrl().toString();\n           if(mDataHelper.hasLocalResource(url)) {\n               WebResourceResponse response = mDataHelper.getReplaceWebResourceResponse(getApplicationContext(), url);\n               if(response != null) {\n                   return response;\n               }\n           }\n           return super.shouleInterceptRequest(view, request);\n       }\n   });\n   ```\n\n   DataHelper 是一个工具类\n\n   ```java\n   public class DataHelper {\n       private Map<String, String> mMap;\n       public DataHelper(){\n           mMap = new HashMap<>();\n           initData();\n       }\n       \n       private void initData(){\n           String imageDir = \"images/\";\n           String pngSuffix = \".png\";\n           mMap.put(\"http://renyugang.io/wp-content/themes/twentyseventeen/style.css?ver=4.9.8\", \"css/style.css\");\n           mMap.put(\"http://renyugang.io/wp-content/uploads/2018/06/cropped-ryg.png\",imageDir + \"cropped-ryg.png\");\n           // ...\n       }\n       \n       public boolean hasLocalResource(String url) {\n           return mMap.containsKey(url);\n       }\n       \n       public WebResourceResponce getReplacedWebResourceResponse(Context context, String url) {\n           String localResourcePath = mMap.get(url);\n           if(TextUtils.isEmpty(localResourcePath)) {\n               return null;\n           }\n           InputStream is = null;\n           try {\n               is = context.getApplicationContext().getAssets().open(localResourcePath);\n           } catch (Exception e) {\n               e.printStackTrace();\n               return null;\n           }\n           String mimeType;\n           if(url.contans(\"css\")) {\n               mimeType = \"text/css\";\n           } else if (url.contains(\".jpg\")) {\n               mimeType = \"image/jpeg\";\n           } else {\n               mimeType = \"image/png\";\n           }\n           \n           WebResourceResponse response = new WebResourceResponse(mimeType, \"utf-8\", is);\n           return response;\n       }\n   }\n   ```\n\n****\n\n### **WebView 的缓存**\n\n在不配置本地资源的时候，我们第一次打开页面，产生了 n  多请求。但是当我们退出后再次打开这个页面（没有设置加载本地资源）的时候，居然只发生了一次请求，这现象与加载本地资源十分相似。![image-20201027164335807](https://github.com/xiaomanwong/static_file/blob/master/images/image-20201027164335807.png?raw=true)\n\n我们观察到，这个请求的 response 的 headers 中的参数，`Last-Modified,ETag, Expires, Cache-Control` \n\n**Cache-Control：** 例如 Cache-Control:max-age=2592000, 表示缓存时长为 2592000 秒，也就是一个月30天的时间，如果30天内需要再次请求这个文件，那么浏览器不会发生出请求，直接使用本地缓存的文件。这是 `Http/1.1`  标准中的字段。\n\n**Expires：** 例如 Expires:Tue, 25 Sep 2018 07L17L34 GMT, 表示这个文件的过期时间是格林尼治时间2018年9月25日7点17分。因为我们是北京时间 2018年8月26日15点请求的，所以可以看出也是差不多一个月的有效期。在这个事件之前浏览器都不会再次发出请求去获取这个文件。Expires 是 `HTTP/1.0` 中的字段，如果客户端和服务器事件不同步会导致话u农村出现问题，因此才有了上面的 Cache-Control 。当他们同时出现时， Cache-Control 的优先级会更高。\n\n**Last-Modified:** 标识文件在服务器上的最新更新时间，下次请求时，如果文件缓存过期，浏览器通过 `If-Modified-Since` 字段带上这个时间，发送给服务器，由服务器比较时间戳来判断文件是否由修改。如果没有修改，服务器范围 304 （未修改）告诉浏览器继续使用缓存；如果有修改，则返回 200， 同时返回最新的文件。\n\n**ETag：** ETag 的取值时一个对文件进行标识的特征字段，在向服务器查询文件是否有更新时，浏览器通过 `If-None-Match` 字段把特征字串发送给服务器，由服务器和文件最新特征字串进行匹配，来判断文件是否有更新：没有返回 304， 有返回 200。 ETag 和 Last-Modified 可根据需求使用一个或两个同时使用。两个同时使用时，只要满足其中一个条件，就可以认为有更新。\n\n> 常见用法是， `Cache-Control` 与 `Last-Modified` 一起使用， `Expires` 和 `ETag` 一起使用。但实际情况可能并不是这样\n\n**设置 WebView 使用这些内容**\n\n想要 WebView 使用上面说到的缓存机制配置（答案是，不配置或手动设置）\n\n```java\nWebSettings settings = mWebView.getSettings();\nsettings.setCacheMode(WebSettings.LOAD_DEFAULT);\n```\n\n**WebView 的 5 种缓存模式**\n\n* LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据\n* LOAD_DEFAULT: 根据 cache-control 决定是否从网络上取数据\n* LOAD_CACHE_NORMAL: API Level 17 中已废弃，从 API Level 11 开始作用同 LOAD_DEFAULT 模式\n* LOAD_NO_CACHE： 不使用缓存，只从网络获取\n* LOCA_CACHE_ELSE_NETWORK: 只要本地有，无论是否过期，或者 no-cache 都使用缓存的数据。本地没有缓存时才从网络上获取\n\n在移动端，我们一般设置为默认的缓存模式就可以了，关于缓存的配置，主要还是靠 web 前端和后台设置。\n\n\n\n## WebView 的速度方案\n\n### WebView 的初始化\n\n本地 WebView 初始化都要不少时间，首次初始化 webview 与第二次初始化不同，首次会比第二次慢很多。原因第一次初始化是初始化浏览器的内核引擎，第二次则是可以直接拿来使用，并且一些已经初始化好，还没有被回收和销毁的对象也可以直接复用。\n\n### 预加载数据\n\n就是在客户端初始化 WebView 的同时，直接由 native 开始网络请求数据，当页面初始化完成后，向 native 获取其代理请求的数据，数据请求和 WebView 初始化可以并行进行，缩短总体的页面加载时间。‘\n\n简单来说就是配置一个预加载列表，在 APP 启动或者默写时机提前去请求，这个预加载列表需要包含所有 H5 模块的页面和资源，客户端可以接管所有请求的缓存，不走 webview 默认缓存逻辑，自行实现缓存机制，原理其实就是拦截 WebViewClient 的那两个 `shouleInterceptRequest` 方法。\n\n### 离线包\n\n离线包的意思就是将 H5 的页面和资源进行打包后下发到客户端，并由客户端直接解压到本次存储中。优点是由于其本地化，首屏加载速度快，用户体验更接近原生，可以不依赖网络，离线运行，缺点就是开发流程/更新机制复杂，需要客户端、甚至服务端的共同协作。\n\n**资源：**\n\n* H5： 每个代码包都有一个唯一且递增的版本号\n* Native：提供包下载且解压资源文件到对应目录\n* 服务端：提供一个接口，可以获取线商最新代码包的版本号和下载地址\n\n**流程：**\n\n* 前端更新代码打包后按版本号上传至指定的服务器上\n* 每次打开页面时， H5 请求接口获取线商最新代码包版本号，并与本地包进行版本号比对，当线商版本号大于本地包版本号时，调用原生下载离线包\n* 客户端直接去线商地址下载最新的代码包，并解压替换到当前目录文件\n","source":"_posts/Android 基础/View/Android WebView.md","raw":"---\ntitle: Android WebView\ntag: Android View\n---\n\n\n\n## **问题**：\n\n### **为什么** **WebView 的加载速度那么慢?**\n\n1. js 解析效率\n\n   如果 js 文件较多、解析比较复杂，就会导致渲染速度较慢。或者手机硬件性能比较差的花，也会导致渲染速度比较慢\n\n2. 页面资源的下载\n\n   一般加载一个 H5 页面，都会产生比较多的网络请求，如图片、js 文件、css 文件等，需要将这些资源都下载完成之后才能完成渲染，这样也会导致页面渲染速度变慢\n\n<!-- more -->\n\n### **那如何解决呢？**\n\n对于第一点，其实主要是由前端代码和手机硬件决定，因为我们这里讨论的是对于 app 的性能优化，暂时不考虑；\n\n所以我们可以从第二点做文章，主要思路就是一些资源文件都使用 App 本地资源，而不需要从网络下载，从而提高页面的打开速度\n\n1. 首先将一些资源文件放在本地的 `assets` 目录，然后重写 WebViewClient 的 `shouldInterceptRequest(WebView view, String url)` 和  `shouleInterceptRequest(WebView view, WebResourceRequest request)` 这两个方法，对访问地址进行拦截，当 `url` 地址命中本地配置的 `url` 时，使用本地资源替代，否则就使用网络上的资源。\n\n   ```Java\n   mWebView.setWebViewClient(new WebViewClient() {\n       // 设置不使用系统浏览器打开，直接显示在当前 WebView\n       @Override\n       public boolean shouldOverrideUrlLoading(WebView view, String url) {\n           view.loadUrl(url);\n           return true;\n       }\n       \n       @Override\n       public WebResourceResponse shouldIntercepteReqeuest(WebView view, String url) {\n           // 如果命中本地资源，使用本地资源替代\n           if(mDataHelper.hasLocalResource(url)){\n               WebResourceResponse response = mDataHelper.getReplaceWebResourceResponse(getApplicationContext(), url);\n               if(response != null) {\n                   return response;\n               }\n           }\n           return super.shouldInterceptRequest(view, url);\n       }\n       \n       // 兼容 5.0 以上的设备\n       @TargetApi(VERSION_CODE.LOLLIPOP)\n       @Override\n       public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) {\n           String url = request.getUrl().toString();\n           if(mDataHelper.hasLocalResource(url)) {\n               WebResourceResponse response = mDataHelper.getReplaceWebResourceResponse(getApplicationContext(), url);\n               if(response != null) {\n                   return response;\n               }\n           }\n           return super.shouleInterceptRequest(view, request);\n       }\n   });\n   ```\n\n   DataHelper 是一个工具类\n\n   ```java\n   public class DataHelper {\n       private Map<String, String> mMap;\n       public DataHelper(){\n           mMap = new HashMap<>();\n           initData();\n       }\n       \n       private void initData(){\n           String imageDir = \"images/\";\n           String pngSuffix = \".png\";\n           mMap.put(\"http://renyugang.io/wp-content/themes/twentyseventeen/style.css?ver=4.9.8\", \"css/style.css\");\n           mMap.put(\"http://renyugang.io/wp-content/uploads/2018/06/cropped-ryg.png\",imageDir + \"cropped-ryg.png\");\n           // ...\n       }\n       \n       public boolean hasLocalResource(String url) {\n           return mMap.containsKey(url);\n       }\n       \n       public WebResourceResponce getReplacedWebResourceResponse(Context context, String url) {\n           String localResourcePath = mMap.get(url);\n           if(TextUtils.isEmpty(localResourcePath)) {\n               return null;\n           }\n           InputStream is = null;\n           try {\n               is = context.getApplicationContext().getAssets().open(localResourcePath);\n           } catch (Exception e) {\n               e.printStackTrace();\n               return null;\n           }\n           String mimeType;\n           if(url.contans(\"css\")) {\n               mimeType = \"text/css\";\n           } else if (url.contains(\".jpg\")) {\n               mimeType = \"image/jpeg\";\n           } else {\n               mimeType = \"image/png\";\n           }\n           \n           WebResourceResponse response = new WebResourceResponse(mimeType, \"utf-8\", is);\n           return response;\n       }\n   }\n   ```\n\n****\n\n### **WebView 的缓存**\n\n在不配置本地资源的时候，我们第一次打开页面，产生了 n  多请求。但是当我们退出后再次打开这个页面（没有设置加载本地资源）的时候，居然只发生了一次请求，这现象与加载本地资源十分相似。![image-20201027164335807](https://github.com/xiaomanwong/static_file/blob/master/images/image-20201027164335807.png?raw=true)\n\n我们观察到，这个请求的 response 的 headers 中的参数，`Last-Modified,ETag, Expires, Cache-Control` \n\n**Cache-Control：** 例如 Cache-Control:max-age=2592000, 表示缓存时长为 2592000 秒，也就是一个月30天的时间，如果30天内需要再次请求这个文件，那么浏览器不会发生出请求，直接使用本地缓存的文件。这是 `Http/1.1`  标准中的字段。\n\n**Expires：** 例如 Expires:Tue, 25 Sep 2018 07L17L34 GMT, 表示这个文件的过期时间是格林尼治时间2018年9月25日7点17分。因为我们是北京时间 2018年8月26日15点请求的，所以可以看出也是差不多一个月的有效期。在这个事件之前浏览器都不会再次发出请求去获取这个文件。Expires 是 `HTTP/1.0` 中的字段，如果客户端和服务器事件不同步会导致话u农村出现问题，因此才有了上面的 Cache-Control 。当他们同时出现时， Cache-Control 的优先级会更高。\n\n**Last-Modified:** 标识文件在服务器上的最新更新时间，下次请求时，如果文件缓存过期，浏览器通过 `If-Modified-Since` 字段带上这个时间，发送给服务器，由服务器比较时间戳来判断文件是否由修改。如果没有修改，服务器范围 304 （未修改）告诉浏览器继续使用缓存；如果有修改，则返回 200， 同时返回最新的文件。\n\n**ETag：** ETag 的取值时一个对文件进行标识的特征字段，在向服务器查询文件是否有更新时，浏览器通过 `If-None-Match` 字段把特征字串发送给服务器，由服务器和文件最新特征字串进行匹配，来判断文件是否有更新：没有返回 304， 有返回 200。 ETag 和 Last-Modified 可根据需求使用一个或两个同时使用。两个同时使用时，只要满足其中一个条件，就可以认为有更新。\n\n> 常见用法是， `Cache-Control` 与 `Last-Modified` 一起使用， `Expires` 和 `ETag` 一起使用。但实际情况可能并不是这样\n\n**设置 WebView 使用这些内容**\n\n想要 WebView 使用上面说到的缓存机制配置（答案是，不配置或手动设置）\n\n```java\nWebSettings settings = mWebView.getSettings();\nsettings.setCacheMode(WebSettings.LOAD_DEFAULT);\n```\n\n**WebView 的 5 种缓存模式**\n\n* LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据\n* LOAD_DEFAULT: 根据 cache-control 决定是否从网络上取数据\n* LOAD_CACHE_NORMAL: API Level 17 中已废弃，从 API Level 11 开始作用同 LOAD_DEFAULT 模式\n* LOAD_NO_CACHE： 不使用缓存，只从网络获取\n* LOCA_CACHE_ELSE_NETWORK: 只要本地有，无论是否过期，或者 no-cache 都使用缓存的数据。本地没有缓存时才从网络上获取\n\n在移动端，我们一般设置为默认的缓存模式就可以了，关于缓存的配置，主要还是靠 web 前端和后台设置。\n\n\n\n## WebView 的速度方案\n\n### WebView 的初始化\n\n本地 WebView 初始化都要不少时间，首次初始化 webview 与第二次初始化不同，首次会比第二次慢很多。原因第一次初始化是初始化浏览器的内核引擎，第二次则是可以直接拿来使用，并且一些已经初始化好，还没有被回收和销毁的对象也可以直接复用。\n\n### 预加载数据\n\n就是在客户端初始化 WebView 的同时，直接由 native 开始网络请求数据，当页面初始化完成后，向 native 获取其代理请求的数据，数据请求和 WebView 初始化可以并行进行，缩短总体的页面加载时间。‘\n\n简单来说就是配置一个预加载列表，在 APP 启动或者默写时机提前去请求，这个预加载列表需要包含所有 H5 模块的页面和资源，客户端可以接管所有请求的缓存，不走 webview 默认缓存逻辑，自行实现缓存机制，原理其实就是拦截 WebViewClient 的那两个 `shouleInterceptRequest` 方法。\n\n### 离线包\n\n离线包的意思就是将 H5 的页面和资源进行打包后下发到客户端，并由客户端直接解压到本次存储中。优点是由于其本地化，首屏加载速度快，用户体验更接近原生，可以不依赖网络，离线运行，缺点就是开发流程/更新机制复杂，需要客户端、甚至服务端的共同协作。\n\n**资源：**\n\n* H5： 每个代码包都有一个唯一且递增的版本号\n* Native：提供包下载且解压资源文件到对应目录\n* 服务端：提供一个接口，可以获取线商最新代码包的版本号和下载地址\n\n**流程：**\n\n* 前端更新代码打包后按版本号上传至指定的服务器上\n* 每次打开页面时， H5 请求接口获取线商最新代码包版本号，并与本地包进行版本号比对，当线商版本号大于本地包版本号时，调用原生下载离线包\n* 客户端直接去线商地址下载最新的代码包，并解压替换到当前目录文件\n","slug":"Android 基础/View/Android WebView","published":1,"date":"2021-01-29T15:54:28.283Z","updated":"2021-01-29T15:54:28.284Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8jm002xsz5qia04mgnq","content":"<h2 id=\"问题：\"><a href=\"#问题：\" class=\"headerlink\" title=\"问题：\"></a><strong>问题</strong>：</h2><h3 id=\"为什么-WebView-的加载速度那么慢\"><a href=\"#为什么-WebView-的加载速度那么慢\" class=\"headerlink\" title=\"为什么 WebView 的加载速度那么慢?\"></a><strong>为什么</strong> <strong>WebView 的加载速度那么慢?</strong></h3><ol>\n<li><p>js 解析效率</p>\n<p>如果 js 文件较多、解析比较复杂，就会导致渲染速度较慢。或者手机硬件性能比较差的花，也会导致渲染速度比较慢</p>\n</li>\n<li><p>页面资源的下载</p>\n<p>一般加载一个 H5 页面，都会产生比较多的网络请求，如图片、js 文件、css 文件等，需要将这些资源都下载完成之后才能完成渲染，这样也会导致页面渲染速度变慢</p>\n</li>\n</ol>\n<a id=\"more\"></a>\n<h3 id=\"那如何解决呢？\"><a href=\"#那如何解决呢？\" class=\"headerlink\" title=\"那如何解决呢？\"></a><strong>那如何解决呢？</strong></h3><p>对于第一点，其实主要是由前端代码和手机硬件决定，因为我们这里讨论的是对于 app 的性能优化，暂时不考虑；</p>\n<p>所以我们可以从第二点做文章，主要思路就是一些资源文件都使用 App 本地资源，而不需要从网络下载，从而提高页面的打开速度</p>\n<ol>\n<li><p>首先将一些资源文件放在本地的 <code>assets</code> 目录，然后重写 WebViewClient 的 <code>shouldInterceptRequest(WebView view, String url)</code> 和  <code>shouleInterceptRequest(WebView view, WebResourceRequest request)</code> 这两个方法，对访问地址进行拦截，当 <code>url</code> 地址命中本地配置的 <code>url</code> 时，使用本地资源替代，否则就使用网络上的资源。</p>\n<pre class=\" language-Java\"><code class=\"language-Java\">mWebView.setWebViewClient(new WebViewClient() {\n    // 设置不使用系统浏览器打开，直接显示在当前 WebView\n    @Override\n    public boolean shouldOverrideUrlLoading(WebView view, String url) {\n        view.loadUrl(url);\n        return true;\n    }\n\n    @Override\n    public WebResourceResponse shouldIntercepteReqeuest(WebView view, String url) {\n        // 如果命中本地资源，使用本地资源替代\n        if(mDataHelper.hasLocalResource(url)){\n            WebResourceResponse response = mDataHelper.getReplaceWebResourceResponse(getApplicationContext(), url);\n            if(response != null) {\n                return response;\n            }\n        }\n        return super.shouldInterceptRequest(view, url);\n    }\n\n    // 兼容 5.0 以上的设备\n    @TargetApi(VERSION_CODE.LOLLIPOP)\n    @Override\n    public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) {\n        String url = request.getUrl().toString();\n        if(mDataHelper.hasLocalResource(url)) {\n            WebResourceResponse response = mDataHelper.getReplaceWebResourceResponse(getApplicationContext(), url);\n            if(response != null) {\n                return response;\n            }\n        }\n        return super.shouleInterceptRequest(view, request);\n    }\n});\n</code></pre>\n<p>DataHelper 是一个工具类</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DataHelper</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> String<span class=\"token operator\">></span> mMap<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">DataHelper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        mMap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">initData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">initData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        String imageDir <span class=\"token operator\">=</span> <span class=\"token string\">\"images/\"</span><span class=\"token punctuation\">;</span>\n        String pngSuffix <span class=\"token operator\">=</span> <span class=\"token string\">\".png\"</span><span class=\"token punctuation\">;</span>\n        mMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"http://renyugang.io/wp-content/themes/twentyseventeen/style.css?ver=4.9.8\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"css/style.css\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        mMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"http://renyugang.io/wp-content/uploads/2018/06/cropped-ryg.png\"</span><span class=\"token punctuation\">,</span>imageDir <span class=\"token operator\">+</span> <span class=\"token string\">\"cropped-ryg.png\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">hasLocalResource</span><span class=\"token punctuation\">(</span>String url<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> mMap<span class=\"token punctuation\">.</span><span class=\"token function\">containsKey</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> WebResourceResponce <span class=\"token function\">getReplacedWebResourceResponse</span><span class=\"token punctuation\">(</span>Context context<span class=\"token punctuation\">,</span> String url<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        String localResourcePath <span class=\"token operator\">=</span> mMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>TextUtils<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span>localResourcePath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> null<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        InputStream is <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            is <span class=\"token operator\">=</span> context<span class=\"token punctuation\">.</span><span class=\"token function\">getApplicationContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getAssets</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span>localResourcePath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> null<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        String mimeType<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">.</span><span class=\"token function\">contans</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"css\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            mimeType <span class=\"token operator\">=</span> <span class=\"token string\">\"text/css\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span><span class=\"token string\">\".jpg\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            mimeType <span class=\"token operator\">=</span> <span class=\"token string\">\"image/jpeg\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            mimeType <span class=\"token operator\">=</span> <span class=\"token string\">\"image/png\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        WebResourceResponse response <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WebResourceResponse</span><span class=\"token punctuation\">(</span>mimeType<span class=\"token punctuation\">,</span> <span class=\"token string\">\"utf-8\"</span><span class=\"token punctuation\">,</span> is<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> response<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n</li>\n</ol>\n<hr>\n<h3 id=\"WebView-的缓存\"><a href=\"#WebView-的缓存\" class=\"headerlink\" title=\"WebView 的缓存\"></a><strong>WebView 的缓存</strong></h3><p>在不配置本地资源的时候，我们第一次打开页面，产生了 n  多请求。但是当我们退出后再次打开这个页面（没有设置加载本地资源）的时候，居然只发生了一次请求，这现象与加载本地资源十分相似。<img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/image-20201027164335807.png?raw=true\" alt=\"image-20201027164335807\"></p>\n<p>我们观察到，这个请求的 response 的 headers 中的参数，<code>Last-Modified,ETag, Expires, Cache-Control</code> </p>\n<p><strong>Cache-Control：</strong> 例如 Cache-Control:max-age=2592000, 表示缓存时长为 2592000 秒，也就是一个月30天的时间，如果30天内需要再次请求这个文件，那么浏览器不会发生出请求，直接使用本地缓存的文件。这是 <code>Http/1.1</code>  标准中的字段。</p>\n<p><strong>Expires：</strong> 例如 Expires:Tue, 25 Sep 2018 07L17L34 GMT, 表示这个文件的过期时间是格林尼治时间2018年9月25日7点17分。因为我们是北京时间 2018年8月26日15点请求的，所以可以看出也是差不多一个月的有效期。在这个事件之前浏览器都不会再次发出请求去获取这个文件。Expires 是 <code>HTTP/1.0</code> 中的字段，如果客户端和服务器事件不同步会导致话u农村出现问题，因此才有了上面的 Cache-Control 。当他们同时出现时， Cache-Control 的优先级会更高。</p>\n<p><strong>Last-Modified:</strong> 标识文件在服务器上的最新更新时间，下次请求时，如果文件缓存过期，浏览器通过 <code>If-Modified-Since</code> 字段带上这个时间，发送给服务器，由服务器比较时间戳来判断文件是否由修改。如果没有修改，服务器范围 304 （未修改）告诉浏览器继续使用缓存；如果有修改，则返回 200， 同时返回最新的文件。</p>\n<p><strong>ETag：</strong> ETag 的取值时一个对文件进行标识的特征字段，在向服务器查询文件是否有更新时，浏览器通过 <code>If-None-Match</code> 字段把特征字串发送给服务器，由服务器和文件最新特征字串进行匹配，来判断文件是否有更新：没有返回 304， 有返回 200。 ETag 和 Last-Modified 可根据需求使用一个或两个同时使用。两个同时使用时，只要满足其中一个条件，就可以认为有更新。</p>\n<blockquote>\n<p>常见用法是， <code>Cache-Control</code> 与 <code>Last-Modified</code> 一起使用， <code>Expires</code> 和 <code>ETag</code> 一起使用。但实际情况可能并不是这样</p>\n</blockquote>\n<p><strong>设置 WebView 使用这些内容</strong></p>\n<p>想要 WebView 使用上面说到的缓存机制配置（答案是，不配置或手动设置）</p>\n<pre class=\" language-java\"><code class=\"language-java\">WebSettings settings <span class=\"token operator\">=</span> mWebView<span class=\"token punctuation\">.</span><span class=\"token function\">getSettings</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nsettings<span class=\"token punctuation\">.</span><span class=\"token function\">setCacheMode</span><span class=\"token punctuation\">(</span>WebSettings<span class=\"token punctuation\">.</span>LOAD_DEFAULT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><strong>WebView 的 5 种缓存模式</strong></p>\n<ul>\n<li>LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据</li>\n<li>LOAD_DEFAULT: 根据 cache-control 决定是否从网络上取数据</li>\n<li>LOAD_CACHE_NORMAL: API Level 17 中已废弃，从 API Level 11 开始作用同 LOAD_DEFAULT 模式</li>\n<li>LOAD_NO_CACHE： 不使用缓存，只从网络获取</li>\n<li>LOCA_CACHE_ELSE_NETWORK: 只要本地有，无论是否过期，或者 no-cache 都使用缓存的数据。本地没有缓存时才从网络上获取</li>\n</ul>\n<p>在移动端，我们一般设置为默认的缓存模式就可以了，关于缓存的配置，主要还是靠 web 前端和后台设置。</p>\n<h2 id=\"WebView-的速度方案\"><a href=\"#WebView-的速度方案\" class=\"headerlink\" title=\"WebView 的速度方案\"></a>WebView 的速度方案</h2><h3 id=\"WebView-的初始化\"><a href=\"#WebView-的初始化\" class=\"headerlink\" title=\"WebView 的初始化\"></a>WebView 的初始化</h3><p>本地 WebView 初始化都要不少时间，首次初始化 webview 与第二次初始化不同，首次会比第二次慢很多。原因第一次初始化是初始化浏览器的内核引擎，第二次则是可以直接拿来使用，并且一些已经初始化好，还没有被回收和销毁的对象也可以直接复用。</p>\n<h3 id=\"预加载数据\"><a href=\"#预加载数据\" class=\"headerlink\" title=\"预加载数据\"></a>预加载数据</h3><p>就是在客户端初始化 WebView 的同时，直接由 native 开始网络请求数据，当页面初始化完成后，向 native 获取其代理请求的数据，数据请求和 WebView 初始化可以并行进行，缩短总体的页面加载时间。‘</p>\n<p>简单来说就是配置一个预加载列表，在 APP 启动或者默写时机提前去请求，这个预加载列表需要包含所有 H5 模块的页面和资源，客户端可以接管所有请求的缓存，不走 webview 默认缓存逻辑，自行实现缓存机制，原理其实就是拦截 WebViewClient 的那两个 <code>shouleInterceptRequest</code> 方法。</p>\n<h3 id=\"离线包\"><a href=\"#离线包\" class=\"headerlink\" title=\"离线包\"></a>离线包</h3><p>离线包的意思就是将 H5 的页面和资源进行打包后下发到客户端，并由客户端直接解压到本次存储中。优点是由于其本地化，首屏加载速度快，用户体验更接近原生，可以不依赖网络，离线运行，缺点就是开发流程/更新机制复杂，需要客户端、甚至服务端的共同协作。</p>\n<p><strong>资源：</strong></p>\n<ul>\n<li>H5： 每个代码包都有一个唯一且递增的版本号</li>\n<li>Native：提供包下载且解压资源文件到对应目录</li>\n<li>服务端：提供一个接口，可以获取线商最新代码包的版本号和下载地址</li>\n</ul>\n<p><strong>流程：</strong></p>\n<ul>\n<li>前端更新代码打包后按版本号上传至指定的服务器上</li>\n<li>每次打开页面时， H5 请求接口获取线商最新代码包版本号，并与本地包进行版本号比对，当线商版本号大于本地包版本号时，调用原生下载离线包</li>\n<li>客户端直接去线商地址下载最新的代码包，并解压替换到当前目录文件</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"问题：\"><a href=\"#问题：\" class=\"headerlink\" title=\"问题：\"></a><strong>问题</strong>：</h2><h3 id=\"为什么-WebView-的加载速度那么慢\"><a href=\"#为什么-WebView-的加载速度那么慢\" class=\"headerlink\" title=\"为什么 WebView 的加载速度那么慢?\"></a><strong>为什么</strong> <strong>WebView 的加载速度那么慢?</strong></h3><ol>\n<li><p>js 解析效率</p>\n<p>如果 js 文件较多、解析比较复杂，就会导致渲染速度较慢。或者手机硬件性能比较差的花，也会导致渲染速度比较慢</p>\n</li>\n<li><p>页面资源的下载</p>\n<p>一般加载一个 H5 页面，都会产生比较多的网络请求，如图片、js 文件、css 文件等，需要将这些资源都下载完成之后才能完成渲染，这样也会导致页面渲染速度变慢</p>\n</li>\n</ol>","more":"<h3 id=\"那如何解决呢？\"><a href=\"#那如何解决呢？\" class=\"headerlink\" title=\"那如何解决呢？\"></a><strong>那如何解决呢？</strong></h3><p>对于第一点，其实主要是由前端代码和手机硬件决定，因为我们这里讨论的是对于 app 的性能优化，暂时不考虑；</p>\n<p>所以我们可以从第二点做文章，主要思路就是一些资源文件都使用 App 本地资源，而不需要从网络下载，从而提高页面的打开速度</p>\n<ol>\n<li><p>首先将一些资源文件放在本地的 <code>assets</code> 目录，然后重写 WebViewClient 的 <code>shouldInterceptRequest(WebView view, String url)</code> 和  <code>shouleInterceptRequest(WebView view, WebResourceRequest request)</code> 这两个方法，对访问地址进行拦截，当 <code>url</code> 地址命中本地配置的 <code>url</code> 时，使用本地资源替代，否则就使用网络上的资源。</p>\n<pre><code class=\"Java\">mWebView.setWebViewClient(new WebViewClient() {\n    // 设置不使用系统浏览器打开，直接显示在当前 WebView\n    @Override\n    public boolean shouldOverrideUrlLoading(WebView view, String url) {\n        view.loadUrl(url);\n        return true;\n    }\n\n    @Override\n    public WebResourceResponse shouldIntercepteReqeuest(WebView view, String url) {\n        // 如果命中本地资源，使用本地资源替代\n        if(mDataHelper.hasLocalResource(url)){\n            WebResourceResponse response = mDataHelper.getReplaceWebResourceResponse(getApplicationContext(), url);\n            if(response != null) {\n                return response;\n            }\n        }\n        return super.shouldInterceptRequest(view, url);\n    }\n\n    // 兼容 5.0 以上的设备\n    @TargetApi(VERSION_CODE.LOLLIPOP)\n    @Override\n    public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) {\n        String url = request.getUrl().toString();\n        if(mDataHelper.hasLocalResource(url)) {\n            WebResourceResponse response = mDataHelper.getReplaceWebResourceResponse(getApplicationContext(), url);\n            if(response != null) {\n                return response;\n            }\n        }\n        return super.shouleInterceptRequest(view, request);\n    }\n});\n</code></pre>\n<p>DataHelper 是一个工具类</p>\n<pre><code class=\"java\">public class DataHelper {\n    private Map&lt;String, String&gt; mMap;\n    public DataHelper(){\n        mMap = new HashMap&lt;&gt;();\n        initData();\n    }\n\n    private void initData(){\n        String imageDir = &quot;images/&quot;;\n        String pngSuffix = &quot;.png&quot;;\n        mMap.put(&quot;http://renyugang.io/wp-content/themes/twentyseventeen/style.css?ver=4.9.8&quot;, &quot;css/style.css&quot;);\n        mMap.put(&quot;http://renyugang.io/wp-content/uploads/2018/06/cropped-ryg.png&quot;,imageDir + &quot;cropped-ryg.png&quot;);\n        // ...\n    }\n\n    public boolean hasLocalResource(String url) {\n        return mMap.containsKey(url);\n    }\n\n    public WebResourceResponce getReplacedWebResourceResponse(Context context, String url) {\n        String localResourcePath = mMap.get(url);\n        if(TextUtils.isEmpty(localResourcePath)) {\n            return null;\n        }\n        InputStream is = null;\n        try {\n            is = context.getApplicationContext().getAssets().open(localResourcePath);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n        String mimeType;\n        if(url.contans(&quot;css&quot;)) {\n            mimeType = &quot;text/css&quot;;\n        } else if (url.contains(&quot;.jpg&quot;)) {\n            mimeType = &quot;image/jpeg&quot;;\n        } else {\n            mimeType = &quot;image/png&quot;;\n        }\n\n        WebResourceResponse response = new WebResourceResponse(mimeType, &quot;utf-8&quot;, is);\n        return response;\n    }\n}\n</code></pre>\n</li>\n</ol>\n<hr>\n<h3 id=\"WebView-的缓存\"><a href=\"#WebView-的缓存\" class=\"headerlink\" title=\"WebView 的缓存\"></a><strong>WebView 的缓存</strong></h3><p>在不配置本地资源的时候，我们第一次打开页面，产生了 n  多请求。但是当我们退出后再次打开这个页面（没有设置加载本地资源）的时候，居然只发生了一次请求，这现象与加载本地资源十分相似。<img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/image-20201027164335807.png?raw=true\" alt=\"image-20201027164335807\"></p>\n<p>我们观察到，这个请求的 response 的 headers 中的参数，<code>Last-Modified,ETag, Expires, Cache-Control</code> </p>\n<p><strong>Cache-Control：</strong> 例如 Cache-Control:max-age=2592000, 表示缓存时长为 2592000 秒，也就是一个月30天的时间，如果30天内需要再次请求这个文件，那么浏览器不会发生出请求，直接使用本地缓存的文件。这是 <code>Http/1.1</code>  标准中的字段。</p>\n<p><strong>Expires：</strong> 例如 Expires:Tue, 25 Sep 2018 07L17L34 GMT, 表示这个文件的过期时间是格林尼治时间2018年9月25日7点17分。因为我们是北京时间 2018年8月26日15点请求的，所以可以看出也是差不多一个月的有效期。在这个事件之前浏览器都不会再次发出请求去获取这个文件。Expires 是 <code>HTTP/1.0</code> 中的字段，如果客户端和服务器事件不同步会导致话u农村出现问题，因此才有了上面的 Cache-Control 。当他们同时出现时， Cache-Control 的优先级会更高。</p>\n<p><strong>Last-Modified:</strong> 标识文件在服务器上的最新更新时间，下次请求时，如果文件缓存过期，浏览器通过 <code>If-Modified-Since</code> 字段带上这个时间，发送给服务器，由服务器比较时间戳来判断文件是否由修改。如果没有修改，服务器范围 304 （未修改）告诉浏览器继续使用缓存；如果有修改，则返回 200， 同时返回最新的文件。</p>\n<p><strong>ETag：</strong> ETag 的取值时一个对文件进行标识的特征字段，在向服务器查询文件是否有更新时，浏览器通过 <code>If-None-Match</code> 字段把特征字串发送给服务器，由服务器和文件最新特征字串进行匹配，来判断文件是否有更新：没有返回 304， 有返回 200。 ETag 和 Last-Modified 可根据需求使用一个或两个同时使用。两个同时使用时，只要满足其中一个条件，就可以认为有更新。</p>\n<blockquote>\n<p>常见用法是， <code>Cache-Control</code> 与 <code>Last-Modified</code> 一起使用， <code>Expires</code> 和 <code>ETag</code> 一起使用。但实际情况可能并不是这样</p>\n</blockquote>\n<p><strong>设置 WebView 使用这些内容</strong></p>\n<p>想要 WebView 使用上面说到的缓存机制配置（答案是，不配置或手动设置）</p>\n<pre><code class=\"java\">WebSettings settings = mWebView.getSettings();\nsettings.setCacheMode(WebSettings.LOAD_DEFAULT);\n</code></pre>\n<p><strong>WebView 的 5 种缓存模式</strong></p>\n<ul>\n<li>LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据</li>\n<li>LOAD_DEFAULT: 根据 cache-control 决定是否从网络上取数据</li>\n<li>LOAD_CACHE_NORMAL: API Level 17 中已废弃，从 API Level 11 开始作用同 LOAD_DEFAULT 模式</li>\n<li>LOAD_NO_CACHE： 不使用缓存，只从网络获取</li>\n<li>LOCA_CACHE_ELSE_NETWORK: 只要本地有，无论是否过期，或者 no-cache 都使用缓存的数据。本地没有缓存时才从网络上获取</li>\n</ul>\n<p>在移动端，我们一般设置为默认的缓存模式就可以了，关于缓存的配置，主要还是靠 web 前端和后台设置。</p>\n<h2 id=\"WebView-的速度方案\"><a href=\"#WebView-的速度方案\" class=\"headerlink\" title=\"WebView 的速度方案\"></a>WebView 的速度方案</h2><h3 id=\"WebView-的初始化\"><a href=\"#WebView-的初始化\" class=\"headerlink\" title=\"WebView 的初始化\"></a>WebView 的初始化</h3><p>本地 WebView 初始化都要不少时间，首次初始化 webview 与第二次初始化不同，首次会比第二次慢很多。原因第一次初始化是初始化浏览器的内核引擎，第二次则是可以直接拿来使用，并且一些已经初始化好，还没有被回收和销毁的对象也可以直接复用。</p>\n<h3 id=\"预加载数据\"><a href=\"#预加载数据\" class=\"headerlink\" title=\"预加载数据\"></a>预加载数据</h3><p>就是在客户端初始化 WebView 的同时，直接由 native 开始网络请求数据，当页面初始化完成后，向 native 获取其代理请求的数据，数据请求和 WebView 初始化可以并行进行，缩短总体的页面加载时间。‘</p>\n<p>简单来说就是配置一个预加载列表，在 APP 启动或者默写时机提前去请求，这个预加载列表需要包含所有 H5 模块的页面和资源，客户端可以接管所有请求的缓存，不走 webview 默认缓存逻辑，自行实现缓存机制，原理其实就是拦截 WebViewClient 的那两个 <code>shouleInterceptRequest</code> 方法。</p>\n<h3 id=\"离线包\"><a href=\"#离线包\" class=\"headerlink\" title=\"离线包\"></a>离线包</h3><p>离线包的意思就是将 H5 的页面和资源进行打包后下发到客户端，并由客户端直接解压到本次存储中。优点是由于其本地化，首屏加载速度快，用户体验更接近原生，可以不依赖网络，离线运行，缺点就是开发流程/更新机制复杂，需要客户端、甚至服务端的共同协作。</p>\n<p><strong>资源：</strong></p>\n<ul>\n<li>H5： 每个代码包都有一个唯一且递增的版本号</li>\n<li>Native：提供包下载且解压资源文件到对应目录</li>\n<li>服务端：提供一个接口，可以获取线商最新代码包的版本号和下载地址</li>\n</ul>\n<p><strong>流程：</strong></p>\n<ul>\n<li>前端更新代码打包后按版本号上传至指定的服务器上</li>\n<li>每次打开页面时， H5 请求接口获取线商最新代码包版本号，并与本地包进行版本号比对，当线商版本号大于本地包版本号时，调用原生下载离线包</li>\n<li>客户端直接去线商地址下载最新的代码包，并解压替换到当前目录文件</li>\n</ul>"},{"title":"Android自定义View","_content":"\n\n[TOC]\n\n## 概述\n\n### Android开发进阶的必经之路\n\n### 为什么要自定义View\n\n### 自定义View的基本方法\n\n自定义View的最基本的三个方法分别是： onMeasure()、onLayout()、onDraw();\nView在Activity中显示出来，要经历测量、布局和绘制三个步骤，分别对应三个动作：measure、layout和draw。\n<!-- more-->\n\n- 测量：onMeasure()决定View的大小；\n- 布局：onLayout()决定View在ViewGroup中的位置；\n- 绘制：onDraw()决定绘制这个View。\n\n### 自定义控件分类\n\n- 自定义View: 只需要重写onMeasure()和onDraw()\n- 自定义ViewGroup: 则只需要重写onMeasure()和onLayout()\n\n## 自定义View基础\n\n### View的分类\n\n视图View主要分为两类\n\n| 类别     | 解释                                      | 特点         |\n| -------- | ----------------------------------------- | ------------ |\n| 单一视图 | 即一个View，如TextView                    | 不包含子View |\n| 视图组   | 即多个View组成的ViewGroup，如LinearLayout | 包含子View   |\n\n### View类简介\n\n- View类是Android中各种组件的基类，如View是ViewGroup基类\n- View表现为显示在屏幕上的各种视图\n\n> Android中的UI组件都由View、ViewGroup组成。\n\n- View的构造函数：共有4个\n\n  ```java\n  // 如果View是在Java代码里面new的，则调用第一个构造函数\n   public CarsonView(Context context) {\n          super(context);\n      }\n  \n  // 如果View是在.xml里声明的，则调用第二个构造函数\n  // 自定义属性是从AttributeSet参数传进来的\n      public  CarsonView(Context context, AttributeSet attrs) {\n          super(context, attrs);\n      }\n  \n  // 不会自动调用\n  // 一般是在第二个构造函数里主动调用\n  // 如View有style属性时\n      public  CarsonView(Context context, AttributeSet attrs, int defStyleAttr) {\n          super(context, attrs, defStyleAttr);\n      }\n  \n      //API21之后才使用\n      // 不会自动调用\n      // 一般是在第二个构造函数里主动调用\n      // 如View有style属性时\n      public  CarsonView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {\n          super(context, attrs, defStyleAttr, defStyleRes);\n      }\n  ```\n\n### AttributeSet与自定义属性\n\n　系统自带的View可以在xml中配置属性，对于写的好的自定义View同样可以在xml中配置属性，为了使自定义的View的属性可以在xml中配置，需要以下4个步骤：\n\n1. 通过```<declare-styleable>```为自定义View添加属性\n2. 在xml中为相应的属性声明属性值\n3. 在运行时（一般为构造函数）获取属性值\n4. 将获取到的属性值应用到View\n\n\n\n### View视图结构\n\n1. PhoneWindow是Android系统中最基本的窗口系统，继承自Windows类，负责管理界面显示以及事件响应。它是Activity与View系统交互的接口，每个Activity都会创建一个\n2. DecorView是PhoneWindow中的起始节点View，继承于View类，作为整个视图容器来使用。用于设置窗口属性。它本质上是一个FrameLayout\n3. ViewRoot在Activtiy启动时创建，负责管理、布局、渲染窗口UI等等\n\n![activity](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/activity.png)\n\n对于多View的视图，结构是树形结构：最顶层是ViewGroup，ViewGroup下可能有多个ViewGroup或View，如下图：\n\n![view_arch](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_arch.png)\n\n一定要记住：无论是measure过程、layout过程还是draw过程，永远都是从View树的根节点开始测量或计算（即从树的顶端开始），一层一层、一个分支一个分支地进行（即树形递归），最终计算整个View树中各个View，最终确定整个View树的相关属性。\n\n### Android坐标系\n\nAndroid的坐标系定义为：\n\n- 屏幕的左上角为坐标原点\n- 向右为x轴增大方向\n- 向下为y轴增大方向\n  ![zuobiaoxi](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/zuobiaoxi.png)\n\n> 区别于一般的数学坐标系\n> ![zuobiaoxi_qubie](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/zuobiaoxi_qubie.png)\n\n###  View位置（坐标）描述\n\nView的位置由4个顶点决定的\n4个顶点的位置描述分别由4个值决定：\n\n> 请记住：View的位置是相对于父控件而言的）\n\n- Top：子View上边界到父view上边界的距离\n- Left：子View左边界到父view左边界的距离\n- Bottom：子View下边距到父View上边界的距离\n- Right：子View右边界到父view左边界的距离\n\n### 位置获取方式\n\nView的位置是通过view.getxxx()函数进行获取：（以Top为例）\n\n```java\n// 获取Top位置\npublic final int getTop() {  \n    return mTop;  \n}  \n\n// 其余如下：\n  getLeft();      //获取子View左上角距父View左侧的距离\n  getBottom();    //获取子View右下角距父View顶部的距离\n  getRight();     //获取子View右下角距父View左侧的距离\n```\n\n与MotionEvent中 get()和getRaw()的区别\n\n```java\n//get() ：触摸点相对于其所在组件坐标系的坐标\n event.getX();       \n event.getY();\n\n//getRaw() ：触摸点相对于屏幕默认坐标系的坐标\n event.getRawX();    \n event.getRawY();\n```\n\n![zuobiaoxiweizhi](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/zuobiaoxiweizhi.png)\n\n### Android中颜色相关内容\n\nAndroid支持的颜色模式：\n![color1](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/color1.png)\n\n以ARGB8888为例介绍颜色定义:\n![color2](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/color2.png)\n\n## View树的绘制流程\n\n### View树的绘制流程是谁负责的？\n\nview树的绘制流程是通过ViewRoot去负责绘制的，ViewRoot这个类的命名有点坑，最初看到这个名字，翻译过来是view的根节点，但是事实完全不是这样，ViewRoot其实不是View的根节点，它连view节点都算不上，它的主要作用是View树的管理者，负责将DecorView和PhoneWindow“组合”起来，而View树的根节点严格意义上来说只有DecorView；每个DecorView都有一个ViewRoot与之关联，这种关联关系是由WindowManager去进行管理的；绘制就是从ViewRoot.performTraversals()开始的。\n\n```java\n  private void performTraversals() {\n        .....\n        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);\n        .....\n        performLayout(lp, mWidth, mHeight);\n        .....\n        performDraw();\n        .....\n    }\n```\n\n\n\n### view的添加\n\n![](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_qiyuan.png)\n\n### view的绘制流程\n\n![view_traversals](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_traversals.png)\n\n### measure\n\n1. 系统为什么要有measure过程？\n\n   ```xml\n       <TextView\n           android:layout_width=\"wrap_content\"\n           android:layout_height=\"match_parent\"\n           android:text=\"Hello World!\" />\n   ```\n\n   谷歌建议使用自适应，自适应的话，就不知道大小，所以需要去测量。\n\n2. measure过程都干了点什么事？\n\n3. 对于自适应的尺寸机制，如何合理的测量一颗View树？\n\n4. 那么ViewGroup是如何向子View传递限制信息的？\n\n5. ScrollView嵌套ListView问题？\n\n![view_requestlayout](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_requestlayout.png)\n\n### layout\n\n1. 系统为什么要有layout过程？\n2. layout过程都干了点什么事？\n\n![view_performlayout](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_performlayout.png)\n\n### draw\n\n1. 系统为什么要有draw过程？\n2. draw过程都干了点什么事？\n\n![view_invalidate](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_invalidate.png)\n\n## LayoutParams\n\nayoutParams翻译过来就是布局参数，子View通过LayoutParams告诉父容器（ViewGroup）应该如何放置自己。从这个定义中也可以看出来LayoutParams与ViewGroup是息息相关的，因此脱离ViewGroup谈LayoutParams是没有意义的。\n\n事实上，每个ViewGroup的子类都有自己对应的LayoutParams类，典型的如LinearLayout.LayoutParams和FrameLayout.LayoutParams等，可以看出来LayoutParams都是对应ViewGroup子类的内部类\n\n### MarginLayoutParams\n\nMarginLayoutParams是和外间距有关的。事实也确实如此，和LayoutParams相比，MarginLayoutParams只是增加了对上下左右外间距的支持。实际上大部分LayoutParams的实现类都是继承自MarginLayoutParams，因为基本所有的父容器都是支持子View设置外间距的\n\n- 属性优先级问题\n  MarginLayoutParams主要就是增加了上下左右4种外间距。在构造方法中，先是获取了margin属性；如果该值不合法，就获取horizontalMargin；如果该值不合法，再去获取leftMargin和rightMargin属性（verticalMargin、topMargin和bottomMargin同理）。我们可以据此总结出这几种属性的优先级\n\n> margin > horizontalMargin和verticalMargin > leftMargin和RightMargin、topMargin和bottomMargin\n\n- 属性覆盖问题\n  优先级更高的属性会覆盖掉优先级较低的属性。此外，还要注意一下这几种属性上的注释\n\n> Call {@link ViewGroup#setLayoutParams(LayoutParams)} after reassigning a new value\n\n### LayoutParams与View如何建立联系\n\n- 在XML中定义View\n- 在Java代码中直接生成View对应的实例对象\n\n### addView\n\n```java\n/**\n * 重载方法1：添加一个子View\n * 如果这个子View还没有LayoutParams，就为子View设置当前ViewGroup默认的LayoutParams\n */\npublic void addView(View child) {\n    addView(child, -1);\n}\n\n/**\n * 重载方法2：在指定位置添加一个子View\n * 如果这个子View还没有LayoutParams，就为子View设置当前ViewGroup默认的LayoutParams\n * @param index View将在ViewGroup中被添加的位置（-1代表添加到末尾）\n */\npublic void addView(View child, int index) {\n    if (child == null) {\n        throw new IllegalArgumentException(\"Cannot add a null child view to a ViewGroup\");\n    }\n    LayoutParams params = child.getLayoutParams();\n    if (params == null) {\n        params = generateDefaultLayoutParams();// 生成当前ViewGroup默认的LayoutParams\n        if (params == null) {\n            throw new IllegalArgumentException(\"generateDefaultLayoutParams() cannot return null\");\n        }\n    }\n    addView(child, index, params);\n}\n\n/**\n * 重载方法3：添加一个子View\n * 使用当前ViewGroup默认的LayoutParams，并以传入参数作为LayoutParams的width和height\n */\npublic void addView(View child, int width, int height) {\n    final LayoutParams params = generateDefaultLayoutParams();  // 生成当前ViewGroup默认的LayoutParams\n    params.width = width;\n    params.height = height;\n    addView(child, -1, params);\n}\n\n/**\n * 重载方法4：添加一个子View，并使用传入的LayoutParams\n */\n@Override\npublic void addView(View child, LayoutParams params) {\n    addView(child, -1, params);\n}\n\n/**\n * 重载方法4：在指定位置添加一个子View，并使用传入的LayoutParams\n */\npublic void addView(View child, int index, LayoutParams params) {\n    if (child == null) {\n        throw new IllegalArgumentException(\"Cannot add a null child view to a ViewGroup\");\n    }\n\n    // addViewInner() will call child.requestLayout() when setting the new LayoutParams\n    // therefore, we call requestLayout() on ourselves before, so that the child's request\n    // will be blocked at our level\n    requestLayout();\n    invalidate(true);\n    addViewInner(child, index, params, false);\n}\n\nprivate void addViewInner(View child, int index, LayoutParams params,\n        boolean preventRequestLayout) {\n    .....\n    if (mTransition != null) {\n        mTransition.addChild(this, child);\n    }\n\n    if (!checkLayoutParams(params)) { // ① 检查传入的LayoutParams是否合法\n        params = generateLayoutParams(params); // 如果传入的LayoutParams不合法，将进行转化操作\n    }\n\n    if (preventRequestLayout) { // ② 是否需要阻止重新执行布局流程\n        child.mLayoutParams = params; // 这不会引起子View重新布局（onMeasure->onLayout->onDraw）\n    } else {\n        child.setLayoutParams(params); // 这会引起子View重新布局（onMeasure->onLayout->onDraw）\n    }\n\n    if (index < 0) {\n        index = mChildrenCount;\n    }\n\n    addInArray(child, index);\n\n    // tell our children\n    if (preventRequestLayout) {\n        child.assignParent(this);\n    } else {\n        child.mParent = this;\n    }\n    .....\n}\n\n```\n\n### 自定义LayoutParams\n\n1. 创建自定义属性\n\n```java\n<resources>\n    <declare-styleable name=\"xxxViewGroup_Layout\">\n        <!-- 自定义的属性 -->\n        <attr name=\"layout_simple_attr\" format=\"integer\"/>\n        <!-- 使用系统预置的属性 -->\n        <attr name=\"android:layout_gravity\"/>\n    </declare-styleable>\n</resources>\n```\n\n2. 继承MarginLayout\n\n```java\npublic static class LayoutParams extends ViewGroup.MarginLayoutParams {\n    public int simpleAttr;\n    public int gravity;\n\n    public LayoutParams(Context c, AttributeSet attrs) {\n        super(c, attrs);\n        // 解析布局属性\n        TypedArray typedArray = c.obtainStyledAttributes(attrs, R.styleable.SimpleViewGroup_Layout);\n        simpleAttr = typedArray.getInteger(R.styleable.SimpleViewGroup_Layout_layout_simple_attr, 0);\n        gravity=typedArray.getInteger(R.styleable.SimpleViewGroup_Layout_android_layout_gravity, -1);\n\n        typedArray.recycle();//释放资源\n    }\n\n    public LayoutParams(int width, int height) {\n        super(width, height);\n    }\n\n    public LayoutParams(MarginLayoutParams source) {\n        super(source);\n    }\n\n    public LayoutParams(ViewGroup.LayoutParams source) {\n        super(source);\n    }\n}\n```\n\n3. 重写ViewGroup中几个与LayoutParams相关的方法\n\n```java\n// 检查LayoutParams是否合法\n@Override\nprotected boolean checkLayoutParams(ViewGroup.LayoutParams p) { \n    return p instanceof SimpleViewGroup.LayoutParams;\n}\n\n// 生成默认的LayoutParams\n@Override\nprotected ViewGroup.LayoutParams generateDefaultLayoutParams() { \n    return new SimpleViewGroup.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);\n}\n\n// 对传入的LayoutParams进行转化\n@Override\nprotected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) { \n    return new SimpleViewGroup.LayoutParams(p);\n}\n\n// 对传入的LayoutParams进行转化\n@Override\npublic ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) { \n    return new SimpleViewGroup.LayoutParams(getContext(), attrs);\n}\n```\n\n### LayoutParams常见的子类\n\n在为View设置LayoutParams的时候需要根据它的父容器选择对应的LayoutParams，否则结果可能与预期不一致，这里简单罗列一些常见的LayoutParams子类：\n\n- ViewGroup.MarginLayoutParams\n- FrameLayout.LayoutParams\n- LinearLayout.LayoutParams\n- RelativeLayout.LayoutParams\n- RecyclerView.LayoutParams\n- GridLayoutManager.LayoutParams\n- StaggeredGridLayoutManager.LayoutParams\n- ViewPager.LayoutParams\n- WindowManager.LayoutParams\n\n## MeasureSpec\n\n### 定义\n\n测量规格,封装了父容器对 view 的布局上的限制，内部提供了宽高的信息（ SpecMode 、 SpecSize ），SpecSize是指在某种SpecMode下的参考尺寸，其中SpecMode 有如下三种：\n\n- UNSPECIFIED\n  不指定测量模式，父控件不对你有任何限制，你想要多大给你多大，想上天就上天。这种情况一般用于系统内部，表示一种测量状态。（这个模式主要用于系统内部多次Measure的情形，并不是真的说你想要多大最后就真有多大，开发中很少用到）\n\n- EXACTLY\n  精确测量模式，当该视图的宽高为match_parent或者具体数值时生效，表示父布局已经决定了子视图的精确大小，View的测量值就是SpecSize。\n\n- AT_MOST\n  当该视图的宽高为wrap_content时生效，你的大小不能大于父控件给你指定的size，但具体是多少，得看你自己的实现。\n  MeasureSpecs（32位的Int）=SpecMode（高2位） + SpecSize（低30位）\n\n  ```java\n  //获取尚未显示的view的宽和高\n  int tempWidth =View.MeasureSpec.makeMeasureSpec(0,View.MeasureSpec.UNSPECIFIED);\n  int tempHeight =View.MeasureSpec.makeMeasureSpec(0,View.MeasureSpec.UNSPECIFIED);\n  view.measure(tempWidth,tempHeight);\n  int realHeight=view.getMeasuredHeight(); \n  int realWidth=view.getMeasuredWidth();\n  ```\n\n  \n\n### MeasureSpecs 的意义\n\n通过将 SpecMode 和 SpecSize 打包成一个 int 值可以避免过多的对象内存分配，为了方便操作，其提供了打包 / 解包方法\n\n### MeasureSpec值的确定\n\nMeasureSpec值到底是如何计算得来的呢?\n\n对于DecorView而言，他的MeasureSpecs是由自身窗口大小和自身的LayoutParams共同决定的，子View的MeasureSpec值是根据子View的布局参数（LayoutParams）和父容器的MeasureSpec值计算得来的，具体计算逻辑封装在getChildMeasureSpec()里\n\n```java\n    private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {\n        ...\n        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n        ...\n    }\n```\n\n具体的测量操作是分发给ViewGroup的，由ViewGroup的measureChildren方法传递为子View，如下\n\n```java\n   protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {\n        final int size = mChildrenCount;\n        final View[] children = mChildren;\n        for (int i = 0; i < size; ++i) {\n            final View child = children[i];\n            if ((child.mViewFlags & VISIBILITY_MASK) != GONE) {\n                //测量指定的View\n                measureChild(child, widthMeasureSpec, heightMeasureSpec);\n            }\n        }\n    }\n```\n\n测量指定的View\n\n```java\n    protected void measureChild(View child, int parentWidthMeasureSpec,\n            int parentHeightMeasureSpec) {\n        final LayoutParams lp = child.getLayoutParams();\n\t\t//根据父容器的MeasureSpec和子View的布局参数（LayoutParams）计算子View的MeasureSpec\n        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,\n                mPaddingLeft + mPaddingRight, lp.width);\n        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,\n                mPaddingTop + mPaddingBottom, lp.height);\n\n        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n    }\n```\n\n\n\n子View的MeasureSpec值是根据子View的布局参数（LayoutParams）和父容器的MeasureSpec值计算得来的，具体计算逻辑封装在getChildMeasureSpec()里\n\n```java\n  /**\n     *\n     * 目标是将父控件的测量规格和child view的布局参数LayoutParams相结合，得到一个\n     * 最可能符合条件的child view的测量规格。  \n\n     * @param spec 父控件的测量规格\n     * @param padding 父控件里已经占用的大小\n     * @param childDimension child view布局LayoutParams里的尺寸\n     * @return child view 的测量规格\n     */\n    public static int getChildMeasureSpec(int spec, int padding, int childDimension) {\n        int specMode = MeasureSpec.getMode(spec); //父控件的测量模式\n        int specSize = MeasureSpec.getSize(spec); //父控件的测量大小\n\n        int size = Math.max(0, specSize - padding);\n\n        int resultSize = 0;\n        int resultMode = 0;\n\n        switch (specMode) {\n        // 当父控件的测量模式 是 精确模式，也就是有精确的尺寸了\n        case MeasureSpec.EXACTLY:\n            //如果child的布局参数有固定值，比如\"layout_width\" = \"100dp\"\n            //那么显然child的测量规格也可以确定下来了，测量大小就是100dp，测量模式也是EXACTLY\n            if (childDimension >= 0) {\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } \n\n            //如果child的布局参数是\"match_parent\"，也就是想要占满父控件\n            //而此时父控件是精确模式，也就是能确定自己的尺寸了，那child也能确定自己大小了\n            else if (childDimension == LayoutParams.MATCH_PARENT) {\n                resultSize = size;\n                resultMode = MeasureSpec.EXACTLY;\n            }\n            //如果child的布局参数是\"wrap_content\"，也就是想要根据自己的逻辑决定自己大小，\n            //比如TextView根据设置的字符串大小来决定自己的大小\n            //那就自己决定呗，不过你的大小肯定不能大于父控件的大小嘛\n            //所以测量模式就是AT_MOST，测量大小就是父控件的size\n            else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            }\n            break;\n\n        // 当父控件的测量模式 是 最大模式，也就是说父控件自己还不知道自己的尺寸，但是大小不能超过size\n        case MeasureSpec.AT_MOST:\n            //同样的，既然child能确定自己大小，尽管父控件自己还不知道自己大小，也优先满足孩子的需求\n            if (childDimension >= 0) {\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } \n            //child想要和父控件一样大，但父控件自己也不确定自己大小，所以child也无法确定自己大小\n            //但同样的，child的尺寸上限也是父控件的尺寸上限size\n            else if (childDimension == LayoutParams.MATCH_PARENT) {\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            }\n            //child想要根据自己逻辑决定大小，那就自己决定呗\n            else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            }\n            break;\n\n        // Parent asked to see how big we want to be\n        case MeasureSpec.UNSPECIFIED:\n            if (childDimension >= 0) {\n                // Child wants a specific size... let him have it\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == LayoutParams.MATCH_PARENT) {\n                // Child wants to be our size... find out how big it should\n                // be\n                resultSize = 0;\n                resultMode = MeasureSpec.UNSPECIFIED;\n            } else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                // Child wants to determine its own size.... find out how\n                // big it should be\n                resultSize = 0;\n                resultMode = MeasureSpec.UNSPECIFIED;\n            }\n            break;\n        }\n        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);\n    }\n```\n\n![measurespec3](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/measurespec3.png)\n针对上表，这里再做一下具体的说明\n\n- 对于应用层 View ，其 MeasureSpec 由父容器的 MeasureSpec 和自身的 LayoutParams 来共同决定\n\n- 对于不同的父容器和view本身不同的LayoutParams，view就可以有多种MeasureSpec。\n      1.  当view采用固定宽高的时候，不管父容器的MeasureSpec是什么，view的MeasureSpec都是精确模式并且其大小遵循Layoutparams中的大小；\n      2. 当view的宽高是match_parent时，这个时候如果父容器的模式是精准模式，那么view也是精准模式并且其大小是父容器的剩余空间，如果父容器是最大模式，那么view也是最大模式并且其大小不会超过父容器的剩余空间；\n      3.  当view的宽高是wrap_content时，不管父容器的模式是精准还是最大化，view的模式总是最大化并且大小不能超过父容器的剩余空间。\n      4. Unspecified模式，这个模式主要用于系统内部多次measure的情况下，一般来说，我们不需要关注此模式(这里注意自定义View放到ScrollView的情况 需要处理)。\n\n  \n\n  ### View （ViewGroup）的measure方法\n\n  最终是通过回调onMeasure方法实现的，这个方法通常有View的特定子类的方法去实现的，通过重写这个View实现自定义View。\n\n```\n    public final void measure(int widthMeasureSpec, int heightMeasureSpec) {\n        ...\n        onMeasure(widthMeasureSpec, heightMeasureSpec);\n        ...\n    }\n\n```\n\n```\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n    \t//设置size\n        setMeasuredDimension(1,1);\n    }\n```\n\n-------------------\n\n```java\nonMeasure()\n//1. 测量自身\n//2. 为每个子View计算测量的限制信息 Mode / Size\n//3. 把上一步确定的限制信息，传递给每一个子View，然后子View开始measure\n//4. 获取子View测量完成后的尺寸\n//5. ViewGroup根据自身的情况，计算自己的尺寸\n//6. 保存自身的尺寸\n```\n\n```java\nonLayout()\n//1. 遍历子View for\n//2. 确定自己的规则\n//3. 获取子View的测量尺寸\n//4. 确定子View的left,top,right,bottom\n//6. 调用child.layout\n```\n\n------------------\n\n1. **简介**：点、线、矩形、多边形、 弧、圆等。\n\n2. **Paint**\n\n   2.1 常用属性\n\n   ​    mPaint.setARGB();//设置画笔的A、R、G、B值 \n\n   ​    mPaint.setStyle();//设置画笔的风格(空心或实心)\n\n   ​    mPaint.setColor();//设置画笔的颜色\n\n   ​    mPaint.setAlpha();//设置画笔的Alpha \n\n   ​    mPaint.setAntiAlias();// 设置画笔的锯齿效果\n\n   ​    mPaint.setTextSize();\n\n   ​    mPaint.setStrokeWidth();//设置空心边框的宽度\n\n      2.2 常用style \n\n   ​        Paint.Style.FILL   //填充\n\n   ​        Paint.Style.STROKE//空心\n\n      2.3 注意:用到paint的不同属性时，创建多个画笔，因为ondraw的代码并不是马上就执行 \n\n3. **常用的画图方法**\n\n   3.1 drawPoint(x,y,paint)//点\n\n   3.2 drawLine(startX,startY,endX,endY,paint)//线\n\n   3.3 drawLines(pts,paint)//绘制多条线，float[] pts=new flaot{startX1,startY1,endX1,endY1,startX2,startY2,endX2,endY2},每够4个float是一条线\n\n   3.4 drawRect(l,t,r,b,paint)//矩形\n\n   3.5 drawPoundRect(l,t,r,b,radiusX,radiusY,paint)//圆角矩形，radiusX,radiusY分别是每一个角的x和y轴上的弧度长度\n\n   3.6 drawtCircle(circleX,circleY,radius，paint)//圆\n\n   3.7 drawArc(l,t,r,b,startAngle,sweepAngle,useCenter,paint)//圆弧，useCenter是否与圆心连线\n\n   3.8 drawOval(l,t,r,b,paint)//椭圆\n\n   3.9 drawText(text,startX，startY,paint)//文本\n\n   3.10 canvas.drawPosText(text, new float[]{x1, y1, x2, y2, x3, y3}mPaint);//指定位置绘制文本，text的个数必须和float的点数一致,已过时\n\n   3.11 drawTextOnPath(text,path,hOffset,vOffset,paint)//给据路径画文字，hOffset角度偏移量，vOffset半径偏移量\n\n   3.12 drawPath(path,paint)//画路径\n\n   \n\n   4.**Path的用法**//http://blog.sina.com.cn/s/blog_4d9c3fec0102vyhs.html\n\n5. **Canvas常用方法**\n\n   5.1 save()//将已经绘制好的图像保存起来\n\n   5.2 restore()//删除所有对矩阵/剪辑状态的修改，自上次保存调用\n\n   5.3 restoreToCount//\n\n   5.4 translate(x,y)//将原始的画布原点（0,0）平移到（x,y）\n\n   5.5 rotate()//将坐标系旋转一定的角度\n\n   5.6 drawColor()//设置画布的颜色  \n\n","source":"_posts/Android 基础/View/Android 自定义 View.md","raw":"---\ntitle: Android自定义View\ntag: Android View\n---\n\n\n[TOC]\n\n## 概述\n\n### Android开发进阶的必经之路\n\n### 为什么要自定义View\n\n### 自定义View的基本方法\n\n自定义View的最基本的三个方法分别是： onMeasure()、onLayout()、onDraw();\nView在Activity中显示出来，要经历测量、布局和绘制三个步骤，分别对应三个动作：measure、layout和draw。\n<!-- more-->\n\n- 测量：onMeasure()决定View的大小；\n- 布局：onLayout()决定View在ViewGroup中的位置；\n- 绘制：onDraw()决定绘制这个View。\n\n### 自定义控件分类\n\n- 自定义View: 只需要重写onMeasure()和onDraw()\n- 自定义ViewGroup: 则只需要重写onMeasure()和onLayout()\n\n## 自定义View基础\n\n### View的分类\n\n视图View主要分为两类\n\n| 类别     | 解释                                      | 特点         |\n| -------- | ----------------------------------------- | ------------ |\n| 单一视图 | 即一个View，如TextView                    | 不包含子View |\n| 视图组   | 即多个View组成的ViewGroup，如LinearLayout | 包含子View   |\n\n### View类简介\n\n- View类是Android中各种组件的基类，如View是ViewGroup基类\n- View表现为显示在屏幕上的各种视图\n\n> Android中的UI组件都由View、ViewGroup组成。\n\n- View的构造函数：共有4个\n\n  ```java\n  // 如果View是在Java代码里面new的，则调用第一个构造函数\n   public CarsonView(Context context) {\n          super(context);\n      }\n  \n  // 如果View是在.xml里声明的，则调用第二个构造函数\n  // 自定义属性是从AttributeSet参数传进来的\n      public  CarsonView(Context context, AttributeSet attrs) {\n          super(context, attrs);\n      }\n  \n  // 不会自动调用\n  // 一般是在第二个构造函数里主动调用\n  // 如View有style属性时\n      public  CarsonView(Context context, AttributeSet attrs, int defStyleAttr) {\n          super(context, attrs, defStyleAttr);\n      }\n  \n      //API21之后才使用\n      // 不会自动调用\n      // 一般是在第二个构造函数里主动调用\n      // 如View有style属性时\n      public  CarsonView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {\n          super(context, attrs, defStyleAttr, defStyleRes);\n      }\n  ```\n\n### AttributeSet与自定义属性\n\n　系统自带的View可以在xml中配置属性，对于写的好的自定义View同样可以在xml中配置属性，为了使自定义的View的属性可以在xml中配置，需要以下4个步骤：\n\n1. 通过```<declare-styleable>```为自定义View添加属性\n2. 在xml中为相应的属性声明属性值\n3. 在运行时（一般为构造函数）获取属性值\n4. 将获取到的属性值应用到View\n\n\n\n### View视图结构\n\n1. PhoneWindow是Android系统中最基本的窗口系统，继承自Windows类，负责管理界面显示以及事件响应。它是Activity与View系统交互的接口，每个Activity都会创建一个\n2. DecorView是PhoneWindow中的起始节点View，继承于View类，作为整个视图容器来使用。用于设置窗口属性。它本质上是一个FrameLayout\n3. ViewRoot在Activtiy启动时创建，负责管理、布局、渲染窗口UI等等\n\n![activity](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/activity.png)\n\n对于多View的视图，结构是树形结构：最顶层是ViewGroup，ViewGroup下可能有多个ViewGroup或View，如下图：\n\n![view_arch](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_arch.png)\n\n一定要记住：无论是measure过程、layout过程还是draw过程，永远都是从View树的根节点开始测量或计算（即从树的顶端开始），一层一层、一个分支一个分支地进行（即树形递归），最终计算整个View树中各个View，最终确定整个View树的相关属性。\n\n### Android坐标系\n\nAndroid的坐标系定义为：\n\n- 屏幕的左上角为坐标原点\n- 向右为x轴增大方向\n- 向下为y轴增大方向\n  ![zuobiaoxi](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/zuobiaoxi.png)\n\n> 区别于一般的数学坐标系\n> ![zuobiaoxi_qubie](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/zuobiaoxi_qubie.png)\n\n###  View位置（坐标）描述\n\nView的位置由4个顶点决定的\n4个顶点的位置描述分别由4个值决定：\n\n> 请记住：View的位置是相对于父控件而言的）\n\n- Top：子View上边界到父view上边界的距离\n- Left：子View左边界到父view左边界的距离\n- Bottom：子View下边距到父View上边界的距离\n- Right：子View右边界到父view左边界的距离\n\n### 位置获取方式\n\nView的位置是通过view.getxxx()函数进行获取：（以Top为例）\n\n```java\n// 获取Top位置\npublic final int getTop() {  \n    return mTop;  \n}  \n\n// 其余如下：\n  getLeft();      //获取子View左上角距父View左侧的距离\n  getBottom();    //获取子View右下角距父View顶部的距离\n  getRight();     //获取子View右下角距父View左侧的距离\n```\n\n与MotionEvent中 get()和getRaw()的区别\n\n```java\n//get() ：触摸点相对于其所在组件坐标系的坐标\n event.getX();       \n event.getY();\n\n//getRaw() ：触摸点相对于屏幕默认坐标系的坐标\n event.getRawX();    \n event.getRawY();\n```\n\n![zuobiaoxiweizhi](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/zuobiaoxiweizhi.png)\n\n### Android中颜色相关内容\n\nAndroid支持的颜色模式：\n![color1](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/color1.png)\n\n以ARGB8888为例介绍颜色定义:\n![color2](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/color2.png)\n\n## View树的绘制流程\n\n### View树的绘制流程是谁负责的？\n\nview树的绘制流程是通过ViewRoot去负责绘制的，ViewRoot这个类的命名有点坑，最初看到这个名字，翻译过来是view的根节点，但是事实完全不是这样，ViewRoot其实不是View的根节点，它连view节点都算不上，它的主要作用是View树的管理者，负责将DecorView和PhoneWindow“组合”起来，而View树的根节点严格意义上来说只有DecorView；每个DecorView都有一个ViewRoot与之关联，这种关联关系是由WindowManager去进行管理的；绘制就是从ViewRoot.performTraversals()开始的。\n\n```java\n  private void performTraversals() {\n        .....\n        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);\n        .....\n        performLayout(lp, mWidth, mHeight);\n        .....\n        performDraw();\n        .....\n    }\n```\n\n\n\n### view的添加\n\n![](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_qiyuan.png)\n\n### view的绘制流程\n\n![view_traversals](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_traversals.png)\n\n### measure\n\n1. 系统为什么要有measure过程？\n\n   ```xml\n       <TextView\n           android:layout_width=\"wrap_content\"\n           android:layout_height=\"match_parent\"\n           android:text=\"Hello World!\" />\n   ```\n\n   谷歌建议使用自适应，自适应的话，就不知道大小，所以需要去测量。\n\n2. measure过程都干了点什么事？\n\n3. 对于自适应的尺寸机制，如何合理的测量一颗View树？\n\n4. 那么ViewGroup是如何向子View传递限制信息的？\n\n5. ScrollView嵌套ListView问题？\n\n![view_requestlayout](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_requestlayout.png)\n\n### layout\n\n1. 系统为什么要有layout过程？\n2. layout过程都干了点什么事？\n\n![view_performlayout](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_performlayout.png)\n\n### draw\n\n1. 系统为什么要有draw过程？\n2. draw过程都干了点什么事？\n\n![view_invalidate](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_invalidate.png)\n\n## LayoutParams\n\nayoutParams翻译过来就是布局参数，子View通过LayoutParams告诉父容器（ViewGroup）应该如何放置自己。从这个定义中也可以看出来LayoutParams与ViewGroup是息息相关的，因此脱离ViewGroup谈LayoutParams是没有意义的。\n\n事实上，每个ViewGroup的子类都有自己对应的LayoutParams类，典型的如LinearLayout.LayoutParams和FrameLayout.LayoutParams等，可以看出来LayoutParams都是对应ViewGroup子类的内部类\n\n### MarginLayoutParams\n\nMarginLayoutParams是和外间距有关的。事实也确实如此，和LayoutParams相比，MarginLayoutParams只是增加了对上下左右外间距的支持。实际上大部分LayoutParams的实现类都是继承自MarginLayoutParams，因为基本所有的父容器都是支持子View设置外间距的\n\n- 属性优先级问题\n  MarginLayoutParams主要就是增加了上下左右4种外间距。在构造方法中，先是获取了margin属性；如果该值不合法，就获取horizontalMargin；如果该值不合法，再去获取leftMargin和rightMargin属性（verticalMargin、topMargin和bottomMargin同理）。我们可以据此总结出这几种属性的优先级\n\n> margin > horizontalMargin和verticalMargin > leftMargin和RightMargin、topMargin和bottomMargin\n\n- 属性覆盖问题\n  优先级更高的属性会覆盖掉优先级较低的属性。此外，还要注意一下这几种属性上的注释\n\n> Call {@link ViewGroup#setLayoutParams(LayoutParams)} after reassigning a new value\n\n### LayoutParams与View如何建立联系\n\n- 在XML中定义View\n- 在Java代码中直接生成View对应的实例对象\n\n### addView\n\n```java\n/**\n * 重载方法1：添加一个子View\n * 如果这个子View还没有LayoutParams，就为子View设置当前ViewGroup默认的LayoutParams\n */\npublic void addView(View child) {\n    addView(child, -1);\n}\n\n/**\n * 重载方法2：在指定位置添加一个子View\n * 如果这个子View还没有LayoutParams，就为子View设置当前ViewGroup默认的LayoutParams\n * @param index View将在ViewGroup中被添加的位置（-1代表添加到末尾）\n */\npublic void addView(View child, int index) {\n    if (child == null) {\n        throw new IllegalArgumentException(\"Cannot add a null child view to a ViewGroup\");\n    }\n    LayoutParams params = child.getLayoutParams();\n    if (params == null) {\n        params = generateDefaultLayoutParams();// 生成当前ViewGroup默认的LayoutParams\n        if (params == null) {\n            throw new IllegalArgumentException(\"generateDefaultLayoutParams() cannot return null\");\n        }\n    }\n    addView(child, index, params);\n}\n\n/**\n * 重载方法3：添加一个子View\n * 使用当前ViewGroup默认的LayoutParams，并以传入参数作为LayoutParams的width和height\n */\npublic void addView(View child, int width, int height) {\n    final LayoutParams params = generateDefaultLayoutParams();  // 生成当前ViewGroup默认的LayoutParams\n    params.width = width;\n    params.height = height;\n    addView(child, -1, params);\n}\n\n/**\n * 重载方法4：添加一个子View，并使用传入的LayoutParams\n */\n@Override\npublic void addView(View child, LayoutParams params) {\n    addView(child, -1, params);\n}\n\n/**\n * 重载方法4：在指定位置添加一个子View，并使用传入的LayoutParams\n */\npublic void addView(View child, int index, LayoutParams params) {\n    if (child == null) {\n        throw new IllegalArgumentException(\"Cannot add a null child view to a ViewGroup\");\n    }\n\n    // addViewInner() will call child.requestLayout() when setting the new LayoutParams\n    // therefore, we call requestLayout() on ourselves before, so that the child's request\n    // will be blocked at our level\n    requestLayout();\n    invalidate(true);\n    addViewInner(child, index, params, false);\n}\n\nprivate void addViewInner(View child, int index, LayoutParams params,\n        boolean preventRequestLayout) {\n    .....\n    if (mTransition != null) {\n        mTransition.addChild(this, child);\n    }\n\n    if (!checkLayoutParams(params)) { // ① 检查传入的LayoutParams是否合法\n        params = generateLayoutParams(params); // 如果传入的LayoutParams不合法，将进行转化操作\n    }\n\n    if (preventRequestLayout) { // ② 是否需要阻止重新执行布局流程\n        child.mLayoutParams = params; // 这不会引起子View重新布局（onMeasure->onLayout->onDraw）\n    } else {\n        child.setLayoutParams(params); // 这会引起子View重新布局（onMeasure->onLayout->onDraw）\n    }\n\n    if (index < 0) {\n        index = mChildrenCount;\n    }\n\n    addInArray(child, index);\n\n    // tell our children\n    if (preventRequestLayout) {\n        child.assignParent(this);\n    } else {\n        child.mParent = this;\n    }\n    .....\n}\n\n```\n\n### 自定义LayoutParams\n\n1. 创建自定义属性\n\n```java\n<resources>\n    <declare-styleable name=\"xxxViewGroup_Layout\">\n        <!-- 自定义的属性 -->\n        <attr name=\"layout_simple_attr\" format=\"integer\"/>\n        <!-- 使用系统预置的属性 -->\n        <attr name=\"android:layout_gravity\"/>\n    </declare-styleable>\n</resources>\n```\n\n2. 继承MarginLayout\n\n```java\npublic static class LayoutParams extends ViewGroup.MarginLayoutParams {\n    public int simpleAttr;\n    public int gravity;\n\n    public LayoutParams(Context c, AttributeSet attrs) {\n        super(c, attrs);\n        // 解析布局属性\n        TypedArray typedArray = c.obtainStyledAttributes(attrs, R.styleable.SimpleViewGroup_Layout);\n        simpleAttr = typedArray.getInteger(R.styleable.SimpleViewGroup_Layout_layout_simple_attr, 0);\n        gravity=typedArray.getInteger(R.styleable.SimpleViewGroup_Layout_android_layout_gravity, -1);\n\n        typedArray.recycle();//释放资源\n    }\n\n    public LayoutParams(int width, int height) {\n        super(width, height);\n    }\n\n    public LayoutParams(MarginLayoutParams source) {\n        super(source);\n    }\n\n    public LayoutParams(ViewGroup.LayoutParams source) {\n        super(source);\n    }\n}\n```\n\n3. 重写ViewGroup中几个与LayoutParams相关的方法\n\n```java\n// 检查LayoutParams是否合法\n@Override\nprotected boolean checkLayoutParams(ViewGroup.LayoutParams p) { \n    return p instanceof SimpleViewGroup.LayoutParams;\n}\n\n// 生成默认的LayoutParams\n@Override\nprotected ViewGroup.LayoutParams generateDefaultLayoutParams() { \n    return new SimpleViewGroup.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);\n}\n\n// 对传入的LayoutParams进行转化\n@Override\nprotected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) { \n    return new SimpleViewGroup.LayoutParams(p);\n}\n\n// 对传入的LayoutParams进行转化\n@Override\npublic ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) { \n    return new SimpleViewGroup.LayoutParams(getContext(), attrs);\n}\n```\n\n### LayoutParams常见的子类\n\n在为View设置LayoutParams的时候需要根据它的父容器选择对应的LayoutParams，否则结果可能与预期不一致，这里简单罗列一些常见的LayoutParams子类：\n\n- ViewGroup.MarginLayoutParams\n- FrameLayout.LayoutParams\n- LinearLayout.LayoutParams\n- RelativeLayout.LayoutParams\n- RecyclerView.LayoutParams\n- GridLayoutManager.LayoutParams\n- StaggeredGridLayoutManager.LayoutParams\n- ViewPager.LayoutParams\n- WindowManager.LayoutParams\n\n## MeasureSpec\n\n### 定义\n\n测量规格,封装了父容器对 view 的布局上的限制，内部提供了宽高的信息（ SpecMode 、 SpecSize ），SpecSize是指在某种SpecMode下的参考尺寸，其中SpecMode 有如下三种：\n\n- UNSPECIFIED\n  不指定测量模式，父控件不对你有任何限制，你想要多大给你多大，想上天就上天。这种情况一般用于系统内部，表示一种测量状态。（这个模式主要用于系统内部多次Measure的情形，并不是真的说你想要多大最后就真有多大，开发中很少用到）\n\n- EXACTLY\n  精确测量模式，当该视图的宽高为match_parent或者具体数值时生效，表示父布局已经决定了子视图的精确大小，View的测量值就是SpecSize。\n\n- AT_MOST\n  当该视图的宽高为wrap_content时生效，你的大小不能大于父控件给你指定的size，但具体是多少，得看你自己的实现。\n  MeasureSpecs（32位的Int）=SpecMode（高2位） + SpecSize（低30位）\n\n  ```java\n  //获取尚未显示的view的宽和高\n  int tempWidth =View.MeasureSpec.makeMeasureSpec(0,View.MeasureSpec.UNSPECIFIED);\n  int tempHeight =View.MeasureSpec.makeMeasureSpec(0,View.MeasureSpec.UNSPECIFIED);\n  view.measure(tempWidth,tempHeight);\n  int realHeight=view.getMeasuredHeight(); \n  int realWidth=view.getMeasuredWidth();\n  ```\n\n  \n\n### MeasureSpecs 的意义\n\n通过将 SpecMode 和 SpecSize 打包成一个 int 值可以避免过多的对象内存分配，为了方便操作，其提供了打包 / 解包方法\n\n### MeasureSpec值的确定\n\nMeasureSpec值到底是如何计算得来的呢?\n\n对于DecorView而言，他的MeasureSpecs是由自身窗口大小和自身的LayoutParams共同决定的，子View的MeasureSpec值是根据子View的布局参数（LayoutParams）和父容器的MeasureSpec值计算得来的，具体计算逻辑封装在getChildMeasureSpec()里\n\n```java\n    private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {\n        ...\n        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n        ...\n    }\n```\n\n具体的测量操作是分发给ViewGroup的，由ViewGroup的measureChildren方法传递为子View，如下\n\n```java\n   protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {\n        final int size = mChildrenCount;\n        final View[] children = mChildren;\n        for (int i = 0; i < size; ++i) {\n            final View child = children[i];\n            if ((child.mViewFlags & VISIBILITY_MASK) != GONE) {\n                //测量指定的View\n                measureChild(child, widthMeasureSpec, heightMeasureSpec);\n            }\n        }\n    }\n```\n\n测量指定的View\n\n```java\n    protected void measureChild(View child, int parentWidthMeasureSpec,\n            int parentHeightMeasureSpec) {\n        final LayoutParams lp = child.getLayoutParams();\n\t\t//根据父容器的MeasureSpec和子View的布局参数（LayoutParams）计算子View的MeasureSpec\n        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,\n                mPaddingLeft + mPaddingRight, lp.width);\n        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,\n                mPaddingTop + mPaddingBottom, lp.height);\n\n        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n    }\n```\n\n\n\n子View的MeasureSpec值是根据子View的布局参数（LayoutParams）和父容器的MeasureSpec值计算得来的，具体计算逻辑封装在getChildMeasureSpec()里\n\n```java\n  /**\n     *\n     * 目标是将父控件的测量规格和child view的布局参数LayoutParams相结合，得到一个\n     * 最可能符合条件的child view的测量规格。  \n\n     * @param spec 父控件的测量规格\n     * @param padding 父控件里已经占用的大小\n     * @param childDimension child view布局LayoutParams里的尺寸\n     * @return child view 的测量规格\n     */\n    public static int getChildMeasureSpec(int spec, int padding, int childDimension) {\n        int specMode = MeasureSpec.getMode(spec); //父控件的测量模式\n        int specSize = MeasureSpec.getSize(spec); //父控件的测量大小\n\n        int size = Math.max(0, specSize - padding);\n\n        int resultSize = 0;\n        int resultMode = 0;\n\n        switch (specMode) {\n        // 当父控件的测量模式 是 精确模式，也就是有精确的尺寸了\n        case MeasureSpec.EXACTLY:\n            //如果child的布局参数有固定值，比如\"layout_width\" = \"100dp\"\n            //那么显然child的测量规格也可以确定下来了，测量大小就是100dp，测量模式也是EXACTLY\n            if (childDimension >= 0) {\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } \n\n            //如果child的布局参数是\"match_parent\"，也就是想要占满父控件\n            //而此时父控件是精确模式，也就是能确定自己的尺寸了，那child也能确定自己大小了\n            else if (childDimension == LayoutParams.MATCH_PARENT) {\n                resultSize = size;\n                resultMode = MeasureSpec.EXACTLY;\n            }\n            //如果child的布局参数是\"wrap_content\"，也就是想要根据自己的逻辑决定自己大小，\n            //比如TextView根据设置的字符串大小来决定自己的大小\n            //那就自己决定呗，不过你的大小肯定不能大于父控件的大小嘛\n            //所以测量模式就是AT_MOST，测量大小就是父控件的size\n            else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            }\n            break;\n\n        // 当父控件的测量模式 是 最大模式，也就是说父控件自己还不知道自己的尺寸，但是大小不能超过size\n        case MeasureSpec.AT_MOST:\n            //同样的，既然child能确定自己大小，尽管父控件自己还不知道自己大小，也优先满足孩子的需求\n            if (childDimension >= 0) {\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } \n            //child想要和父控件一样大，但父控件自己也不确定自己大小，所以child也无法确定自己大小\n            //但同样的，child的尺寸上限也是父控件的尺寸上限size\n            else if (childDimension == LayoutParams.MATCH_PARENT) {\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            }\n            //child想要根据自己逻辑决定大小，那就自己决定呗\n            else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            }\n            break;\n\n        // Parent asked to see how big we want to be\n        case MeasureSpec.UNSPECIFIED:\n            if (childDimension >= 0) {\n                // Child wants a specific size... let him have it\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == LayoutParams.MATCH_PARENT) {\n                // Child wants to be our size... find out how big it should\n                // be\n                resultSize = 0;\n                resultMode = MeasureSpec.UNSPECIFIED;\n            } else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                // Child wants to determine its own size.... find out how\n                // big it should be\n                resultSize = 0;\n                resultMode = MeasureSpec.UNSPECIFIED;\n            }\n            break;\n        }\n        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);\n    }\n```\n\n![measurespec3](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/measurespec3.png)\n针对上表，这里再做一下具体的说明\n\n- 对于应用层 View ，其 MeasureSpec 由父容器的 MeasureSpec 和自身的 LayoutParams 来共同决定\n\n- 对于不同的父容器和view本身不同的LayoutParams，view就可以有多种MeasureSpec。\n      1.  当view采用固定宽高的时候，不管父容器的MeasureSpec是什么，view的MeasureSpec都是精确模式并且其大小遵循Layoutparams中的大小；\n      2. 当view的宽高是match_parent时，这个时候如果父容器的模式是精准模式，那么view也是精准模式并且其大小是父容器的剩余空间，如果父容器是最大模式，那么view也是最大模式并且其大小不会超过父容器的剩余空间；\n      3.  当view的宽高是wrap_content时，不管父容器的模式是精准还是最大化，view的模式总是最大化并且大小不能超过父容器的剩余空间。\n      4. Unspecified模式，这个模式主要用于系统内部多次measure的情况下，一般来说，我们不需要关注此模式(这里注意自定义View放到ScrollView的情况 需要处理)。\n\n  \n\n  ### View （ViewGroup）的measure方法\n\n  最终是通过回调onMeasure方法实现的，这个方法通常有View的特定子类的方法去实现的，通过重写这个View实现自定义View。\n\n```\n    public final void measure(int widthMeasureSpec, int heightMeasureSpec) {\n        ...\n        onMeasure(widthMeasureSpec, heightMeasureSpec);\n        ...\n    }\n\n```\n\n```\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n    \t//设置size\n        setMeasuredDimension(1,1);\n    }\n```\n\n-------------------\n\n```java\nonMeasure()\n//1. 测量自身\n//2. 为每个子View计算测量的限制信息 Mode / Size\n//3. 把上一步确定的限制信息，传递给每一个子View，然后子View开始measure\n//4. 获取子View测量完成后的尺寸\n//5. ViewGroup根据自身的情况，计算自己的尺寸\n//6. 保存自身的尺寸\n```\n\n```java\nonLayout()\n//1. 遍历子View for\n//2. 确定自己的规则\n//3. 获取子View的测量尺寸\n//4. 确定子View的left,top,right,bottom\n//6. 调用child.layout\n```\n\n------------------\n\n1. **简介**：点、线、矩形、多边形、 弧、圆等。\n\n2. **Paint**\n\n   2.1 常用属性\n\n   ​    mPaint.setARGB();//设置画笔的A、R、G、B值 \n\n   ​    mPaint.setStyle();//设置画笔的风格(空心或实心)\n\n   ​    mPaint.setColor();//设置画笔的颜色\n\n   ​    mPaint.setAlpha();//设置画笔的Alpha \n\n   ​    mPaint.setAntiAlias();// 设置画笔的锯齿效果\n\n   ​    mPaint.setTextSize();\n\n   ​    mPaint.setStrokeWidth();//设置空心边框的宽度\n\n      2.2 常用style \n\n   ​        Paint.Style.FILL   //填充\n\n   ​        Paint.Style.STROKE//空心\n\n      2.3 注意:用到paint的不同属性时，创建多个画笔，因为ondraw的代码并不是马上就执行 \n\n3. **常用的画图方法**\n\n   3.1 drawPoint(x,y,paint)//点\n\n   3.2 drawLine(startX,startY,endX,endY,paint)//线\n\n   3.3 drawLines(pts,paint)//绘制多条线，float[] pts=new flaot{startX1,startY1,endX1,endY1,startX2,startY2,endX2,endY2},每够4个float是一条线\n\n   3.4 drawRect(l,t,r,b,paint)//矩形\n\n   3.5 drawPoundRect(l,t,r,b,radiusX,radiusY,paint)//圆角矩形，radiusX,radiusY分别是每一个角的x和y轴上的弧度长度\n\n   3.6 drawtCircle(circleX,circleY,radius，paint)//圆\n\n   3.7 drawArc(l,t,r,b,startAngle,sweepAngle,useCenter,paint)//圆弧，useCenter是否与圆心连线\n\n   3.8 drawOval(l,t,r,b,paint)//椭圆\n\n   3.9 drawText(text,startX，startY,paint)//文本\n\n   3.10 canvas.drawPosText(text, new float[]{x1, y1, x2, y2, x3, y3}mPaint);//指定位置绘制文本，text的个数必须和float的点数一致,已过时\n\n   3.11 drawTextOnPath(text,path,hOffset,vOffset,paint)//给据路径画文字，hOffset角度偏移量，vOffset半径偏移量\n\n   3.12 drawPath(path,paint)//画路径\n\n   \n\n   4.**Path的用法**//http://blog.sina.com.cn/s/blog_4d9c3fec0102vyhs.html\n\n5. **Canvas常用方法**\n\n   5.1 save()//将已经绘制好的图像保存起来\n\n   5.2 restore()//删除所有对矩阵/剪辑状态的修改，自上次保存调用\n\n   5.3 restoreToCount//\n\n   5.4 translate(x,y)//将原始的画布原点（0,0）平移到（x,y）\n\n   5.5 rotate()//将坐标系旋转一定的角度\n\n   5.6 drawColor()//设置画布的颜色  \n\n","slug":"Android 基础/View/Android 自定义 View","published":1,"date":"2021-01-29T15:54:28.288Z","updated":"2021-01-29T16:18:01.765Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8jn002ysz5q53dba459","content":"<p>[TOC]</p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"Android开发进阶的必经之路\"><a href=\"#Android开发进阶的必经之路\" class=\"headerlink\" title=\"Android开发进阶的必经之路\"></a>Android开发进阶的必经之路</h3><h3 id=\"为什么要自定义View\"><a href=\"#为什么要自定义View\" class=\"headerlink\" title=\"为什么要自定义View\"></a>为什么要自定义View</h3><h3 id=\"自定义View的基本方法\"><a href=\"#自定义View的基本方法\" class=\"headerlink\" title=\"自定义View的基本方法\"></a>自定义View的基本方法</h3><p>自定义View的最基本的三个方法分别是： onMeasure()、onLayout()、onDraw();<br>View在Activity中显示出来，要经历测量、布局和绘制三个步骤，分别对应三个动作：measure、layout和draw。<br><a id=\"more\"></a></p>\n<ul>\n<li>测量：onMeasure()决定View的大小；</li>\n<li>布局：onLayout()决定View在ViewGroup中的位置；</li>\n<li>绘制：onDraw()决定绘制这个View。</li>\n</ul>\n<h3 id=\"自定义控件分类\"><a href=\"#自定义控件分类\" class=\"headerlink\" title=\"自定义控件分类\"></a>自定义控件分类</h3><ul>\n<li>自定义View: 只需要重写onMeasure()和onDraw()</li>\n<li>自定义ViewGroup: 则只需要重写onMeasure()和onLayout()</li>\n</ul>\n<h2 id=\"自定义View基础\"><a href=\"#自定义View基础\" class=\"headerlink\" title=\"自定义View基础\"></a>自定义View基础</h2><h3 id=\"View的分类\"><a href=\"#View的分类\" class=\"headerlink\" title=\"View的分类\"></a>View的分类</h3><p>视图View主要分为两类</p>\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>解释</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>单一视图</td>\n<td>即一个View，如TextView</td>\n<td>不包含子View</td>\n</tr>\n<tr>\n<td>视图组</td>\n<td>即多个View组成的ViewGroup，如LinearLayout</td>\n<td>包含子View</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"View类简介\"><a href=\"#View类简介\" class=\"headerlink\" title=\"View类简介\"></a>View类简介</h3><ul>\n<li>View类是Android中各种组件的基类，如View是ViewGroup基类</li>\n<li>View表现为显示在屏幕上的各种视图</li>\n</ul>\n<blockquote>\n<p>Android中的UI组件都由View、ViewGroup组成。</p>\n</blockquote>\n<ul>\n<li><p>View的构造函数：共有4个</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// 如果View是在Java代码里面new的，则调用第一个构造函数</span>\n <span class=\"token keyword\">public</span> <span class=\"token function\">CarsonView</span><span class=\"token punctuation\">(</span>Context context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 如果View是在.xml里声明的，则调用第二个构造函数</span>\n<span class=\"token comment\" spellcheck=\"true\">// 自定义属性是从AttributeSet参数传进来的</span>\n    <span class=\"token keyword\">public</span>  <span class=\"token function\">CarsonView</span><span class=\"token punctuation\">(</span>Context context<span class=\"token punctuation\">,</span> AttributeSet attrs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> attrs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 不会自动调用</span>\n<span class=\"token comment\" spellcheck=\"true\">// 一般是在第二个构造函数里主动调用</span>\n<span class=\"token comment\" spellcheck=\"true\">// 如View有style属性时</span>\n    <span class=\"token keyword\">public</span>  <span class=\"token function\">CarsonView</span><span class=\"token punctuation\">(</span>Context context<span class=\"token punctuation\">,</span> AttributeSet attrs<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> defStyleAttr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> attrs<span class=\"token punctuation\">,</span> defStyleAttr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//API21之后才使用</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 不会自动调用</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 一般是在第二个构造函数里主动调用</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 如View有style属性时</span>\n    <span class=\"token keyword\">public</span>  <span class=\"token function\">CarsonView</span><span class=\"token punctuation\">(</span>Context context<span class=\"token punctuation\">,</span> AttributeSet attrs<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> defStyleAttr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> defStyleRes<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> attrs<span class=\"token punctuation\">,</span> defStyleAttr<span class=\"token punctuation\">,</span> defStyleRes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n</li>\n</ul>\n<h3 id=\"AttributeSet与自定义属性\"><a href=\"#AttributeSet与自定义属性\" class=\"headerlink\" title=\"AttributeSet与自定义属性\"></a>AttributeSet与自定义属性</h3><p>　系统自带的View可以在xml中配置属性，对于写的好的自定义View同样可以在xml中配置属性，为了使自定义的View的属性可以在xml中配置，需要以下4个步骤：</p>\n<ol>\n<li>通过<code>&lt;declare-styleable&gt;</code>为自定义View添加属性</li>\n<li>在xml中为相应的属性声明属性值</li>\n<li>在运行时（一般为构造函数）获取属性值</li>\n<li>将获取到的属性值应用到View</li>\n</ol>\n<h3 id=\"View视图结构\"><a href=\"#View视图结构\" class=\"headerlink\" title=\"View视图结构\"></a>View视图结构</h3><ol>\n<li>PhoneWindow是Android系统中最基本的窗口系统，继承自Windows类，负责管理界面显示以及事件响应。它是Activity与View系统交互的接口，每个Activity都会创建一个</li>\n<li>DecorView是PhoneWindow中的起始节点View，继承于View类，作为整个视图容器来使用。用于设置窗口属性。它本质上是一个FrameLayout</li>\n<li>ViewRoot在Activtiy启动时创建，负责管理、布局、渲染窗口UI等等</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/activity.png\" alt=\"activity\"></p>\n<p>对于多View的视图，结构是树形结构：最顶层是ViewGroup，ViewGroup下可能有多个ViewGroup或View，如下图：</p>\n<p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_arch.png\" alt=\"view_arch\"></p>\n<p>一定要记住：无论是measure过程、layout过程还是draw过程，永远都是从View树的根节点开始测量或计算（即从树的顶端开始），一层一层、一个分支一个分支地进行（即树形递归），最终计算整个View树中各个View，最终确定整个View树的相关属性。</p>\n<h3 id=\"Android坐标系\"><a href=\"#Android坐标系\" class=\"headerlink\" title=\"Android坐标系\"></a>Android坐标系</h3><p>Android的坐标系定义为：</p>\n<ul>\n<li>屏幕的左上角为坐标原点</li>\n<li>向右为x轴增大方向</li>\n<li>向下为y轴增大方向<br><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/zuobiaoxi.png\" alt=\"zuobiaoxi\"></li>\n</ul>\n<blockquote>\n<p>区别于一般的数学坐标系<br><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/zuobiaoxi_qubie.png\" alt=\"zuobiaoxi_qubie\"></p>\n</blockquote>\n<h3 id=\"View位置（坐标）描述\"><a href=\"#View位置（坐标）描述\" class=\"headerlink\" title=\"View位置（坐标）描述\"></a>View位置（坐标）描述</h3><p>View的位置由4个顶点决定的<br>4个顶点的位置描述分别由4个值决定：</p>\n<blockquote>\n<p>请记住：View的位置是相对于父控件而言的）</p>\n</blockquote>\n<ul>\n<li>Top：子View上边界到父view上边界的距离</li>\n<li>Left：子View左边界到父view左边界的距离</li>\n<li>Bottom：子View下边距到父View上边界的距离</li>\n<li>Right：子View右边界到父view左边界的距离</li>\n</ul>\n<h3 id=\"位置获取方式\"><a href=\"#位置获取方式\" class=\"headerlink\" title=\"位置获取方式\"></a>位置获取方式</h3><p>View的位置是通过view.getxxx()函数进行获取：（以Top为例）</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// 获取Top位置</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getTop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n    <span class=\"token keyword\">return</span> mTop<span class=\"token punctuation\">;</span>  \n<span class=\"token punctuation\">}</span>  \n\n<span class=\"token comment\" spellcheck=\"true\">// 其余如下：</span>\n  <span class=\"token function\">getLeft</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\" spellcheck=\"true\">//获取子View左上角距父View左侧的距离</span>\n  <span class=\"token function\">getBottom</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">//获取子View右下角距父View顶部的距离</span>\n  <span class=\"token function\">getRight</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\" spellcheck=\"true\">//获取子View右下角距父View左侧的距离</span>\n</code></pre>\n<p>与MotionEvent中 get()和getRaw()的区别</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//get() ：触摸点相对于其所在组件坐标系的坐标</span>\n event<span class=\"token punctuation\">.</span><span class=\"token function\">getX</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>       \n event<span class=\"token punctuation\">.</span><span class=\"token function\">getY</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//getRaw() ：触摸点相对于屏幕默认坐标系的坐标</span>\n event<span class=\"token punctuation\">.</span><span class=\"token function\">getRawX</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    \n event<span class=\"token punctuation\">.</span><span class=\"token function\">getRawY</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/zuobiaoxiweizhi.png\" alt=\"zuobiaoxiweizhi\"></p>\n<h3 id=\"Android中颜色相关内容\"><a href=\"#Android中颜色相关内容\" class=\"headerlink\" title=\"Android中颜色相关内容\"></a>Android中颜色相关内容</h3><p>Android支持的颜色模式：<br><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/color1.png\" alt=\"color1\"></p>\n<p>以ARGB8888为例介绍颜色定义:<br><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/color2.png\" alt=\"color2\"></p>\n<h2 id=\"View树的绘制流程\"><a href=\"#View树的绘制流程\" class=\"headerlink\" title=\"View树的绘制流程\"></a>View树的绘制流程</h2><h3 id=\"View树的绘制流程是谁负责的？\"><a href=\"#View树的绘制流程是谁负责的？\" class=\"headerlink\" title=\"View树的绘制流程是谁负责的？\"></a>View树的绘制流程是谁负责的？</h3><p>view树的绘制流程是通过ViewRoot去负责绘制的，ViewRoot这个类的命名有点坑，最初看到这个名字，翻译过来是view的根节点，但是事实完全不是这样，ViewRoot其实不是View的根节点，它连view节点都算不上，它的主要作用是View树的管理者，负责将DecorView和PhoneWindow“组合”起来，而View树的根节点严格意义上来说只有DecorView；每个DecorView都有一个ViewRoot与之关联，这种关联关系是由WindowManager去进行管理的；绘制就是从ViewRoot.performTraversals()开始的。</p>\n<pre class=\" language-java\"><code class=\"language-java\">  <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">performTraversals</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n        <span class=\"token function\">performMeasure</span><span class=\"token punctuation\">(</span>childWidthMeasureSpec<span class=\"token punctuation\">,</span> childHeightMeasureSpec<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n        <span class=\"token function\">performLayout</span><span class=\"token punctuation\">(</span>lp<span class=\"token punctuation\">,</span> mWidth<span class=\"token punctuation\">,</span> mHeight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n        <span class=\"token function\">performDraw</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"view的添加\"><a href=\"#view的添加\" class=\"headerlink\" title=\"view的添加\"></a>view的添加</h3><p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_qiyuan.png\" alt></p>\n<h3 id=\"view的绘制流程\"><a href=\"#view的绘制流程\" class=\"headerlink\" title=\"view的绘制流程\"></a>view的绘制流程</h3><p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_traversals.png\" alt=\"view_traversals\"></p>\n<h3 id=\"measure\"><a href=\"#measure\" class=\"headerlink\" title=\"measure\"></a>measure</h3><ol>\n<li><p>系统为什么要有measure过程？</p>\n<pre class=\" language-xml\"><code class=\"language-xml\">    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>TextView</span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_width</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>wrap_content<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_height</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>match_parent<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>text</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>Hello World!<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n</code></pre>\n<p>谷歌建议使用自适应，自适应的话，就不知道大小，所以需要去测量。</p>\n</li>\n<li><p>measure过程都干了点什么事？</p>\n</li>\n<li><p>对于自适应的尺寸机制，如何合理的测量一颗View树？</p>\n</li>\n<li><p>那么ViewGroup是如何向子View传递限制信息的？</p>\n</li>\n<li><p>ScrollView嵌套ListView问题？</p>\n</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_requestlayout.png\" alt=\"view_requestlayout\"></p>\n<h3 id=\"layout\"><a href=\"#layout\" class=\"headerlink\" title=\"layout\"></a>layout</h3><ol>\n<li>系统为什么要有layout过程？</li>\n<li>layout过程都干了点什么事？</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_performlayout.png\" alt=\"view_performlayout\"></p>\n<h3 id=\"draw\"><a href=\"#draw\" class=\"headerlink\" title=\"draw\"></a>draw</h3><ol>\n<li>系统为什么要有draw过程？</li>\n<li>draw过程都干了点什么事？</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_invalidate.png\" alt=\"view_invalidate\"></p>\n<h2 id=\"LayoutParams\"><a href=\"#LayoutParams\" class=\"headerlink\" title=\"LayoutParams\"></a>LayoutParams</h2><p>ayoutParams翻译过来就是布局参数，子View通过LayoutParams告诉父容器（ViewGroup）应该如何放置自己。从这个定义中也可以看出来LayoutParams与ViewGroup是息息相关的，因此脱离ViewGroup谈LayoutParams是没有意义的。</p>\n<p>事实上，每个ViewGroup的子类都有自己对应的LayoutParams类，典型的如LinearLayout.LayoutParams和FrameLayout.LayoutParams等，可以看出来LayoutParams都是对应ViewGroup子类的内部类</p>\n<h3 id=\"MarginLayoutParams\"><a href=\"#MarginLayoutParams\" class=\"headerlink\" title=\"MarginLayoutParams\"></a>MarginLayoutParams</h3><p>MarginLayoutParams是和外间距有关的。事实也确实如此，和LayoutParams相比，MarginLayoutParams只是增加了对上下左右外间距的支持。实际上大部分LayoutParams的实现类都是继承自MarginLayoutParams，因为基本所有的父容器都是支持子View设置外间距的</p>\n<ul>\n<li>属性优先级问题<br>MarginLayoutParams主要就是增加了上下左右4种外间距。在构造方法中，先是获取了margin属性；如果该值不合法，就获取horizontalMargin；如果该值不合法，再去获取leftMargin和rightMargin属性（verticalMargin、topMargin和bottomMargin同理）。我们可以据此总结出这几种属性的优先级</li>\n</ul>\n<blockquote>\n<p>margin &gt; horizontalMargin和verticalMargin &gt; leftMargin和RightMargin、topMargin和bottomMargin</p>\n</blockquote>\n<ul>\n<li>属性覆盖问题<br>优先级更高的属性会覆盖掉优先级较低的属性。此外，还要注意一下这几种属性上的注释</li>\n</ul>\n<blockquote>\n<p>Call {@link ViewGroup#setLayoutParams(LayoutParams)} after reassigning a new value</p>\n</blockquote>\n<h3 id=\"LayoutParams与View如何建立联系\"><a href=\"#LayoutParams与View如何建立联系\" class=\"headerlink\" title=\"LayoutParams与View如何建立联系\"></a>LayoutParams与View如何建立联系</h3><ul>\n<li>在XML中定义View</li>\n<li>在Java代码中直接生成View对应的实例对象</li>\n</ul>\n<h3 id=\"addView\"><a href=\"#addView\" class=\"headerlink\" title=\"addView\"></a>addView</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/**\n * 重载方法1：添加一个子View\n * 如果这个子View还没有LayoutParams，就为子View设置当前ViewGroup默认的LayoutParams\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">addView</span><span class=\"token punctuation\">(</span>View child<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">addView</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/**\n * 重载方法2：在指定位置添加一个子View\n * 如果这个子View还没有LayoutParams，就为子View设置当前ViewGroup默认的LayoutParams\n * @param index View将在ViewGroup中被添加的位置（-1代表添加到末尾）\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">addView</span><span class=\"token punctuation\">(</span>View child<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>child <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Cannot add a null child view to a ViewGroup\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    LayoutParams params <span class=\"token operator\">=</span> child<span class=\"token punctuation\">.</span><span class=\"token function\">getLayoutParams</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>params <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        params <span class=\"token operator\">=</span> <span class=\"token function\">generateDefaultLayoutParams</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// 生成当前ViewGroup默认的LayoutParams</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>params <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"generateDefaultLayoutParams() cannot return null\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">addView</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">,</span> params<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/**\n * 重载方法3：添加一个子View\n * 使用当前ViewGroup默认的LayoutParams，并以传入参数作为LayoutParams的width和height\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">addView</span><span class=\"token punctuation\">(</span>View child<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> width<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> height<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> LayoutParams params <span class=\"token operator\">=</span> <span class=\"token function\">generateDefaultLayoutParams</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 生成当前ViewGroup默认的LayoutParams</span>\n    params<span class=\"token punctuation\">.</span>width <span class=\"token operator\">=</span> width<span class=\"token punctuation\">;</span>\n    params<span class=\"token punctuation\">.</span>height <span class=\"token operator\">=</span> height<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">addView</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> params<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/**\n * 重载方法4：添加一个子View，并使用传入的LayoutParams\n */</span>\n<span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">addView</span><span class=\"token punctuation\">(</span>View child<span class=\"token punctuation\">,</span> LayoutParams params<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">addView</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> params<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/**\n * 重载方法4：在指定位置添加一个子View，并使用传入的LayoutParams\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">addView</span><span class=\"token punctuation\">(</span>View child<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> index<span class=\"token punctuation\">,</span> LayoutParams params<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>child <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Cannot add a null child view to a ViewGroup\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// addViewInner() will call child.requestLayout() when setting the new LayoutParams</span>\n    <span class=\"token comment\" spellcheck=\"true\">// therefore, we call requestLayout() on ourselves before, so that the child's request</span>\n    <span class=\"token comment\" spellcheck=\"true\">// will be blocked at our level</span>\n    <span class=\"token function\">requestLayout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">invalidate</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">addViewInner</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">,</span> params<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">addViewInner</span><span class=\"token punctuation\">(</span>View child<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> index<span class=\"token punctuation\">,</span> LayoutParams params<span class=\"token punctuation\">,</span>\n        <span class=\"token keyword\">boolean</span> preventRequestLayout<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mTransition <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        mTransition<span class=\"token punctuation\">.</span><span class=\"token function\">addChild</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> child<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">checkLayoutParams</span><span class=\"token punctuation\">(</span>params<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// ① 检查传入的LayoutParams是否合法</span>\n        params <span class=\"token operator\">=</span> <span class=\"token function\">generateLayoutParams</span><span class=\"token punctuation\">(</span>params<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 如果传入的LayoutParams不合法，将进行转化操作</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>preventRequestLayout<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// ② 是否需要阻止重新执行布局流程</span>\n        child<span class=\"token punctuation\">.</span>mLayoutParams <span class=\"token operator\">=</span> params<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 这不会引起子View重新布局（onMeasure->onLayout->onDraw）</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        child<span class=\"token punctuation\">.</span><span class=\"token function\">setLayoutParams</span><span class=\"token punctuation\">(</span>params<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 这会引起子View重新布局（onMeasure->onLayout->onDraw）</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        index <span class=\"token operator\">=</span> mChildrenCount<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">addInArray</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// tell our children</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>preventRequestLayout<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        child<span class=\"token punctuation\">.</span><span class=\"token function\">assignParent</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        child<span class=\"token punctuation\">.</span>mParent <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<h3 id=\"自定义LayoutParams\"><a href=\"#自定义LayoutParams\" class=\"headerlink\" title=\"自定义LayoutParams\"></a>自定义LayoutParams</h3><ol>\n<li>创建自定义属性</li>\n</ol>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token operator\">&lt;</span>resources<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>declare<span class=\"token operator\">-</span>styleable name<span class=\"token operator\">=</span><span class=\"token string\">\"xxxViewGroup_Layout\"</span><span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> 自定义的属性 <span class=\"token operator\">--</span><span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span>attr name<span class=\"token operator\">=</span><span class=\"token string\">\"layout_simple_attr\"</span> format<span class=\"token operator\">=</span><span class=\"token string\">\"integer\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> 使用系统预置的属性 <span class=\"token operator\">--</span><span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span>attr name<span class=\"token operator\">=</span><span class=\"token string\">\"android:layout_gravity\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>declare<span class=\"token operator\">-</span>styleable<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>resources<span class=\"token operator\">></span>\n</code></pre>\n<ol start=\"2\">\n<li>继承MarginLayout</li>\n</ol>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">LayoutParams</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">ViewGroup<span class=\"token punctuation\">.</span>MarginLayoutParams</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> simpleAttr<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> gravity<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">LayoutParams</span><span class=\"token punctuation\">(</span>Context c<span class=\"token punctuation\">,</span> AttributeSet attrs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">,</span> attrs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 解析布局属性</span>\n        TypedArray typedArray <span class=\"token operator\">=</span> c<span class=\"token punctuation\">.</span><span class=\"token function\">obtainStyledAttributes</span><span class=\"token punctuation\">(</span>attrs<span class=\"token punctuation\">,</span> R<span class=\"token punctuation\">.</span>styleable<span class=\"token punctuation\">.</span>SimpleViewGroup_Layout<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        simpleAttr <span class=\"token operator\">=</span> typedArray<span class=\"token punctuation\">.</span><span class=\"token function\">getInteger</span><span class=\"token punctuation\">(</span>R<span class=\"token punctuation\">.</span>styleable<span class=\"token punctuation\">.</span>SimpleViewGroup_Layout_layout_simple_attr<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        gravity<span class=\"token operator\">=</span>typedArray<span class=\"token punctuation\">.</span><span class=\"token function\">getInteger</span><span class=\"token punctuation\">(</span>R<span class=\"token punctuation\">.</span>styleable<span class=\"token punctuation\">.</span>SimpleViewGroup_Layout_android_layout_gravity<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        typedArray<span class=\"token punctuation\">.</span><span class=\"token function\">recycle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//释放资源</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">LayoutParams</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> width<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> height<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">LayoutParams</span><span class=\"token punctuation\">(</span>MarginLayoutParams source<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>source<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">LayoutParams</span><span class=\"token punctuation\">(</span>ViewGroup<span class=\"token punctuation\">.</span>LayoutParams source<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>source<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<ol start=\"3\">\n<li>重写ViewGroup中几个与LayoutParams相关的方法</li>\n</ol>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// 检查LayoutParams是否合法</span>\n<span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">protected</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">checkLayoutParams</span><span class=\"token punctuation\">(</span>ViewGroup<span class=\"token punctuation\">.</span>LayoutParams p<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token keyword\">return</span> p <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">SimpleViewGroup<span class=\"token punctuation\">.</span>LayoutParams</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 生成默认的LayoutParams</span>\n<span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">protected</span> ViewGroup<span class=\"token punctuation\">.</span>LayoutParams <span class=\"token function\">generateDefaultLayoutParams</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SimpleViewGroup<span class=\"token punctuation\">.</span>LayoutParams</span><span class=\"token punctuation\">(</span>LayoutParams<span class=\"token punctuation\">.</span>MATCH_PARENT<span class=\"token punctuation\">,</span> LayoutParams<span class=\"token punctuation\">.</span>WRAP_CONTENT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 对传入的LayoutParams进行转化</span>\n<span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">protected</span> ViewGroup<span class=\"token punctuation\">.</span>LayoutParams <span class=\"token function\">generateLayoutParams</span><span class=\"token punctuation\">(</span>ViewGroup<span class=\"token punctuation\">.</span>LayoutParams p<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SimpleViewGroup<span class=\"token punctuation\">.</span>LayoutParams</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 对传入的LayoutParams进行转化</span>\n<span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">public</span> ViewGroup<span class=\"token punctuation\">.</span>LayoutParams <span class=\"token function\">generateLayoutParams</span><span class=\"token punctuation\">(</span>AttributeSet attrs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SimpleViewGroup<span class=\"token punctuation\">.</span>LayoutParams</span><span class=\"token punctuation\">(</span><span class=\"token function\">getContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> attrs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"LayoutParams常见的子类\"><a href=\"#LayoutParams常见的子类\" class=\"headerlink\" title=\"LayoutParams常见的子类\"></a>LayoutParams常见的子类</h3><p>在为View设置LayoutParams的时候需要根据它的父容器选择对应的LayoutParams，否则结果可能与预期不一致，这里简单罗列一些常见的LayoutParams子类：</p>\n<ul>\n<li>ViewGroup.MarginLayoutParams</li>\n<li>FrameLayout.LayoutParams</li>\n<li>LinearLayout.LayoutParams</li>\n<li>RelativeLayout.LayoutParams</li>\n<li>RecyclerView.LayoutParams</li>\n<li>GridLayoutManager.LayoutParams</li>\n<li>StaggeredGridLayoutManager.LayoutParams</li>\n<li>ViewPager.LayoutParams</li>\n<li>WindowManager.LayoutParams</li>\n</ul>\n<h2 id=\"MeasureSpec\"><a href=\"#MeasureSpec\" class=\"headerlink\" title=\"MeasureSpec\"></a>MeasureSpec</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>测量规格,封装了父容器对 view 的布局上的限制，内部提供了宽高的信息（ SpecMode 、 SpecSize ），SpecSize是指在某种SpecMode下的参考尺寸，其中SpecMode 有如下三种：</p>\n<ul>\n<li><p>UNSPECIFIED<br>不指定测量模式，父控件不对你有任何限制，你想要多大给你多大，想上天就上天。这种情况一般用于系统内部，表示一种测量状态。（这个模式主要用于系统内部多次Measure的情形，并不是真的说你想要多大最后就真有多大，开发中很少用到）</p>\n</li>\n<li><p>EXACTLY<br>精确测量模式，当该视图的宽高为match_parent或者具体数值时生效，表示父布局已经决定了子视图的精确大小，View的测量值就是SpecSize。</p>\n</li>\n<li><p>AT_MOST<br>当该视图的宽高为wrap_content时生效，你的大小不能大于父控件给你指定的size，但具体是多少，得看你自己的实现。<br>MeasureSpecs（32位的Int）=SpecMode（高2位） + SpecSize（低30位）</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//获取尚未显示的view的宽和高</span>\n<span class=\"token keyword\">int</span> tempWidth <span class=\"token operator\">=</span>View<span class=\"token punctuation\">.</span>MeasureSpec<span class=\"token punctuation\">.</span><span class=\"token function\">makeMeasureSpec</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>View<span class=\"token punctuation\">.</span>MeasureSpec<span class=\"token punctuation\">.</span>UNSPECIFIED<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> tempHeight <span class=\"token operator\">=</span>View<span class=\"token punctuation\">.</span>MeasureSpec<span class=\"token punctuation\">.</span><span class=\"token function\">makeMeasureSpec</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>View<span class=\"token punctuation\">.</span>MeasureSpec<span class=\"token punctuation\">.</span>UNSPECIFIED<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nview<span class=\"token punctuation\">.</span><span class=\"token function\">measure</span><span class=\"token punctuation\">(</span>tempWidth<span class=\"token punctuation\">,</span>tempHeight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> realHeight<span class=\"token operator\">=</span>view<span class=\"token punctuation\">.</span><span class=\"token function\">getMeasuredHeight</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">int</span> realWidth<span class=\"token operator\">=</span>view<span class=\"token punctuation\">.</span><span class=\"token function\">getMeasuredWidth</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n</li>\n</ul>\n<h3 id=\"MeasureSpecs-的意义\"><a href=\"#MeasureSpecs-的意义\" class=\"headerlink\" title=\"MeasureSpecs 的意义\"></a>MeasureSpecs 的意义</h3><p>通过将 SpecMode 和 SpecSize 打包成一个 int 值可以避免过多的对象内存分配，为了方便操作，其提供了打包 / 解包方法</p>\n<h3 id=\"MeasureSpec值的确定\"><a href=\"#MeasureSpec值的确定\" class=\"headerlink\" title=\"MeasureSpec值的确定\"></a>MeasureSpec值的确定</h3><p>MeasureSpec值到底是如何计算得来的呢?</p>\n<p>对于DecorView而言，他的MeasureSpecs是由自身窗口大小和自身的LayoutParams共同决定的，子View的MeasureSpec值是根据子View的布局参数（LayoutParams）和父容器的MeasureSpec值计算得来的，具体计算逻辑封装在getChildMeasureSpec()里</p>\n<pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">performMeasure</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> childWidthMeasureSpec<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> childHeightMeasureSpec<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n        mView<span class=\"token punctuation\">.</span><span class=\"token function\">measure</span><span class=\"token punctuation\">(</span>childWidthMeasureSpec<span class=\"token punctuation\">,</span> childHeightMeasureSpec<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>具体的测量操作是分发给ViewGroup的，由ViewGroup的measureChildren方法传递为子View，如下</p>\n<pre class=\" language-java\"><code class=\"language-java\">   <span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">measureChildren</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> widthMeasureSpec<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> heightMeasureSpec<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> size <span class=\"token operator\">=</span> mChildrenCount<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">final</span> View<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> children <span class=\"token operator\">=</span> mChildren<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> size<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">final</span> View child <span class=\"token operator\">=</span> children<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">.</span>mViewFlags <span class=\"token operator\">&amp;</span> VISIBILITY_MASK<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> GONE<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">//测量指定的View</span>\n                <span class=\"token function\">measureChild</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">,</span> widthMeasureSpec<span class=\"token punctuation\">,</span> heightMeasureSpec<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>测量指定的View</p>\n<pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">measureChild</span><span class=\"token punctuation\">(</span>View child<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> parentWidthMeasureSpec<span class=\"token punctuation\">,</span>\n            <span class=\"token keyword\">int</span> parentHeightMeasureSpec<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">final</span> LayoutParams lp <span class=\"token operator\">=</span> child<span class=\"token punctuation\">.</span><span class=\"token function\">getLayoutParams</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//根据父容器的MeasureSpec和子View的布局参数（LayoutParams）计算子View的MeasureSpec</span>\n        <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> childWidthMeasureSpec <span class=\"token operator\">=</span> <span class=\"token function\">getChildMeasureSpec</span><span class=\"token punctuation\">(</span>parentWidthMeasureSpec<span class=\"token punctuation\">,</span>\n                mPaddingLeft <span class=\"token operator\">+</span> mPaddingRight<span class=\"token punctuation\">,</span> lp<span class=\"token punctuation\">.</span>width<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> childHeightMeasureSpec <span class=\"token operator\">=</span> <span class=\"token function\">getChildMeasureSpec</span><span class=\"token punctuation\">(</span>parentHeightMeasureSpec<span class=\"token punctuation\">,</span>\n                mPaddingTop <span class=\"token operator\">+</span> mPaddingBottom<span class=\"token punctuation\">,</span> lp<span class=\"token punctuation\">.</span>height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        child<span class=\"token punctuation\">.</span><span class=\"token function\">measure</span><span class=\"token punctuation\">(</span>childWidthMeasureSpec<span class=\"token punctuation\">,</span> childHeightMeasureSpec<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>子View的MeasureSpec值是根据子View的布局参数（LayoutParams）和父容器的MeasureSpec值计算得来的，具体计算逻辑封装在getChildMeasureSpec()里</p>\n<pre class=\" language-java\"><code class=\"language-java\">  <span class=\"token comment\" spellcheck=\"true\">/**\n     *\n     * 目标是将父控件的测量规格和child view的布局参数LayoutParams相结合，得到一个\n     * 最可能符合条件的child view的测量规格。  \n\n     * @param spec 父控件的测量规格\n     * @param padding 父控件里已经占用的大小\n     * @param childDimension child view布局LayoutParams里的尺寸\n     * @return child view 的测量规格\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getChildMeasureSpec</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> spec<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> padding<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> childDimension<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> specMode <span class=\"token operator\">=</span> MeasureSpec<span class=\"token punctuation\">.</span><span class=\"token function\">getMode</span><span class=\"token punctuation\">(</span>spec<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//父控件的测量模式</span>\n        <span class=\"token keyword\">int</span> specSize <span class=\"token operator\">=</span> MeasureSpec<span class=\"token punctuation\">.</span><span class=\"token function\">getSize</span><span class=\"token punctuation\">(</span>spec<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//父控件的测量大小</span>\n\n        <span class=\"token keyword\">int</span> size <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> specSize <span class=\"token operator\">-</span> padding<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">int</span> resultSize <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> resultMode <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>specMode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 当父控件的测量模式 是 精确模式，也就是有精确的尺寸了</span>\n        <span class=\"token keyword\">case</span> MeasureSpec<span class=\"token punctuation\">.</span>EXACTLY<span class=\"token operator\">:</span>\n            <span class=\"token comment\" spellcheck=\"true\">//如果child的布局参数有固定值，比如\"layout_width\" = \"100dp\"</span>\n            <span class=\"token comment\" spellcheck=\"true\">//那么显然child的测量规格也可以确定下来了，测量大小就是100dp，测量模式也是EXACTLY</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>childDimension <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                resultSize <span class=\"token operator\">=</span> childDimension<span class=\"token punctuation\">;</span>\n                resultMode <span class=\"token operator\">=</span> MeasureSpec<span class=\"token punctuation\">.</span>EXACTLY<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> \n\n            <span class=\"token comment\" spellcheck=\"true\">//如果child的布局参数是\"match_parent\"，也就是想要占满父控件</span>\n            <span class=\"token comment\" spellcheck=\"true\">//而此时父控件是精确模式，也就是能确定自己的尺寸了，那child也能确定自己大小了</span>\n            <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>childDimension <span class=\"token operator\">==</span> LayoutParams<span class=\"token punctuation\">.</span>MATCH_PARENT<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                resultSize <span class=\"token operator\">=</span> size<span class=\"token punctuation\">;</span>\n                resultMode <span class=\"token operator\">=</span> MeasureSpec<span class=\"token punctuation\">.</span>EXACTLY<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token comment\" spellcheck=\"true\">//如果child的布局参数是\"wrap_content\"，也就是想要根据自己的逻辑决定自己大小，</span>\n            <span class=\"token comment\" spellcheck=\"true\">//比如TextView根据设置的字符串大小来决定自己的大小</span>\n            <span class=\"token comment\" spellcheck=\"true\">//那就自己决定呗，不过你的大小肯定不能大于父控件的大小嘛</span>\n            <span class=\"token comment\" spellcheck=\"true\">//所以测量模式就是AT_MOST，测量大小就是父控件的size</span>\n            <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>childDimension <span class=\"token operator\">==</span> LayoutParams<span class=\"token punctuation\">.</span>WRAP_CONTENT<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                resultSize <span class=\"token operator\">=</span> size<span class=\"token punctuation\">;</span>\n                resultMode <span class=\"token operator\">=</span> MeasureSpec<span class=\"token punctuation\">.</span>AT_MOST<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 当父控件的测量模式 是 最大模式，也就是说父控件自己还不知道自己的尺寸，但是大小不能超过size</span>\n        <span class=\"token keyword\">case</span> MeasureSpec<span class=\"token punctuation\">.</span>AT_MOST<span class=\"token operator\">:</span>\n            <span class=\"token comment\" spellcheck=\"true\">//同样的，既然child能确定自己大小，尽管父控件自己还不知道自己大小，也优先满足孩子的需求</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>childDimension <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                resultSize <span class=\"token operator\">=</span> childDimension<span class=\"token punctuation\">;</span>\n                resultMode <span class=\"token operator\">=</span> MeasureSpec<span class=\"token punctuation\">.</span>EXACTLY<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> \n            <span class=\"token comment\" spellcheck=\"true\">//child想要和父控件一样大，但父控件自己也不确定自己大小，所以child也无法确定自己大小</span>\n            <span class=\"token comment\" spellcheck=\"true\">//但同样的，child的尺寸上限也是父控件的尺寸上限size</span>\n            <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>childDimension <span class=\"token operator\">==</span> LayoutParams<span class=\"token punctuation\">.</span>MATCH_PARENT<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                resultSize <span class=\"token operator\">=</span> size<span class=\"token punctuation\">;</span>\n                resultMode <span class=\"token operator\">=</span> MeasureSpec<span class=\"token punctuation\">.</span>AT_MOST<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token comment\" spellcheck=\"true\">//child想要根据自己逻辑决定大小，那就自己决定呗</span>\n            <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>childDimension <span class=\"token operator\">==</span> LayoutParams<span class=\"token punctuation\">.</span>WRAP_CONTENT<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                resultSize <span class=\"token operator\">=</span> size<span class=\"token punctuation\">;</span>\n                resultMode <span class=\"token operator\">=</span> MeasureSpec<span class=\"token punctuation\">.</span>AT_MOST<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// Parent asked to see how big we want to be</span>\n        <span class=\"token keyword\">case</span> MeasureSpec<span class=\"token punctuation\">.</span>UNSPECIFIED<span class=\"token operator\">:</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>childDimension <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// Child wants a specific size... let him have it</span>\n                resultSize <span class=\"token operator\">=</span> childDimension<span class=\"token punctuation\">;</span>\n                resultMode <span class=\"token operator\">=</span> MeasureSpec<span class=\"token punctuation\">.</span>EXACTLY<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>childDimension <span class=\"token operator\">==</span> LayoutParams<span class=\"token punctuation\">.</span>MATCH_PARENT<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// Child wants to be our size... find out how big it should</span>\n                <span class=\"token comment\" spellcheck=\"true\">// be</span>\n                resultSize <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n                resultMode <span class=\"token operator\">=</span> MeasureSpec<span class=\"token punctuation\">.</span>UNSPECIFIED<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>childDimension <span class=\"token operator\">==</span> LayoutParams<span class=\"token punctuation\">.</span>WRAP_CONTENT<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// Child wants to determine its own size.... find out how</span>\n                <span class=\"token comment\" spellcheck=\"true\">// big it should be</span>\n                resultSize <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n                resultMode <span class=\"token operator\">=</span> MeasureSpec<span class=\"token punctuation\">.</span>UNSPECIFIED<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> MeasureSpec<span class=\"token punctuation\">.</span><span class=\"token function\">makeMeasureSpec</span><span class=\"token punctuation\">(</span>resultSize<span class=\"token punctuation\">,</span> resultMode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/measurespec3.png\" alt=\"measurespec3\"><br>针对上表，这里再做一下具体的说明</p>\n<ul>\n<li><p>对于应用层 View ，其 MeasureSpec 由父容器的 MeasureSpec 和自身的 LayoutParams 来共同决定</p>\n</li>\n<li><p>对于不同的父容器和view本身不同的LayoutParams，view就可以有多种MeasureSpec。</p>\n<pre><code>1.  当view采用固定宽高的时候，不管父容器的MeasureSpec是什么，view的MeasureSpec都是精确模式并且其大小遵循Layoutparams中的大小；\n2. 当view的宽高是match_parent时，这个时候如果父容器的模式是精准模式，那么view也是精准模式并且其大小是父容器的剩余空间，如果父容器是最大模式，那么view也是最大模式并且其大小不会超过父容器的剩余空间；\n3.  当view的宽高是wrap_content时，不管父容器的模式是精准还是最大化，view的模式总是最大化并且大小不能超过父容器的剩余空间。\n4. Unspecified模式，这个模式主要用于系统内部多次measure的情况下，一般来说，我们不需要关注此模式(这里注意自定义View放到ScrollView的情况 需要处理)。\n</code></pre></li>\n</ul>\n<h3 id=\"View-（ViewGroup）的measure方法\"><a href=\"#View-（ViewGroup）的measure方法\" class=\"headerlink\" title=\"View （ViewGroup）的measure方法\"></a>View （ViewGroup）的measure方法</h3><p>  最终是通过回调onMeasure方法实现的，这个方法通常有View的特定子类的方法去实现的，通过重写这个View实现自定义View。</p>\n<pre><code>    public final void measure(int widthMeasureSpec, int heightMeasureSpec) {\n        ...\n        onMeasure(widthMeasureSpec, heightMeasureSpec);\n        ...\n    }\n\n</code></pre><pre><code>    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        //设置size\n        setMeasuredDimension(1,1);\n    }\n</code></pre><hr>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token function\">onMeasure</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\">//1. 测量自身</span>\n<span class=\"token comment\" spellcheck=\"true\">//2. 为每个子View计算测量的限制信息 Mode / Size</span>\n<span class=\"token comment\" spellcheck=\"true\">//3. 把上一步确定的限制信息，传递给每一个子View，然后子View开始measure</span>\n<span class=\"token comment\" spellcheck=\"true\">//4. 获取子View测量完成后的尺寸</span>\n<span class=\"token comment\" spellcheck=\"true\">//5. ViewGroup根据自身的情况，计算自己的尺寸</span>\n<span class=\"token comment\" spellcheck=\"true\">//6. 保存自身的尺寸</span>\n</code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token function\">onLayout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\">//1. 遍历子View for</span>\n<span class=\"token comment\" spellcheck=\"true\">//2. 确定自己的规则</span>\n<span class=\"token comment\" spellcheck=\"true\">//3. 获取子View的测量尺寸</span>\n<span class=\"token comment\" spellcheck=\"true\">//4. 确定子View的left,top,right,bottom</span>\n<span class=\"token comment\" spellcheck=\"true\">//6. 调用child.layout</span>\n</code></pre>\n<hr>\n<ol>\n<li><p><strong>简介</strong>：点、线、矩形、多边形、 弧、圆等。</p>\n</li>\n<li><p><strong>Paint</strong></p>\n<p>2.1 常用属性</p>\n<p>​    mPaint.setARGB();//设置画笔的A、R、G、B值 </p>\n<p>​    mPaint.setStyle();//设置画笔的风格(空心或实心)</p>\n<p>​    mPaint.setColor();//设置画笔的颜色</p>\n<p>​    mPaint.setAlpha();//设置画笔的Alpha </p>\n<p>​    mPaint.setAntiAlias();// 设置画笔的锯齿效果</p>\n<p>​    mPaint.setTextSize();</p>\n<p>​    mPaint.setStrokeWidth();//设置空心边框的宽度</p>\n<p>   2.2 常用style </p>\n<p>​        Paint.Style.FILL   //填充</p>\n<p>​        Paint.Style.STROKE//空心</p>\n<p>   2.3 注意:用到paint的不同属性时，创建多个画笔，因为ondraw的代码并不是马上就执行 </p>\n</li>\n<li><p><strong>常用的画图方法</strong></p>\n<p>3.1 drawPoint(x,y,paint)//点</p>\n<p>3.2 drawLine(startX,startY,endX,endY,paint)//线</p>\n<p>3.3 drawLines(pts,paint)//绘制多条线，float[] pts=new flaot{startX1,startY1,endX1,endY1,startX2,startY2,endX2,endY2},每够4个float是一条线</p>\n<p>3.4 drawRect(l,t,r,b,paint)//矩形</p>\n<p>3.5 drawPoundRect(l,t,r,b,radiusX,radiusY,paint)//圆角矩形，radiusX,radiusY分别是每一个角的x和y轴上的弧度长度</p>\n<p>3.6 drawtCircle(circleX,circleY,radius，paint)//圆</p>\n<p>3.7 drawArc(l,t,r,b,startAngle,sweepAngle,useCenter,paint)//圆弧，useCenter是否与圆心连线</p>\n<p>3.8 drawOval(l,t,r,b,paint)//椭圆</p>\n<p>3.9 drawText(text,startX，startY,paint)//文本</p>\n<p>3.10 canvas.drawPosText(text, new float[]{x1, y1, x2, y2, x3, y3}mPaint);//指定位置绘制文本，text的个数必须和float的点数一致,已过时</p>\n<p>3.11 drawTextOnPath(text,path,hOffset,vOffset,paint)//给据路径画文字，hOffset角度偏移量，vOffset半径偏移量</p>\n<p>3.12 drawPath(path,paint)//画路径</p>\n</li>\n</ol>\n<p>   4.<strong>Path的用法</strong>//<span class=\"exturl\" data-url=\"aHR0cDovL2Jsb2cuc2luYS5jb20uY24vcy9ibG9nXzRkOWMzZmVjMDEwMnZ5aHMuaHRtbA==\" title=\"http://blog.sina.com.cn/s/blog_4d9c3fec0102vyhs.html\">http://blog.sina.com.cn/s/blog_4d9c3fec0102vyhs.html<i class=\"fa fa-external-link\"></i></span></p>\n<ol start=\"5\">\n<li><p><strong>Canvas常用方法</strong></p>\n<p>5.1 save()//将已经绘制好的图像保存起来</p>\n<p>5.2 restore()//删除所有对矩阵/剪辑状态的修改，自上次保存调用</p>\n<p>5.3 restoreToCount//</p>\n<p>5.4 translate(x,y)//将原始的画布原点（0,0）平移到（x,y）</p>\n<p>5.5 rotate()//将坐标系旋转一定的角度</p>\n<p>5.6 drawColor()//设置画布的颜色  </p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>[TOC]</p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"Android开发进阶的必经之路\"><a href=\"#Android开发进阶的必经之路\" class=\"headerlink\" title=\"Android开发进阶的必经之路\"></a>Android开发进阶的必经之路</h3><h3 id=\"为什么要自定义View\"><a href=\"#为什么要自定义View\" class=\"headerlink\" title=\"为什么要自定义View\"></a>为什么要自定义View</h3><h3 id=\"自定义View的基本方法\"><a href=\"#自定义View的基本方法\" class=\"headerlink\" title=\"自定义View的基本方法\"></a>自定义View的基本方法</h3><p>自定义View的最基本的三个方法分别是： onMeasure()、onLayout()、onDraw();<br>View在Activity中显示出来，要经历测量、布局和绘制三个步骤，分别对应三个动作：measure、layout和draw。<br>","more":"</p>\n<ul>\n<li>测量：onMeasure()决定View的大小；</li>\n<li>布局：onLayout()决定View在ViewGroup中的位置；</li>\n<li>绘制：onDraw()决定绘制这个View。</li>\n</ul>\n<h3 id=\"自定义控件分类\"><a href=\"#自定义控件分类\" class=\"headerlink\" title=\"自定义控件分类\"></a>自定义控件分类</h3><ul>\n<li>自定义View: 只需要重写onMeasure()和onDraw()</li>\n<li>自定义ViewGroup: 则只需要重写onMeasure()和onLayout()</li>\n</ul>\n<h2 id=\"自定义View基础\"><a href=\"#自定义View基础\" class=\"headerlink\" title=\"自定义View基础\"></a>自定义View基础</h2><h3 id=\"View的分类\"><a href=\"#View的分类\" class=\"headerlink\" title=\"View的分类\"></a>View的分类</h3><p>视图View主要分为两类</p>\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>解释</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>单一视图</td>\n<td>即一个View，如TextView</td>\n<td>不包含子View</td>\n</tr>\n<tr>\n<td>视图组</td>\n<td>即多个View组成的ViewGroup，如LinearLayout</td>\n<td>包含子View</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"View类简介\"><a href=\"#View类简介\" class=\"headerlink\" title=\"View类简介\"></a>View类简介</h3><ul>\n<li>View类是Android中各种组件的基类，如View是ViewGroup基类</li>\n<li>View表现为显示在屏幕上的各种视图</li>\n</ul>\n<blockquote>\n<p>Android中的UI组件都由View、ViewGroup组成。</p>\n</blockquote>\n<ul>\n<li><p>View的构造函数：共有4个</p>\n<pre><code class=\"java\">// 如果View是在Java代码里面new的，则调用第一个构造函数\n public CarsonView(Context context) {\n        super(context);\n    }\n\n// 如果View是在.xml里声明的，则调用第二个构造函数\n// 自定义属性是从AttributeSet参数传进来的\n    public  CarsonView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n\n// 不会自动调用\n// 一般是在第二个构造函数里主动调用\n// 如View有style属性时\n    public  CarsonView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n    }\n\n    //API21之后才使用\n    // 不会自动调用\n    // 一般是在第二个构造函数里主动调用\n    // 如View有style属性时\n    public  CarsonView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {\n        super(context, attrs, defStyleAttr, defStyleRes);\n    }\n</code></pre>\n</li>\n</ul>\n<h3 id=\"AttributeSet与自定义属性\"><a href=\"#AttributeSet与自定义属性\" class=\"headerlink\" title=\"AttributeSet与自定义属性\"></a>AttributeSet与自定义属性</h3><p>　系统自带的View可以在xml中配置属性，对于写的好的自定义View同样可以在xml中配置属性，为了使自定义的View的属性可以在xml中配置，需要以下4个步骤：</p>\n<ol>\n<li>通过<code>&lt;declare-styleable&gt;</code>为自定义View添加属性</li>\n<li>在xml中为相应的属性声明属性值</li>\n<li>在运行时（一般为构造函数）获取属性值</li>\n<li>将获取到的属性值应用到View</li>\n</ol>\n<h3 id=\"View视图结构\"><a href=\"#View视图结构\" class=\"headerlink\" title=\"View视图结构\"></a>View视图结构</h3><ol>\n<li>PhoneWindow是Android系统中最基本的窗口系统，继承自Windows类，负责管理界面显示以及事件响应。它是Activity与View系统交互的接口，每个Activity都会创建一个</li>\n<li>DecorView是PhoneWindow中的起始节点View，继承于View类，作为整个视图容器来使用。用于设置窗口属性。它本质上是一个FrameLayout</li>\n<li>ViewRoot在Activtiy启动时创建，负责管理、布局、渲染窗口UI等等</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/activity.png\" alt=\"activity\"></p>\n<p>对于多View的视图，结构是树形结构：最顶层是ViewGroup，ViewGroup下可能有多个ViewGroup或View，如下图：</p>\n<p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_arch.png\" alt=\"view_arch\"></p>\n<p>一定要记住：无论是measure过程、layout过程还是draw过程，永远都是从View树的根节点开始测量或计算（即从树的顶端开始），一层一层、一个分支一个分支地进行（即树形递归），最终计算整个View树中各个View，最终确定整个View树的相关属性。</p>\n<h3 id=\"Android坐标系\"><a href=\"#Android坐标系\" class=\"headerlink\" title=\"Android坐标系\"></a>Android坐标系</h3><p>Android的坐标系定义为：</p>\n<ul>\n<li>屏幕的左上角为坐标原点</li>\n<li>向右为x轴增大方向</li>\n<li>向下为y轴增大方向<br><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/zuobiaoxi.png\" alt=\"zuobiaoxi\"></li>\n</ul>\n<blockquote>\n<p>区别于一般的数学坐标系<br><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/zuobiaoxi_qubie.png\" alt=\"zuobiaoxi_qubie\"></p>\n</blockquote>\n<h3 id=\"View位置（坐标）描述\"><a href=\"#View位置（坐标）描述\" class=\"headerlink\" title=\"View位置（坐标）描述\"></a>View位置（坐标）描述</h3><p>View的位置由4个顶点决定的<br>4个顶点的位置描述分别由4个值决定：</p>\n<blockquote>\n<p>请记住：View的位置是相对于父控件而言的）</p>\n</blockquote>\n<ul>\n<li>Top：子View上边界到父view上边界的距离</li>\n<li>Left：子View左边界到父view左边界的距离</li>\n<li>Bottom：子View下边距到父View上边界的距离</li>\n<li>Right：子View右边界到父view左边界的距离</li>\n</ul>\n<h3 id=\"位置获取方式\"><a href=\"#位置获取方式\" class=\"headerlink\" title=\"位置获取方式\"></a>位置获取方式</h3><p>View的位置是通过view.getxxx()函数进行获取：（以Top为例）</p>\n<pre><code class=\"java\">// 获取Top位置\npublic final int getTop() {  \n    return mTop;  \n}  \n\n// 其余如下：\n  getLeft();      //获取子View左上角距父View左侧的距离\n  getBottom();    //获取子View右下角距父View顶部的距离\n  getRight();     //获取子View右下角距父View左侧的距离\n</code></pre>\n<p>与MotionEvent中 get()和getRaw()的区别</p>\n<pre><code class=\"java\">//get() ：触摸点相对于其所在组件坐标系的坐标\n event.getX();       \n event.getY();\n\n//getRaw() ：触摸点相对于屏幕默认坐标系的坐标\n event.getRawX();    \n event.getRawY();\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/zuobiaoxiweizhi.png\" alt=\"zuobiaoxiweizhi\"></p>\n<h3 id=\"Android中颜色相关内容\"><a href=\"#Android中颜色相关内容\" class=\"headerlink\" title=\"Android中颜色相关内容\"></a>Android中颜色相关内容</h3><p>Android支持的颜色模式：<br><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/color1.png\" alt=\"color1\"></p>\n<p>以ARGB8888为例介绍颜色定义:<br><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/color2.png\" alt=\"color2\"></p>\n<h2 id=\"View树的绘制流程\"><a href=\"#View树的绘制流程\" class=\"headerlink\" title=\"View树的绘制流程\"></a>View树的绘制流程</h2><h3 id=\"View树的绘制流程是谁负责的？\"><a href=\"#View树的绘制流程是谁负责的？\" class=\"headerlink\" title=\"View树的绘制流程是谁负责的？\"></a>View树的绘制流程是谁负责的？</h3><p>view树的绘制流程是通过ViewRoot去负责绘制的，ViewRoot这个类的命名有点坑，最初看到这个名字，翻译过来是view的根节点，但是事实完全不是这样，ViewRoot其实不是View的根节点，它连view节点都算不上，它的主要作用是View树的管理者，负责将DecorView和PhoneWindow“组合”起来，而View树的根节点严格意义上来说只有DecorView；每个DecorView都有一个ViewRoot与之关联，这种关联关系是由WindowManager去进行管理的；绘制就是从ViewRoot.performTraversals()开始的。</p>\n<pre><code class=\"java\">  private void performTraversals() {\n        .....\n        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);\n        .....\n        performLayout(lp, mWidth, mHeight);\n        .....\n        performDraw();\n        .....\n    }\n</code></pre>\n<h3 id=\"view的添加\"><a href=\"#view的添加\" class=\"headerlink\" title=\"view的添加\"></a>view的添加</h3><p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_qiyuan.png\" alt></p>\n<h3 id=\"view的绘制流程\"><a href=\"#view的绘制流程\" class=\"headerlink\" title=\"view的绘制流程\"></a>view的绘制流程</h3><p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_traversals.png\" alt=\"view_traversals\"></p>\n<h3 id=\"measure\"><a href=\"#measure\" class=\"headerlink\" title=\"measure\"></a>measure</h3><ol>\n<li><p>系统为什么要有measure过程？</p>\n<pre><code class=\"xml\">    &lt;TextView\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;match_parent&quot;\n        android:text=&quot;Hello World!&quot; /&gt;\n</code></pre>\n<p>谷歌建议使用自适应，自适应的话，就不知道大小，所以需要去测量。</p>\n</li>\n<li><p>measure过程都干了点什么事？</p>\n</li>\n<li><p>对于自适应的尺寸机制，如何合理的测量一颗View树？</p>\n</li>\n<li><p>那么ViewGroup是如何向子View传递限制信息的？</p>\n</li>\n<li><p>ScrollView嵌套ListView问题？</p>\n</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_requestlayout.png\" alt=\"view_requestlayout\"></p>\n<h3 id=\"layout\"><a href=\"#layout\" class=\"headerlink\" title=\"layout\"></a>layout</h3><ol>\n<li>系统为什么要有layout过程？</li>\n<li>layout过程都干了点什么事？</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_performlayout.png\" alt=\"view_performlayout\"></p>\n<h3 id=\"draw\"><a href=\"#draw\" class=\"headerlink\" title=\"draw\"></a>draw</h3><ol>\n<li>系统为什么要有draw过程？</li>\n<li>draw过程都干了点什么事？</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/view_invalidate.png\" alt=\"view_invalidate\"></p>\n<h2 id=\"LayoutParams\"><a href=\"#LayoutParams\" class=\"headerlink\" title=\"LayoutParams\"></a>LayoutParams</h2><p>ayoutParams翻译过来就是布局参数，子View通过LayoutParams告诉父容器（ViewGroup）应该如何放置自己。从这个定义中也可以看出来LayoutParams与ViewGroup是息息相关的，因此脱离ViewGroup谈LayoutParams是没有意义的。</p>\n<p>事实上，每个ViewGroup的子类都有自己对应的LayoutParams类，典型的如LinearLayout.LayoutParams和FrameLayout.LayoutParams等，可以看出来LayoutParams都是对应ViewGroup子类的内部类</p>\n<h3 id=\"MarginLayoutParams\"><a href=\"#MarginLayoutParams\" class=\"headerlink\" title=\"MarginLayoutParams\"></a>MarginLayoutParams</h3><p>MarginLayoutParams是和外间距有关的。事实也确实如此，和LayoutParams相比，MarginLayoutParams只是增加了对上下左右外间距的支持。实际上大部分LayoutParams的实现类都是继承自MarginLayoutParams，因为基本所有的父容器都是支持子View设置外间距的</p>\n<ul>\n<li>属性优先级问题<br>MarginLayoutParams主要就是增加了上下左右4种外间距。在构造方法中，先是获取了margin属性；如果该值不合法，就获取horizontalMargin；如果该值不合法，再去获取leftMargin和rightMargin属性（verticalMargin、topMargin和bottomMargin同理）。我们可以据此总结出这几种属性的优先级</li>\n</ul>\n<blockquote>\n<p>margin &gt; horizontalMargin和verticalMargin &gt; leftMargin和RightMargin、topMargin和bottomMargin</p>\n</blockquote>\n<ul>\n<li>属性覆盖问题<br>优先级更高的属性会覆盖掉优先级较低的属性。此外，还要注意一下这几种属性上的注释</li>\n</ul>\n<blockquote>\n<p>Call {@link ViewGroup#setLayoutParams(LayoutParams)} after reassigning a new value</p>\n</blockquote>\n<h3 id=\"LayoutParams与View如何建立联系\"><a href=\"#LayoutParams与View如何建立联系\" class=\"headerlink\" title=\"LayoutParams与View如何建立联系\"></a>LayoutParams与View如何建立联系</h3><ul>\n<li>在XML中定义View</li>\n<li>在Java代码中直接生成View对应的实例对象</li>\n</ul>\n<h3 id=\"addView\"><a href=\"#addView\" class=\"headerlink\" title=\"addView\"></a>addView</h3><pre><code class=\"java\">/**\n * 重载方法1：添加一个子View\n * 如果这个子View还没有LayoutParams，就为子View设置当前ViewGroup默认的LayoutParams\n */\npublic void addView(View child) {\n    addView(child, -1);\n}\n\n/**\n * 重载方法2：在指定位置添加一个子View\n * 如果这个子View还没有LayoutParams，就为子View设置当前ViewGroup默认的LayoutParams\n * @param index View将在ViewGroup中被添加的位置（-1代表添加到末尾）\n */\npublic void addView(View child, int index) {\n    if (child == null) {\n        throw new IllegalArgumentException(&quot;Cannot add a null child view to a ViewGroup&quot;);\n    }\n    LayoutParams params = child.getLayoutParams();\n    if (params == null) {\n        params = generateDefaultLayoutParams();// 生成当前ViewGroup默认的LayoutParams\n        if (params == null) {\n            throw new IllegalArgumentException(&quot;generateDefaultLayoutParams() cannot return null&quot;);\n        }\n    }\n    addView(child, index, params);\n}\n\n/**\n * 重载方法3：添加一个子View\n * 使用当前ViewGroup默认的LayoutParams，并以传入参数作为LayoutParams的width和height\n */\npublic void addView(View child, int width, int height) {\n    final LayoutParams params = generateDefaultLayoutParams();  // 生成当前ViewGroup默认的LayoutParams\n    params.width = width;\n    params.height = height;\n    addView(child, -1, params);\n}\n\n/**\n * 重载方法4：添加一个子View，并使用传入的LayoutParams\n */\n@Override\npublic void addView(View child, LayoutParams params) {\n    addView(child, -1, params);\n}\n\n/**\n * 重载方法4：在指定位置添加一个子View，并使用传入的LayoutParams\n */\npublic void addView(View child, int index, LayoutParams params) {\n    if (child == null) {\n        throw new IllegalArgumentException(&quot;Cannot add a null child view to a ViewGroup&quot;);\n    }\n\n    // addViewInner() will call child.requestLayout() when setting the new LayoutParams\n    // therefore, we call requestLayout() on ourselves before, so that the child&#39;s request\n    // will be blocked at our level\n    requestLayout();\n    invalidate(true);\n    addViewInner(child, index, params, false);\n}\n\nprivate void addViewInner(View child, int index, LayoutParams params,\n        boolean preventRequestLayout) {\n    .....\n    if (mTransition != null) {\n        mTransition.addChild(this, child);\n    }\n\n    if (!checkLayoutParams(params)) { // ① 检查传入的LayoutParams是否合法\n        params = generateLayoutParams(params); // 如果传入的LayoutParams不合法，将进行转化操作\n    }\n\n    if (preventRequestLayout) { // ② 是否需要阻止重新执行布局流程\n        child.mLayoutParams = params; // 这不会引起子View重新布局（onMeasure-&gt;onLayout-&gt;onDraw）\n    } else {\n        child.setLayoutParams(params); // 这会引起子View重新布局（onMeasure-&gt;onLayout-&gt;onDraw）\n    }\n\n    if (index &lt; 0) {\n        index = mChildrenCount;\n    }\n\n    addInArray(child, index);\n\n    // tell our children\n    if (preventRequestLayout) {\n        child.assignParent(this);\n    } else {\n        child.mParent = this;\n    }\n    .....\n}\n\n</code></pre>\n<h3 id=\"自定义LayoutParams\"><a href=\"#自定义LayoutParams\" class=\"headerlink\" title=\"自定义LayoutParams\"></a>自定义LayoutParams</h3><ol>\n<li>创建自定义属性</li>\n</ol>\n<pre><code class=\"java\">&lt;resources&gt;\n    &lt;declare-styleable name=&quot;xxxViewGroup_Layout&quot;&gt;\n        &lt;!-- 自定义的属性 --&gt;\n        &lt;attr name=&quot;layout_simple_attr&quot; format=&quot;integer&quot;/&gt;\n        &lt;!-- 使用系统预置的属性 --&gt;\n        &lt;attr name=&quot;android:layout_gravity&quot;/&gt;\n    &lt;/declare-styleable&gt;\n&lt;/resources&gt;\n</code></pre>\n<ol start=\"2\">\n<li>继承MarginLayout</li>\n</ol>\n<pre><code class=\"java\">public static class LayoutParams extends ViewGroup.MarginLayoutParams {\n    public int simpleAttr;\n    public int gravity;\n\n    public LayoutParams(Context c, AttributeSet attrs) {\n        super(c, attrs);\n        // 解析布局属性\n        TypedArray typedArray = c.obtainStyledAttributes(attrs, R.styleable.SimpleViewGroup_Layout);\n        simpleAttr = typedArray.getInteger(R.styleable.SimpleViewGroup_Layout_layout_simple_attr, 0);\n        gravity=typedArray.getInteger(R.styleable.SimpleViewGroup_Layout_android_layout_gravity, -1);\n\n        typedArray.recycle();//释放资源\n    }\n\n    public LayoutParams(int width, int height) {\n        super(width, height);\n    }\n\n    public LayoutParams(MarginLayoutParams source) {\n        super(source);\n    }\n\n    public LayoutParams(ViewGroup.LayoutParams source) {\n        super(source);\n    }\n}\n</code></pre>\n<ol start=\"3\">\n<li>重写ViewGroup中几个与LayoutParams相关的方法</li>\n</ol>\n<pre><code class=\"java\">// 检查LayoutParams是否合法\n@Override\nprotected boolean checkLayoutParams(ViewGroup.LayoutParams p) { \n    return p instanceof SimpleViewGroup.LayoutParams;\n}\n\n// 生成默认的LayoutParams\n@Override\nprotected ViewGroup.LayoutParams generateDefaultLayoutParams() { \n    return new SimpleViewGroup.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);\n}\n\n// 对传入的LayoutParams进行转化\n@Override\nprotected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) { \n    return new SimpleViewGroup.LayoutParams(p);\n}\n\n// 对传入的LayoutParams进行转化\n@Override\npublic ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) { \n    return new SimpleViewGroup.LayoutParams(getContext(), attrs);\n}\n</code></pre>\n<h3 id=\"LayoutParams常见的子类\"><a href=\"#LayoutParams常见的子类\" class=\"headerlink\" title=\"LayoutParams常见的子类\"></a>LayoutParams常见的子类</h3><p>在为View设置LayoutParams的时候需要根据它的父容器选择对应的LayoutParams，否则结果可能与预期不一致，这里简单罗列一些常见的LayoutParams子类：</p>\n<ul>\n<li>ViewGroup.MarginLayoutParams</li>\n<li>FrameLayout.LayoutParams</li>\n<li>LinearLayout.LayoutParams</li>\n<li>RelativeLayout.LayoutParams</li>\n<li>RecyclerView.LayoutParams</li>\n<li>GridLayoutManager.LayoutParams</li>\n<li>StaggeredGridLayoutManager.LayoutParams</li>\n<li>ViewPager.LayoutParams</li>\n<li>WindowManager.LayoutParams</li>\n</ul>\n<h2 id=\"MeasureSpec\"><a href=\"#MeasureSpec\" class=\"headerlink\" title=\"MeasureSpec\"></a>MeasureSpec</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>测量规格,封装了父容器对 view 的布局上的限制，内部提供了宽高的信息（ SpecMode 、 SpecSize ），SpecSize是指在某种SpecMode下的参考尺寸，其中SpecMode 有如下三种：</p>\n<ul>\n<li><p>UNSPECIFIED<br>不指定测量模式，父控件不对你有任何限制，你想要多大给你多大，想上天就上天。这种情况一般用于系统内部，表示一种测量状态。（这个模式主要用于系统内部多次Measure的情形，并不是真的说你想要多大最后就真有多大，开发中很少用到）</p>\n</li>\n<li><p>EXACTLY<br>精确测量模式，当该视图的宽高为match_parent或者具体数值时生效，表示父布局已经决定了子视图的精确大小，View的测量值就是SpecSize。</p>\n</li>\n<li><p>AT_MOST<br>当该视图的宽高为wrap_content时生效，你的大小不能大于父控件给你指定的size，但具体是多少，得看你自己的实现。<br>MeasureSpecs（32位的Int）=SpecMode（高2位） + SpecSize（低30位）</p>\n<pre><code class=\"java\">//获取尚未显示的view的宽和高\nint tempWidth =View.MeasureSpec.makeMeasureSpec(0,View.MeasureSpec.UNSPECIFIED);\nint tempHeight =View.MeasureSpec.makeMeasureSpec(0,View.MeasureSpec.UNSPECIFIED);\nview.measure(tempWidth,tempHeight);\nint realHeight=view.getMeasuredHeight(); \nint realWidth=view.getMeasuredWidth();\n</code></pre>\n</li>\n</ul>\n<h3 id=\"MeasureSpecs-的意义\"><a href=\"#MeasureSpecs-的意义\" class=\"headerlink\" title=\"MeasureSpecs 的意义\"></a>MeasureSpecs 的意义</h3><p>通过将 SpecMode 和 SpecSize 打包成一个 int 值可以避免过多的对象内存分配，为了方便操作，其提供了打包 / 解包方法</p>\n<h3 id=\"MeasureSpec值的确定\"><a href=\"#MeasureSpec值的确定\" class=\"headerlink\" title=\"MeasureSpec值的确定\"></a>MeasureSpec值的确定</h3><p>MeasureSpec值到底是如何计算得来的呢?</p>\n<p>对于DecorView而言，他的MeasureSpecs是由自身窗口大小和自身的LayoutParams共同决定的，子View的MeasureSpec值是根据子View的布局参数（LayoutParams）和父容器的MeasureSpec值计算得来的，具体计算逻辑封装在getChildMeasureSpec()里</p>\n<pre><code class=\"java\">    private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {\n        ...\n        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n        ...\n    }\n</code></pre>\n<p>具体的测量操作是分发给ViewGroup的，由ViewGroup的measureChildren方法传递为子View，如下</p>\n<pre><code class=\"java\">   protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {\n        final int size = mChildrenCount;\n        final View[] children = mChildren;\n        for (int i = 0; i &lt; size; ++i) {\n            final View child = children[i];\n            if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) {\n                //测量指定的View\n                measureChild(child, widthMeasureSpec, heightMeasureSpec);\n            }\n        }\n    }\n</code></pre>\n<p>测量指定的View</p>\n<pre><code class=\"java\">    protected void measureChild(View child, int parentWidthMeasureSpec,\n            int parentHeightMeasureSpec) {\n        final LayoutParams lp = child.getLayoutParams();\n        //根据父容器的MeasureSpec和子View的布局参数（LayoutParams）计算子View的MeasureSpec\n        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,\n                mPaddingLeft + mPaddingRight, lp.width);\n        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,\n                mPaddingTop + mPaddingBottom, lp.height);\n\n        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n    }\n</code></pre>\n<p>子View的MeasureSpec值是根据子View的布局参数（LayoutParams）和父容器的MeasureSpec值计算得来的，具体计算逻辑封装在getChildMeasureSpec()里</p>\n<pre><code class=\"java\">  /**\n     *\n     * 目标是将父控件的测量规格和child view的布局参数LayoutParams相结合，得到一个\n     * 最可能符合条件的child view的测量规格。  \n\n     * @param spec 父控件的测量规格\n     * @param padding 父控件里已经占用的大小\n     * @param childDimension child view布局LayoutParams里的尺寸\n     * @return child view 的测量规格\n     */\n    public static int getChildMeasureSpec(int spec, int padding, int childDimension) {\n        int specMode = MeasureSpec.getMode(spec); //父控件的测量模式\n        int specSize = MeasureSpec.getSize(spec); //父控件的测量大小\n\n        int size = Math.max(0, specSize - padding);\n\n        int resultSize = 0;\n        int resultMode = 0;\n\n        switch (specMode) {\n        // 当父控件的测量模式 是 精确模式，也就是有精确的尺寸了\n        case MeasureSpec.EXACTLY:\n            //如果child的布局参数有固定值，比如&quot;layout_width&quot; = &quot;100dp&quot;\n            //那么显然child的测量规格也可以确定下来了，测量大小就是100dp，测量模式也是EXACTLY\n            if (childDimension &gt;= 0) {\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } \n\n            //如果child的布局参数是&quot;match_parent&quot;，也就是想要占满父控件\n            //而此时父控件是精确模式，也就是能确定自己的尺寸了，那child也能确定自己大小了\n            else if (childDimension == LayoutParams.MATCH_PARENT) {\n                resultSize = size;\n                resultMode = MeasureSpec.EXACTLY;\n            }\n            //如果child的布局参数是&quot;wrap_content&quot;，也就是想要根据自己的逻辑决定自己大小，\n            //比如TextView根据设置的字符串大小来决定自己的大小\n            //那就自己决定呗，不过你的大小肯定不能大于父控件的大小嘛\n            //所以测量模式就是AT_MOST，测量大小就是父控件的size\n            else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            }\n            break;\n\n        // 当父控件的测量模式 是 最大模式，也就是说父控件自己还不知道自己的尺寸，但是大小不能超过size\n        case MeasureSpec.AT_MOST:\n            //同样的，既然child能确定自己大小，尽管父控件自己还不知道自己大小，也优先满足孩子的需求\n            if (childDimension &gt;= 0) {\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } \n            //child想要和父控件一样大，但父控件自己也不确定自己大小，所以child也无法确定自己大小\n            //但同样的，child的尺寸上限也是父控件的尺寸上限size\n            else if (childDimension == LayoutParams.MATCH_PARENT) {\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            }\n            //child想要根据自己逻辑决定大小，那就自己决定呗\n            else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            }\n            break;\n\n        // Parent asked to see how big we want to be\n        case MeasureSpec.UNSPECIFIED:\n            if (childDimension &gt;= 0) {\n                // Child wants a specific size... let him have it\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == LayoutParams.MATCH_PARENT) {\n                // Child wants to be our size... find out how big it should\n                // be\n                resultSize = 0;\n                resultMode = MeasureSpec.UNSPECIFIED;\n            } else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                // Child wants to determine its own size.... find out how\n                // big it should be\n                resultSize = 0;\n                resultMode = MeasureSpec.UNSPECIFIED;\n            }\n            break;\n        }\n        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);\n    }\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/measurespec3.png\" alt=\"measurespec3\"><br>针对上表，这里再做一下具体的说明</p>\n<ul>\n<li><p>对于应用层 View ，其 MeasureSpec 由父容器的 MeasureSpec 和自身的 LayoutParams 来共同决定</p>\n</li>\n<li><p>对于不同的父容器和view本身不同的LayoutParams，view就可以有多种MeasureSpec。</p>\n<pre><code>1.  当view采用固定宽高的时候，不管父容器的MeasureSpec是什么，view的MeasureSpec都是精确模式并且其大小遵循Layoutparams中的大小；\n2. 当view的宽高是match_parent时，这个时候如果父容器的模式是精准模式，那么view也是精准模式并且其大小是父容器的剩余空间，如果父容器是最大模式，那么view也是最大模式并且其大小不会超过父容器的剩余空间；\n3.  当view的宽高是wrap_content时，不管父容器的模式是精准还是最大化，view的模式总是最大化并且大小不能超过父容器的剩余空间。\n4. Unspecified模式，这个模式主要用于系统内部多次measure的情况下，一般来说，我们不需要关注此模式(这里注意自定义View放到ScrollView的情况 需要处理)。\n</code></pre></li>\n</ul>\n<h3 id=\"View-（ViewGroup）的measure方法\"><a href=\"#View-（ViewGroup）的measure方法\" class=\"headerlink\" title=\"View （ViewGroup）的measure方法\"></a>View （ViewGroup）的measure方法</h3><p>  最终是通过回调onMeasure方法实现的，这个方法通常有View的特定子类的方法去实现的，通过重写这个View实现自定义View。</p>\n<pre><code>    public final void measure(int widthMeasureSpec, int heightMeasureSpec) {\n        ...\n        onMeasure(widthMeasureSpec, heightMeasureSpec);\n        ...\n    }\n\n</code></pre><pre><code>    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        //设置size\n        setMeasuredDimension(1,1);\n    }\n</code></pre><hr>\n<pre><code class=\"java\">onMeasure()\n//1. 测量自身\n//2. 为每个子View计算测量的限制信息 Mode / Size\n//3. 把上一步确定的限制信息，传递给每一个子View，然后子View开始measure\n//4. 获取子View测量完成后的尺寸\n//5. ViewGroup根据自身的情况，计算自己的尺寸\n//6. 保存自身的尺寸\n</code></pre>\n<pre><code class=\"java\">onLayout()\n//1. 遍历子View for\n//2. 确定自己的规则\n//3. 获取子View的测量尺寸\n//4. 确定子View的left,top,right,bottom\n//6. 调用child.layout\n</code></pre>\n<hr>\n<ol>\n<li><p><strong>简介</strong>：点、线、矩形、多边形、 弧、圆等。</p>\n</li>\n<li><p><strong>Paint</strong></p>\n<p>2.1 常用属性</p>\n<p>​    mPaint.setARGB();//设置画笔的A、R、G、B值 </p>\n<p>​    mPaint.setStyle();//设置画笔的风格(空心或实心)</p>\n<p>​    mPaint.setColor();//设置画笔的颜色</p>\n<p>​    mPaint.setAlpha();//设置画笔的Alpha </p>\n<p>​    mPaint.setAntiAlias();// 设置画笔的锯齿效果</p>\n<p>​    mPaint.setTextSize();</p>\n<p>​    mPaint.setStrokeWidth();//设置空心边框的宽度</p>\n<p>   2.2 常用style </p>\n<p>​        Paint.Style.FILL   //填充</p>\n<p>​        Paint.Style.STROKE//空心</p>\n<p>   2.3 注意:用到paint的不同属性时，创建多个画笔，因为ondraw的代码并不是马上就执行 </p>\n</li>\n<li><p><strong>常用的画图方法</strong></p>\n<p>3.1 drawPoint(x,y,paint)//点</p>\n<p>3.2 drawLine(startX,startY,endX,endY,paint)//线</p>\n<p>3.3 drawLines(pts,paint)//绘制多条线，float[] pts=new flaot{startX1,startY1,endX1,endY1,startX2,startY2,endX2,endY2},每够4个float是一条线</p>\n<p>3.4 drawRect(l,t,r,b,paint)//矩形</p>\n<p>3.5 drawPoundRect(l,t,r,b,radiusX,radiusY,paint)//圆角矩形，radiusX,radiusY分别是每一个角的x和y轴上的弧度长度</p>\n<p>3.6 drawtCircle(circleX,circleY,radius，paint)//圆</p>\n<p>3.7 drawArc(l,t,r,b,startAngle,sweepAngle,useCenter,paint)//圆弧，useCenter是否与圆心连线</p>\n<p>3.8 drawOval(l,t,r,b,paint)//椭圆</p>\n<p>3.9 drawText(text,startX，startY,paint)//文本</p>\n<p>3.10 canvas.drawPosText(text, new float[]{x1, y1, x2, y2, x3, y3}mPaint);//指定位置绘制文本，text的个数必须和float的点数一致,已过时</p>\n<p>3.11 drawTextOnPath(text,path,hOffset,vOffset,paint)//给据路径画文字，hOffset角度偏移量，vOffset半径偏移量</p>\n<p>3.12 drawPath(path,paint)//画路径</p>\n</li>\n</ol>\n<p>   4.<strong>Path的用法</strong>//<span class=\"exturl\" data-url=\"aHR0cDovL2Jsb2cuc2luYS5jb20uY24vcy9ibG9nXzRkOWMzZmVjMDEwMnZ5aHMuaHRtbA==\" title=\"http://blog.sina.com.cn/s/blog_4d9c3fec0102vyhs.html\">http://blog.sina.com.cn/s/blog_4d9c3fec0102vyhs.html<i class=\"fa fa-external-link\"></i></span></p>\n<ol start=\"5\">\n<li><p><strong>Canvas常用方法</strong></p>\n<p>5.1 save()//将已经绘制好的图像保存起来</p>\n<p>5.2 restore()//删除所有对矩阵/剪辑状态的修改，自上次保存调用</p>\n<p>5.3 restoreToCount//</p>\n<p>5.4 translate(x,y)//将原始的画布原点（0,0）平移到（x,y）</p>\n<p>5.5 rotate()//将坐标系旋转一定的角度</p>\n<p>5.6 drawColor()//设置画布的颜色  </p>\n</li>\n</ol>"},{"title":"RecyclerView 总结","_content":"\n\n\n## List View 的局限性\n\n1. 只有纵向列表一种布局\n2. 没有支持动画的  API\n3. 接口设计和系统不一致\n   1. setOnItemClickListener()\n   2. setOnItemLongClickListener()\n   3. setSelection()\n4. 没有强制实现 ViewHolder\n5. 性能不如 RecyclerView\n\n## RecyclerView 优势\n\n1. 默认支持 Linear、Grid、Staggered Grid 三种布局\n2. 友好的 ItemAnimator 动画 API\n3. 强制实现 ViewHolder\n4. 解耦的架构设计\n5. 相对 ListView 性能更好\n\n \n<!-- more-->\n\n\n![image-20200709164241306](https://github.com/xiaomanwong/static_file/blob/master/images/image-20200709164241306.png?raw=true)\n\n\n\nRecycler View： 负责将 Datas 展示在自己身上，其本身是一个 ViewGroup，只认识 View，因此需要一个 Adapter 来将 Datas 的内容转换为 View\n\nAdapter： 负责翻译，将 Datas 内容，转换为 View，方便 RecyclerView 展示\n\nViewHolder： RecyclerView 只会与 ViewHolder 进行交互，因此 ViewHolder 充当中间件，来将 Datas 的内容传递给  RecyclerView\n\nLayoutManager：负责布局，RecyclerView 将其子 View 的布局管理，交给它来完成\n\nRecycler：负责管理 View 的生命周期，LayoutManager 只管负责 View 的布局任务，对其回收交给了 Recycler 来处理，避免造成不必要的错误\n\nItemAnimator： 负责动画，当 RecyclerView 中的数据发生变化（增、删等）都会通过它来完成平滑的过渡\n\n\n\n## RecyclerView 的绘制\n\nRecyclerView 无疑也是一个 View ，View 的绘制同样逃离不了三大步骤 `onMeasure()` `onLayout()` `onDraw()` \n\n\n\n### onMeasure\n\nLayoutManager 负责 RecyclerView 的绘制，其有一个 `mAutoMeasure` 属性，用来控制是否开启自动测量，开启情况下，布局交由 `RecyclerView` 使用一套默认的测量机制；否则，自定义的 LayoutManager 需要重写 `onMeasure` 来处理自身的测量工作。\n\n#### **自动测量原理：**\n\n当 RecyclerView 的宽高都为 `EXACTLY` 时， 可以直接设置对应的宽高，然后返回，结束测量\n\n如果宽高都不时 `EXACTLY` 则会在 `onMeasure` 中开始布局的处理。\n\nRecyclerView.State 这个类封装了当前 RecyclerView 的信息。State 中的一个变量 `mLayoutStep` 记录了 RecyclerView  当前的布局状态\n\n* STEP_START\n* STEP_LAYOUT\n* STEP_ANIMATIONS\n\n对应的， RecyclerView 的布局过程也分为三步，STEP_START 表示开始布局，对应需要调用 `dispatchLayoutStep1()` 来执行第一步布局，结束后， `mLayoutStep` 变为 STEP_LAYOUT ，表示接下来需要调用 `dispatchLayoutStep2()` 进行布局，结束后 `mLayoutStep` 变为 STEP_ANIMATIONS, 继续执行第三步 `dispatchLayoutStep3()`\n\n\n\n* dispatchLayoutStep1:  负责记录状态\n\n* dispatchLayoutStep2：负责布局\n* dispatchLayoutStep3：与 step1 比较，根据变化来触发动画\n\n\n\n### onLayout\n\n```java\nprotected void onLayout(boolean changed, int l int t, int r, int b) {\n    TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);\n    dispatchLayout();\n    TraceCompat.endSection();\n    mFirstLayoutComplete = true;\n}\n\nvoid dispatchLayout() {\n    mState.mIsMeasuring = false;\n    if(mState.mLayoutStep == State.STEP_START) {\n        dispatchLayoutStep1();\n        mLayout.setExactMeasureSpecsFrom(this);\n        dispatchLayoutStep2();\n    } else if(mAdapterHelper.hasUpdates() \n              || mLayout.getWidth() != getWidth() \n              || mLayout.getHeight() != getHeight()) {\n        // first 2 steps are done in onMeasure but looks like we have to run again due to changed size\n        mLayout.setExactMeasureSpecsFrom(this);\n        dispatchLayoutStep2();\n    } else {\n        // always make sure we sync them (to ensure mode is exact)\n        mLayout.setExactMeasureSpecsFrom(this);\n    }\n    \n    dispatchLayoutStep3();\n}\n```\n\n通过 `dispatchLayout` 可以验证RecyclerView 的 layout三步走原则，如果在 `onMeasure` 中已经完成了 step1 和 step2 ，则只会执行 step3，否则，会在 `onLayout` 中依次触发三步走。\n\n#### dispatchLayoutStep1\n\n```java\nprivate void dispatchLayoutStep1(){\n\tif(mState.mRunSimpleAnimations) {\n        int count = mChildHelper.getChildCount();\n        for(int i = 0; i < count; i++) {\n            final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));\n            final ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(mState, holder, ItemAnimator.buildAdapterChangeFlagsForAnimations(holder), holder.getUnmodifiedPayloads());\n            mViewInfoStore.addToPreLayout(holder, animationInfo);\n        }\n    }\n    mState.mLayoutStep = State.STEP_LAYOUT\n}\n```\n\nstep 的第一步目的就是记录 View 的状态，先遍历当前所有 View，一次进行处理，mItemAnimator 会根据每个 View 的信息，封装一个 ItemHolderInfo, 这个 ItemHolderInfo 中主要包含的就是 View 的位置状态等。然后将 ItemHodlerInfo 存入 mViewInfoStore 中。在进入第二步后， View 的信息就将被改变\n\n#### dispatchLayoutStep2\n\n```java\nprivate void dispatchLayoutStep2(){\n    mLayout.onLayoutChildren(mRecycler, mState);\n    \n    mState.mLayoutStep = State.STATE_ANIMATIONS;\n}\n```\n\nlayout 的第二步就是真正的布局 View。RecyclerView 的真正布局是由 LayoutManger 来负责的，其主要工作也在 LayoutManager 中。\n\n```java\npublic  void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {\n    \n    if(!mAnchorInfo.mValid \n      || mPendingScrollPosition != NO_POSITION \n      || mPendingSavedState != null) {\n        updateAnchorInfoForLayout(recycler, state, mAnchorInfo);\n    }\n    \n    if(mAnchorInfo.mLayoutFromEnd) {\n        firstLayoutDirection = mShouldReverseLayout \n            ? LayoutState.ITEM_DIRECTIONTAIL\n            : LayoutState.ITEM_DIRECTION_HEAD;\n    } else {\n        firstLayoutDirection = mShouldReverseLayout \n            ? LayoutState.ITEM_DIRECTION_HEAD\n            : LayoutState.ITEM_DIRECTION_TAIL;\n    }\n    \n    onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);\n    \n    if(mAnchorInfo.mLayoutFromEnd) {\n        \n    } else {\n        // fill towards end\n        updateLayouStateToFillEnd(mAnchorInfo);\n        fill(recycler, mLayoutState, state, false);\n        \n        // fill towards start\n        updateLayoutStateToFillStart(mAnchorInfo);\n        fill(recycler, mLayoutState, state, false);\n    }\n}\n```\n\n流程很负责，大致流程如下\n\n* 找到 anchor点\n* 根据 anchor 一直向前布局，直到填充满 anchor 点前面的所有区域\n* 根据 anchor 一直向后布局，直到填充满 anchor 点后面的所有区域\n\nanchor 点的寻找是由 `updateAnchorInfoForLayout` 函数负责。向下追踪会看到 `updateAnchorFromChildren`  方法，其内容为，先寻找被 focus 的 child， 找到以此 child 作为 anchor ，否则根据布局方向寻找最合适的 child 来作为 anchor，如果找到则将 child 的信息复制给 anchorInfo 。 `anchorInfo` 主要记录的信息就是 View 的物理位置与 Adapter 中的位置。找到后返回 true，否则返回 false，交给上一步函数做处理。\n\n继续当找到 anchor 后，会根据 anchor 来布局，通过 fill 方法来完成\n\n```java\nint fill(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.state state, boolean stopOnFocusable) {\n    final int start = layoutState.mAvailable;\n    if(layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {\n        recycleByLayoutState(recycler, layoutState);\n    }\n    \n    int remainingSpace = layoutState.mAvailable + layoutState.mExtra;\n    LayoutChunkResult layoutChunkResult = mLayoutChunkResult;\n    while((layoutState.mInfinite || remainingSpace > 0)\n         && layoutState.hasMore(state)) {\n        layoutChunk(recycler, state, layoutState, layoutChunkResult);\n    }\n    return start-layoutState.mAvailable;\n}\n```\n\n**recycleByLayoutState** 这个函数，会根据当前信息对不需要的 View 进行回收:\n\n```java\nprivate void recycleByLayoutState(RecyclerView.Recycler recycler, LayoutState layoutState) {\n    if(layoutState.mLayoutDirection == LayoutState.LAYOUT_START) {\n        \n    } else {\n        recycleViewsFromStart(recycler, layoutState.mScrollingOffset);\n    }\n}\n```\n\n继续看 `recycleViewsFromStart`\n\n```java\nprivate void recycleViewsFromStart(RecyclerView.Recycler recycler, int dt){\n    final int limit = dt;\n    final int childCount = getChildCount();\n    if(mShouldReverseLayout) {\n        \n    } else {\n        for(int i = 0; i < childCount; i++){\n            View child = getChildAt(i);\n            if(mOrientationHelper.getDecoratedEnd(child) > limit\n              || mOrientationHelper.getTransformedEndWithDecoration(child) > limit) {\n        recycleChildren(recycler, 0, i);\n                return;\n            }\n        }\n    }\n}\n```\n\n该函数的作用时遍历所有的子 View ,找出逃离边界的 View 进行回收，回收函数在 `recycleChildren` 里，而这函数又调用了 `removeAndRecycleViewAt` \n\n```java\npublic void removeAndRecycleViewAt(int index, Recycler recycler) {\n    final View view = getChildAt(index);\n    removeViewAt(index);\n    recycler.recycleView(view);\n}\n```\n\n该函数先调用 `removeViewAt` ，将 View 从 RecyclerView 中移除，紧接着是 recycler 执行了 View 的回收逻辑。在 fill 函数的一开始会去回收逃离出屏幕的 view。\n\n```java\nwhile((layoutState.mInfinite || remainningSpace > 0) \n     && layoutState.hasMore(state)) {\n    layoutChunk(recycler, state, layoutState, layoutChunkResult);\n}\n```\n\n只要又剩余空间，就会执行 layoutChunk 方法\n\n```java\nvoid layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State stat, LayoutState layoutState, LayoutCHunkResult result){\n    View view = layoutState.next(recycler);\n    \n    LayoutParams params = (LayoutParams) view.getLayoutParams();\n    if(layoutState.mScrapList == null) {\n        if(mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) {\n            addView(view);\n        } else {\n            addView(view, 0);\n        }\n    } else {\n        \n    }\n    \n    layoutDecoratedWithMargins(view, left, top, right, bottom);\n}\n```\n\n在 layoutState 的 next 方法返回了一个 view， 凭空变出一个 View， 很神奇\n\n```java\nView next(RecyclerView.Recycler recycler ) {\n    final View view = recycler.getViewForPosition(mCurrentPosition);\n    return view;\n}\n```\n\n可见 view 的获取逻辑也是由 recycler 来负责， 所以我们只需要清楚 recycler 可以根据位置返回一个 View 即可。\n\n我们在看 layoutChunk 对刚刚生成的 View 的处理\n\n```java\nif(mShouldReverseLayout == (layoutState.mLayoutDirectoin == LayoutState.LAYOUT_STATE)) {\n    addView(view);\n} else {\n    addView(view, 0);\n}\n```\n\n明显的调用了 addView 方法，虽然这个方法是 LayoutManager 的，但是这个方法最终会多次辗转调用到 Recycler View 的 addView 方法，将 view 添加到 RecyclerView 中。\n\ndispatchLayoutStep2 整个布局过程，完成了对 子 View 的测量与布局\n\n#### dispatchLayoutStep3\n\n最后一步\n\n```java\nprivate void dispatchLayoutStep3(){\n    mState.mLayoutStep = State.STEP_START;\n    if(mState.mRunSimpleAnimations) {\n        for(int i = mChildHelper.getChildCount() - 1; i >= 0; i--) {\n            final ItemHolderInfo animationInfo = mItemAnimator.recordPostLayoutInformation(mState, holder);\n            mViewInfoStore.addToPostLayout(holder, animationInfo);\n        }\n        \n        mViewInfoStore.process(mViewInfoProcessCallback);\n    }\n}\n```\n\n这里是与第一步呼应的，此时子 View 都已布局完成，所以子 View 的信息都发生了变化。第一步出现的 mViewInfoStore 和 mItemAnimator 再次登场，这次 mItemAnimator 调用的是 recordPostLayoutInformation 方法，而 mViewInfoStore 调用的是 addToPostLayout 方法，\n\n```java\nvoid addToPostLayout(ViewHolder holder, ItemHolderInfo info) {\n    InfoRecord record = mLayoutHolderMap.get(holder);\n    if(record == null ) {\n        record = InfoRecord.obtain();\n        mLayoutHolderMap.put(holder, record);\n    }\n    record.postInfo = info;record.flags |= FLAT_POST;\n}\n```\n\n最后 mViewInfoStore 调用了 process 方法，根据 mViewInfoStore 中的 View 信息，来执行动画逻辑。\n\n\n\n### 缓存逻辑\n\n\n\n缓存共分为四层\n\n1. Scrap  内存缓存\n2. Cache 内存缓存\n3. ViewCacheExtension 用户自定义缓存\n4. Recycled View Pool 缓存池\n\n\n\nRecyclerView 的缓存时分为多级的，但其实真个逻辑很好理解，\n\n```java\nView getViewForPosition(int position, boolean dryRun) {\n    boolean fromScrap = false;\n    ViewHolder holder = null;\n    if(mState.isPreLayout()) {\n        holder = getChangedScrapViewForPosition(position);\n\t\tfromScrap = holder != null\n    }\n    \n    if(hoder == null) {\n        hodler = getScrapViewForPosition(position, INVALID_TYPE, dryRun);\n    }\n    \n    if(holder == null ){\n        final int offsetPosition = mAdapterHelper.findPositionOffset(position);\n        final int type = mAdapter.getItemViewType(offsetPosition);\n        if(mAdapter.hasStableIds()){\n            holder = getScrapViewForId(mAdapter.getItemId(offsetPosition), type, dryRun);\n        }\n        \n        if(holder == null && mViewCacheExtension != null) {\n            final View view = mViewCacheExtension.getViewForPositionAndType(this, position, type);\n        }\n        \n        if(holder == null) {\n            // fallback to recycler\n            holder = getRecyclerViewPool().getRecyclerView(type);\n            if(holder != null){\n                holder.resetInternal();\n                if(FORCE_INVALIDATE_DISPLAY_LIST){\n                    invalidateDisplayListInt(holder);\n                }\n            }\n        } \n        \n        if(holder == null ){\n            holder = mAdapter.createViewHolder(RecyclerView.this, type);\n        }\n    }\n    \n    \n    // 生成 LayoutParams 的代码\n    return holder.itemView;\n}\n```\n\n获取 View 的逻辑可以整理为\n\n* 搜索 mChangedScrap， 如果找到则返回相应的 holder\n* 搜索 mAttachedScrap与 mCachedViews， 如果找到且 holder 有效则返回相应的 holder\n* 如果设置了 mViewCacheExtension, 对其调用 getViewForPositionAndType 方法进行获取，若返回结果则生成对应的 holder\n* 搜索 mRecyclerPool, 如果找到则返回 Holder\n* 如果上述过程都没有找到对饮的 holder, 则执行 Adapter.createViewHolder(); 创建新的 ViewHolder 实例\n\n**对于 View 的回收**\n\n```java\nvoid recycleViewHolderInternal(ViewHolder holder ) {\n    \n    if(holder.isRecyclable()) {\n        if(!holder.hasAnyOfTheFlags(VieHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED) | ViewHolder.FLAG_UPDATE) {\n            int cachedViewSize = mCachedViews.size();\n            if(cachedViewSize >= mViewCacheMax && cachedViewSize > 0) {\n                recycleCachedViewAt(0);\n                cachedViewSize--;\n            }\n            \n            if(cachedViewSize < mViewCacheMax) {\n                mCachedViews.add(holder);\n                cached = true;\n            }\n        }\n        \n        if(!cached) {\n            addViewHolderToRecycledViewPool(holder);\n            recycled = true;\n        }\n    }\n}\n```\n\n回收没有创建复杂，只涉及到两次缓存， mCachedViews 和 mRecyclerPool , mCachedViews 相当于一个先进先出的数据结构（队列），当有新的 View 需要缓存时，都会将新的 View 存入到 mCachedViews， 而 mCachedView  则会移除头部元素，并将头部元素存储在 mRecyclerPool 中， 即 mCachedViews 相当于一级缓存， mRecyclerPool 相当于二级缓存，并且 mRecyclerPool  时可以多个 RecyclerView 共享的。\n\n\n\n## 与 AdapterView 比较\n\n| index |      AdapterView      |                RecyclerView                |\n| :---: | :-------------------: | :----------------------------------------: |\n|   1   | Simple click listener |            OnItemTouchListener             |\n|   2   |    Simple Divider     |               ItemDecoration               |\n|   3   | ListView and GridView | LinearLayoutManager<br />GridLayoutManager |\n|   4   |      RecyclerBin      |                  Recycler                  |\n|   5   |   Header and Footer   |              Partial refresh               |\n\n##### 点击事件\n\nListView 原生提供了Item 点击、长安的事件，而 RecyclerView  则需要使用 onTouchListener 相对比较复杂\n\n##### 分割线\n\nListView  可以很轻松设施 Divider 属性来显示 item 之间的分割线，\n\nRecyclerView 需要自己实现 ItemDecoration ，两者比较，前者使用更简单，后者定制性更强\n\n##### 布局类型\n\nAdapterView 提提供了 三种布局管理方式，LinearLayoutManager, GirdLayoutManager, StaggeredGirdLayoutManager\n\nListView 只提供了一种 LinearLayoutManager 方式\n\n##### 性能优化\n\n* RecyclerView 提供了DiffUtil 工具类，用于整个页面需要刷新，对比列表中的数据，如果未发生变化，则不会触发重绘制操作\n* ListView 不支持单个 Item  的刷新，只能整个列表进行 `notifyDataSetChanged` ， RecyclerView 提供了 `itemChange`, `ItemInsert`, `ItemRemoved` 等方法，减少了 性能的开销\n\n\n\n","source":"_posts/Android 基础/View/RecyclerView 总结.md","raw":"---\ntitle: RecyclerView 总结\ntag: Android View\n\n---\n\n\n\n## List View 的局限性\n\n1. 只有纵向列表一种布局\n2. 没有支持动画的  API\n3. 接口设计和系统不一致\n   1. setOnItemClickListener()\n   2. setOnItemLongClickListener()\n   3. setSelection()\n4. 没有强制实现 ViewHolder\n5. 性能不如 RecyclerView\n\n## RecyclerView 优势\n\n1. 默认支持 Linear、Grid、Staggered Grid 三种布局\n2. 友好的 ItemAnimator 动画 API\n3. 强制实现 ViewHolder\n4. 解耦的架构设计\n5. 相对 ListView 性能更好\n\n \n<!-- more-->\n\n\n![image-20200709164241306](https://github.com/xiaomanwong/static_file/blob/master/images/image-20200709164241306.png?raw=true)\n\n\n\nRecycler View： 负责将 Datas 展示在自己身上，其本身是一个 ViewGroup，只认识 View，因此需要一个 Adapter 来将 Datas 的内容转换为 View\n\nAdapter： 负责翻译，将 Datas 内容，转换为 View，方便 RecyclerView 展示\n\nViewHolder： RecyclerView 只会与 ViewHolder 进行交互，因此 ViewHolder 充当中间件，来将 Datas 的内容传递给  RecyclerView\n\nLayoutManager：负责布局，RecyclerView 将其子 View 的布局管理，交给它来完成\n\nRecycler：负责管理 View 的生命周期，LayoutManager 只管负责 View 的布局任务，对其回收交给了 Recycler 来处理，避免造成不必要的错误\n\nItemAnimator： 负责动画，当 RecyclerView 中的数据发生变化（增、删等）都会通过它来完成平滑的过渡\n\n\n\n## RecyclerView 的绘制\n\nRecyclerView 无疑也是一个 View ，View 的绘制同样逃离不了三大步骤 `onMeasure()` `onLayout()` `onDraw()` \n\n\n\n### onMeasure\n\nLayoutManager 负责 RecyclerView 的绘制，其有一个 `mAutoMeasure` 属性，用来控制是否开启自动测量，开启情况下，布局交由 `RecyclerView` 使用一套默认的测量机制；否则，自定义的 LayoutManager 需要重写 `onMeasure` 来处理自身的测量工作。\n\n#### **自动测量原理：**\n\n当 RecyclerView 的宽高都为 `EXACTLY` 时， 可以直接设置对应的宽高，然后返回，结束测量\n\n如果宽高都不时 `EXACTLY` 则会在 `onMeasure` 中开始布局的处理。\n\nRecyclerView.State 这个类封装了当前 RecyclerView 的信息。State 中的一个变量 `mLayoutStep` 记录了 RecyclerView  当前的布局状态\n\n* STEP_START\n* STEP_LAYOUT\n* STEP_ANIMATIONS\n\n对应的， RecyclerView 的布局过程也分为三步，STEP_START 表示开始布局，对应需要调用 `dispatchLayoutStep1()` 来执行第一步布局，结束后， `mLayoutStep` 变为 STEP_LAYOUT ，表示接下来需要调用 `dispatchLayoutStep2()` 进行布局，结束后 `mLayoutStep` 变为 STEP_ANIMATIONS, 继续执行第三步 `dispatchLayoutStep3()`\n\n\n\n* dispatchLayoutStep1:  负责记录状态\n\n* dispatchLayoutStep2：负责布局\n* dispatchLayoutStep3：与 step1 比较，根据变化来触发动画\n\n\n\n### onLayout\n\n```java\nprotected void onLayout(boolean changed, int l int t, int r, int b) {\n    TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);\n    dispatchLayout();\n    TraceCompat.endSection();\n    mFirstLayoutComplete = true;\n}\n\nvoid dispatchLayout() {\n    mState.mIsMeasuring = false;\n    if(mState.mLayoutStep == State.STEP_START) {\n        dispatchLayoutStep1();\n        mLayout.setExactMeasureSpecsFrom(this);\n        dispatchLayoutStep2();\n    } else if(mAdapterHelper.hasUpdates() \n              || mLayout.getWidth() != getWidth() \n              || mLayout.getHeight() != getHeight()) {\n        // first 2 steps are done in onMeasure but looks like we have to run again due to changed size\n        mLayout.setExactMeasureSpecsFrom(this);\n        dispatchLayoutStep2();\n    } else {\n        // always make sure we sync them (to ensure mode is exact)\n        mLayout.setExactMeasureSpecsFrom(this);\n    }\n    \n    dispatchLayoutStep3();\n}\n```\n\n通过 `dispatchLayout` 可以验证RecyclerView 的 layout三步走原则，如果在 `onMeasure` 中已经完成了 step1 和 step2 ，则只会执行 step3，否则，会在 `onLayout` 中依次触发三步走。\n\n#### dispatchLayoutStep1\n\n```java\nprivate void dispatchLayoutStep1(){\n\tif(mState.mRunSimpleAnimations) {\n        int count = mChildHelper.getChildCount();\n        for(int i = 0; i < count; i++) {\n            final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));\n            final ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(mState, holder, ItemAnimator.buildAdapterChangeFlagsForAnimations(holder), holder.getUnmodifiedPayloads());\n            mViewInfoStore.addToPreLayout(holder, animationInfo);\n        }\n    }\n    mState.mLayoutStep = State.STEP_LAYOUT\n}\n```\n\nstep 的第一步目的就是记录 View 的状态，先遍历当前所有 View，一次进行处理，mItemAnimator 会根据每个 View 的信息，封装一个 ItemHolderInfo, 这个 ItemHolderInfo 中主要包含的就是 View 的位置状态等。然后将 ItemHodlerInfo 存入 mViewInfoStore 中。在进入第二步后， View 的信息就将被改变\n\n#### dispatchLayoutStep2\n\n```java\nprivate void dispatchLayoutStep2(){\n    mLayout.onLayoutChildren(mRecycler, mState);\n    \n    mState.mLayoutStep = State.STATE_ANIMATIONS;\n}\n```\n\nlayout 的第二步就是真正的布局 View。RecyclerView 的真正布局是由 LayoutManger 来负责的，其主要工作也在 LayoutManager 中。\n\n```java\npublic  void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {\n    \n    if(!mAnchorInfo.mValid \n      || mPendingScrollPosition != NO_POSITION \n      || mPendingSavedState != null) {\n        updateAnchorInfoForLayout(recycler, state, mAnchorInfo);\n    }\n    \n    if(mAnchorInfo.mLayoutFromEnd) {\n        firstLayoutDirection = mShouldReverseLayout \n            ? LayoutState.ITEM_DIRECTIONTAIL\n            : LayoutState.ITEM_DIRECTION_HEAD;\n    } else {\n        firstLayoutDirection = mShouldReverseLayout \n            ? LayoutState.ITEM_DIRECTION_HEAD\n            : LayoutState.ITEM_DIRECTION_TAIL;\n    }\n    \n    onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);\n    \n    if(mAnchorInfo.mLayoutFromEnd) {\n        \n    } else {\n        // fill towards end\n        updateLayouStateToFillEnd(mAnchorInfo);\n        fill(recycler, mLayoutState, state, false);\n        \n        // fill towards start\n        updateLayoutStateToFillStart(mAnchorInfo);\n        fill(recycler, mLayoutState, state, false);\n    }\n}\n```\n\n流程很负责，大致流程如下\n\n* 找到 anchor点\n* 根据 anchor 一直向前布局，直到填充满 anchor 点前面的所有区域\n* 根据 anchor 一直向后布局，直到填充满 anchor 点后面的所有区域\n\nanchor 点的寻找是由 `updateAnchorInfoForLayout` 函数负责。向下追踪会看到 `updateAnchorFromChildren`  方法，其内容为，先寻找被 focus 的 child， 找到以此 child 作为 anchor ，否则根据布局方向寻找最合适的 child 来作为 anchor，如果找到则将 child 的信息复制给 anchorInfo 。 `anchorInfo` 主要记录的信息就是 View 的物理位置与 Adapter 中的位置。找到后返回 true，否则返回 false，交给上一步函数做处理。\n\n继续当找到 anchor 后，会根据 anchor 来布局，通过 fill 方法来完成\n\n```java\nint fill(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.state state, boolean stopOnFocusable) {\n    final int start = layoutState.mAvailable;\n    if(layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {\n        recycleByLayoutState(recycler, layoutState);\n    }\n    \n    int remainingSpace = layoutState.mAvailable + layoutState.mExtra;\n    LayoutChunkResult layoutChunkResult = mLayoutChunkResult;\n    while((layoutState.mInfinite || remainingSpace > 0)\n         && layoutState.hasMore(state)) {\n        layoutChunk(recycler, state, layoutState, layoutChunkResult);\n    }\n    return start-layoutState.mAvailable;\n}\n```\n\n**recycleByLayoutState** 这个函数，会根据当前信息对不需要的 View 进行回收:\n\n```java\nprivate void recycleByLayoutState(RecyclerView.Recycler recycler, LayoutState layoutState) {\n    if(layoutState.mLayoutDirection == LayoutState.LAYOUT_START) {\n        \n    } else {\n        recycleViewsFromStart(recycler, layoutState.mScrollingOffset);\n    }\n}\n```\n\n继续看 `recycleViewsFromStart`\n\n```java\nprivate void recycleViewsFromStart(RecyclerView.Recycler recycler, int dt){\n    final int limit = dt;\n    final int childCount = getChildCount();\n    if(mShouldReverseLayout) {\n        \n    } else {\n        for(int i = 0; i < childCount; i++){\n            View child = getChildAt(i);\n            if(mOrientationHelper.getDecoratedEnd(child) > limit\n              || mOrientationHelper.getTransformedEndWithDecoration(child) > limit) {\n        recycleChildren(recycler, 0, i);\n                return;\n            }\n        }\n    }\n}\n```\n\n该函数的作用时遍历所有的子 View ,找出逃离边界的 View 进行回收，回收函数在 `recycleChildren` 里，而这函数又调用了 `removeAndRecycleViewAt` \n\n```java\npublic void removeAndRecycleViewAt(int index, Recycler recycler) {\n    final View view = getChildAt(index);\n    removeViewAt(index);\n    recycler.recycleView(view);\n}\n```\n\n该函数先调用 `removeViewAt` ，将 View 从 RecyclerView 中移除，紧接着是 recycler 执行了 View 的回收逻辑。在 fill 函数的一开始会去回收逃离出屏幕的 view。\n\n```java\nwhile((layoutState.mInfinite || remainningSpace > 0) \n     && layoutState.hasMore(state)) {\n    layoutChunk(recycler, state, layoutState, layoutChunkResult);\n}\n```\n\n只要又剩余空间，就会执行 layoutChunk 方法\n\n```java\nvoid layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State stat, LayoutState layoutState, LayoutCHunkResult result){\n    View view = layoutState.next(recycler);\n    \n    LayoutParams params = (LayoutParams) view.getLayoutParams();\n    if(layoutState.mScrapList == null) {\n        if(mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) {\n            addView(view);\n        } else {\n            addView(view, 0);\n        }\n    } else {\n        \n    }\n    \n    layoutDecoratedWithMargins(view, left, top, right, bottom);\n}\n```\n\n在 layoutState 的 next 方法返回了一个 view， 凭空变出一个 View， 很神奇\n\n```java\nView next(RecyclerView.Recycler recycler ) {\n    final View view = recycler.getViewForPosition(mCurrentPosition);\n    return view;\n}\n```\n\n可见 view 的获取逻辑也是由 recycler 来负责， 所以我们只需要清楚 recycler 可以根据位置返回一个 View 即可。\n\n我们在看 layoutChunk 对刚刚生成的 View 的处理\n\n```java\nif(mShouldReverseLayout == (layoutState.mLayoutDirectoin == LayoutState.LAYOUT_STATE)) {\n    addView(view);\n} else {\n    addView(view, 0);\n}\n```\n\n明显的调用了 addView 方法，虽然这个方法是 LayoutManager 的，但是这个方法最终会多次辗转调用到 Recycler View 的 addView 方法，将 view 添加到 RecyclerView 中。\n\ndispatchLayoutStep2 整个布局过程，完成了对 子 View 的测量与布局\n\n#### dispatchLayoutStep3\n\n最后一步\n\n```java\nprivate void dispatchLayoutStep3(){\n    mState.mLayoutStep = State.STEP_START;\n    if(mState.mRunSimpleAnimations) {\n        for(int i = mChildHelper.getChildCount() - 1; i >= 0; i--) {\n            final ItemHolderInfo animationInfo = mItemAnimator.recordPostLayoutInformation(mState, holder);\n            mViewInfoStore.addToPostLayout(holder, animationInfo);\n        }\n        \n        mViewInfoStore.process(mViewInfoProcessCallback);\n    }\n}\n```\n\n这里是与第一步呼应的，此时子 View 都已布局完成，所以子 View 的信息都发生了变化。第一步出现的 mViewInfoStore 和 mItemAnimator 再次登场，这次 mItemAnimator 调用的是 recordPostLayoutInformation 方法，而 mViewInfoStore 调用的是 addToPostLayout 方法，\n\n```java\nvoid addToPostLayout(ViewHolder holder, ItemHolderInfo info) {\n    InfoRecord record = mLayoutHolderMap.get(holder);\n    if(record == null ) {\n        record = InfoRecord.obtain();\n        mLayoutHolderMap.put(holder, record);\n    }\n    record.postInfo = info;record.flags |= FLAT_POST;\n}\n```\n\n最后 mViewInfoStore 调用了 process 方法，根据 mViewInfoStore 中的 View 信息，来执行动画逻辑。\n\n\n\n### 缓存逻辑\n\n\n\n缓存共分为四层\n\n1. Scrap  内存缓存\n2. Cache 内存缓存\n3. ViewCacheExtension 用户自定义缓存\n4. Recycled View Pool 缓存池\n\n\n\nRecyclerView 的缓存时分为多级的，但其实真个逻辑很好理解，\n\n```java\nView getViewForPosition(int position, boolean dryRun) {\n    boolean fromScrap = false;\n    ViewHolder holder = null;\n    if(mState.isPreLayout()) {\n        holder = getChangedScrapViewForPosition(position);\n\t\tfromScrap = holder != null\n    }\n    \n    if(hoder == null) {\n        hodler = getScrapViewForPosition(position, INVALID_TYPE, dryRun);\n    }\n    \n    if(holder == null ){\n        final int offsetPosition = mAdapterHelper.findPositionOffset(position);\n        final int type = mAdapter.getItemViewType(offsetPosition);\n        if(mAdapter.hasStableIds()){\n            holder = getScrapViewForId(mAdapter.getItemId(offsetPosition), type, dryRun);\n        }\n        \n        if(holder == null && mViewCacheExtension != null) {\n            final View view = mViewCacheExtension.getViewForPositionAndType(this, position, type);\n        }\n        \n        if(holder == null) {\n            // fallback to recycler\n            holder = getRecyclerViewPool().getRecyclerView(type);\n            if(holder != null){\n                holder.resetInternal();\n                if(FORCE_INVALIDATE_DISPLAY_LIST){\n                    invalidateDisplayListInt(holder);\n                }\n            }\n        } \n        \n        if(holder == null ){\n            holder = mAdapter.createViewHolder(RecyclerView.this, type);\n        }\n    }\n    \n    \n    // 生成 LayoutParams 的代码\n    return holder.itemView;\n}\n```\n\n获取 View 的逻辑可以整理为\n\n* 搜索 mChangedScrap， 如果找到则返回相应的 holder\n* 搜索 mAttachedScrap与 mCachedViews， 如果找到且 holder 有效则返回相应的 holder\n* 如果设置了 mViewCacheExtension, 对其调用 getViewForPositionAndType 方法进行获取，若返回结果则生成对应的 holder\n* 搜索 mRecyclerPool, 如果找到则返回 Holder\n* 如果上述过程都没有找到对饮的 holder, 则执行 Adapter.createViewHolder(); 创建新的 ViewHolder 实例\n\n**对于 View 的回收**\n\n```java\nvoid recycleViewHolderInternal(ViewHolder holder ) {\n    \n    if(holder.isRecyclable()) {\n        if(!holder.hasAnyOfTheFlags(VieHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED) | ViewHolder.FLAG_UPDATE) {\n            int cachedViewSize = mCachedViews.size();\n            if(cachedViewSize >= mViewCacheMax && cachedViewSize > 0) {\n                recycleCachedViewAt(0);\n                cachedViewSize--;\n            }\n            \n            if(cachedViewSize < mViewCacheMax) {\n                mCachedViews.add(holder);\n                cached = true;\n            }\n        }\n        \n        if(!cached) {\n            addViewHolderToRecycledViewPool(holder);\n            recycled = true;\n        }\n    }\n}\n```\n\n回收没有创建复杂，只涉及到两次缓存， mCachedViews 和 mRecyclerPool , mCachedViews 相当于一个先进先出的数据结构（队列），当有新的 View 需要缓存时，都会将新的 View 存入到 mCachedViews， 而 mCachedView  则会移除头部元素，并将头部元素存储在 mRecyclerPool 中， 即 mCachedViews 相当于一级缓存， mRecyclerPool 相当于二级缓存，并且 mRecyclerPool  时可以多个 RecyclerView 共享的。\n\n\n\n## 与 AdapterView 比较\n\n| index |      AdapterView      |                RecyclerView                |\n| :---: | :-------------------: | :----------------------------------------: |\n|   1   | Simple click listener |            OnItemTouchListener             |\n|   2   |    Simple Divider     |               ItemDecoration               |\n|   3   | ListView and GridView | LinearLayoutManager<br />GridLayoutManager |\n|   4   |      RecyclerBin      |                  Recycler                  |\n|   5   |   Header and Footer   |              Partial refresh               |\n\n##### 点击事件\n\nListView 原生提供了Item 点击、长安的事件，而 RecyclerView  则需要使用 onTouchListener 相对比较复杂\n\n##### 分割线\n\nListView  可以很轻松设施 Divider 属性来显示 item 之间的分割线，\n\nRecyclerView 需要自己实现 ItemDecoration ，两者比较，前者使用更简单，后者定制性更强\n\n##### 布局类型\n\nAdapterView 提提供了 三种布局管理方式，LinearLayoutManager, GirdLayoutManager, StaggeredGirdLayoutManager\n\nListView 只提供了一种 LinearLayoutManager 方式\n\n##### 性能优化\n\n* RecyclerView 提供了DiffUtil 工具类，用于整个页面需要刷新，对比列表中的数据，如果未发生变化，则不会触发重绘制操作\n* ListView 不支持单个 Item  的刷新，只能整个列表进行 `notifyDataSetChanged` ， RecyclerView 提供了 `itemChange`, `ItemInsert`, `ItemRemoved` 等方法，减少了 性能的开销\n\n\n\n","slug":"Android 基础/View/RecyclerView 总结","published":1,"date":"2021-01-29T15:54:28.296Z","updated":"2021-01-29T16:17:54.159Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8jq0030sz5qctj6lpko","content":"<h2 id=\"List-View-的局限性\"><a href=\"#List-View-的局限性\" class=\"headerlink\" title=\"List View 的局限性\"></a>List View 的局限性</h2><ol>\n<li>只有纵向列表一种布局</li>\n<li>没有支持动画的  API</li>\n<li>接口设计和系统不一致<ol>\n<li>setOnItemClickListener()</li>\n<li>setOnItemLongClickListener()</li>\n<li>setSelection()</li>\n</ol>\n</li>\n<li>没有强制实现 ViewHolder</li>\n<li>性能不如 RecyclerView</li>\n</ol>\n<h2 id=\"RecyclerView-优势\"><a href=\"#RecyclerView-优势\" class=\"headerlink\" title=\"RecyclerView 优势\"></a>RecyclerView 优势</h2><ol>\n<li>默认支持 Linear、Grid、Staggered Grid 三种布局</li>\n<li>友好的 ItemAnimator 动画 API</li>\n<li>强制实现 ViewHolder</li>\n<li>解耦的架构设计</li>\n<li>相对 ListView 性能更好</li>\n</ol>\n<a id=\"more\"></a>\n<p><img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/image-20200709164241306.png?raw=true\" alt=\"image-20200709164241306\"></p>\n<p>Recycler View： 负责将 Datas 展示在自己身上，其本身是一个 ViewGroup，只认识 View，因此需要一个 Adapter 来将 Datas 的内容转换为 View</p>\n<p>Adapter： 负责翻译，将 Datas 内容，转换为 View，方便 RecyclerView 展示</p>\n<p>ViewHolder： RecyclerView 只会与 ViewHolder 进行交互，因此 ViewHolder 充当中间件，来将 Datas 的内容传递给  RecyclerView</p>\n<p>LayoutManager：负责布局，RecyclerView 将其子 View 的布局管理，交给它来完成</p>\n<p>Recycler：负责管理 View 的生命周期，LayoutManager 只管负责 View 的布局任务，对其回收交给了 Recycler 来处理，避免造成不必要的错误</p>\n<p>ItemAnimator： 负责动画，当 RecyclerView 中的数据发生变化（增、删等）都会通过它来完成平滑的过渡</p>\n<h2 id=\"RecyclerView-的绘制\"><a href=\"#RecyclerView-的绘制\" class=\"headerlink\" title=\"RecyclerView 的绘制\"></a>RecyclerView 的绘制</h2><p>RecyclerView 无疑也是一个 View ，View 的绘制同样逃离不了三大步骤 <code>onMeasure()</code> <code>onLayout()</code> <code>onDraw()</code> </p>\n<h3 id=\"onMeasure\"><a href=\"#onMeasure\" class=\"headerlink\" title=\"onMeasure\"></a>onMeasure</h3><p>LayoutManager 负责 RecyclerView 的绘制，其有一个 <code>mAutoMeasure</code> 属性，用来控制是否开启自动测量，开启情况下，布局交由 <code>RecyclerView</code> 使用一套默认的测量机制；否则，自定义的 LayoutManager 需要重写 <code>onMeasure</code> 来处理自身的测量工作。</p>\n<h4 id=\"自动测量原理：\"><a href=\"#自动测量原理：\" class=\"headerlink\" title=\"自动测量原理：\"></a><strong>自动测量原理：</strong></h4><p>当 RecyclerView 的宽高都为 <code>EXACTLY</code> 时， 可以直接设置对应的宽高，然后返回，结束测量</p>\n<p>如果宽高都不时 <code>EXACTLY</code> 则会在 <code>onMeasure</code> 中开始布局的处理。</p>\n<p>RecyclerView.State 这个类封装了当前 RecyclerView 的信息。State 中的一个变量 <code>mLayoutStep</code> 记录了 RecyclerView  当前的布局状态</p>\n<ul>\n<li>STEP_START</li>\n<li>STEP_LAYOUT</li>\n<li>STEP_ANIMATIONS</li>\n</ul>\n<p>对应的， RecyclerView 的布局过程也分为三步，STEP_START 表示开始布局，对应需要调用 <code>dispatchLayoutStep1()</code> 来执行第一步布局，结束后， <code>mLayoutStep</code> 变为 STEP_LAYOUT ，表示接下来需要调用 <code>dispatchLayoutStep2()</code> 进行布局，结束后 <code>mLayoutStep</code> 变为 STEP_ANIMATIONS, 继续执行第三步 <code>dispatchLayoutStep3()</code></p>\n<ul>\n<li><p>dispatchLayoutStep1:  负责记录状态</p>\n</li>\n<li><p>dispatchLayoutStep2：负责布局</p>\n</li>\n<li>dispatchLayoutStep3：与 step1 比较，根据变化来触发动画</li>\n</ul>\n<h3 id=\"onLayout\"><a href=\"#onLayout\" class=\"headerlink\" title=\"onLayout\"></a>onLayout</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onLayout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span> changed<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> l <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> r<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    TraceCompat<span class=\"token punctuation\">.</span><span class=\"token function\">beginSection</span><span class=\"token punctuation\">(</span>TRACE_ON_LAYOUT_TAG<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">dispatchLayout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    TraceCompat<span class=\"token punctuation\">.</span><span class=\"token function\">endSection</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    mFirstLayoutComplete <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">dispatchLayout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    mState<span class=\"token punctuation\">.</span>mIsMeasuring <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mState<span class=\"token punctuation\">.</span>mLayoutStep <span class=\"token operator\">==</span> State<span class=\"token punctuation\">.</span>STEP_START<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">dispatchLayoutStep1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        mLayout<span class=\"token punctuation\">.</span><span class=\"token function\">setExactMeasureSpecsFrom</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">dispatchLayoutStep2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mAdapterHelper<span class=\"token punctuation\">.</span><span class=\"token function\">hasUpdates</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> \n              <span class=\"token operator\">||</span> mLayout<span class=\"token punctuation\">.</span><span class=\"token function\">getWidth</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token function\">getWidth</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> \n              <span class=\"token operator\">||</span> mLayout<span class=\"token punctuation\">.</span><span class=\"token function\">getHeight</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token function\">getHeight</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// first 2 steps are done in onMeasure but looks like we have to run again due to changed size</span>\n        mLayout<span class=\"token punctuation\">.</span><span class=\"token function\">setExactMeasureSpecsFrom</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">dispatchLayoutStep2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// always make sure we sync them (to ensure mode is exact)</span>\n        mLayout<span class=\"token punctuation\">.</span><span class=\"token function\">setExactMeasureSpecsFrom</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">dispatchLayoutStep3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>通过 <code>dispatchLayout</code> 可以验证RecyclerView 的 layout三步走原则，如果在 <code>onMeasure</code> 中已经完成了 step1 和 step2 ，则只会执行 step3，否则，会在 <code>onLayout</code> 中依次触发三步走。</p>\n<h4 id=\"dispatchLayoutStep1\"><a href=\"#dispatchLayoutStep1\" class=\"headerlink\" title=\"dispatchLayoutStep1\"></a>dispatchLayoutStep1</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">dispatchLayoutStep1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mState<span class=\"token punctuation\">.</span>mRunSimpleAnimations<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> mChildHelper<span class=\"token punctuation\">.</span><span class=\"token function\">getChildCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> count<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">final</span> ViewHolder holder <span class=\"token operator\">=</span> <span class=\"token function\">getChildViewHolderInt</span><span class=\"token punctuation\">(</span>mChildHelper<span class=\"token punctuation\">.</span><span class=\"token function\">getChildAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">final</span> ItemHolderInfo animationInfo <span class=\"token operator\">=</span> mItemAnimator<span class=\"token punctuation\">.</span><span class=\"token function\">recordPreLayoutInformation</span><span class=\"token punctuation\">(</span>mState<span class=\"token punctuation\">,</span> holder<span class=\"token punctuation\">,</span> ItemAnimator<span class=\"token punctuation\">.</span><span class=\"token function\">buildAdapterChangeFlagsForAnimations</span><span class=\"token punctuation\">(</span>holder<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> holder<span class=\"token punctuation\">.</span><span class=\"token function\">getUnmodifiedPayloads</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            mViewInfoStore<span class=\"token punctuation\">.</span><span class=\"token function\">addToPreLayout</span><span class=\"token punctuation\">(</span>holder<span class=\"token punctuation\">,</span> animationInfo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    mState<span class=\"token punctuation\">.</span>mLayoutStep <span class=\"token operator\">=</span> State<span class=\"token punctuation\">.</span>STEP_LAYOUT\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>step 的第一步目的就是记录 View 的状态，先遍历当前所有 View，一次进行处理，mItemAnimator 会根据每个 View 的信息，封装一个 ItemHolderInfo, 这个 ItemHolderInfo 中主要包含的就是 View 的位置状态等。然后将 ItemHodlerInfo 存入 mViewInfoStore 中。在进入第二步后， View 的信息就将被改变</p>\n<h4 id=\"dispatchLayoutStep2\"><a href=\"#dispatchLayoutStep2\" class=\"headerlink\" title=\"dispatchLayoutStep2\"></a>dispatchLayoutStep2</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">dispatchLayoutStep2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    mLayout<span class=\"token punctuation\">.</span><span class=\"token function\">onLayoutChildren</span><span class=\"token punctuation\">(</span>mRecycler<span class=\"token punctuation\">,</span> mState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    mState<span class=\"token punctuation\">.</span>mLayoutStep <span class=\"token operator\">=</span> State<span class=\"token punctuation\">.</span>STATE_ANIMATIONS<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>layout 的第二步就是真正的布局 View。RecyclerView 的真正布局是由 LayoutManger 来负责的，其主要工作也在 LayoutManager 中。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span>  <span class=\"token keyword\">void</span> <span class=\"token function\">onLayoutChildren</span><span class=\"token punctuation\">(</span>RecyclerView<span class=\"token punctuation\">.</span>Recycler recycler<span class=\"token punctuation\">,</span> RecyclerView<span class=\"token punctuation\">.</span>State state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>mAnchorInfo<span class=\"token punctuation\">.</span>mValid \n      <span class=\"token operator\">||</span> mPendingScrollPosition <span class=\"token operator\">!=</span> NO_POSITION \n      <span class=\"token operator\">||</span> mPendingSavedState <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">updateAnchorInfoForLayout</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">,</span> mAnchorInfo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mAnchorInfo<span class=\"token punctuation\">.</span>mLayoutFromEnd<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        firstLayoutDirection <span class=\"token operator\">=</span> mShouldReverseLayout \n            <span class=\"token operator\">?</span> LayoutState<span class=\"token punctuation\">.</span>ITEM_DIRECTIONTAIL\n            <span class=\"token operator\">:</span> LayoutState<span class=\"token punctuation\">.</span>ITEM_DIRECTION_HEAD<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        firstLayoutDirection <span class=\"token operator\">=</span> mShouldReverseLayout \n            <span class=\"token operator\">?</span> LayoutState<span class=\"token punctuation\">.</span>ITEM_DIRECTION_HEAD\n            <span class=\"token operator\">:</span> LayoutState<span class=\"token punctuation\">.</span>ITEM_DIRECTION_TAIL<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">onAnchorReady</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">,</span> mAnchorInfo<span class=\"token punctuation\">,</span> firstLayoutDirection<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mAnchorInfo<span class=\"token punctuation\">.</span>mLayoutFromEnd<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// fill towards end</span>\n        <span class=\"token function\">updateLayouStateToFillEnd</span><span class=\"token punctuation\">(</span>mAnchorInfo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">fill</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">,</span> mLayoutState<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// fill towards start</span>\n        <span class=\"token function\">updateLayoutStateToFillStart</span><span class=\"token punctuation\">(</span>mAnchorInfo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">fill</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">,</span> mLayoutState<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>流程很负责，大致流程如下</p>\n<ul>\n<li>找到 anchor点</li>\n<li>根据 anchor 一直向前布局，直到填充满 anchor 点前面的所有区域</li>\n<li>根据 anchor 一直向后布局，直到填充满 anchor 点后面的所有区域</li>\n</ul>\n<p>anchor 点的寻找是由 <code>updateAnchorInfoForLayout</code> 函数负责。向下追踪会看到 <code>updateAnchorFromChildren</code>  方法，其内容为，先寻找被 focus 的 child， 找到以此 child 作为 anchor ，否则根据布局方向寻找最合适的 child 来作为 anchor，如果找到则将 child 的信息复制给 anchorInfo 。 <code>anchorInfo</code> 主要记录的信息就是 View 的物理位置与 Adapter 中的位置。找到后返回 true，否则返回 false，交给上一步函数做处理。</p>\n<p>继续当找到 anchor 后，会根据 anchor 来布局，通过 fill 方法来完成</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> <span class=\"token function\">fill</span><span class=\"token punctuation\">(</span>RecyclerView<span class=\"token punctuation\">.</span>Recycler recycler<span class=\"token punctuation\">,</span> LayoutState layoutState<span class=\"token punctuation\">,</span> RecyclerView<span class=\"token punctuation\">.</span>state state<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> stopOnFocusable<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> start <span class=\"token operator\">=</span> layoutState<span class=\"token punctuation\">.</span>mAvailable<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>layoutState<span class=\"token punctuation\">.</span>mScrollingOffset <span class=\"token operator\">!=</span> LayoutState<span class=\"token punctuation\">.</span>SCROLLING_OFFSET_NaN<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">recycleByLayoutState</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">,</span> layoutState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">int</span> remainingSpace <span class=\"token operator\">=</span> layoutState<span class=\"token punctuation\">.</span>mAvailable <span class=\"token operator\">+</span> layoutState<span class=\"token punctuation\">.</span>mExtra<span class=\"token punctuation\">;</span>\n    LayoutChunkResult layoutChunkResult <span class=\"token operator\">=</span> mLayoutChunkResult<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>layoutState<span class=\"token punctuation\">.</span>mInfinite <span class=\"token operator\">||</span> remainingSpace <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n         <span class=\"token operator\">&amp;&amp;</span> layoutState<span class=\"token punctuation\">.</span><span class=\"token function\">hasMore</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">layoutChunk</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">,</span> layoutState<span class=\"token punctuation\">,</span> layoutChunkResult<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> start<span class=\"token operator\">-</span>layoutState<span class=\"token punctuation\">.</span>mAvailable<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>recycleByLayoutState</strong> 这个函数，会根据当前信息对不需要的 View 进行回收:</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">recycleByLayoutState</span><span class=\"token punctuation\">(</span>RecyclerView<span class=\"token punctuation\">.</span>Recycler recycler<span class=\"token punctuation\">,</span> LayoutState layoutState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>layoutState<span class=\"token punctuation\">.</span>mLayoutDirection <span class=\"token operator\">==</span> LayoutState<span class=\"token punctuation\">.</span>LAYOUT_START<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">recycleViewsFromStart</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">,</span> layoutState<span class=\"token punctuation\">.</span>mScrollingOffset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>继续看 <code>recycleViewsFromStart</code></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">recycleViewsFromStart</span><span class=\"token punctuation\">(</span>RecyclerView<span class=\"token punctuation\">.</span>Recycler recycler<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> dt<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> limit <span class=\"token operator\">=</span> dt<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> childCount <span class=\"token operator\">=</span> <span class=\"token function\">getChildCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mShouldReverseLayout<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> childCount<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            View child <span class=\"token operator\">=</span> <span class=\"token function\">getChildAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mOrientationHelper<span class=\"token punctuation\">.</span><span class=\"token function\">getDecoratedEnd</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> limit\n              <span class=\"token operator\">||</span> mOrientationHelper<span class=\"token punctuation\">.</span><span class=\"token function\">getTransformedEndWithDecoration</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> limit<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">recycleChildren</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>该函数的作用时遍历所有的子 View ,找出逃离边界的 View 进行回收，回收函数在 <code>recycleChildren</code> 里，而这函数又调用了 <code>removeAndRecycleViewAt</code> </p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">removeAndRecycleViewAt</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> index<span class=\"token punctuation\">,</span> Recycler recycler<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> View view <span class=\"token operator\">=</span> <span class=\"token function\">getChildAt</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">removeViewAt</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    recycler<span class=\"token punctuation\">.</span><span class=\"token function\">recycleView</span><span class=\"token punctuation\">(</span>view<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>该函数先调用 <code>removeViewAt</code> ，将 View 从 RecyclerView 中移除，紧接着是 recycler 执行了 View 的回收逻辑。在 fill 函数的一开始会去回收逃离出屏幕的 view。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>layoutState<span class=\"token punctuation\">.</span>mInfinite <span class=\"token operator\">||</span> remainningSpace <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> \n     <span class=\"token operator\">&amp;&amp;</span> layoutState<span class=\"token punctuation\">.</span><span class=\"token function\">hasMore</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">layoutChunk</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">,</span> layoutState<span class=\"token punctuation\">,</span> layoutChunkResult<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>只要又剩余空间，就会执行 layoutChunk 方法</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">void</span> <span class=\"token function\">layoutChunk</span><span class=\"token punctuation\">(</span>RecyclerView<span class=\"token punctuation\">.</span>Recycler recycler<span class=\"token punctuation\">,</span> RecyclerView<span class=\"token punctuation\">.</span>State stat<span class=\"token punctuation\">,</span> LayoutState layoutState<span class=\"token punctuation\">,</span> LayoutCHunkResult result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    View view <span class=\"token operator\">=</span> layoutState<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    LayoutParams params <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>LayoutParams<span class=\"token punctuation\">)</span> view<span class=\"token punctuation\">.</span><span class=\"token function\">getLayoutParams</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>layoutState<span class=\"token punctuation\">.</span>mScrapList <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mShouldReverseLayout <span class=\"token operator\">==</span> <span class=\"token punctuation\">(</span>layoutState<span class=\"token punctuation\">.</span>mLayoutDirection <span class=\"token operator\">==</span> LayoutState<span class=\"token punctuation\">.</span>LAYOUT_START<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">addView</span><span class=\"token punctuation\">(</span>view<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">addView</span><span class=\"token punctuation\">(</span>view<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">layoutDecoratedWithMargins</span><span class=\"token punctuation\">(</span>view<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> top<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">,</span> bottom<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>在 layoutState 的 next 方法返回了一个 view， 凭空变出一个 View， 很神奇</p>\n<pre class=\" language-java\"><code class=\"language-java\">View <span class=\"token function\">next</span><span class=\"token punctuation\">(</span>RecyclerView<span class=\"token punctuation\">.</span>Recycler recycler <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> View view <span class=\"token operator\">=</span> recycler<span class=\"token punctuation\">.</span><span class=\"token function\">getViewForPosition</span><span class=\"token punctuation\">(</span>mCurrentPosition<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> view<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>可见 view 的获取逻辑也是由 recycler 来负责， 所以我们只需要清楚 recycler 可以根据位置返回一个 View 即可。</p>\n<p>我们在看 layoutChunk 对刚刚生成的 View 的处理</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mShouldReverseLayout <span class=\"token operator\">==</span> <span class=\"token punctuation\">(</span>layoutState<span class=\"token punctuation\">.</span>mLayoutDirectoin <span class=\"token operator\">==</span> LayoutState<span class=\"token punctuation\">.</span>LAYOUT_STATE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">addView</span><span class=\"token punctuation\">(</span>view<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">addView</span><span class=\"token punctuation\">(</span>view<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>明显的调用了 addView 方法，虽然这个方法是 LayoutManager 的，但是这个方法最终会多次辗转调用到 Recycler View 的 addView 方法，将 view 添加到 RecyclerView 中。</p>\n<p>dispatchLayoutStep2 整个布局过程，完成了对 子 View 的测量与布局</p>\n<h4 id=\"dispatchLayoutStep3\"><a href=\"#dispatchLayoutStep3\" class=\"headerlink\" title=\"dispatchLayoutStep3\"></a>dispatchLayoutStep3</h4><p>最后一步</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">dispatchLayoutStep3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    mState<span class=\"token punctuation\">.</span>mLayoutStep <span class=\"token operator\">=</span> State<span class=\"token punctuation\">.</span>STEP_START<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mState<span class=\"token punctuation\">.</span>mRunSimpleAnimations<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> mChildHelper<span class=\"token punctuation\">.</span><span class=\"token function\">getChildCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">final</span> ItemHolderInfo animationInfo <span class=\"token operator\">=</span> mItemAnimator<span class=\"token punctuation\">.</span><span class=\"token function\">recordPostLayoutInformation</span><span class=\"token punctuation\">(</span>mState<span class=\"token punctuation\">,</span> holder<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            mViewInfoStore<span class=\"token punctuation\">.</span><span class=\"token function\">addToPostLayout</span><span class=\"token punctuation\">(</span>holder<span class=\"token punctuation\">,</span> animationInfo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        mViewInfoStore<span class=\"token punctuation\">.</span><span class=\"token function\">process</span><span class=\"token punctuation\">(</span>mViewInfoProcessCallback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>这里是与第一步呼应的，此时子 View 都已布局完成，所以子 View 的信息都发生了变化。第一步出现的 mViewInfoStore 和 mItemAnimator 再次登场，这次 mItemAnimator 调用的是 recordPostLayoutInformation 方法，而 mViewInfoStore 调用的是 addToPostLayout 方法，</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">void</span> <span class=\"token function\">addToPostLayout</span><span class=\"token punctuation\">(</span>ViewHolder holder<span class=\"token punctuation\">,</span> ItemHolderInfo info<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    InfoRecord record <span class=\"token operator\">=</span> mLayoutHolderMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>holder<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>record <span class=\"token operator\">==</span> null <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        record <span class=\"token operator\">=</span> InfoRecord<span class=\"token punctuation\">.</span><span class=\"token function\">obtain</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        mLayoutHolderMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>holder<span class=\"token punctuation\">,</span> record<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    record<span class=\"token punctuation\">.</span>postInfo <span class=\"token operator\">=</span> info<span class=\"token punctuation\">;</span>record<span class=\"token punctuation\">.</span>flags <span class=\"token operator\">|=</span> FLAT_POST<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>最后 mViewInfoStore 调用了 process 方法，根据 mViewInfoStore 中的 View 信息，来执行动画逻辑。</p>\n<h3 id=\"缓存逻辑\"><a href=\"#缓存逻辑\" class=\"headerlink\" title=\"缓存逻辑\"></a>缓存逻辑</h3><p>缓存共分为四层</p>\n<ol>\n<li>Scrap  内存缓存</li>\n<li>Cache 内存缓存</li>\n<li>ViewCacheExtension 用户自定义缓存</li>\n<li>Recycled View Pool 缓存池</li>\n</ol>\n<p>RecyclerView 的缓存时分为多级的，但其实真个逻辑很好理解，</p>\n<pre class=\" language-java\"><code class=\"language-java\">View <span class=\"token function\">getViewForPosition</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> position<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> dryRun<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">boolean</span> fromScrap <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    ViewHolder holder <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mState<span class=\"token punctuation\">.</span><span class=\"token function\">isPreLayout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        holder <span class=\"token operator\">=</span> <span class=\"token function\">getChangedScrapViewForPosition</span><span class=\"token punctuation\">(</span>position<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        fromScrap <span class=\"token operator\">=</span> holder <span class=\"token operator\">!=</span> null\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>hoder <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        hodler <span class=\"token operator\">=</span> <span class=\"token function\">getScrapViewForPosition</span><span class=\"token punctuation\">(</span>position<span class=\"token punctuation\">,</span> INVALID_TYPE<span class=\"token punctuation\">,</span> dryRun<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>holder <span class=\"token operator\">==</span> null <span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> offsetPosition <span class=\"token operator\">=</span> mAdapterHelper<span class=\"token punctuation\">.</span><span class=\"token function\">findPositionOffset</span><span class=\"token punctuation\">(</span>position<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> type <span class=\"token operator\">=</span> mAdapter<span class=\"token punctuation\">.</span><span class=\"token function\">getItemViewType</span><span class=\"token punctuation\">(</span>offsetPosition<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mAdapter<span class=\"token punctuation\">.</span><span class=\"token function\">hasStableIds</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            holder <span class=\"token operator\">=</span> <span class=\"token function\">getScrapViewForId</span><span class=\"token punctuation\">(</span>mAdapter<span class=\"token punctuation\">.</span><span class=\"token function\">getItemId</span><span class=\"token punctuation\">(</span>offsetPosition<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">,</span> dryRun<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>holder <span class=\"token operator\">==</span> null <span class=\"token operator\">&amp;&amp;</span> mViewCacheExtension <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">final</span> View view <span class=\"token operator\">=</span> mViewCacheExtension<span class=\"token punctuation\">.</span><span class=\"token function\">getViewForPositionAndType</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> position<span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>holder <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// fallback to recycler</span>\n            holder <span class=\"token operator\">=</span> <span class=\"token function\">getRecyclerViewPool</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getRecyclerView</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>holder <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                holder<span class=\"token punctuation\">.</span><span class=\"token function\">resetInternal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>FORCE_INVALIDATE_DISPLAY_LIST<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">invalidateDisplayListInt</span><span class=\"token punctuation\">(</span>holder<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> \n\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>holder <span class=\"token operator\">==</span> null <span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            holder <span class=\"token operator\">=</span> mAdapter<span class=\"token punctuation\">.</span><span class=\"token function\">createViewHolder</span><span class=\"token punctuation\">(</span>RecyclerView<span class=\"token punctuation\">.</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n\n    <span class=\"token comment\" spellcheck=\"true\">// 生成 LayoutParams 的代码</span>\n    <span class=\"token keyword\">return</span> holder<span class=\"token punctuation\">.</span>itemView<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>获取 View 的逻辑可以整理为</p>\n<ul>\n<li>搜索 mChangedScrap， 如果找到则返回相应的 holder</li>\n<li>搜索 mAttachedScrap与 mCachedViews， 如果找到且 holder 有效则返回相应的 holder</li>\n<li>如果设置了 mViewCacheExtension, 对其调用 getViewForPositionAndType 方法进行获取，若返回结果则生成对应的 holder</li>\n<li>搜索 mRecyclerPool, 如果找到则返回 Holder</li>\n<li>如果上述过程都没有找到对饮的 holder, 则执行 Adapter.createViewHolder(); 创建新的 ViewHolder 实例</li>\n</ul>\n<p><strong>对于 View 的回收</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">void</span> <span class=\"token function\">recycleViewHolderInternal</span><span class=\"token punctuation\">(</span>ViewHolder holder <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>holder<span class=\"token punctuation\">.</span><span class=\"token function\">isRecyclable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>holder<span class=\"token punctuation\">.</span><span class=\"token function\">hasAnyOfTheFlags</span><span class=\"token punctuation\">(</span>VieHolder<span class=\"token punctuation\">.</span>FLAG_INVALID <span class=\"token operator\">|</span> ViewHolder<span class=\"token punctuation\">.</span>FLAG_REMOVED<span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span> ViewHolder<span class=\"token punctuation\">.</span>FLAG_UPDATE<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> cachedViewSize <span class=\"token operator\">=</span> mCachedViews<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>cachedViewSize <span class=\"token operator\">>=</span> mViewCacheMax <span class=\"token operator\">&amp;&amp;</span> cachedViewSize <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">recycleCachedViewAt</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                cachedViewSize<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>cachedViewSize <span class=\"token operator\">&lt;</span> mViewCacheMax<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                mCachedViews<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>holder<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                cached <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>cached<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">addViewHolderToRecycledViewPool</span><span class=\"token punctuation\">(</span>holder<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            recycled <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>回收没有创建复杂，只涉及到两次缓存， mCachedViews 和 mRecyclerPool , mCachedViews 相当于一个先进先出的数据结构（队列），当有新的 View 需要缓存时，都会将新的 View 存入到 mCachedViews， 而 mCachedView  则会移除头部元素，并将头部元素存储在 mRecyclerPool 中， 即 mCachedViews 相当于一级缓存， mRecyclerPool 相当于二级缓存，并且 mRecyclerPool  时可以多个 RecyclerView 共享的。</p>\n<h2 id=\"与-AdapterView-比较\"><a href=\"#与-AdapterView-比较\" class=\"headerlink\" title=\"与 AdapterView 比较\"></a>与 AdapterView 比较</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">index</th>\n<th style=\"text-align:center\">AdapterView</th>\n<th style=\"text-align:center\">RecyclerView</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">Simple click listener</td>\n<td style=\"text-align:center\">OnItemTouchListener</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">Simple Divider</td>\n<td style=\"text-align:center\">ItemDecoration</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">ListView and GridView</td>\n<td style=\"text-align:center\">LinearLayoutManager<br>GridLayoutManager</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">RecyclerBin</td>\n<td style=\"text-align:center\">Recycler</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">Header and Footer</td>\n<td style=\"text-align:center\">Partial refresh</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"点击事件\"><a href=\"#点击事件\" class=\"headerlink\" title=\"点击事件\"></a>点击事件</h5><p>ListView 原生提供了Item 点击、长安的事件，而 RecyclerView  则需要使用 onTouchListener 相对比较复杂</p>\n<h5 id=\"分割线\"><a href=\"#分割线\" class=\"headerlink\" title=\"分割线\"></a>分割线</h5><p>ListView  可以很轻松设施 Divider 属性来显示 item 之间的分割线，</p>\n<p>RecyclerView 需要自己实现 ItemDecoration ，两者比较，前者使用更简单，后者定制性更强</p>\n<h5 id=\"布局类型\"><a href=\"#布局类型\" class=\"headerlink\" title=\"布局类型\"></a>布局类型</h5><p>AdapterView 提提供了 三种布局管理方式，LinearLayoutManager, GirdLayoutManager, StaggeredGirdLayoutManager</p>\n<p>ListView 只提供了一种 LinearLayoutManager 方式</p>\n<h5 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h5><ul>\n<li>RecyclerView 提供了DiffUtil 工具类，用于整个页面需要刷新，对比列表中的数据，如果未发生变化，则不会触发重绘制操作</li>\n<li>ListView 不支持单个 Item  的刷新，只能整个列表进行 <code>notifyDataSetChanged</code> ， RecyclerView 提供了 <code>itemChange</code>, <code>ItemInsert</code>, <code>ItemRemoved</code> 等方法，减少了 性能的开销</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"List-View-的局限性\"><a href=\"#List-View-的局限性\" class=\"headerlink\" title=\"List View 的局限性\"></a>List View 的局限性</h2><ol>\n<li>只有纵向列表一种布局</li>\n<li>没有支持动画的  API</li>\n<li>接口设计和系统不一致<ol>\n<li>setOnItemClickListener()</li>\n<li>setOnItemLongClickListener()</li>\n<li>setSelection()</li>\n</ol>\n</li>\n<li>没有强制实现 ViewHolder</li>\n<li>性能不如 RecyclerView</li>\n</ol>\n<h2 id=\"RecyclerView-优势\"><a href=\"#RecyclerView-优势\" class=\"headerlink\" title=\"RecyclerView 优势\"></a>RecyclerView 优势</h2><ol>\n<li>默认支持 Linear、Grid、Staggered Grid 三种布局</li>\n<li>友好的 ItemAnimator 动画 API</li>\n<li>强制实现 ViewHolder</li>\n<li>解耦的架构设计</li>\n<li>相对 ListView 性能更好</li>\n</ol>","more":"<p><img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/image-20200709164241306.png?raw=true\" alt=\"image-20200709164241306\"></p>\n<p>Recycler View： 负责将 Datas 展示在自己身上，其本身是一个 ViewGroup，只认识 View，因此需要一个 Adapter 来将 Datas 的内容转换为 View</p>\n<p>Adapter： 负责翻译，将 Datas 内容，转换为 View，方便 RecyclerView 展示</p>\n<p>ViewHolder： RecyclerView 只会与 ViewHolder 进行交互，因此 ViewHolder 充当中间件，来将 Datas 的内容传递给  RecyclerView</p>\n<p>LayoutManager：负责布局，RecyclerView 将其子 View 的布局管理，交给它来完成</p>\n<p>Recycler：负责管理 View 的生命周期，LayoutManager 只管负责 View 的布局任务，对其回收交给了 Recycler 来处理，避免造成不必要的错误</p>\n<p>ItemAnimator： 负责动画，当 RecyclerView 中的数据发生变化（增、删等）都会通过它来完成平滑的过渡</p>\n<h2 id=\"RecyclerView-的绘制\"><a href=\"#RecyclerView-的绘制\" class=\"headerlink\" title=\"RecyclerView 的绘制\"></a>RecyclerView 的绘制</h2><p>RecyclerView 无疑也是一个 View ，View 的绘制同样逃离不了三大步骤 <code>onMeasure()</code> <code>onLayout()</code> <code>onDraw()</code> </p>\n<h3 id=\"onMeasure\"><a href=\"#onMeasure\" class=\"headerlink\" title=\"onMeasure\"></a>onMeasure</h3><p>LayoutManager 负责 RecyclerView 的绘制，其有一个 <code>mAutoMeasure</code> 属性，用来控制是否开启自动测量，开启情况下，布局交由 <code>RecyclerView</code> 使用一套默认的测量机制；否则，自定义的 LayoutManager 需要重写 <code>onMeasure</code> 来处理自身的测量工作。</p>\n<h4 id=\"自动测量原理：\"><a href=\"#自动测量原理：\" class=\"headerlink\" title=\"自动测量原理：\"></a><strong>自动测量原理：</strong></h4><p>当 RecyclerView 的宽高都为 <code>EXACTLY</code> 时， 可以直接设置对应的宽高，然后返回，结束测量</p>\n<p>如果宽高都不时 <code>EXACTLY</code> 则会在 <code>onMeasure</code> 中开始布局的处理。</p>\n<p>RecyclerView.State 这个类封装了当前 RecyclerView 的信息。State 中的一个变量 <code>mLayoutStep</code> 记录了 RecyclerView  当前的布局状态</p>\n<ul>\n<li>STEP_START</li>\n<li>STEP_LAYOUT</li>\n<li>STEP_ANIMATIONS</li>\n</ul>\n<p>对应的， RecyclerView 的布局过程也分为三步，STEP_START 表示开始布局，对应需要调用 <code>dispatchLayoutStep1()</code> 来执行第一步布局，结束后， <code>mLayoutStep</code> 变为 STEP_LAYOUT ，表示接下来需要调用 <code>dispatchLayoutStep2()</code> 进行布局，结束后 <code>mLayoutStep</code> 变为 STEP_ANIMATIONS, 继续执行第三步 <code>dispatchLayoutStep3()</code></p>\n<ul>\n<li><p>dispatchLayoutStep1:  负责记录状态</p>\n</li>\n<li><p>dispatchLayoutStep2：负责布局</p>\n</li>\n<li>dispatchLayoutStep3：与 step1 比较，根据变化来触发动画</li>\n</ul>\n<h3 id=\"onLayout\"><a href=\"#onLayout\" class=\"headerlink\" title=\"onLayout\"></a>onLayout</h3><pre><code class=\"java\">protected void onLayout(boolean changed, int l int t, int r, int b) {\n    TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);\n    dispatchLayout();\n    TraceCompat.endSection();\n    mFirstLayoutComplete = true;\n}\n\nvoid dispatchLayout() {\n    mState.mIsMeasuring = false;\n    if(mState.mLayoutStep == State.STEP_START) {\n        dispatchLayoutStep1();\n        mLayout.setExactMeasureSpecsFrom(this);\n        dispatchLayoutStep2();\n    } else if(mAdapterHelper.hasUpdates() \n              || mLayout.getWidth() != getWidth() \n              || mLayout.getHeight() != getHeight()) {\n        // first 2 steps are done in onMeasure but looks like we have to run again due to changed size\n        mLayout.setExactMeasureSpecsFrom(this);\n        dispatchLayoutStep2();\n    } else {\n        // always make sure we sync them (to ensure mode is exact)\n        mLayout.setExactMeasureSpecsFrom(this);\n    }\n\n    dispatchLayoutStep3();\n}\n</code></pre>\n<p>通过 <code>dispatchLayout</code> 可以验证RecyclerView 的 layout三步走原则，如果在 <code>onMeasure</code> 中已经完成了 step1 和 step2 ，则只会执行 step3，否则，会在 <code>onLayout</code> 中依次触发三步走。</p>\n<h4 id=\"dispatchLayoutStep1\"><a href=\"#dispatchLayoutStep1\" class=\"headerlink\" title=\"dispatchLayoutStep1\"></a>dispatchLayoutStep1</h4><pre><code class=\"java\">private void dispatchLayoutStep1(){\n    if(mState.mRunSimpleAnimations) {\n        int count = mChildHelper.getChildCount();\n        for(int i = 0; i &lt; count; i++) {\n            final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));\n            final ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(mState, holder, ItemAnimator.buildAdapterChangeFlagsForAnimations(holder), holder.getUnmodifiedPayloads());\n            mViewInfoStore.addToPreLayout(holder, animationInfo);\n        }\n    }\n    mState.mLayoutStep = State.STEP_LAYOUT\n}\n</code></pre>\n<p>step 的第一步目的就是记录 View 的状态，先遍历当前所有 View，一次进行处理，mItemAnimator 会根据每个 View 的信息，封装一个 ItemHolderInfo, 这个 ItemHolderInfo 中主要包含的就是 View 的位置状态等。然后将 ItemHodlerInfo 存入 mViewInfoStore 中。在进入第二步后， View 的信息就将被改变</p>\n<h4 id=\"dispatchLayoutStep2\"><a href=\"#dispatchLayoutStep2\" class=\"headerlink\" title=\"dispatchLayoutStep2\"></a>dispatchLayoutStep2</h4><pre><code class=\"java\">private void dispatchLayoutStep2(){\n    mLayout.onLayoutChildren(mRecycler, mState);\n\n    mState.mLayoutStep = State.STATE_ANIMATIONS;\n}\n</code></pre>\n<p>layout 的第二步就是真正的布局 View。RecyclerView 的真正布局是由 LayoutManger 来负责的，其主要工作也在 LayoutManager 中。</p>\n<pre><code class=\"java\">public  void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {\n\n    if(!mAnchorInfo.mValid \n      || mPendingScrollPosition != NO_POSITION \n      || mPendingSavedState != null) {\n        updateAnchorInfoForLayout(recycler, state, mAnchorInfo);\n    }\n\n    if(mAnchorInfo.mLayoutFromEnd) {\n        firstLayoutDirection = mShouldReverseLayout \n            ? LayoutState.ITEM_DIRECTIONTAIL\n            : LayoutState.ITEM_DIRECTION_HEAD;\n    } else {\n        firstLayoutDirection = mShouldReverseLayout \n            ? LayoutState.ITEM_DIRECTION_HEAD\n            : LayoutState.ITEM_DIRECTION_TAIL;\n    }\n\n    onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);\n\n    if(mAnchorInfo.mLayoutFromEnd) {\n\n    } else {\n        // fill towards end\n        updateLayouStateToFillEnd(mAnchorInfo);\n        fill(recycler, mLayoutState, state, false);\n\n        // fill towards start\n        updateLayoutStateToFillStart(mAnchorInfo);\n        fill(recycler, mLayoutState, state, false);\n    }\n}\n</code></pre>\n<p>流程很负责，大致流程如下</p>\n<ul>\n<li>找到 anchor点</li>\n<li>根据 anchor 一直向前布局，直到填充满 anchor 点前面的所有区域</li>\n<li>根据 anchor 一直向后布局，直到填充满 anchor 点后面的所有区域</li>\n</ul>\n<p>anchor 点的寻找是由 <code>updateAnchorInfoForLayout</code> 函数负责。向下追踪会看到 <code>updateAnchorFromChildren</code>  方法，其内容为，先寻找被 focus 的 child， 找到以此 child 作为 anchor ，否则根据布局方向寻找最合适的 child 来作为 anchor，如果找到则将 child 的信息复制给 anchorInfo 。 <code>anchorInfo</code> 主要记录的信息就是 View 的物理位置与 Adapter 中的位置。找到后返回 true，否则返回 false，交给上一步函数做处理。</p>\n<p>继续当找到 anchor 后，会根据 anchor 来布局，通过 fill 方法来完成</p>\n<pre><code class=\"java\">int fill(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.state state, boolean stopOnFocusable) {\n    final int start = layoutState.mAvailable;\n    if(layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {\n        recycleByLayoutState(recycler, layoutState);\n    }\n\n    int remainingSpace = layoutState.mAvailable + layoutState.mExtra;\n    LayoutChunkResult layoutChunkResult = mLayoutChunkResult;\n    while((layoutState.mInfinite || remainingSpace &gt; 0)\n         &amp;&amp; layoutState.hasMore(state)) {\n        layoutChunk(recycler, state, layoutState, layoutChunkResult);\n    }\n    return start-layoutState.mAvailable;\n}\n</code></pre>\n<p><strong>recycleByLayoutState</strong> 这个函数，会根据当前信息对不需要的 View 进行回收:</p>\n<pre><code class=\"java\">private void recycleByLayoutState(RecyclerView.Recycler recycler, LayoutState layoutState) {\n    if(layoutState.mLayoutDirection == LayoutState.LAYOUT_START) {\n\n    } else {\n        recycleViewsFromStart(recycler, layoutState.mScrollingOffset);\n    }\n}\n</code></pre>\n<p>继续看 <code>recycleViewsFromStart</code></p>\n<pre><code class=\"java\">private void recycleViewsFromStart(RecyclerView.Recycler recycler, int dt){\n    final int limit = dt;\n    final int childCount = getChildCount();\n    if(mShouldReverseLayout) {\n\n    } else {\n        for(int i = 0; i &lt; childCount; i++){\n            View child = getChildAt(i);\n            if(mOrientationHelper.getDecoratedEnd(child) &gt; limit\n              || mOrientationHelper.getTransformedEndWithDecoration(child) &gt; limit) {\n        recycleChildren(recycler, 0, i);\n                return;\n            }\n        }\n    }\n}\n</code></pre>\n<p>该函数的作用时遍历所有的子 View ,找出逃离边界的 View 进行回收，回收函数在 <code>recycleChildren</code> 里，而这函数又调用了 <code>removeAndRecycleViewAt</code> </p>\n<pre><code class=\"java\">public void removeAndRecycleViewAt(int index, Recycler recycler) {\n    final View view = getChildAt(index);\n    removeViewAt(index);\n    recycler.recycleView(view);\n}\n</code></pre>\n<p>该函数先调用 <code>removeViewAt</code> ，将 View 从 RecyclerView 中移除，紧接着是 recycler 执行了 View 的回收逻辑。在 fill 函数的一开始会去回收逃离出屏幕的 view。</p>\n<pre><code class=\"java\">while((layoutState.mInfinite || remainningSpace &gt; 0) \n     &amp;&amp; layoutState.hasMore(state)) {\n    layoutChunk(recycler, state, layoutState, layoutChunkResult);\n}\n</code></pre>\n<p>只要又剩余空间，就会执行 layoutChunk 方法</p>\n<pre><code class=\"java\">void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State stat, LayoutState layoutState, LayoutCHunkResult result){\n    View view = layoutState.next(recycler);\n\n    LayoutParams params = (LayoutParams) view.getLayoutParams();\n    if(layoutState.mScrapList == null) {\n        if(mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) {\n            addView(view);\n        } else {\n            addView(view, 0);\n        }\n    } else {\n\n    }\n\n    layoutDecoratedWithMargins(view, left, top, right, bottom);\n}\n</code></pre>\n<p>在 layoutState 的 next 方法返回了一个 view， 凭空变出一个 View， 很神奇</p>\n<pre><code class=\"java\">View next(RecyclerView.Recycler recycler ) {\n    final View view = recycler.getViewForPosition(mCurrentPosition);\n    return view;\n}\n</code></pre>\n<p>可见 view 的获取逻辑也是由 recycler 来负责， 所以我们只需要清楚 recycler 可以根据位置返回一个 View 即可。</p>\n<p>我们在看 layoutChunk 对刚刚生成的 View 的处理</p>\n<pre><code class=\"java\">if(mShouldReverseLayout == (layoutState.mLayoutDirectoin == LayoutState.LAYOUT_STATE)) {\n    addView(view);\n} else {\n    addView(view, 0);\n}\n</code></pre>\n<p>明显的调用了 addView 方法，虽然这个方法是 LayoutManager 的，但是这个方法最终会多次辗转调用到 Recycler View 的 addView 方法，将 view 添加到 RecyclerView 中。</p>\n<p>dispatchLayoutStep2 整个布局过程，完成了对 子 View 的测量与布局</p>\n<h4 id=\"dispatchLayoutStep3\"><a href=\"#dispatchLayoutStep3\" class=\"headerlink\" title=\"dispatchLayoutStep3\"></a>dispatchLayoutStep3</h4><p>最后一步</p>\n<pre><code class=\"java\">private void dispatchLayoutStep3(){\n    mState.mLayoutStep = State.STEP_START;\n    if(mState.mRunSimpleAnimations) {\n        for(int i = mChildHelper.getChildCount() - 1; i &gt;= 0; i--) {\n            final ItemHolderInfo animationInfo = mItemAnimator.recordPostLayoutInformation(mState, holder);\n            mViewInfoStore.addToPostLayout(holder, animationInfo);\n        }\n\n        mViewInfoStore.process(mViewInfoProcessCallback);\n    }\n}\n</code></pre>\n<p>这里是与第一步呼应的，此时子 View 都已布局完成，所以子 View 的信息都发生了变化。第一步出现的 mViewInfoStore 和 mItemAnimator 再次登场，这次 mItemAnimator 调用的是 recordPostLayoutInformation 方法，而 mViewInfoStore 调用的是 addToPostLayout 方法，</p>\n<pre><code class=\"java\">void addToPostLayout(ViewHolder holder, ItemHolderInfo info) {\n    InfoRecord record = mLayoutHolderMap.get(holder);\n    if(record == null ) {\n        record = InfoRecord.obtain();\n        mLayoutHolderMap.put(holder, record);\n    }\n    record.postInfo = info;record.flags |= FLAT_POST;\n}\n</code></pre>\n<p>最后 mViewInfoStore 调用了 process 方法，根据 mViewInfoStore 中的 View 信息，来执行动画逻辑。</p>\n<h3 id=\"缓存逻辑\"><a href=\"#缓存逻辑\" class=\"headerlink\" title=\"缓存逻辑\"></a>缓存逻辑</h3><p>缓存共分为四层</p>\n<ol>\n<li>Scrap  内存缓存</li>\n<li>Cache 内存缓存</li>\n<li>ViewCacheExtension 用户自定义缓存</li>\n<li>Recycled View Pool 缓存池</li>\n</ol>\n<p>RecyclerView 的缓存时分为多级的，但其实真个逻辑很好理解，</p>\n<pre><code class=\"java\">View getViewForPosition(int position, boolean dryRun) {\n    boolean fromScrap = false;\n    ViewHolder holder = null;\n    if(mState.isPreLayout()) {\n        holder = getChangedScrapViewForPosition(position);\n        fromScrap = holder != null\n    }\n\n    if(hoder == null) {\n        hodler = getScrapViewForPosition(position, INVALID_TYPE, dryRun);\n    }\n\n    if(holder == null ){\n        final int offsetPosition = mAdapterHelper.findPositionOffset(position);\n        final int type = mAdapter.getItemViewType(offsetPosition);\n        if(mAdapter.hasStableIds()){\n            holder = getScrapViewForId(mAdapter.getItemId(offsetPosition), type, dryRun);\n        }\n\n        if(holder == null &amp;&amp; mViewCacheExtension != null) {\n            final View view = mViewCacheExtension.getViewForPositionAndType(this, position, type);\n        }\n\n        if(holder == null) {\n            // fallback to recycler\n            holder = getRecyclerViewPool().getRecyclerView(type);\n            if(holder != null){\n                holder.resetInternal();\n                if(FORCE_INVALIDATE_DISPLAY_LIST){\n                    invalidateDisplayListInt(holder);\n                }\n            }\n        } \n\n        if(holder == null ){\n            holder = mAdapter.createViewHolder(RecyclerView.this, type);\n        }\n    }\n\n\n    // 生成 LayoutParams 的代码\n    return holder.itemView;\n}\n</code></pre>\n<p>获取 View 的逻辑可以整理为</p>\n<ul>\n<li>搜索 mChangedScrap， 如果找到则返回相应的 holder</li>\n<li>搜索 mAttachedScrap与 mCachedViews， 如果找到且 holder 有效则返回相应的 holder</li>\n<li>如果设置了 mViewCacheExtension, 对其调用 getViewForPositionAndType 方法进行获取，若返回结果则生成对应的 holder</li>\n<li>搜索 mRecyclerPool, 如果找到则返回 Holder</li>\n<li>如果上述过程都没有找到对饮的 holder, 则执行 Adapter.createViewHolder(); 创建新的 ViewHolder 实例</li>\n</ul>\n<p><strong>对于 View 的回收</strong></p>\n<pre><code class=\"java\">void recycleViewHolderInternal(ViewHolder holder ) {\n\n    if(holder.isRecyclable()) {\n        if(!holder.hasAnyOfTheFlags(VieHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED) | ViewHolder.FLAG_UPDATE) {\n            int cachedViewSize = mCachedViews.size();\n            if(cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; 0) {\n                recycleCachedViewAt(0);\n                cachedViewSize--;\n            }\n\n            if(cachedViewSize &lt; mViewCacheMax) {\n                mCachedViews.add(holder);\n                cached = true;\n            }\n        }\n\n        if(!cached) {\n            addViewHolderToRecycledViewPool(holder);\n            recycled = true;\n        }\n    }\n}\n</code></pre>\n<p>回收没有创建复杂，只涉及到两次缓存， mCachedViews 和 mRecyclerPool , mCachedViews 相当于一个先进先出的数据结构（队列），当有新的 View 需要缓存时，都会将新的 View 存入到 mCachedViews， 而 mCachedView  则会移除头部元素，并将头部元素存储在 mRecyclerPool 中， 即 mCachedViews 相当于一级缓存， mRecyclerPool 相当于二级缓存，并且 mRecyclerPool  时可以多个 RecyclerView 共享的。</p>\n<h2 id=\"与-AdapterView-比较\"><a href=\"#与-AdapterView-比较\" class=\"headerlink\" title=\"与 AdapterView 比较\"></a>与 AdapterView 比较</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">index</th>\n<th style=\"text-align:center\">AdapterView</th>\n<th style=\"text-align:center\">RecyclerView</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">Simple click listener</td>\n<td style=\"text-align:center\">OnItemTouchListener</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">Simple Divider</td>\n<td style=\"text-align:center\">ItemDecoration</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">ListView and GridView</td>\n<td style=\"text-align:center\">LinearLayoutManager<br>GridLayoutManager</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">RecyclerBin</td>\n<td style=\"text-align:center\">Recycler</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">Header and Footer</td>\n<td style=\"text-align:center\">Partial refresh</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"点击事件\"><a href=\"#点击事件\" class=\"headerlink\" title=\"点击事件\"></a>点击事件</h5><p>ListView 原生提供了Item 点击、长安的事件，而 RecyclerView  则需要使用 onTouchListener 相对比较复杂</p>\n<h5 id=\"分割线\"><a href=\"#分割线\" class=\"headerlink\" title=\"分割线\"></a>分割线</h5><p>ListView  可以很轻松设施 Divider 属性来显示 item 之间的分割线，</p>\n<p>RecyclerView 需要自己实现 ItemDecoration ，两者比较，前者使用更简单，后者定制性更强</p>\n<h5 id=\"布局类型\"><a href=\"#布局类型\" class=\"headerlink\" title=\"布局类型\"></a>布局类型</h5><p>AdapterView 提提供了 三种布局管理方式，LinearLayoutManager, GirdLayoutManager, StaggeredGirdLayoutManager</p>\n<p>ListView 只提供了一种 LinearLayoutManager 方式</p>\n<h5 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h5><ul>\n<li>RecyclerView 提供了DiffUtil 工具类，用于整个页面需要刷新，对比列表中的数据，如果未发生变化，则不会触发重绘制操作</li>\n<li>ListView 不支持单个 Item  的刷新，只能整个列表进行 <code>notifyDataSetChanged</code> ， RecyclerView 提供了 <code>itemChange</code>, <code>ItemInsert</code>, <code>ItemRemoved</code> 等方法，减少了 性能的开销</li>\n</ul>"},{"title":"自定义 ViewGroup","_content":"\n\n\n## View Group 的测量布局流程\n\n**View Group绘制和布局流程中的重点**\n<!-- more-->\n\n1. View 在 `onMeasure` 方法中进行自我测量和保存。\n\n2. ViewGroup 循环遍历调用所有子 view 的 onMeasure 方法，利用 onMeasure 方法计算出来的大小，来确定这些 子 View 最终可以占用的大小和所处布局的位置\n\n3. 关注 onMeasure 和 onLayout\n\n4. 父 View 调用子 View 的layout 方法的时候，会把之前 measure 阶段确定的位置和大小都传递给子 View\n\n5. 自定义 View/ViewGroup，只需要关注下面三种需求：\n\n   1. 对于已有的 Android 自带 View，我们只需要重写他的 `onMeasure` 方法即可,**修改一下这个尺寸就完成需求**\n   2. 对于 Android 系统没有的，属于我们自定义的 View，需要完全重写 `onMeasure`\n   3. 需要重写 `onMeasure` 和 `onLayout` 2个方法，来完成一个复杂的 `ViewGroup` 的测量和布局。\n\n6. onMeasure 的说明\n\n   widthMeasureSpec, heightMeasureSpec  两个参数主要是 父 view 对子view 的尺寸限制\n\n7. 理解父 view 对子 view 的限制\n\n   实际上，父 View 对子 View 的限制据大多数就来自于我们开发者所设置的 layout 开头的这些属性。**这些以 layout 开头的属性，都是设置给父 view 看的**\n\n   > 父 View 要知道这些属性以后，才知道要对子view 的测量加以什么限制\n\n\n<!-- more -->\n\n## 自定义 BannerView\n\n```java\npublic class BannerImageView extends ImageView{\n    // 宽高比\n    float ratio;\n    public BannerImageView(Context context) {\n        super(context);\n    }\n    \n    public BannerImageView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.BannerImageView);\n        ratio = array.getFloat(R.styleable.BannerImageView_ratio, 1.0f);\n        array.recycle();\n    }\n    \n    @Override\n    public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        // 自己的测量走一遍，因为这个方法内部会调用 setMEasureDimension() 来保存测量结果\n        // 只有保存了以后，才能取得这个测量结果，否则获取不到\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        \n        // 获取测量结果\n        int tempWidth = getMeasureWidth();\n        int tempHeight = (int) (tempWidth * ratio);\n        // 保存以后，父 view 可以拿到这个测量的宽高了。不保存是拿不到的\n        setMeasureDimension(tempWidth, tempHeight);\n    }\n}\n```\n\n## 自定义 View ，完全自己写 onMeasure 方法\n\n对于完全自定义  View ，完全自己写的 onMeasure 方法，保存的宽高必须符合父 View 的限制，否则会发生 bug，保存父 View 对子 View 的限制的方法就是直接调用 `resolveSize` 方法即可。\n\n```java\npublic static int resolveSizeAndState(int size, int measureSpec, int childMeasureState) {\n    final int specMode = MeasureSpec.getMode(measureSpec);\n    final int specSize = MeasureSpec.getSize(measureSpec);\n    final int result;\n    switch(specMode) {\n        case MeasureSpce.AT_MOST:\n            if(specSize < size) {\n                result = specSize | MEASURED_STATE_TOO_SMALL;\n            } else {\n                result = size;\n            }\n            break;\n        case MeasureSpec.EXACTLY:\n            result = specSize;\n            break;\n        case MeasureSpec.UNSPECIFIED:\n        default:\n            result = size;\n    }\n    return result | (childMeasureState * MEASURED_STATE_MASK);\n}\n```\n\n完全自定义 view onMeasure 方法：\n\n1. 先算自己想要的宽高\n2. 直接拿 `resolveSize` 方法处理一下\n3. 最后 `setMeasuredDimension` 保存\n\n```java\npublic class LoadingView extends View {\n    // 圆的半径\n    int radius;\n    // 外部矩形的起点\n    int left = 10, top = 30;\n    \n    Paint mPaint = new Paint();\n    public LoadingView(Context context) {\n        super(context);\n    }\n    \n    public LoadingView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.LoadingView);\n        radius = typedArray.getInt(R.styleable.LoadingView_radius, 0);\n    }\n    \n    @Override\n    public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        \n        int width = left + radius * 2;\n        int height = top + radius * 2;\n        \n        // 一定要用 resolveSize 方法来格式化 View 的宽高，否则遇到某些 layout 的时候一定会出现器官的 bug\n        // 不用这个，就完全没有父 View 的感受\n        width = resolveSize(width, widthMeasureSpec);\n        height = resolveSize(height, heightMeasureSpec);\n        setMeasuredDimension(width, height);\n    }\n    \n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        \n        // 画矩形\n        RectF oval = new Rectf(left, top ,left + radius * 2, top + radius * 2);\n        mPaint.setColor(Color.BLUE);\n        canvas.drawRect(oval, mPaint);\n        // 画圆弧\n        mPaint.setColor(Color.RED);\n        mPaint.setStyle(Paint.Style.STROKE);\n        mPaint.setStrokeWidth(2);\n        canvas.drawArc(oval, -90, 360, false, mPaint);\n    }\n}\n```\n\n## 自定义 ViewGroup\n\n注意以下几点：\n\n1. 一定要先重写 onMeasure 确定子 View 的宽高和自己的宽高以后，才可以继续写 onLayout 对这些子 View 进行布局\n2. ViewGroup 的 onMeasure 其实就是遍历自己的 view ，对自己的每一个子 View 进行 measure，据大多数的时候对子 View 的measure 都可以直接调用  measureChild() 这个方法\n3. 计算出 View Group 自己的尺寸并保存，`onMeasuredDinmension`\n4. 逼不得已需要重写`measureChild` 的时候，无非就是对父 view 的测量和子 View 的测量，做一个取舍关系而已，可参照 `measureChild` 方法。\n\n```java\n/**\n * 从左到右布局，如果不够放，就直接另起一行layout\n */\npublic class SimpleFlowLayout extends ViewGroup {\n    public SimpleFlowLayout(Context context) {\n        super(context);\n    }\n    \n    public SimpleFlowLayout(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n    \n    /**\n     *\tlayout 算法，就是不够放，就另外放一行\n     * \n\t *  无非就是前面 onMeasure 结束以后，你可以拿到所有子 View和自己的测量宽高，\n     */\n    @Override\n    public void onLayout(boolean changed, int l, int t, int r, int b) {\n        int childTop = 0;\n        int childLeft = 0;\n        int childRight = 0;\n        int childBottom = 0;\n        \n        // 已使用的 width\n        int usedWidth = 0;\n        // customlayout 自己可使用的宽度\n        int layoutWidth = getMeasuredWidth();\n        \n        for(int i = 0; i < getChildCount(); i++) {\n            View childView = getChildAt(i);\n            // 取得这个子 View 要求的宽度和高度\n            int childWidth = childView.getMeasuredWidth();\n            int childHeight = childView.getMeasuredHeight();\n            \n            // 如果宽度不够，就另外启动一行\n            if(layoutWidth - usedWidth < childWidth) {\n                childLeft = 0;\n                usedWidth = 0;\n                childTop += childHeight;\n                childBottom = childTop + childHeight;\n                childView.layout(0, childTop, childRight, childBottom);\n                usedWidth = usedWidth + childWidth;\n                childLeft = childWidth;\n                continue;\n            }\n            childRight = childLeft + childWidth;\n            childBottom = childTop + childHeight;\n            childView.layout(childLeft, childTop, childRight, childBottom);\n            childLeft += childWidth;\n            usedWidth += childWidth;\n        }\n    }\n    \n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        // 先取出 SimpleFlowLayout 的父 View 对他的测量限制\n        // 只有知道了自己的宽高，才能限制子 View 的宽高\n        int widthMode = MeasureSpec.getMode(widthMeasureSpec);\n        int heightMode = MeasureSpec.getMode(heightMeasureSpec);\n        \n        int widthSize = MeasureSpec.getSize(widthMeasureSpec);\n        int heightSize = MeasureSpec.getSize(heightMeasureSpec);\n        \n        int usedWidth = 0; // 已使用宽度\n        int remaining = 0;\t// 剩余可用宽度\n        int totalHeight = 0; // 总高度\n        int lineHeight = 0; // 当前行高\n        \n        for(int i = 0; i< getChildCount(); i++) {\n            View childView = getChildAt(i);\n            LayoutParams lp = childView.getLayoutParams();\n            \n            // 先测量子View\n            measureChild(childView, widthMeasureSpec, heightMeasureSpec);\n            // 然后计算以下宽度里面，还有多少是可用的，也就是剩余可用宽度\n            remaining = widthSize - usedWidth;\n            \n            // 如果一行不够放，也就是说这个子 View 测量的宽度，大于这一行剩下的宽度时，我们要另外启动一行\n            if(childView.getMeasuredWidth > remaining) {\n                // 另外启动一行\n                usedWidth = 0;\n                totalHeight += lineHeight;\n            }\n            \n            // 已使用 width 进行累加\n            usedWidth += childView.getMeasuredWidth();\n            // 当前 view 的高度\n\t\t\tlineHeight = childView.getMeasuredHeight();\n            \n    }\n        // 如果 SimpleFlowLayout 的高度为 wrap_content  的时候，采用我们叠加的高度，否则我们当然用父对其的限制高度\n        if(heightMode == MeasureSpec.AT_MOST) {\n            heightSize = totalHeight;\n        }\n        \n        setMeasuredDimension(widthSize, heightSize);\n    }\n}\n```\n\n","source":"_posts/Android 基础/View/自定义 ViewGroup.md","raw":"---\ntitle: 自定义 ViewGroup\ntag: Android View\n---\n\n\n\n## View Group 的测量布局流程\n\n**View Group绘制和布局流程中的重点**\n<!-- more-->\n\n1. View 在 `onMeasure` 方法中进行自我测量和保存。\n\n2. ViewGroup 循环遍历调用所有子 view 的 onMeasure 方法，利用 onMeasure 方法计算出来的大小，来确定这些 子 View 最终可以占用的大小和所处布局的位置\n\n3. 关注 onMeasure 和 onLayout\n\n4. 父 View 调用子 View 的layout 方法的时候，会把之前 measure 阶段确定的位置和大小都传递给子 View\n\n5. 自定义 View/ViewGroup，只需要关注下面三种需求：\n\n   1. 对于已有的 Android 自带 View，我们只需要重写他的 `onMeasure` 方法即可,**修改一下这个尺寸就完成需求**\n   2. 对于 Android 系统没有的，属于我们自定义的 View，需要完全重写 `onMeasure`\n   3. 需要重写 `onMeasure` 和 `onLayout` 2个方法，来完成一个复杂的 `ViewGroup` 的测量和布局。\n\n6. onMeasure 的说明\n\n   widthMeasureSpec, heightMeasureSpec  两个参数主要是 父 view 对子view 的尺寸限制\n\n7. 理解父 view 对子 view 的限制\n\n   实际上，父 View 对子 View 的限制据大多数就来自于我们开发者所设置的 layout 开头的这些属性。**这些以 layout 开头的属性，都是设置给父 view 看的**\n\n   > 父 View 要知道这些属性以后，才知道要对子view 的测量加以什么限制\n\n\n<!-- more -->\n\n## 自定义 BannerView\n\n```java\npublic class BannerImageView extends ImageView{\n    // 宽高比\n    float ratio;\n    public BannerImageView(Context context) {\n        super(context);\n    }\n    \n    public BannerImageView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.BannerImageView);\n        ratio = array.getFloat(R.styleable.BannerImageView_ratio, 1.0f);\n        array.recycle();\n    }\n    \n    @Override\n    public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        // 自己的测量走一遍，因为这个方法内部会调用 setMEasureDimension() 来保存测量结果\n        // 只有保存了以后，才能取得这个测量结果，否则获取不到\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        \n        // 获取测量结果\n        int tempWidth = getMeasureWidth();\n        int tempHeight = (int) (tempWidth * ratio);\n        // 保存以后，父 view 可以拿到这个测量的宽高了。不保存是拿不到的\n        setMeasureDimension(tempWidth, tempHeight);\n    }\n}\n```\n\n## 自定义 View ，完全自己写 onMeasure 方法\n\n对于完全自定义  View ，完全自己写的 onMeasure 方法，保存的宽高必须符合父 View 的限制，否则会发生 bug，保存父 View 对子 View 的限制的方法就是直接调用 `resolveSize` 方法即可。\n\n```java\npublic static int resolveSizeAndState(int size, int measureSpec, int childMeasureState) {\n    final int specMode = MeasureSpec.getMode(measureSpec);\n    final int specSize = MeasureSpec.getSize(measureSpec);\n    final int result;\n    switch(specMode) {\n        case MeasureSpce.AT_MOST:\n            if(specSize < size) {\n                result = specSize | MEASURED_STATE_TOO_SMALL;\n            } else {\n                result = size;\n            }\n            break;\n        case MeasureSpec.EXACTLY:\n            result = specSize;\n            break;\n        case MeasureSpec.UNSPECIFIED:\n        default:\n            result = size;\n    }\n    return result | (childMeasureState * MEASURED_STATE_MASK);\n}\n```\n\n完全自定义 view onMeasure 方法：\n\n1. 先算自己想要的宽高\n2. 直接拿 `resolveSize` 方法处理一下\n3. 最后 `setMeasuredDimension` 保存\n\n```java\npublic class LoadingView extends View {\n    // 圆的半径\n    int radius;\n    // 外部矩形的起点\n    int left = 10, top = 30;\n    \n    Paint mPaint = new Paint();\n    public LoadingView(Context context) {\n        super(context);\n    }\n    \n    public LoadingView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.LoadingView);\n        radius = typedArray.getInt(R.styleable.LoadingView_radius, 0);\n    }\n    \n    @Override\n    public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        \n        int width = left + radius * 2;\n        int height = top + radius * 2;\n        \n        // 一定要用 resolveSize 方法来格式化 View 的宽高，否则遇到某些 layout 的时候一定会出现器官的 bug\n        // 不用这个，就完全没有父 View 的感受\n        width = resolveSize(width, widthMeasureSpec);\n        height = resolveSize(height, heightMeasureSpec);\n        setMeasuredDimension(width, height);\n    }\n    \n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        \n        // 画矩形\n        RectF oval = new Rectf(left, top ,left + radius * 2, top + radius * 2);\n        mPaint.setColor(Color.BLUE);\n        canvas.drawRect(oval, mPaint);\n        // 画圆弧\n        mPaint.setColor(Color.RED);\n        mPaint.setStyle(Paint.Style.STROKE);\n        mPaint.setStrokeWidth(2);\n        canvas.drawArc(oval, -90, 360, false, mPaint);\n    }\n}\n```\n\n## 自定义 ViewGroup\n\n注意以下几点：\n\n1. 一定要先重写 onMeasure 确定子 View 的宽高和自己的宽高以后，才可以继续写 onLayout 对这些子 View 进行布局\n2. ViewGroup 的 onMeasure 其实就是遍历自己的 view ，对自己的每一个子 View 进行 measure，据大多数的时候对子 View 的measure 都可以直接调用  measureChild() 这个方法\n3. 计算出 View Group 自己的尺寸并保存，`onMeasuredDinmension`\n4. 逼不得已需要重写`measureChild` 的时候，无非就是对父 view 的测量和子 View 的测量，做一个取舍关系而已，可参照 `measureChild` 方法。\n\n```java\n/**\n * 从左到右布局，如果不够放，就直接另起一行layout\n */\npublic class SimpleFlowLayout extends ViewGroup {\n    public SimpleFlowLayout(Context context) {\n        super(context);\n    }\n    \n    public SimpleFlowLayout(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n    \n    /**\n     *\tlayout 算法，就是不够放，就另外放一行\n     * \n\t *  无非就是前面 onMeasure 结束以后，你可以拿到所有子 View和自己的测量宽高，\n     */\n    @Override\n    public void onLayout(boolean changed, int l, int t, int r, int b) {\n        int childTop = 0;\n        int childLeft = 0;\n        int childRight = 0;\n        int childBottom = 0;\n        \n        // 已使用的 width\n        int usedWidth = 0;\n        // customlayout 自己可使用的宽度\n        int layoutWidth = getMeasuredWidth();\n        \n        for(int i = 0; i < getChildCount(); i++) {\n            View childView = getChildAt(i);\n            // 取得这个子 View 要求的宽度和高度\n            int childWidth = childView.getMeasuredWidth();\n            int childHeight = childView.getMeasuredHeight();\n            \n            // 如果宽度不够，就另外启动一行\n            if(layoutWidth - usedWidth < childWidth) {\n                childLeft = 0;\n                usedWidth = 0;\n                childTop += childHeight;\n                childBottom = childTop + childHeight;\n                childView.layout(0, childTop, childRight, childBottom);\n                usedWidth = usedWidth + childWidth;\n                childLeft = childWidth;\n                continue;\n            }\n            childRight = childLeft + childWidth;\n            childBottom = childTop + childHeight;\n            childView.layout(childLeft, childTop, childRight, childBottom);\n            childLeft += childWidth;\n            usedWidth += childWidth;\n        }\n    }\n    \n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        // 先取出 SimpleFlowLayout 的父 View 对他的测量限制\n        // 只有知道了自己的宽高，才能限制子 View 的宽高\n        int widthMode = MeasureSpec.getMode(widthMeasureSpec);\n        int heightMode = MeasureSpec.getMode(heightMeasureSpec);\n        \n        int widthSize = MeasureSpec.getSize(widthMeasureSpec);\n        int heightSize = MeasureSpec.getSize(heightMeasureSpec);\n        \n        int usedWidth = 0; // 已使用宽度\n        int remaining = 0;\t// 剩余可用宽度\n        int totalHeight = 0; // 总高度\n        int lineHeight = 0; // 当前行高\n        \n        for(int i = 0; i< getChildCount(); i++) {\n            View childView = getChildAt(i);\n            LayoutParams lp = childView.getLayoutParams();\n            \n            // 先测量子View\n            measureChild(childView, widthMeasureSpec, heightMeasureSpec);\n            // 然后计算以下宽度里面，还有多少是可用的，也就是剩余可用宽度\n            remaining = widthSize - usedWidth;\n            \n            // 如果一行不够放，也就是说这个子 View 测量的宽度，大于这一行剩下的宽度时，我们要另外启动一行\n            if(childView.getMeasuredWidth > remaining) {\n                // 另外启动一行\n                usedWidth = 0;\n                totalHeight += lineHeight;\n            }\n            \n            // 已使用 width 进行累加\n            usedWidth += childView.getMeasuredWidth();\n            // 当前 view 的高度\n\t\t\tlineHeight = childView.getMeasuredHeight();\n            \n    }\n        // 如果 SimpleFlowLayout 的高度为 wrap_content  的时候，采用我们叠加的高度，否则我们当然用父对其的限制高度\n        if(heightMode == MeasureSpec.AT_MOST) {\n            heightSize = totalHeight;\n        }\n        \n        setMeasuredDimension(widthSize, heightSize);\n    }\n}\n```\n\n","slug":"Android 基础/View/自定义 ViewGroup","published":1,"date":"2021-01-29T15:54:28.302Z","updated":"2021-01-29T16:17:49.560Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8js0032sz5qm8o24jqy","content":"<h2 id=\"View-Group-的测量布局流程\"><a href=\"#View-Group-的测量布局流程\" class=\"headerlink\" title=\"View Group 的测量布局流程\"></a>View Group 的测量布局流程</h2><p><strong>View Group绘制和布局流程中的重点</strong><br><a id=\"more\"></a></p>\n<ol>\n<li><p>View 在 <code>onMeasure</code> 方法中进行自我测量和保存。</p>\n</li>\n<li><p>ViewGroup 循环遍历调用所有子 view 的 onMeasure 方法，利用 onMeasure 方法计算出来的大小，来确定这些 子 View 最终可以占用的大小和所处布局的位置</p>\n</li>\n<li><p>关注 onMeasure 和 onLayout</p>\n</li>\n<li><p>父 View 调用子 View 的layout 方法的时候，会把之前 measure 阶段确定的位置和大小都传递给子 View</p>\n</li>\n<li><p>自定义 View/ViewGroup，只需要关注下面三种需求：</p>\n<ol>\n<li>对于已有的 Android 自带 View，我们只需要重写他的 <code>onMeasure</code> 方法即可,<strong>修改一下这个尺寸就完成需求</strong></li>\n<li>对于 Android 系统没有的，属于我们自定义的 View，需要完全重写 <code>onMeasure</code></li>\n<li>需要重写 <code>onMeasure</code> 和 <code>onLayout</code> 2个方法，来完成一个复杂的 <code>ViewGroup</code> 的测量和布局。</li>\n</ol>\n</li>\n<li><p>onMeasure 的说明</p>\n<p>widthMeasureSpec, heightMeasureSpec  两个参数主要是 父 view 对子view 的尺寸限制</p>\n</li>\n<li><p>理解父 view 对子 view 的限制</p>\n<p>实际上，父 View 对子 View 的限制据大多数就来自于我们开发者所设置的 layout 开头的这些属性。<strong>这些以 layout 开头的属性，都是设置给父 view 看的</strong></p>\n<blockquote>\n<p>父 View 要知道这些属性以后，才知道要对子view 的测量加以什么限制</p>\n</blockquote>\n</li>\n</ol>\n<!-- more -->\n<h2 id=\"自定义-BannerView\"><a href=\"#自定义-BannerView\" class=\"headerlink\" title=\"自定义 BannerView\"></a>自定义 BannerView</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BannerImageView</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">ImageView</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 宽高比</span>\n    <span class=\"token keyword\">float</span> ratio<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">BannerImageView</span><span class=\"token punctuation\">(</span>Context context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">BannerImageView</span><span class=\"token punctuation\">(</span>Context context<span class=\"token punctuation\">,</span> AttributeSet attrs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> attrs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        TypedArray array <span class=\"token operator\">=</span> context<span class=\"token punctuation\">.</span><span class=\"token function\">obtainStyledAttributes</span><span class=\"token punctuation\">(</span>attrs<span class=\"token punctuation\">,</span> R<span class=\"token punctuation\">.</span>styleable<span class=\"token punctuation\">.</span>BannerImageView<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        ratio <span class=\"token operator\">=</span> array<span class=\"token punctuation\">.</span><span class=\"token function\">getFloat</span><span class=\"token punctuation\">(</span>R<span class=\"token punctuation\">.</span>styleable<span class=\"token punctuation\">.</span>BannerImageView_ratio<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        array<span class=\"token punctuation\">.</span><span class=\"token function\">recycle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onMeasure</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> widthMeasureSpec<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> heightMeasureSpec<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 自己的测量走一遍，因为这个方法内部会调用 setMEasureDimension() 来保存测量结果</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 只有保存了以后，才能取得这个测量结果，否则获取不到</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">onMeasure</span><span class=\"token punctuation\">(</span>widthMeasureSpec<span class=\"token punctuation\">,</span> heightMeasureSpec<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 获取测量结果</span>\n        <span class=\"token keyword\">int</span> tempWidth <span class=\"token operator\">=</span> <span class=\"token function\">getMeasureWidth</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> tempHeight <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>tempWidth <span class=\"token operator\">*</span> ratio<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 保存以后，父 view 可以拿到这个测量的宽高了。不保存是拿不到的</span>\n        <span class=\"token function\">setMeasureDimension</span><span class=\"token punctuation\">(</span>tempWidth<span class=\"token punctuation\">,</span> tempHeight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"自定义-View-，完全自己写-onMeasure-方法\"><a href=\"#自定义-View-，完全自己写-onMeasure-方法\" class=\"headerlink\" title=\"自定义 View ，完全自己写 onMeasure 方法\"></a>自定义 View ，完全自己写 onMeasure 方法</h2><p>对于完全自定义  View ，完全自己写的 onMeasure 方法，保存的宽高必须符合父 View 的限制，否则会发生 bug，保存父 View 对子 View 的限制的方法就是直接调用 <code>resolveSize</code> 方法即可。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">resolveSizeAndState</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> size<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> measureSpec<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> childMeasureState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> specMode <span class=\"token operator\">=</span> MeasureSpec<span class=\"token punctuation\">.</span><span class=\"token function\">getMode</span><span class=\"token punctuation\">(</span>measureSpec<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> specSize <span class=\"token operator\">=</span> MeasureSpec<span class=\"token punctuation\">.</span><span class=\"token function\">getSize</span><span class=\"token punctuation\">(</span>measureSpec<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> result<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">switch</span><span class=\"token punctuation\">(</span>specMode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">case</span> MeasureSpce<span class=\"token punctuation\">.</span>AT_MOST<span class=\"token operator\">:</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>specSize <span class=\"token operator\">&lt;</span> size<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                result <span class=\"token operator\">=</span> specSize <span class=\"token operator\">|</span> MEASURED_STATE_TOO_SMALL<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                result <span class=\"token operator\">=</span> size<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> MeasureSpec<span class=\"token punctuation\">.</span>EXACTLY<span class=\"token operator\">:</span>\n            result <span class=\"token operator\">=</span> specSize<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">case</span> MeasureSpec<span class=\"token punctuation\">.</span>UNSPECIFIED<span class=\"token operator\">:</span>\n        <span class=\"token keyword\">default</span><span class=\"token operator\">:</span>\n            result <span class=\"token operator\">=</span> size<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> result <span class=\"token operator\">|</span> <span class=\"token punctuation\">(</span>childMeasureState <span class=\"token operator\">*</span> MEASURED_STATE_MASK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>完全自定义 view onMeasure 方法：</p>\n<ol>\n<li>先算自己想要的宽高</li>\n<li>直接拿 <code>resolveSize</code> 方法处理一下</li>\n<li>最后 <code>setMeasuredDimension</code> 保存</li>\n</ol>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">LoadingView</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">View</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 圆的半径</span>\n    <span class=\"token keyword\">int</span> radius<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 外部矩形的起点</span>\n    <span class=\"token keyword\">int</span> left <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> top <span class=\"token operator\">=</span> <span class=\"token number\">30</span><span class=\"token punctuation\">;</span>\n\n    Paint mPaint <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Paint</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">LoadingView</span><span class=\"token punctuation\">(</span>Context context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">LoadingView</span><span class=\"token punctuation\">(</span>Context context<span class=\"token punctuation\">,</span> AttributeSet attrs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> attrs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        TypedArray typedArray <span class=\"token operator\">=</span> context<span class=\"token punctuation\">.</span><span class=\"token function\">obtainStyledAttributes</span><span class=\"token punctuation\">(</span>attrs<span class=\"token punctuation\">,</span> R<span class=\"token punctuation\">.</span>styleable<span class=\"token punctuation\">.</span>LoadingView<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        radius <span class=\"token operator\">=</span> typedArray<span class=\"token punctuation\">.</span><span class=\"token function\">getInt</span><span class=\"token punctuation\">(</span>R<span class=\"token punctuation\">.</span>styleable<span class=\"token punctuation\">.</span>LoadingView_radius<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onMeasure</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> widthMeasureSpec<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> heightMeasureSpec<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">onMeasure</span><span class=\"token punctuation\">(</span>widthMeasureSpec<span class=\"token punctuation\">,</span> heightMeasureSpec<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">int</span> width <span class=\"token operator\">=</span> left <span class=\"token operator\">+</span> radius <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> height <span class=\"token operator\">=</span> top <span class=\"token operator\">+</span> radius <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 一定要用 resolveSize 方法来格式化 View 的宽高，否则遇到某些 layout 的时候一定会出现器官的 bug</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 不用这个，就完全没有父 View 的感受</span>\n        width <span class=\"token operator\">=</span> <span class=\"token function\">resolveSize</span><span class=\"token punctuation\">(</span>width<span class=\"token punctuation\">,</span> widthMeasureSpec<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        height <span class=\"token operator\">=</span> <span class=\"token function\">resolveSize</span><span class=\"token punctuation\">(</span>height<span class=\"token punctuation\">,</span> heightMeasureSpec<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">setMeasuredDimension</span><span class=\"token punctuation\">(</span>width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onDraw</span><span class=\"token punctuation\">(</span>Canvas canvas<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">onDraw</span><span class=\"token punctuation\">(</span>canvas<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 画矩形</span>\n        RectF oval <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Rectf</span><span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">,</span> top <span class=\"token punctuation\">,</span>left <span class=\"token operator\">+</span> radius <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> top <span class=\"token operator\">+</span> radius <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        mPaint<span class=\"token punctuation\">.</span><span class=\"token function\">setColor</span><span class=\"token punctuation\">(</span>Color<span class=\"token punctuation\">.</span>BLUE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        canvas<span class=\"token punctuation\">.</span><span class=\"token function\">drawRect</span><span class=\"token punctuation\">(</span>oval<span class=\"token punctuation\">,</span> mPaint<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 画圆弧</span>\n        mPaint<span class=\"token punctuation\">.</span><span class=\"token function\">setColor</span><span class=\"token punctuation\">(</span>Color<span class=\"token punctuation\">.</span>RED<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        mPaint<span class=\"token punctuation\">.</span><span class=\"token function\">setStyle</span><span class=\"token punctuation\">(</span>Paint<span class=\"token punctuation\">.</span>Style<span class=\"token punctuation\">.</span>STROKE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        mPaint<span class=\"token punctuation\">.</span><span class=\"token function\">setStrokeWidth</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        canvas<span class=\"token punctuation\">.</span><span class=\"token function\">drawArc</span><span class=\"token punctuation\">(</span>oval<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">90</span><span class=\"token punctuation\">,</span> <span class=\"token number\">360</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> mPaint<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"自定义-ViewGroup\"><a href=\"#自定义-ViewGroup\" class=\"headerlink\" title=\"自定义 ViewGroup\"></a>自定义 ViewGroup</h2><p>注意以下几点：</p>\n<ol>\n<li>一定要先重写 onMeasure 确定子 View 的宽高和自己的宽高以后，才可以继续写 onLayout 对这些子 View 进行布局</li>\n<li>ViewGroup 的 onMeasure 其实就是遍历自己的 view ，对自己的每一个子 View 进行 measure，据大多数的时候对子 View 的measure 都可以直接调用  measureChild() 这个方法</li>\n<li>计算出 View Group 自己的尺寸并保存，<code>onMeasuredDinmension</code></li>\n<li>逼不得已需要重写<code>measureChild</code> 的时候，无非就是对父 view 的测量和子 View 的测量，做一个取舍关系而已，可参照 <code>measureChild</code> 方法。</li>\n</ol>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/**\n * 从左到右布局，如果不够放，就直接另起一行layout\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SimpleFlowLayout</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">ViewGroup</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">SimpleFlowLayout</span><span class=\"token punctuation\">(</span>Context context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">SimpleFlowLayout</span><span class=\"token punctuation\">(</span>Context context<span class=\"token punctuation\">,</span> AttributeSet attrs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> attrs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     *    layout 算法，就是不够放，就另外放一行\n     * \n     *  无非就是前面 onMeasure 结束以后，你可以拿到所有子 View和自己的测量宽高，\n     */</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onLayout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span> changed<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> l<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> t<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> r<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> childTop <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> childLeft <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> childRight <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> childBottom <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 已使用的 width</span>\n        <span class=\"token keyword\">int</span> usedWidth <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// customlayout 自己可使用的宽度</span>\n        <span class=\"token keyword\">int</span> layoutWidth <span class=\"token operator\">=</span> <span class=\"token function\">getMeasuredWidth</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token function\">getChildCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            View childView <span class=\"token operator\">=</span> <span class=\"token function\">getChildAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 取得这个子 View 要求的宽度和高度</span>\n            <span class=\"token keyword\">int</span> childWidth <span class=\"token operator\">=</span> childView<span class=\"token punctuation\">.</span><span class=\"token function\">getMeasuredWidth</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> childHeight <span class=\"token operator\">=</span> childView<span class=\"token punctuation\">.</span><span class=\"token function\">getMeasuredHeight</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 如果宽度不够，就另外启动一行</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>layoutWidth <span class=\"token operator\">-</span> usedWidth <span class=\"token operator\">&lt;</span> childWidth<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                childLeft <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n                usedWidth <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n                childTop <span class=\"token operator\">+=</span> childHeight<span class=\"token punctuation\">;</span>\n                childBottom <span class=\"token operator\">=</span> childTop <span class=\"token operator\">+</span> childHeight<span class=\"token punctuation\">;</span>\n                childView<span class=\"token punctuation\">.</span><span class=\"token function\">layout</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> childTop<span class=\"token punctuation\">,</span> childRight<span class=\"token punctuation\">,</span> childBottom<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                usedWidth <span class=\"token operator\">=</span> usedWidth <span class=\"token operator\">+</span> childWidth<span class=\"token punctuation\">;</span>\n                childLeft <span class=\"token operator\">=</span> childWidth<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            childRight <span class=\"token operator\">=</span> childLeft <span class=\"token operator\">+</span> childWidth<span class=\"token punctuation\">;</span>\n            childBottom <span class=\"token operator\">=</span> childTop <span class=\"token operator\">+</span> childHeight<span class=\"token punctuation\">;</span>\n            childView<span class=\"token punctuation\">.</span><span class=\"token function\">layout</span><span class=\"token punctuation\">(</span>childLeft<span class=\"token punctuation\">,</span> childTop<span class=\"token punctuation\">,</span> childRight<span class=\"token punctuation\">,</span> childBottom<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            childLeft <span class=\"token operator\">+=</span> childWidth<span class=\"token punctuation\">;</span>\n            usedWidth <span class=\"token operator\">+=</span> childWidth<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onMeasure</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> widthMeasureSpec<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> heightMeasureSpec<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 先取出 SimpleFlowLayout 的父 View 对他的测量限制</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 只有知道了自己的宽高，才能限制子 View 的宽高</span>\n        <span class=\"token keyword\">int</span> widthMode <span class=\"token operator\">=</span> MeasureSpec<span class=\"token punctuation\">.</span><span class=\"token function\">getMode</span><span class=\"token punctuation\">(</span>widthMeasureSpec<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> heightMode <span class=\"token operator\">=</span> MeasureSpec<span class=\"token punctuation\">.</span><span class=\"token function\">getMode</span><span class=\"token punctuation\">(</span>heightMeasureSpec<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">int</span> widthSize <span class=\"token operator\">=</span> MeasureSpec<span class=\"token punctuation\">.</span><span class=\"token function\">getSize</span><span class=\"token punctuation\">(</span>widthMeasureSpec<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> heightSize <span class=\"token operator\">=</span> MeasureSpec<span class=\"token punctuation\">.</span><span class=\"token function\">getSize</span><span class=\"token punctuation\">(</span>heightMeasureSpec<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">int</span> usedWidth <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 已使用宽度</span>\n        <span class=\"token keyword\">int</span> remaining <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">// 剩余可用宽度</span>\n        <span class=\"token keyword\">int</span> totalHeight <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 总高度</span>\n        <span class=\"token keyword\">int</span> lineHeight <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 当前行高</span>\n\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span> <span class=\"token function\">getChildCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            View childView <span class=\"token operator\">=</span> <span class=\"token function\">getChildAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            LayoutParams lp <span class=\"token operator\">=</span> childView<span class=\"token punctuation\">.</span><span class=\"token function\">getLayoutParams</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 先测量子View</span>\n            <span class=\"token function\">measureChild</span><span class=\"token punctuation\">(</span>childView<span class=\"token punctuation\">,</span> widthMeasureSpec<span class=\"token punctuation\">,</span> heightMeasureSpec<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 然后计算以下宽度里面，还有多少是可用的，也就是剩余可用宽度</span>\n            remaining <span class=\"token operator\">=</span> widthSize <span class=\"token operator\">-</span> usedWidth<span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 如果一行不够放，也就是说这个子 View 测量的宽度，大于这一行剩下的宽度时，我们要另外启动一行</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>childView<span class=\"token punctuation\">.</span>getMeasuredWidth <span class=\"token operator\">></span> remaining<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 另外启动一行</span>\n                usedWidth <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n                totalHeight <span class=\"token operator\">+=</span> lineHeight<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 已使用 width 进行累加</span>\n            usedWidth <span class=\"token operator\">+=</span> childView<span class=\"token punctuation\">.</span><span class=\"token function\">getMeasuredWidth</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 当前 view 的高度</span>\n            lineHeight <span class=\"token operator\">=</span> childView<span class=\"token punctuation\">.</span><span class=\"token function\">getMeasuredHeight</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 如果 SimpleFlowLayout 的高度为 wrap_content  的时候，采用我们叠加的高度，否则我们当然用父对其的限制高度</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>heightMode <span class=\"token operator\">==</span> MeasureSpec<span class=\"token punctuation\">.</span>AT_MOST<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            heightSize <span class=\"token operator\">=</span> totalHeight<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token function\">setMeasuredDimension</span><span class=\"token punctuation\">(</span>widthSize<span class=\"token punctuation\">,</span> heightSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n","site":{"data":{}},"excerpt":"<h2 id=\"View-Group-的测量布局流程\"><a href=\"#View-Group-的测量布局流程\" class=\"headerlink\" title=\"View Group 的测量布局流程\"></a>View Group 的测量布局流程</h2><p><strong>View Group绘制和布局流程中的重点</strong><br>","more":"</p>\n<ol>\n<li><p>View 在 <code>onMeasure</code> 方法中进行自我测量和保存。</p>\n</li>\n<li><p>ViewGroup 循环遍历调用所有子 view 的 onMeasure 方法，利用 onMeasure 方法计算出来的大小，来确定这些 子 View 最终可以占用的大小和所处布局的位置</p>\n</li>\n<li><p>关注 onMeasure 和 onLayout</p>\n</li>\n<li><p>父 View 调用子 View 的layout 方法的时候，会把之前 measure 阶段确定的位置和大小都传递给子 View</p>\n</li>\n<li><p>自定义 View/ViewGroup，只需要关注下面三种需求：</p>\n<ol>\n<li>对于已有的 Android 自带 View，我们只需要重写他的 <code>onMeasure</code> 方法即可,<strong>修改一下这个尺寸就完成需求</strong></li>\n<li>对于 Android 系统没有的，属于我们自定义的 View，需要完全重写 <code>onMeasure</code></li>\n<li>需要重写 <code>onMeasure</code> 和 <code>onLayout</code> 2个方法，来完成一个复杂的 <code>ViewGroup</code> 的测量和布局。</li>\n</ol>\n</li>\n<li><p>onMeasure 的说明</p>\n<p>widthMeasureSpec, heightMeasureSpec  两个参数主要是 父 view 对子view 的尺寸限制</p>\n</li>\n<li><p>理解父 view 对子 view 的限制</p>\n<p>实际上，父 View 对子 View 的限制据大多数就来自于我们开发者所设置的 layout 开头的这些属性。<strong>这些以 layout 开头的属性，都是设置给父 view 看的</strong></p>\n<blockquote>\n<p>父 View 要知道这些属性以后，才知道要对子view 的测量加以什么限制</p>\n</blockquote>\n</li>\n</ol>\n<!-- more -->\n<h2 id=\"自定义-BannerView\"><a href=\"#自定义-BannerView\" class=\"headerlink\" title=\"自定义 BannerView\"></a>自定义 BannerView</h2><pre><code class=\"java\">public class BannerImageView extends ImageView{\n    // 宽高比\n    float ratio;\n    public BannerImageView(Context context) {\n        super(context);\n    }\n\n    public BannerImageView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.BannerImageView);\n        ratio = array.getFloat(R.styleable.BannerImageView_ratio, 1.0f);\n        array.recycle();\n    }\n\n    @Override\n    public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        // 自己的测量走一遍，因为这个方法内部会调用 setMEasureDimension() 来保存测量结果\n        // 只有保存了以后，才能取得这个测量结果，否则获取不到\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n\n        // 获取测量结果\n        int tempWidth = getMeasureWidth();\n        int tempHeight = (int) (tempWidth * ratio);\n        // 保存以后，父 view 可以拿到这个测量的宽高了。不保存是拿不到的\n        setMeasureDimension(tempWidth, tempHeight);\n    }\n}\n</code></pre>\n<h2 id=\"自定义-View-，完全自己写-onMeasure-方法\"><a href=\"#自定义-View-，完全自己写-onMeasure-方法\" class=\"headerlink\" title=\"自定义 View ，完全自己写 onMeasure 方法\"></a>自定义 View ，完全自己写 onMeasure 方法</h2><p>对于完全自定义  View ，完全自己写的 onMeasure 方法，保存的宽高必须符合父 View 的限制，否则会发生 bug，保存父 View 对子 View 的限制的方法就是直接调用 <code>resolveSize</code> 方法即可。</p>\n<pre><code class=\"java\">public static int resolveSizeAndState(int size, int measureSpec, int childMeasureState) {\n    final int specMode = MeasureSpec.getMode(measureSpec);\n    final int specSize = MeasureSpec.getSize(measureSpec);\n    final int result;\n    switch(specMode) {\n        case MeasureSpce.AT_MOST:\n            if(specSize &lt; size) {\n                result = specSize | MEASURED_STATE_TOO_SMALL;\n            } else {\n                result = size;\n            }\n            break;\n        case MeasureSpec.EXACTLY:\n            result = specSize;\n            break;\n        case MeasureSpec.UNSPECIFIED:\n        default:\n            result = size;\n    }\n    return result | (childMeasureState * MEASURED_STATE_MASK);\n}\n</code></pre>\n<p>完全自定义 view onMeasure 方法：</p>\n<ol>\n<li>先算自己想要的宽高</li>\n<li>直接拿 <code>resolveSize</code> 方法处理一下</li>\n<li>最后 <code>setMeasuredDimension</code> 保存</li>\n</ol>\n<pre><code class=\"java\">public class LoadingView extends View {\n    // 圆的半径\n    int radius;\n    // 外部矩形的起点\n    int left = 10, top = 30;\n\n    Paint mPaint = new Paint();\n    public LoadingView(Context context) {\n        super(context);\n    }\n\n    public LoadingView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.LoadingView);\n        radius = typedArray.getInt(R.styleable.LoadingView_radius, 0);\n    }\n\n    @Override\n    public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n\n        int width = left + radius * 2;\n        int height = top + radius * 2;\n\n        // 一定要用 resolveSize 方法来格式化 View 的宽高，否则遇到某些 layout 的时候一定会出现器官的 bug\n        // 不用这个，就完全没有父 View 的感受\n        width = resolveSize(width, widthMeasureSpec);\n        height = resolveSize(height, heightMeasureSpec);\n        setMeasuredDimension(width, height);\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n\n        // 画矩形\n        RectF oval = new Rectf(left, top ,left + radius * 2, top + radius * 2);\n        mPaint.setColor(Color.BLUE);\n        canvas.drawRect(oval, mPaint);\n        // 画圆弧\n        mPaint.setColor(Color.RED);\n        mPaint.setStyle(Paint.Style.STROKE);\n        mPaint.setStrokeWidth(2);\n        canvas.drawArc(oval, -90, 360, false, mPaint);\n    }\n}\n</code></pre>\n<h2 id=\"自定义-ViewGroup\"><a href=\"#自定义-ViewGroup\" class=\"headerlink\" title=\"自定义 ViewGroup\"></a>自定义 ViewGroup</h2><p>注意以下几点：</p>\n<ol>\n<li>一定要先重写 onMeasure 确定子 View 的宽高和自己的宽高以后，才可以继续写 onLayout 对这些子 View 进行布局</li>\n<li>ViewGroup 的 onMeasure 其实就是遍历自己的 view ，对自己的每一个子 View 进行 measure，据大多数的时候对子 View 的measure 都可以直接调用  measureChild() 这个方法</li>\n<li>计算出 View Group 自己的尺寸并保存，<code>onMeasuredDinmension</code></li>\n<li>逼不得已需要重写<code>measureChild</code> 的时候，无非就是对父 view 的测量和子 View 的测量，做一个取舍关系而已，可参照 <code>measureChild</code> 方法。</li>\n</ol>\n<pre><code class=\"java\">/**\n * 从左到右布局，如果不够放，就直接另起一行layout\n */\npublic class SimpleFlowLayout extends ViewGroup {\n    public SimpleFlowLayout(Context context) {\n        super(context);\n    }\n\n    public SimpleFlowLayout(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n\n    /**\n     *    layout 算法，就是不够放，就另外放一行\n     * \n     *  无非就是前面 onMeasure 结束以后，你可以拿到所有子 View和自己的测量宽高，\n     */\n    @Override\n    public void onLayout(boolean changed, int l, int t, int r, int b) {\n        int childTop = 0;\n        int childLeft = 0;\n        int childRight = 0;\n        int childBottom = 0;\n\n        // 已使用的 width\n        int usedWidth = 0;\n        // customlayout 自己可使用的宽度\n        int layoutWidth = getMeasuredWidth();\n\n        for(int i = 0; i &lt; getChildCount(); i++) {\n            View childView = getChildAt(i);\n            // 取得这个子 View 要求的宽度和高度\n            int childWidth = childView.getMeasuredWidth();\n            int childHeight = childView.getMeasuredHeight();\n\n            // 如果宽度不够，就另外启动一行\n            if(layoutWidth - usedWidth &lt; childWidth) {\n                childLeft = 0;\n                usedWidth = 0;\n                childTop += childHeight;\n                childBottom = childTop + childHeight;\n                childView.layout(0, childTop, childRight, childBottom);\n                usedWidth = usedWidth + childWidth;\n                childLeft = childWidth;\n                continue;\n            }\n            childRight = childLeft + childWidth;\n            childBottom = childTop + childHeight;\n            childView.layout(childLeft, childTop, childRight, childBottom);\n            childLeft += childWidth;\n            usedWidth += childWidth;\n        }\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        // 先取出 SimpleFlowLayout 的父 View 对他的测量限制\n        // 只有知道了自己的宽高，才能限制子 View 的宽高\n        int widthMode = MeasureSpec.getMode(widthMeasureSpec);\n        int heightMode = MeasureSpec.getMode(heightMeasureSpec);\n\n        int widthSize = MeasureSpec.getSize(widthMeasureSpec);\n        int heightSize = MeasureSpec.getSize(heightMeasureSpec);\n\n        int usedWidth = 0; // 已使用宽度\n        int remaining = 0;    // 剩余可用宽度\n        int totalHeight = 0; // 总高度\n        int lineHeight = 0; // 当前行高\n\n        for(int i = 0; i&lt; getChildCount(); i++) {\n            View childView = getChildAt(i);\n            LayoutParams lp = childView.getLayoutParams();\n\n            // 先测量子View\n            measureChild(childView, widthMeasureSpec, heightMeasureSpec);\n            // 然后计算以下宽度里面，还有多少是可用的，也就是剩余可用宽度\n            remaining = widthSize - usedWidth;\n\n            // 如果一行不够放，也就是说这个子 View 测量的宽度，大于这一行剩下的宽度时，我们要另外启动一行\n            if(childView.getMeasuredWidth &gt; remaining) {\n                // 另外启动一行\n                usedWidth = 0;\n                totalHeight += lineHeight;\n            }\n\n            // 已使用 width 进行累加\n            usedWidth += childView.getMeasuredWidth();\n            // 当前 view 的高度\n            lineHeight = childView.getMeasuredHeight();\n\n    }\n        // 如果 SimpleFlowLayout 的高度为 wrap_content  的时候，采用我们叠加的高度，否则我们当然用父对其的限制高度\n        if(heightMode == MeasureSpec.AT_MOST) {\n            heightSize = totalHeight;\n        }\n\n        setMeasuredDimension(widthSize, heightSize);\n    }\n}\n</code></pre>"},{"title":"Handler 消息机制","_content":"\n\n\nHandler 消息机制，在整个 Android 系统中，有着很重要的地位。\n\n他可以帮助我们实现，子线程和主线程的跨线程通信；可以帮助我们发送一些延时任务，帮助我们很好的实现一个 App.\n\n本文旨在对源码进行预览分析。\n\n## UML 类图\n\n先来一张结构图，让我们清晰的了解一下，我们下面都会分析到哪些内容；也了解一下 `Handler` 机制的核心秘密。\n\n![Handler 类图](https://github.com/xiaomanwong/static_file/blob/master/images/Handler%20%E6%9C%BA%E5%88%B6.png?raw=true)\n\n<!-- more -->\n\n#### **类图分析**\n\n从上面的类图我们可以看出，整个 Handler 消息机制，所涉及到的核心内容，只有 3 个类\n\n**Message：** 消息，这个是我们要执行任务的载体，当我们需要 Handler 帮我做事的时候，就会向 Handler 发送一个 Message。\n\n**Handler:**     这个是对我们比较直观的一个类，通常都会在代码中创建一个新的 Handler 来使用\n\n**Looper:** \t  这个类，如果不点进去，我们也是看不到这，它也是整个 Handler 消息通信机制的*大心脏*\n\n## ActivityThread\n\n看过源码后我们能知道，一个 App 的启动流程的入口就在 ActivityThread 的 `main()` 方法中。\n\n在这里系统帮我做了系统进程的 fork 工作，为我们的 app 开辟了一块空间。并帮我们初始化了  `application` 和 `activity` 的工作,接下来我们看一下源码：\n\n```java\npublic static void main(String[] args) {\n    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"ActivityThreadMain\");\n\n    // Install selective syscall interception\n    AndroidOs.install();\n\n    // CloseGuard defaults to true and can be quite spammy.  We\n    // disable it here, but selectively enable it later (via\n    // StrictMode) on debug builds, but using DropBox, not logs.\n    CloseGuard.setEnabled(false);\n\n    Environment.initForCurrentUser();\n\n    // Make sure TrustedCertificateStore looks in the right place for CA certificates\n    final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());\n    TrustedCertificateStore.setDefaultUserDirectory(configDir);\n\n    Process.setArgV0(\"<pre-initialized>\");\n\n    Looper.prepareMainLooper();\n\n    // Find the value for {@link #PROC_START_SEQ_IDENT} if provided on the command line.\n    // It will be in the format \"seq=114\"\n    long startSeq = 0;\n    if (args != null) {\n        for (int i = args.length - 1; i >= 0; --i) {\n            if (args[i] != null && args[i].startsWith(PROC_START_SEQ_IDENT)) {\n                startSeq = Long.parseLong(\n                    args[i].substring(PROC_START_SEQ_IDENT.length()));\n            }\n        }\n    }\n    ActivityThread thread = new ActivityThread();\n    thread.attach(false, startSeq);\n\n    if (sMainThreadHandler == null) {\n        sMainThreadHandler = thread.getHandler();\n    }\n\n    if (false) {\n        Looper.myLooper().setMessageLogging(new\n                                            LogPrinter(Log.DEBUG, \"ActivityThread\"));\n    }\n\n    // End of event ActivityThreadMain.\n    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n    Looper.loop();\n\n    throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n}\n```\n\n通过上面的代码，我主要分析 `Looper.prepareMainLooper()` 和 `Looper.loop()`\n\n## Looper\n\n### Looper.prepare()\n\n这里的标题虽然不是 `prepareMainLooper()`  的一个主要原因是他们的核心内容是一样的，只不过，`prepareMainLooper()` 是系统帮我们创建了要给不可退出的`Looper`，而 `prepare()` 方法创建的 `Looper` 是可以退出的。\n\n```java\n/**\n     * Initialize the current thread as a looper, marking it as an\n     * application's main looper. The main looper for your application\n     * is created by the Android environment, so you should never need\n     * to call this function yourself.  See also: {@link #prepare()}\n     */\npublic static void prepareMainLooper() {\n    prepare(false);\n    synchronized (Looper.class) {\n        if (sMainLooper != null) {\n            throw new IllegalStateException(\"The main Looper has already been prepared.\");\n        }\n        sMainLooper = myLooper();\n    }\n}\n/** Initialize the current thread as a looper.\n      * This gives you a chance to create handlers that then reference\n      * this looper, before actually starting the loop. Be sure to call\n      * {@link #loop()} after calling this method, and end it by calling\n      * {@link #quit()}.\n      */\npublic static void prepare() {\n    prepare(true);\n}\n\nprivate static void prepare(boolean quitAllowed) {\n    if (sThreadLocal.get() != null) {\n        throw new RuntimeException(\"Only one Looper may be created per thread\");\n    }\n    sThreadLocal.set(new Looper(quitAllowed));\n}\n```\n\n### ThreadLocal\n\n说到 `Looper` 的创建工作，这里就需要讲一下 `ThreadLocal` ， 它的意思是**帮助我们在自己线程中保存一份它自己的本地变量**\n\n```java\n@UnsupportedAppUsage\nstatic final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();\n```\n\n也就是说，在 Looper 创建的过程中，我们将 Looper 对象，保存到当前线程中，并做到每个线程中只有一个 Looper 对象，起到线程之间隔离作用。\n\n面试中经常会问到一个线程有且只有一个 Looper 的问题，原因也在这里。系统通过 ThreadLocal 帮我们限制了。\n\n### loop()\n\n继续看源码，` Looper.loop();` 的出现，标志了系统开启了一个循环开始处理消息，跑到这里，基本上我们的 app 已经可以正常运行\n\n这部分的源码比较长，捡主要的看和说：\n\n```java\n/**\n     * Run the message queue in this thread. Be sure to call\n     * {@link #quit()} to end the loop.\n     */\npublic static void loop() {\n    final Looper me = myLooper();\n    if (me == null) {\n        throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n    }\n    //..............\n    final MessageQueue queue = me.mQueue;\n    for (;;) {\n        Message msg = queue.next(); // might block\n        if (msg == null) {\n            // No message indicates that the message queue is quitting.\n            return;\n        }\n        //..............\n        try {\n            msg.target.dispatchMessage(msg);\n        } catch (Exception exception) {\n            throw exception;\n        } finally {\n          \n        }\n        // ...............\n        msg.recycleUnchecked();\n    }\n}\n```\n\nActivityThread 中的 `main()` 方法，在最后一行，执行了我们的 `Looper.loop()` 方法， 进入后，我们可以看到 `loop()` 方法内部是一个死循环，当然，这里我们需要回顾一下 ActivityThread 帮我们初始化的 `prepareMainLooper()`  ，这也是系统帮我们创建的一个主线程`main` 。\n\n接下来就慢慢分析一下 `loop` 都做了什么事情\n\n![looper.loop()](https://github.com/xiaomanwong/static_file/blob/master/images/loop%20for.png?raw=true?raw=true)\n\n从流程图上，我们简述了一下 `loop()` 方法，都做了些什么事情，下面就展开讲都做了什么\n\n1. 首先获取当前线程的 looper 对象，如果不存在，则抛出异常\n2. 接着获取当前 Looper 绑定的消息队列` MessageQueue`\n3. 进入循环，开始获取消息 `queue.next()`\n4. 调用 `msg.target.dispathMessage(msg)` 分发消息\n5. msg.recycleUnchecked()\n\n## Handler\n\n**作用：**\n\n`Handler` 暴露给开发这的功能一共就两块\n\n* 发送消息\n* 处理消息\n\n### 发送消息\n\n* sendMessage(Message msg)\n* sendMessageEmpty()\n* sendMessageAtTime(Message msg, long uptimeMillis)\n* sendMessageDelay(Message msg, long delay)\n* post(Runnable r)\n* ...\n\n所有的发送消息的方法，最终都会去执行`sendMessageAtTime(Message msg, long uptimeMillis)`, 当我们创建一个`Handler` 对象时, 会从当前线程的 Looper 中获取当前的消息队列`mQueue`\n\n```java\npublic Handler(@Nullable Callback callback, boolean async) {\n        if (FIND_POTENTIAL_LEAKS) {\n            final Class<? extends Handler> klass = getClass();\n            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&\n                    (klass.getModifiers() & Modifier.STATIC) == 0) {\n                Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" +\n                    klass.getCanonicalName());\n            }\n        }\n\n        mLooper = Looper.myLooper();\n        if (mLooper == null) {\n            throw new RuntimeException(\n                \"Can't create handler inside thread \" + Thread.currentThread()\n                        + \" that has not called Looper.prepare()\");\n        }\n        mQueue = mLooper.mQueue;\n        mCallback = callback;\n        mAsynchronous = async;\n    }\n```\n\n当我们开始发送一条消息时，调用 `sendMessageAtTime` ，会将消息压入到消息队列中，\n\n```java\nfinal MessageQueue mQueue;\n\npublic boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) {\n        MessageQueue queue = mQueue;\n        if (queue == null) {\n            RuntimeException e = new RuntimeException(\n                    this + \" sendMessageAtTime() called with no mQueue\");\n            Log.w(\"Looper\", e.getMessage(), e);\n            return false;\n        }\n        return enqueueMessage(queue, msg, uptimeMillis);\n    }\n\nprivate boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,\n            long uptimeMillis) {\n        msg.target = this;\n        msg.workSourceUid = ThreadLocalWorkSource.getUid();\n\n        if (mAsynchronous) {\n            msg.setAsynchronous(true);\n        }\n        return queue.enqueueMessage(msg, uptimeMillis);\n    }\n```\n\n通过源码我们看到，在压入队列前，我们会将当前的 `Handler` 对象赋值给 `Message` 中的 `target` ，这也就是为什么 `message` 中会持有 `Handler` 的引用的原因。\n\n### 处理消息\n\n在说处理消息之前，我们先看一下 `Handler` 对**消息的分发**\n\n```Java\n /**\n     * Handle system messages here.\n     */\n    public void dispatchMessage(@NonNull Message msg) {\n        if (msg.callback != null) {\n            handleCallback(msg);\n        } else {\n            if (mCallback != null) {\n                if (mCallback.handleMessage(msg)) {\n                    return;\n                }\n            }\n            handleMessage(msg);\n        }\n    }\n```\n\n* 当我们给 `Message` 设置了 `callback` 时，会直接触发 `Message` 的 `callback` 逻辑\n* 如果我们在创建 `Handler` 时，有设置过 `Callback` ，则会调用由我们传入进来的 `Callback` 方法\n* 如果以上两种情况都没有设置，那么会触发 `Handler` 自己 `handleMessage()` 方法\n\n```java\n/**\n     * Subclasses must implement this to receive messages.\n     */\n    public void handleMessage(@NonNull Message msg) {\n    }\n```\n\n通过源码的注解我们可以看出，当我们继承/创建一个 `Handler` 时，需要我们必须去实现的一个方法（前提是你需要它）\n\n`dispatchMessage` 最终时由 `loop()` 方法在拿取消息队列中的信息时，获取到 `Message` 对象， 通过 `Message` 持有的 `target` 调用。\n\n### 移除消息\n\n这里我们需要注意，当我们使用 `Handler` 处理消息时，通常都是一些异步任务，这时创建 `Handler` 一般都为内部类，此时需要注意的是，在 Java 中，内部类是会持有外部类的引用， 那么在 Handler 中处理的消息如果长时间无法得到释放， 那么会造成 `Activity` 无法被回收的情况。处理这种情况的方案就是，在 `Activity` 销毁时，我们需要将 `Handler` 中的消息进行释放\n\n```java\n    public final void removeCallbacksAndMessages(@Nullable Object token) {\n        mQueue.removeCallbacksAndMessages(this, token);\n    }\n```\n\n\n\n## Message\n\n一种消息的载体，其中包含 `handler` 对象和一个任意类型的对象以及两个 int 型的参数\n\n```java\npublic final class Message implements Parcelable {\n    /**\n     * 用户自定义的消息身份代码，每一个 Handler 都有它自己的命名空间，因此我们不需要担心会和其他的 Handler 混淆 \n     */\n    public int what;\n\n    /**\n     * arg1 and arg2 是一个低成本的替代方案，当我们只需要发送一些 int 型的数据时，可以使用， 避免使用 Object 增加内存的开销\n     */\n    public int arg1;\n\n     /**\n     * arg1 and arg2 是一个低成本的替代方案，当我们只需要发送一些 int 型的数据时，可以使用， 避免使用 Object 增加内存的开销\n     */\n    public int arg2;\n    \n    /**\n     * 任意的消息类型载体，如果是序列化的数据，则一定不能为 null，其他的数据类型，可以使用 setData(Bundle bundle) \n     */\n    public Object obj;\n    /**\n     * 消息的执行时间\n     */\n    public long when;\n}\n```\n\n`Message` 本身是一个**链表** 的数据结构，这种数据结构，在`MessageQueue` 中获取消息时，可以有效的针对 `Handler` 发送进来的消息进行排序。\n\n```java\n    @UnsupportedAppUsage\n    /*package*/ Handler target;\n\n    @UnsupportedAppUsage\n    /*package*/ Runnable callback;\n\n    // sometimes we store linked lists of these things\n    @UnsupportedAppUsage\n    /*package*/ Message next;\n```\n\n`Message` 持有了一个 `Handler` 对象，因此即使我们在同一个线程里面创建了多个 `Handler` 的对象， 也不会出现消息错乱的现象。\n\n**Callback**\n\n同时 Message 也支持设置 `Callback` 方便开发者在处理消息时可以快速的查看处理方案，但这种方法其实个人认为在开发阶段不适合使用。这会导致消息处理到处飞，不利于代码的管理。\n\n#### 构造器\n\n```java\n \tprivate static Message sPool;\n    private static int sPoolSize = 0;\n\n    private static final int MAX_POOL_SIZE = 50;   \n\n\t/** Constructor (but the preferred way to get a Message is to call {@link #obtain() Message.obtain()}).\n    */\n    public Message() {\n    }\n\n\tpublic static Message obtain() {\n        synchronized (sPoolSync) {\n            if (sPool != null) {\n                Message m = sPool;\n                sPool = m.next;\n                m.next = null;\n                m.flags = 0; // clear in-use flag\n                sPoolSize--;\n                return m;\n            }\n        }\n        return new Message();\n    }\n```\n\n`Message` 为我们提供了一个空的构造器去创建一个对象，但这种方案系统却不建议我们使用，而是建议我们通过 `obtain()` 函数去获取。通过 `obtain()` 函数我们可以看出， `Message` 自身维护了一个对象池，池的最大值为 50。因此我们不难看出，当我们通过空构造器去创建一个 `Message` 对象时，反而是增加了系统的内存开销，而 `Message` 为我们提供的利器得不到发挥。\n\n#### 回收\n\n```java\n    public void recycle() {\n        if (isInUse()) {\n            if (gCheckRecycle) {\n                throw new IllegalStateException(\"This message cannot be recycled because it \"\n                        + \"is still in use.\");\n            }\n            return;\n        }\n        recycleUnchecked();\n    }\n```\n\n当一个消息处于不在被使用（Handler 触发 remove 时），或已经使用完成（MessageQueue 触发），那么系统会清空 `Message` 中的全部内容，并将对象丢向消息池中，等待再次被使用( obtain())，当消息被回收时，我们不能在去调用它，否则会出现空指针的情况。\n\n## MessageQueue\n\n存放所有消息的容器，既然是 `Queue` 命名，那自然就是一个队列，拥有先入先出的特性，但消息的存放，并不是由其自己操作，而是通过与 `Looper` 关联的 `Handler` 添加\n\n### 入队\n\n由 `Handler` 触发，将数据压入到队列中\n\n```java\nboolean enqueueMessage(Message msg, long when) {\n    \n\n        synchronized (this) {\n            msg.markInUse();\n            msg.when = when;\n            Message p = mMessages;\n            boolean needWake;\n            if (p == null || when == 0 || when < p.when) {\n                // New head, wake up the event queue if blocked.\n                msg.next = p;\n                mMessages = msg;\n                needWake = mBlocked;\n            } else {\n                // Inserted within the middle of the queue.  Usually we don't have to wake\n                // up the event queue unless there is a barrier at the head of the queue\n                // and the message is the earliest asynchronous message in the queue.\n                needWake = mBlocked && p.target == null && msg.isAsynchronous();\n                Message prev;\n                for (;;) {\n                    prev = p;\n                    p = p.next;\n                    if (p == null || when < p.when) {\n                        break;\n                    }\n                    if (needWake && p.isAsynchronous()) {\n                        needWake = false;\n                    }\n                }\n                msg.next = p; // invariant: p == prev.next\n                prev.next = msg;\n            }\n\n            // We can assume mPtr != 0 because mQuitting is false.\n            if (needWake) {\n                nativeWake(mPtr);\n            }\n        }\n        return true;\n    }\n```\n\n通过源码看出，在消息压入队列中时，发生了排序操作，\n\n当一条消息进来时，判断了如果当前队列内没有消息，或者传入的消息延时执行时间为0，或者传入的消息执行时间小于队列的第一条消息时，将 `Message` 放置在链表头部位置。否则则循环取出每条消息，依据消息的执行时间进行排序，将新消息压入到适当的位置。\n\n### 出队\n\n```java\nMessage next() {\n   \n    for (;;) {\n        if (nextPollTimeoutMillis != 0) {\n            Binder.flushPendingCommands();\n        }\n\n        nativePollOnce(ptr, nextPollTimeoutMillis);\n\n        synchronized (this) {\n            // Try to retrieve the next message.  Return if found.\n            final long now = SystemClock.uptimeMillis();\n            Message prevMsg = null;\n            Message msg = mMessages;\n            // 开启同步屏障，直到找到下一个异步消息结束，目的是优先执行异步消息\n            if (msg != null && msg.target == null) {\n                // Stalled by a barrier.  Find the next asynchronous message in the queue.\n                do {\n                    prevMsg = msg;\n                    msg = msg.next;\n                } while (msg != null && !msg.isAsynchronous());\n            }\n            if (msg != null) {\n                if (now < msg.when) {\n                    // 为到执行时间，设置下一次系统唤醒消息需要的时间\n                    // Next message is not ready.  Set a timeout to wake up when it is ready.\n                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                } else {\n                    // Got a message.\n                    mBlocked = false;\n                    if (prevMsg != null) {\n                        // prevMsg ，即是同步消息，\n                        prevMsg.next = msg.next;\n                    } else {\n                        mMessages = msg.next;\n                    }\n                    msg.next = null;\n                    if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);\n                    msg.markInUse();\n                    return msg;\n                }\n            } else {\n                // No more messages.\n                nextPollTimeoutMillis = -1;\n            }\n        }\n    }\n}\n```\n\n#### 同步屏障\n\n一般是由系统发出，多数情况是用来处理`View` 的刷新，由`ViewRootImpl` 调用 `postSyncBarrier`，将消息插入到链表的头部，我们可以注意到 `msg` 的 `target` 对象为空，因为 每一个 `Message` 对象都持有一个 target 对象，因此这里很不合常理，但这里就是系统的黑魔法，专门用来处理同步消息，因为同步消息的优先级高于所有异步消息。\n\n```java\nprivate int postSyncBarrier(long when) {\n        // Enqueue a new sync barrier token.\n        // We don't need to wake the queue because the purpose of a barrier is to stall it.\n        synchronized (this) {\n            final int token = mNextBarrierToken++;\n            // 创建一个同步消息\n            final Message msg = Message.obtain();\n            msg.markInUse();\n            msg.when = when;\n            msg.arg1 = token;\n\n            Message prev = null;\n            Message p = mMessages;\n            if (when != 0) {\n                // 队列中的消息执行时间，排序，找到消息执行时间大于当前系统时间\n                while (p != null && p.when <= when) {\n                    prev = p;\n                    p = p.next;\n                }\n            }\n            if (prev != null) { // invariant: p == prev.next\n                // 断开链表，将同步消息，插入到要立即执行的消息后面\n                msg.next = p;\n                prev.next = msg;\n            } else {\n                // 没有要立即执行的消息，将同步消息插入到链表第一个节点\n                msg.next = p;\n                mMessages = msg;\n            }\n            return token;\n        }\n    }\n```\n\n\n\n当我们创建一个 Handler 时，默认创建的都是一个异步的（当然也可以创建同步的，调用对应的构造器就可以），因此在这里当收到一个同步消息时，`ViewRootImpl` 会，并给 msg 的 `target` 重新赋值，优先执行。直到找到一个异步消息为止\n\n当从队列中获取一条异步消息后，我们将消息取出来，并将消息的 next 置空断开链表，标记当前消息正在使用，并且返回。如果消息还没有到达执行的时间，则会通知系统去等待，设置下一次唤醒的时间。\n\n### 退出\n\n由 `loop` 调用，当一个 loop 被销毁时，会触发该方法，用来清空内部所有消息,并回收\n\n```java\nvoid quit(boolean safe) {\n        if (!mQuitAllowed) {\n            throw new IllegalStateException(\"Main thread not allowed to quit.\");\n        }\n\n        synchronized (this) {\n            if (mQuitting) {\n                return;\n            }\n            mQuitting = true;\n\n            if (safe) {\n                removeAllFutureMessagesLocked();\n            } else {\n                removeAllMessagesLocked();\n            }\n\n            // We can assume mPtr != 0 because mQuitting was previously false.\n            nativeWake(mPtr);\n        }\n    }\n```\n\n","source":"_posts/Android 基础/原理/Handler 消息机制.md","raw":"---\ntitle: Handler 消息机制\ntag: Android\n---\n\n\n\nHandler 消息机制，在整个 Android 系统中，有着很重要的地位。\n\n他可以帮助我们实现，子线程和主线程的跨线程通信；可以帮助我们发送一些延时任务，帮助我们很好的实现一个 App.\n\n本文旨在对源码进行预览分析。\n\n## UML 类图\n\n先来一张结构图，让我们清晰的了解一下，我们下面都会分析到哪些内容；也了解一下 `Handler` 机制的核心秘密。\n\n![Handler 类图](https://github.com/xiaomanwong/static_file/blob/master/images/Handler%20%E6%9C%BA%E5%88%B6.png?raw=true)\n\n<!-- more -->\n\n#### **类图分析**\n\n从上面的类图我们可以看出，整个 Handler 消息机制，所涉及到的核心内容，只有 3 个类\n\n**Message：** 消息，这个是我们要执行任务的载体，当我们需要 Handler 帮我做事的时候，就会向 Handler 发送一个 Message。\n\n**Handler:**     这个是对我们比较直观的一个类，通常都会在代码中创建一个新的 Handler 来使用\n\n**Looper:** \t  这个类，如果不点进去，我们也是看不到这，它也是整个 Handler 消息通信机制的*大心脏*\n\n## ActivityThread\n\n看过源码后我们能知道，一个 App 的启动流程的入口就在 ActivityThread 的 `main()` 方法中。\n\n在这里系统帮我做了系统进程的 fork 工作，为我们的 app 开辟了一块空间。并帮我们初始化了  `application` 和 `activity` 的工作,接下来我们看一下源码：\n\n```java\npublic static void main(String[] args) {\n    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"ActivityThreadMain\");\n\n    // Install selective syscall interception\n    AndroidOs.install();\n\n    // CloseGuard defaults to true and can be quite spammy.  We\n    // disable it here, but selectively enable it later (via\n    // StrictMode) on debug builds, but using DropBox, not logs.\n    CloseGuard.setEnabled(false);\n\n    Environment.initForCurrentUser();\n\n    // Make sure TrustedCertificateStore looks in the right place for CA certificates\n    final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());\n    TrustedCertificateStore.setDefaultUserDirectory(configDir);\n\n    Process.setArgV0(\"<pre-initialized>\");\n\n    Looper.prepareMainLooper();\n\n    // Find the value for {@link #PROC_START_SEQ_IDENT} if provided on the command line.\n    // It will be in the format \"seq=114\"\n    long startSeq = 0;\n    if (args != null) {\n        for (int i = args.length - 1; i >= 0; --i) {\n            if (args[i] != null && args[i].startsWith(PROC_START_SEQ_IDENT)) {\n                startSeq = Long.parseLong(\n                    args[i].substring(PROC_START_SEQ_IDENT.length()));\n            }\n        }\n    }\n    ActivityThread thread = new ActivityThread();\n    thread.attach(false, startSeq);\n\n    if (sMainThreadHandler == null) {\n        sMainThreadHandler = thread.getHandler();\n    }\n\n    if (false) {\n        Looper.myLooper().setMessageLogging(new\n                                            LogPrinter(Log.DEBUG, \"ActivityThread\"));\n    }\n\n    // End of event ActivityThreadMain.\n    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n    Looper.loop();\n\n    throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n}\n```\n\n通过上面的代码，我主要分析 `Looper.prepareMainLooper()` 和 `Looper.loop()`\n\n## Looper\n\n### Looper.prepare()\n\n这里的标题虽然不是 `prepareMainLooper()`  的一个主要原因是他们的核心内容是一样的，只不过，`prepareMainLooper()` 是系统帮我们创建了要给不可退出的`Looper`，而 `prepare()` 方法创建的 `Looper` 是可以退出的。\n\n```java\n/**\n     * Initialize the current thread as a looper, marking it as an\n     * application's main looper. The main looper for your application\n     * is created by the Android environment, so you should never need\n     * to call this function yourself.  See also: {@link #prepare()}\n     */\npublic static void prepareMainLooper() {\n    prepare(false);\n    synchronized (Looper.class) {\n        if (sMainLooper != null) {\n            throw new IllegalStateException(\"The main Looper has already been prepared.\");\n        }\n        sMainLooper = myLooper();\n    }\n}\n/** Initialize the current thread as a looper.\n      * This gives you a chance to create handlers that then reference\n      * this looper, before actually starting the loop. Be sure to call\n      * {@link #loop()} after calling this method, and end it by calling\n      * {@link #quit()}.\n      */\npublic static void prepare() {\n    prepare(true);\n}\n\nprivate static void prepare(boolean quitAllowed) {\n    if (sThreadLocal.get() != null) {\n        throw new RuntimeException(\"Only one Looper may be created per thread\");\n    }\n    sThreadLocal.set(new Looper(quitAllowed));\n}\n```\n\n### ThreadLocal\n\n说到 `Looper` 的创建工作，这里就需要讲一下 `ThreadLocal` ， 它的意思是**帮助我们在自己线程中保存一份它自己的本地变量**\n\n```java\n@UnsupportedAppUsage\nstatic final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();\n```\n\n也就是说，在 Looper 创建的过程中，我们将 Looper 对象，保存到当前线程中，并做到每个线程中只有一个 Looper 对象，起到线程之间隔离作用。\n\n面试中经常会问到一个线程有且只有一个 Looper 的问题，原因也在这里。系统通过 ThreadLocal 帮我们限制了。\n\n### loop()\n\n继续看源码，` Looper.loop();` 的出现，标志了系统开启了一个循环开始处理消息，跑到这里，基本上我们的 app 已经可以正常运行\n\n这部分的源码比较长，捡主要的看和说：\n\n```java\n/**\n     * Run the message queue in this thread. Be sure to call\n     * {@link #quit()} to end the loop.\n     */\npublic static void loop() {\n    final Looper me = myLooper();\n    if (me == null) {\n        throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n    }\n    //..............\n    final MessageQueue queue = me.mQueue;\n    for (;;) {\n        Message msg = queue.next(); // might block\n        if (msg == null) {\n            // No message indicates that the message queue is quitting.\n            return;\n        }\n        //..............\n        try {\n            msg.target.dispatchMessage(msg);\n        } catch (Exception exception) {\n            throw exception;\n        } finally {\n          \n        }\n        // ...............\n        msg.recycleUnchecked();\n    }\n}\n```\n\nActivityThread 中的 `main()` 方法，在最后一行，执行了我们的 `Looper.loop()` 方法， 进入后，我们可以看到 `loop()` 方法内部是一个死循环，当然，这里我们需要回顾一下 ActivityThread 帮我们初始化的 `prepareMainLooper()`  ，这也是系统帮我们创建的一个主线程`main` 。\n\n接下来就慢慢分析一下 `loop` 都做了什么事情\n\n![looper.loop()](https://github.com/xiaomanwong/static_file/blob/master/images/loop%20for.png?raw=true?raw=true)\n\n从流程图上，我们简述了一下 `loop()` 方法，都做了些什么事情，下面就展开讲都做了什么\n\n1. 首先获取当前线程的 looper 对象，如果不存在，则抛出异常\n2. 接着获取当前 Looper 绑定的消息队列` MessageQueue`\n3. 进入循环，开始获取消息 `queue.next()`\n4. 调用 `msg.target.dispathMessage(msg)` 分发消息\n5. msg.recycleUnchecked()\n\n## Handler\n\n**作用：**\n\n`Handler` 暴露给开发这的功能一共就两块\n\n* 发送消息\n* 处理消息\n\n### 发送消息\n\n* sendMessage(Message msg)\n* sendMessageEmpty()\n* sendMessageAtTime(Message msg, long uptimeMillis)\n* sendMessageDelay(Message msg, long delay)\n* post(Runnable r)\n* ...\n\n所有的发送消息的方法，最终都会去执行`sendMessageAtTime(Message msg, long uptimeMillis)`, 当我们创建一个`Handler` 对象时, 会从当前线程的 Looper 中获取当前的消息队列`mQueue`\n\n```java\npublic Handler(@Nullable Callback callback, boolean async) {\n        if (FIND_POTENTIAL_LEAKS) {\n            final Class<? extends Handler> klass = getClass();\n            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&\n                    (klass.getModifiers() & Modifier.STATIC) == 0) {\n                Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" +\n                    klass.getCanonicalName());\n            }\n        }\n\n        mLooper = Looper.myLooper();\n        if (mLooper == null) {\n            throw new RuntimeException(\n                \"Can't create handler inside thread \" + Thread.currentThread()\n                        + \" that has not called Looper.prepare()\");\n        }\n        mQueue = mLooper.mQueue;\n        mCallback = callback;\n        mAsynchronous = async;\n    }\n```\n\n当我们开始发送一条消息时，调用 `sendMessageAtTime` ，会将消息压入到消息队列中，\n\n```java\nfinal MessageQueue mQueue;\n\npublic boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) {\n        MessageQueue queue = mQueue;\n        if (queue == null) {\n            RuntimeException e = new RuntimeException(\n                    this + \" sendMessageAtTime() called with no mQueue\");\n            Log.w(\"Looper\", e.getMessage(), e);\n            return false;\n        }\n        return enqueueMessage(queue, msg, uptimeMillis);\n    }\n\nprivate boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,\n            long uptimeMillis) {\n        msg.target = this;\n        msg.workSourceUid = ThreadLocalWorkSource.getUid();\n\n        if (mAsynchronous) {\n            msg.setAsynchronous(true);\n        }\n        return queue.enqueueMessage(msg, uptimeMillis);\n    }\n```\n\n通过源码我们看到，在压入队列前，我们会将当前的 `Handler` 对象赋值给 `Message` 中的 `target` ，这也就是为什么 `message` 中会持有 `Handler` 的引用的原因。\n\n### 处理消息\n\n在说处理消息之前，我们先看一下 `Handler` 对**消息的分发**\n\n```Java\n /**\n     * Handle system messages here.\n     */\n    public void dispatchMessage(@NonNull Message msg) {\n        if (msg.callback != null) {\n            handleCallback(msg);\n        } else {\n            if (mCallback != null) {\n                if (mCallback.handleMessage(msg)) {\n                    return;\n                }\n            }\n            handleMessage(msg);\n        }\n    }\n```\n\n* 当我们给 `Message` 设置了 `callback` 时，会直接触发 `Message` 的 `callback` 逻辑\n* 如果我们在创建 `Handler` 时，有设置过 `Callback` ，则会调用由我们传入进来的 `Callback` 方法\n* 如果以上两种情况都没有设置，那么会触发 `Handler` 自己 `handleMessage()` 方法\n\n```java\n/**\n     * Subclasses must implement this to receive messages.\n     */\n    public void handleMessage(@NonNull Message msg) {\n    }\n```\n\n通过源码的注解我们可以看出，当我们继承/创建一个 `Handler` 时，需要我们必须去实现的一个方法（前提是你需要它）\n\n`dispatchMessage` 最终时由 `loop()` 方法在拿取消息队列中的信息时，获取到 `Message` 对象， 通过 `Message` 持有的 `target` 调用。\n\n### 移除消息\n\n这里我们需要注意，当我们使用 `Handler` 处理消息时，通常都是一些异步任务，这时创建 `Handler` 一般都为内部类，此时需要注意的是，在 Java 中，内部类是会持有外部类的引用， 那么在 Handler 中处理的消息如果长时间无法得到释放， 那么会造成 `Activity` 无法被回收的情况。处理这种情况的方案就是，在 `Activity` 销毁时，我们需要将 `Handler` 中的消息进行释放\n\n```java\n    public final void removeCallbacksAndMessages(@Nullable Object token) {\n        mQueue.removeCallbacksAndMessages(this, token);\n    }\n```\n\n\n\n## Message\n\n一种消息的载体，其中包含 `handler` 对象和一个任意类型的对象以及两个 int 型的参数\n\n```java\npublic final class Message implements Parcelable {\n    /**\n     * 用户自定义的消息身份代码，每一个 Handler 都有它自己的命名空间，因此我们不需要担心会和其他的 Handler 混淆 \n     */\n    public int what;\n\n    /**\n     * arg1 and arg2 是一个低成本的替代方案，当我们只需要发送一些 int 型的数据时，可以使用， 避免使用 Object 增加内存的开销\n     */\n    public int arg1;\n\n     /**\n     * arg1 and arg2 是一个低成本的替代方案，当我们只需要发送一些 int 型的数据时，可以使用， 避免使用 Object 增加内存的开销\n     */\n    public int arg2;\n    \n    /**\n     * 任意的消息类型载体，如果是序列化的数据，则一定不能为 null，其他的数据类型，可以使用 setData(Bundle bundle) \n     */\n    public Object obj;\n    /**\n     * 消息的执行时间\n     */\n    public long when;\n}\n```\n\n`Message` 本身是一个**链表** 的数据结构，这种数据结构，在`MessageQueue` 中获取消息时，可以有效的针对 `Handler` 发送进来的消息进行排序。\n\n```java\n    @UnsupportedAppUsage\n    /*package*/ Handler target;\n\n    @UnsupportedAppUsage\n    /*package*/ Runnable callback;\n\n    // sometimes we store linked lists of these things\n    @UnsupportedAppUsage\n    /*package*/ Message next;\n```\n\n`Message` 持有了一个 `Handler` 对象，因此即使我们在同一个线程里面创建了多个 `Handler` 的对象， 也不会出现消息错乱的现象。\n\n**Callback**\n\n同时 Message 也支持设置 `Callback` 方便开发者在处理消息时可以快速的查看处理方案，但这种方法其实个人认为在开发阶段不适合使用。这会导致消息处理到处飞，不利于代码的管理。\n\n#### 构造器\n\n```java\n \tprivate static Message sPool;\n    private static int sPoolSize = 0;\n\n    private static final int MAX_POOL_SIZE = 50;   \n\n\t/** Constructor (but the preferred way to get a Message is to call {@link #obtain() Message.obtain()}).\n    */\n    public Message() {\n    }\n\n\tpublic static Message obtain() {\n        synchronized (sPoolSync) {\n            if (sPool != null) {\n                Message m = sPool;\n                sPool = m.next;\n                m.next = null;\n                m.flags = 0; // clear in-use flag\n                sPoolSize--;\n                return m;\n            }\n        }\n        return new Message();\n    }\n```\n\n`Message` 为我们提供了一个空的构造器去创建一个对象，但这种方案系统却不建议我们使用，而是建议我们通过 `obtain()` 函数去获取。通过 `obtain()` 函数我们可以看出， `Message` 自身维护了一个对象池，池的最大值为 50。因此我们不难看出，当我们通过空构造器去创建一个 `Message` 对象时，反而是增加了系统的内存开销，而 `Message` 为我们提供的利器得不到发挥。\n\n#### 回收\n\n```java\n    public void recycle() {\n        if (isInUse()) {\n            if (gCheckRecycle) {\n                throw new IllegalStateException(\"This message cannot be recycled because it \"\n                        + \"is still in use.\");\n            }\n            return;\n        }\n        recycleUnchecked();\n    }\n```\n\n当一个消息处于不在被使用（Handler 触发 remove 时），或已经使用完成（MessageQueue 触发），那么系统会清空 `Message` 中的全部内容，并将对象丢向消息池中，等待再次被使用( obtain())，当消息被回收时，我们不能在去调用它，否则会出现空指针的情况。\n\n## MessageQueue\n\n存放所有消息的容器，既然是 `Queue` 命名，那自然就是一个队列，拥有先入先出的特性，但消息的存放，并不是由其自己操作，而是通过与 `Looper` 关联的 `Handler` 添加\n\n### 入队\n\n由 `Handler` 触发，将数据压入到队列中\n\n```java\nboolean enqueueMessage(Message msg, long when) {\n    \n\n        synchronized (this) {\n            msg.markInUse();\n            msg.when = when;\n            Message p = mMessages;\n            boolean needWake;\n            if (p == null || when == 0 || when < p.when) {\n                // New head, wake up the event queue if blocked.\n                msg.next = p;\n                mMessages = msg;\n                needWake = mBlocked;\n            } else {\n                // Inserted within the middle of the queue.  Usually we don't have to wake\n                // up the event queue unless there is a barrier at the head of the queue\n                // and the message is the earliest asynchronous message in the queue.\n                needWake = mBlocked && p.target == null && msg.isAsynchronous();\n                Message prev;\n                for (;;) {\n                    prev = p;\n                    p = p.next;\n                    if (p == null || when < p.when) {\n                        break;\n                    }\n                    if (needWake && p.isAsynchronous()) {\n                        needWake = false;\n                    }\n                }\n                msg.next = p; // invariant: p == prev.next\n                prev.next = msg;\n            }\n\n            // We can assume mPtr != 0 because mQuitting is false.\n            if (needWake) {\n                nativeWake(mPtr);\n            }\n        }\n        return true;\n    }\n```\n\n通过源码看出，在消息压入队列中时，发生了排序操作，\n\n当一条消息进来时，判断了如果当前队列内没有消息，或者传入的消息延时执行时间为0，或者传入的消息执行时间小于队列的第一条消息时，将 `Message` 放置在链表头部位置。否则则循环取出每条消息，依据消息的执行时间进行排序，将新消息压入到适当的位置。\n\n### 出队\n\n```java\nMessage next() {\n   \n    for (;;) {\n        if (nextPollTimeoutMillis != 0) {\n            Binder.flushPendingCommands();\n        }\n\n        nativePollOnce(ptr, nextPollTimeoutMillis);\n\n        synchronized (this) {\n            // Try to retrieve the next message.  Return if found.\n            final long now = SystemClock.uptimeMillis();\n            Message prevMsg = null;\n            Message msg = mMessages;\n            // 开启同步屏障，直到找到下一个异步消息结束，目的是优先执行异步消息\n            if (msg != null && msg.target == null) {\n                // Stalled by a barrier.  Find the next asynchronous message in the queue.\n                do {\n                    prevMsg = msg;\n                    msg = msg.next;\n                } while (msg != null && !msg.isAsynchronous());\n            }\n            if (msg != null) {\n                if (now < msg.when) {\n                    // 为到执行时间，设置下一次系统唤醒消息需要的时间\n                    // Next message is not ready.  Set a timeout to wake up when it is ready.\n                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                } else {\n                    // Got a message.\n                    mBlocked = false;\n                    if (prevMsg != null) {\n                        // prevMsg ，即是同步消息，\n                        prevMsg.next = msg.next;\n                    } else {\n                        mMessages = msg.next;\n                    }\n                    msg.next = null;\n                    if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);\n                    msg.markInUse();\n                    return msg;\n                }\n            } else {\n                // No more messages.\n                nextPollTimeoutMillis = -1;\n            }\n        }\n    }\n}\n```\n\n#### 同步屏障\n\n一般是由系统发出，多数情况是用来处理`View` 的刷新，由`ViewRootImpl` 调用 `postSyncBarrier`，将消息插入到链表的头部，我们可以注意到 `msg` 的 `target` 对象为空，因为 每一个 `Message` 对象都持有一个 target 对象，因此这里很不合常理，但这里就是系统的黑魔法，专门用来处理同步消息，因为同步消息的优先级高于所有异步消息。\n\n```java\nprivate int postSyncBarrier(long when) {\n        // Enqueue a new sync barrier token.\n        // We don't need to wake the queue because the purpose of a barrier is to stall it.\n        synchronized (this) {\n            final int token = mNextBarrierToken++;\n            // 创建一个同步消息\n            final Message msg = Message.obtain();\n            msg.markInUse();\n            msg.when = when;\n            msg.arg1 = token;\n\n            Message prev = null;\n            Message p = mMessages;\n            if (when != 0) {\n                // 队列中的消息执行时间，排序，找到消息执行时间大于当前系统时间\n                while (p != null && p.when <= when) {\n                    prev = p;\n                    p = p.next;\n                }\n            }\n            if (prev != null) { // invariant: p == prev.next\n                // 断开链表，将同步消息，插入到要立即执行的消息后面\n                msg.next = p;\n                prev.next = msg;\n            } else {\n                // 没有要立即执行的消息，将同步消息插入到链表第一个节点\n                msg.next = p;\n                mMessages = msg;\n            }\n            return token;\n        }\n    }\n```\n\n\n\n当我们创建一个 Handler 时，默认创建的都是一个异步的（当然也可以创建同步的，调用对应的构造器就可以），因此在这里当收到一个同步消息时，`ViewRootImpl` 会，并给 msg 的 `target` 重新赋值，优先执行。直到找到一个异步消息为止\n\n当从队列中获取一条异步消息后，我们将消息取出来，并将消息的 next 置空断开链表，标记当前消息正在使用，并且返回。如果消息还没有到达执行的时间，则会通知系统去等待，设置下一次唤醒的时间。\n\n### 退出\n\n由 `loop` 调用，当一个 loop 被销毁时，会触发该方法，用来清空内部所有消息,并回收\n\n```java\nvoid quit(boolean safe) {\n        if (!mQuitAllowed) {\n            throw new IllegalStateException(\"Main thread not allowed to quit.\");\n        }\n\n        synchronized (this) {\n            if (mQuitting) {\n                return;\n            }\n            mQuitting = true;\n\n            if (safe) {\n                removeAllFutureMessagesLocked();\n            } else {\n                removeAllMessagesLocked();\n            }\n\n            // We can assume mPtr != 0 because mQuitting was previously false.\n            nativeWake(mPtr);\n        }\n    }\n```\n\n","slug":"Android 基础/原理/Handler 消息机制","published":1,"date":"2021-01-29T15:54:28.302Z","updated":"2021-01-29T15:54:28.303Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8k00034sz5qe8oqtlxu","content":"<p>Handler 消息机制，在整个 Android 系统中，有着很重要的地位。</p>\n<p>他可以帮助我们实现，子线程和主线程的跨线程通信；可以帮助我们发送一些延时任务，帮助我们很好的实现一个 App.</p>\n<p>本文旨在对源码进行预览分析。</p>\n<h2 id=\"UML-类图\"><a href=\"#UML-类图\" class=\"headerlink\" title=\"UML 类图\"></a>UML 类图</h2><p>先来一张结构图，让我们清晰的了解一下，我们下面都会分析到哪些内容；也了解一下 <code>Handler</code> 机制的核心秘密。</p>\n<p><img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/Handler%20%E6%9C%BA%E5%88%B6.png?raw=true\" alt=\"Handler 类图\"></p>\n<a id=\"more\"></a>\n<h4 id=\"类图分析\"><a href=\"#类图分析\" class=\"headerlink\" title=\"类图分析\"></a><strong>类图分析</strong></h4><p>从上面的类图我们可以看出，整个 Handler 消息机制，所涉及到的核心内容，只有 3 个类</p>\n<p><strong>Message：</strong> 消息，这个是我们要执行任务的载体，当我们需要 Handler 帮我做事的时候，就会向 Handler 发送一个 Message。</p>\n<p><strong>Handler:</strong>     这个是对我们比较直观的一个类，通常都会在代码中创建一个新的 Handler 来使用</p>\n<p><strong>Looper:</strong>       这个类，如果不点进去，我们也是看不到这，它也是整个 Handler 消息通信机制的<em>大心脏</em></p>\n<h2 id=\"ActivityThread\"><a href=\"#ActivityThread\" class=\"headerlink\" title=\"ActivityThread\"></a>ActivityThread</h2><p>看过源码后我们能知道，一个 App 的启动流程的入口就在 ActivityThread 的 <code>main()</code> 方法中。</p>\n<p>在这里系统帮我做了系统进程的 fork 工作，为我们的 app 开辟了一块空间。并帮我们初始化了  <code>application</code> 和 <code>activity</code> 的工作,接下来我们看一下源码：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Trace<span class=\"token punctuation\">.</span><span class=\"token function\">traceBegin</span><span class=\"token punctuation\">(</span>Trace<span class=\"token punctuation\">.</span>TRACE_TAG_ACTIVITY_MANAGER<span class=\"token punctuation\">,</span> <span class=\"token string\">\"ActivityThreadMain\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Install selective syscall interception</span>\n    AndroidOs<span class=\"token punctuation\">.</span><span class=\"token function\">install</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// CloseGuard defaults to true and can be quite spammy.  We</span>\n    <span class=\"token comment\" spellcheck=\"true\">// disable it here, but selectively enable it later (via</span>\n    <span class=\"token comment\" spellcheck=\"true\">// StrictMode) on debug builds, but using DropBox, not logs.</span>\n    CloseGuard<span class=\"token punctuation\">.</span><span class=\"token function\">setEnabled</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    Environment<span class=\"token punctuation\">.</span><span class=\"token function\">initForCurrentUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span>\n    <span class=\"token keyword\">final</span> File configDir <span class=\"token operator\">=</span> Environment<span class=\"token punctuation\">.</span><span class=\"token function\">getUserConfigDirectory</span><span class=\"token punctuation\">(</span>UserHandle<span class=\"token punctuation\">.</span><span class=\"token function\">myUserId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    TrustedCertificateStore<span class=\"token punctuation\">.</span><span class=\"token function\">setDefaultUserDirectory</span><span class=\"token punctuation\">(</span>configDir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    Process<span class=\"token punctuation\">.</span><span class=\"token function\">setArgV0</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"&lt;pre-initialized>\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    Looper<span class=\"token punctuation\">.</span><span class=\"token function\">prepareMainLooper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Find the value for {@link #PROC_START_SEQ_IDENT} if provided on the command line.</span>\n    <span class=\"token comment\" spellcheck=\"true\">// It will be in the format \"seq=114\"</span>\n    <span class=\"token keyword\">long</span> startSeq <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>args <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> args<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">--</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> args<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span>PROC_START_SEQ_IDENT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                startSeq <span class=\"token operator\">=</span> Long<span class=\"token punctuation\">.</span><span class=\"token function\">parseLong</span><span class=\"token punctuation\">(</span>\n                    args<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span>PROC_START_SEQ_IDENT<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    ActivityThread thread <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ActivityThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    thread<span class=\"token punctuation\">.</span><span class=\"token function\">attach</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> startSeq<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sMainThreadHandler <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        sMainThreadHandler <span class=\"token operator\">=</span> thread<span class=\"token punctuation\">.</span><span class=\"token function\">getHandler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Looper<span class=\"token punctuation\">.</span><span class=\"token function\">myLooper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">setMessageLogging</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span>\n                                            <span class=\"token class-name\">LogPrinter</span><span class=\"token punctuation\">(</span>Log<span class=\"token punctuation\">.</span>DEBUG<span class=\"token punctuation\">,</span> <span class=\"token string\">\"ActivityThread\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// End of event ActivityThreadMain.</span>\n    Trace<span class=\"token punctuation\">.</span><span class=\"token function\">traceEnd</span><span class=\"token punctuation\">(</span>Trace<span class=\"token punctuation\">.</span>TRACE_TAG_ACTIVITY_MANAGER<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Looper<span class=\"token punctuation\">.</span><span class=\"token function\">loop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Main thread loop unexpectedly exited\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>通过上面的代码，我主要分析 <code>Looper.prepareMainLooper()</code> 和 <code>Looper.loop()</code></p>\n<h2 id=\"Looper\"><a href=\"#Looper\" class=\"headerlink\" title=\"Looper\"></a>Looper</h2><h3 id=\"Looper-prepare\"><a href=\"#Looper-prepare\" class=\"headerlink\" title=\"Looper.prepare()\"></a>Looper.prepare()</h3><p>这里的标题虽然不是 <code>prepareMainLooper()</code>  的一个主要原因是他们的核心内容是一样的，只不过，<code>prepareMainLooper()</code> 是系统帮我们创建了要给不可退出的<code>Looper</code>，而 <code>prepare()</code> 方法创建的 <code>Looper</code> 是可以退出的。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/**\n     * Initialize the current thread as a looper, marking it as an\n     * application's main looper. The main looper for your application\n     * is created by the Android environment, so you should never need\n     * to call this function yourself.  See also: {@link #prepare()}\n     */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">prepareMainLooper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">prepare</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>Looper<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sMainLooper <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalStateException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"The main Looper has already been prepared.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        sMainLooper <span class=\"token operator\">=</span> <span class=\"token function\">myLooper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">/** Initialize the current thread as a looper.\n      * This gives you a chance to create handlers that then reference\n      * this looper, before actually starting the loop. Be sure to call\n      * {@link #loop()} after calling this method, and end it by calling\n      * {@link #quit()}.\n      */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">prepare</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">prepare</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">prepare</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span> quitAllowed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sThreadLocal<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Only one Looper may be created per thread\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    sThreadLocal<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Looper</span><span class=\"token punctuation\">(</span>quitAllowed<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h3><p>说到 <code>Looper</code> 的创建工作，这里就需要讲一下 <code>ThreadLocal</code> ， 它的意思是<strong>帮助我们在自己线程中保存一份它自己的本地变量</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@UnsupportedAppUsage</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> ThreadLocal<span class=\"token operator\">&lt;</span>Looper<span class=\"token operator\">></span> sThreadLocal <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadLocal</span><span class=\"token operator\">&lt;</span>Looper<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>也就是说，在 Looper 创建的过程中，我们将 Looper 对象，保存到当前线程中，并做到每个线程中只有一个 Looper 对象，起到线程之间隔离作用。</p>\n<p>面试中经常会问到一个线程有且只有一个 Looper 的问题，原因也在这里。系统通过 ThreadLocal 帮我们限制了。</p>\n<h3 id=\"loop\"><a href=\"#loop\" class=\"headerlink\" title=\"loop()\"></a>loop()</h3><p>继续看源码，<code>Looper.loop();</code> 的出现，标志了系统开启了一个循环开始处理消息，跑到这里，基本上我们的 app 已经可以正常运行</p>\n<p>这部分的源码比较长，捡主要的看和说：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/**\n     * Run the message queue in this thread. Be sure to call\n     * {@link #quit()} to end the loop.\n     */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">loop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> Looper me <span class=\"token operator\">=</span> <span class=\"token function\">myLooper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>me <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"No Looper; Looper.prepare() wasn't called on this thread.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//..............</span>\n    <span class=\"token keyword\">final</span> MessageQueue queue <span class=\"token operator\">=</span> me<span class=\"token punctuation\">.</span>mQueue<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Message msg <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// might block</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>msg <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// No message indicates that the message queue is quitting.</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">//..............</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            msg<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span><span class=\"token function\">dispatchMessage</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> exception<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">throw</span> exception<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">// ...............</span>\n        msg<span class=\"token punctuation\">.</span><span class=\"token function\">recycleUnchecked</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>ActivityThread 中的 <code>main()</code> 方法，在最后一行，执行了我们的 <code>Looper.loop()</code> 方法， 进入后，我们可以看到 <code>loop()</code> 方法内部是一个死循环，当然，这里我们需要回顾一下 ActivityThread 帮我们初始化的 <code>prepareMainLooper()</code>  ，这也是系统帮我们创建的一个主线程<code>main</code> 。</p>\n<p>接下来就慢慢分析一下 <code>loop</code> 都做了什么事情</p>\n<p><img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/loop%20for.png?raw=true?raw=true\" alt=\"looper.loop()\"></p>\n<p>从流程图上，我们简述了一下 <code>loop()</code> 方法，都做了些什么事情，下面就展开讲都做了什么</p>\n<ol>\n<li>首先获取当前线程的 looper 对象，如果不存在，则抛出异常</li>\n<li>接着获取当前 Looper 绑定的消息队列<code>MessageQueue</code></li>\n<li>进入循环，开始获取消息 <code>queue.next()</code></li>\n<li>调用 <code>msg.target.dispathMessage(msg)</code> 分发消息</li>\n<li>msg.recycleUnchecked()</li>\n</ol>\n<h2 id=\"Handler\"><a href=\"#Handler\" class=\"headerlink\" title=\"Handler\"></a>Handler</h2><p><strong>作用：</strong></p>\n<p><code>Handler</code> 暴露给开发这的功能一共就两块</p>\n<ul>\n<li>发送消息</li>\n<li>处理消息</li>\n</ul>\n<h3 id=\"发送消息\"><a href=\"#发送消息\" class=\"headerlink\" title=\"发送消息\"></a>发送消息</h3><ul>\n<li>sendMessage(Message msg)</li>\n<li>sendMessageEmpty()</li>\n<li>sendMessageAtTime(Message msg, long uptimeMillis)</li>\n<li>sendMessageDelay(Message msg, long delay)</li>\n<li>post(Runnable r)</li>\n<li>…</li>\n</ul>\n<p>所有的发送消息的方法，最终都会去执行<code>sendMessageAtTime(Message msg, long uptimeMillis)</code>, 当我们创建一个<code>Handler</code> 对象时, 会从当前线程的 Looper 中获取当前的消息队列<code>mQueue</code></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token function\">Handler</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@Nullable</span> Callback callback<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> async<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>FIND_POTENTIAL_LEAKS<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">final</span> Class<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Handler</span><span class=\"token operator\">></span> klass <span class=\"token operator\">=</span> <span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>klass<span class=\"token punctuation\">.</span><span class=\"token function\">isAnonymousClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> klass<span class=\"token punctuation\">.</span><span class=\"token function\">isMemberClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> klass<span class=\"token punctuation\">.</span><span class=\"token function\">isLocalClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n                    <span class=\"token punctuation\">(</span>klass<span class=\"token punctuation\">.</span><span class=\"token function\">getModifiers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> Modifier<span class=\"token punctuation\">.</span>STATIC<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                Log<span class=\"token punctuation\">.</span><span class=\"token function\">w</span><span class=\"token punctuation\">(</span>TAG<span class=\"token punctuation\">,</span> <span class=\"token string\">\"The following Handler class should be static or leaks might occur: \"</span> <span class=\"token operator\">+</span>\n                    klass<span class=\"token punctuation\">.</span><span class=\"token function\">getCanonicalName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n\n        mLooper <span class=\"token operator\">=</span> Looper<span class=\"token punctuation\">.</span><span class=\"token function\">myLooper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mLooper <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">(</span>\n                <span class=\"token string\">\"Can't create handler inside thread \"</span> <span class=\"token operator\">+</span> Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                        <span class=\"token operator\">+</span> <span class=\"token string\">\" that has not called Looper.prepare()\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        mQueue <span class=\"token operator\">=</span> mLooper<span class=\"token punctuation\">.</span>mQueue<span class=\"token punctuation\">;</span>\n        mCallback <span class=\"token operator\">=</span> callback<span class=\"token punctuation\">;</span>\n        mAsynchronous <span class=\"token operator\">=</span> async<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>当我们开始发送一条消息时，调用 <code>sendMessageAtTime</code> ，会将消息压入到消息队列中，</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">final</span> MessageQueue mQueue<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">sendMessageAtTime</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@NonNull</span> Message msg<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> uptimeMillis<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        MessageQueue queue <span class=\"token operator\">=</span> mQueue<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>queue <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            RuntimeException e <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">(</span>\n                    <span class=\"token keyword\">this</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" sendMessageAtTime() called with no mQueue\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            Log<span class=\"token punctuation\">.</span><span class=\"token function\">w</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Looper\"</span><span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">.</span><span class=\"token function\">getMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">enqueueMessage</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">,</span> msg<span class=\"token punctuation\">,</span> uptimeMillis<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">enqueueMessage</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@NonNull</span> MessageQueue queue<span class=\"token punctuation\">,</span> <span class=\"token annotation punctuation\">@NonNull</span> Message msg<span class=\"token punctuation\">,</span>\n            <span class=\"token keyword\">long</span> uptimeMillis<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        msg<span class=\"token punctuation\">.</span>target <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n        msg<span class=\"token punctuation\">.</span>workSourceUid <span class=\"token operator\">=</span> ThreadLocalWorkSource<span class=\"token punctuation\">.</span><span class=\"token function\">getUid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mAsynchronous<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            msg<span class=\"token punctuation\">.</span><span class=\"token function\">setAsynchronous</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> queue<span class=\"token punctuation\">.</span><span class=\"token function\">enqueueMessage</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">,</span> uptimeMillis<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>通过源码我们看到，在压入队列前，我们会将当前的 <code>Handler</code> 对象赋值给 <code>Message</code> 中的 <code>target</code> ，这也就是为什么 <code>message</code> 中会持有 <code>Handler</code> 的引用的原因。</p>\n<h3 id=\"处理消息\"><a href=\"#处理消息\" class=\"headerlink\" title=\"处理消息\"></a>处理消息</h3><p>在说处理消息之前，我们先看一下 <code>Handler</code> 对<strong>消息的分发</strong></p>\n<pre class=\" language-Java\"><code class=\"language-Java\"> /**\n     * Handle system messages here.\n     */\n    public void dispatchMessage(@NonNull Message msg) {\n        if (msg.callback != null) {\n            handleCallback(msg);\n        } else {\n            if (mCallback != null) {\n                if (mCallback.handleMessage(msg)) {\n                    return;\n                }\n            }\n            handleMessage(msg);\n        }\n    }\n</code></pre>\n<ul>\n<li>当我们给 <code>Message</code> 设置了 <code>callback</code> 时，会直接触发 <code>Message</code> 的 <code>callback</code> 逻辑</li>\n<li>如果我们在创建 <code>Handler</code> 时，有设置过 <code>Callback</code> ，则会调用由我们传入进来的 <code>Callback</code> 方法</li>\n<li>如果以上两种情况都没有设置，那么会触发 <code>Handler</code> 自己 <code>handleMessage()</code> 方法</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/**\n     * Subclasses must implement this to receive messages.\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">handleMessage</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@NonNull</span> Message msg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>通过源码的注解我们可以看出，当我们继承/创建一个 <code>Handler</code> 时，需要我们必须去实现的一个方法（前提是你需要它）</p>\n<p><code>dispatchMessage</code> 最终时由 <code>loop()</code> 方法在拿取消息队列中的信息时，获取到 <code>Message</code> 对象， 通过 <code>Message</code> 持有的 <code>target</code> 调用。</p>\n<h3 id=\"移除消息\"><a href=\"#移除消息\" class=\"headerlink\" title=\"移除消息\"></a>移除消息</h3><p>这里我们需要注意，当我们使用 <code>Handler</code> 处理消息时，通常都是一些异步任务，这时创建 <code>Handler</code> 一般都为内部类，此时需要注意的是，在 Java 中，内部类是会持有外部类的引用， 那么在 Handler 中处理的消息如果长时间无法得到释放， 那么会造成 <code>Activity</code> 无法被回收的情况。处理这种情况的方案就是，在 <code>Activity</code> 销毁时，我们需要将 <code>Handler</code> 中的消息进行释放</p>\n<pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">removeCallbacksAndMessages</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@Nullable</span> Object token<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        mQueue<span class=\"token punctuation\">.</span><span class=\"token function\">removeCallbacksAndMessages</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> token<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"Message\"><a href=\"#Message\" class=\"headerlink\" title=\"Message\"></a>Message</h2><p>一种消息的载体，其中包含 <code>handler</code> 对象和一个任意类型的对象以及两个 int 型的参数</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Message</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Parcelable</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 用户自定义的消息身份代码，每一个 Handler 都有它自己的命名空间，因此我们不需要担心会和其他的 Handler 混淆 \n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> what<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * arg1 and arg2 是一个低成本的替代方案，当我们只需要发送一些 int 型的数据时，可以使用， 避免使用 Object 增加内存的开销\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> arg1<span class=\"token punctuation\">;</span>\n\n     <span class=\"token comment\" spellcheck=\"true\">/**\n     * arg1 and arg2 是一个低成本的替代方案，当我们只需要发送一些 int 型的数据时，可以使用， 避免使用 Object 增加内存的开销\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> arg2<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 任意的消息类型载体，如果是序列化的数据，则一定不能为 null，其他的数据类型，可以使用 setData(Bundle bundle) \n     */</span>\n    <span class=\"token keyword\">public</span> Object obj<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 消息的执行时间\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">long</span> when<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><code>Message</code> 本身是一个<strong>链表</strong> 的数据结构，这种数据结构，在<code>MessageQueue</code> 中获取消息时，可以有效的针对 <code>Handler</code> 发送进来的消息进行排序。</p>\n<pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token annotation punctuation\">@UnsupportedAppUsage</span>\n    <span class=\"token comment\" spellcheck=\"true\">/*package*/</span> Handler target<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@UnsupportedAppUsage</span>\n    <span class=\"token comment\" spellcheck=\"true\">/*package*/</span> Runnable callback<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// sometimes we store linked lists of these things</span>\n    <span class=\"token annotation punctuation\">@UnsupportedAppUsage</span>\n    <span class=\"token comment\" spellcheck=\"true\">/*package*/</span> Message next<span class=\"token punctuation\">;</span>\n</code></pre>\n<p><code>Message</code> 持有了一个 <code>Handler</code> 对象，因此即使我们在同一个线程里面创建了多个 <code>Handler</code> 的对象， 也不会出现消息错乱的现象。</p>\n<p><strong>Callback</strong></p>\n<p>同时 Message 也支持设置 <code>Callback</code> 方便开发者在处理消息时可以快速的查看处理方案，但这种方法其实个人认为在开发阶段不适合使用。这会导致消息处理到处飞，不利于代码的管理。</p>\n<h4 id=\"构造器\"><a href=\"#构造器\" class=\"headerlink\" title=\"构造器\"></a>构造器</h4><pre class=\" language-java\"><code class=\"language-java\">     <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> Message sPool<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> sPoolSize <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> MAX_POOL_SIZE <span class=\"token operator\">=</span> <span class=\"token number\">50</span><span class=\"token punctuation\">;</span>   \n\n    <span class=\"token comment\" spellcheck=\"true\">/** Constructor (but the preferred way to get a Message is to call {@link #obtain() Message.obtain()}).\n    */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Message</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> Message <span class=\"token function\">obtain</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>sPoolSync<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sPool <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                Message m <span class=\"token operator\">=</span> sPool<span class=\"token punctuation\">;</span>\n                sPool <span class=\"token operator\">=</span> m<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n                m<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n                m<span class=\"token punctuation\">.</span>flags <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// clear in-use flag</span>\n                sPoolSize<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span> m<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Message</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p><code>Message</code> 为我们提供了一个空的构造器去创建一个对象，但这种方案系统却不建议我们使用，而是建议我们通过 <code>obtain()</code> 函数去获取。通过 <code>obtain()</code> 函数我们可以看出， <code>Message</code> 自身维护了一个对象池，池的最大值为 50。因此我们不难看出，当我们通过空构造器去创建一个 <code>Message</code> 对象时，反而是增加了系统的内存开销，而 <code>Message</code> 为我们提供的利器得不到发挥。</p>\n<h4 id=\"回收\"><a href=\"#回收\" class=\"headerlink\" title=\"回收\"></a>回收</h4><pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">recycle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isInUse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>gCheckRecycle<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalStateException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"This message cannot be recycled because it \"</span>\n                        <span class=\"token operator\">+</span> <span class=\"token string\">\"is still in use.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">recycleUnchecked</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>当一个消息处于不在被使用（Handler 触发 remove 时），或已经使用完成（MessageQueue 触发），那么系统会清空 <code>Message</code> 中的全部内容，并将对象丢向消息池中，等待再次被使用( obtain())，当消息被回收时，我们不能在去调用它，否则会出现空指针的情况。</p>\n<h2 id=\"MessageQueue\"><a href=\"#MessageQueue\" class=\"headerlink\" title=\"MessageQueue\"></a>MessageQueue</h2><p>存放所有消息的容器，既然是 <code>Queue</code> 命名，那自然就是一个队列，拥有先入先出的特性，但消息的存放，并不是由其自己操作，而是通过与 <code>Looper</code> 关联的 <code>Handler</code> 添加</p>\n<h3 id=\"入队\"><a href=\"#入队\" class=\"headerlink\" title=\"入队\"></a>入队</h3><p>由 <code>Handler</code> 触发，将数据压入到队列中</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">boolean</span> <span class=\"token function\">enqueueMessage</span><span class=\"token punctuation\">(</span>Message msg<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> when<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n\n        <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            msg<span class=\"token punctuation\">.</span><span class=\"token function\">markInUse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            msg<span class=\"token punctuation\">.</span>when <span class=\"token operator\">=</span> when<span class=\"token punctuation\">;</span>\n            Message p <span class=\"token operator\">=</span> mMessages<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">boolean</span> needWake<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> when <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> when <span class=\"token operator\">&lt;</span> p<span class=\"token punctuation\">.</span>when<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// New head, wake up the event queue if blocked.</span>\n                msg<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span>\n                mMessages <span class=\"token operator\">=</span> msg<span class=\"token punctuation\">;</span>\n                needWake <span class=\"token operator\">=</span> mBlocked<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// Inserted within the middle of the queue.  Usually we don't have to wake</span>\n                <span class=\"token comment\" spellcheck=\"true\">// up the event queue unless there is a barrier at the head of the queue</span>\n                <span class=\"token comment\" spellcheck=\"true\">// and the message is the earliest asynchronous message in the queue.</span>\n                needWake <span class=\"token operator\">=</span> mBlocked <span class=\"token operator\">&amp;&amp;</span> p<span class=\"token punctuation\">.</span>target <span class=\"token operator\">==</span> null <span class=\"token operator\">&amp;&amp;</span> msg<span class=\"token punctuation\">.</span><span class=\"token function\">isAsynchronous</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                Message prev<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    prev <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span>\n                    p <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> when <span class=\"token operator\">&lt;</span> p<span class=\"token punctuation\">.</span>when<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>needWake <span class=\"token operator\">&amp;&amp;</span> p<span class=\"token punctuation\">.</span><span class=\"token function\">isAsynchronous</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        needWake <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n                msg<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// invariant: p == prev.next</span>\n                prev<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> msg<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// We can assume mPtr != 0 because mQuitting is false.</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>needWake<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">nativeWake</span><span class=\"token punctuation\">(</span>mPtr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>通过源码看出，在消息压入队列中时，发生了排序操作，</p>\n<p>当一条消息进来时，判断了如果当前队列内没有消息，或者传入的消息延时执行时间为0，或者传入的消息执行时间小于队列的第一条消息时，将 <code>Message</code> 放置在链表头部位置。否则则循环取出每条消息，依据消息的执行时间进行排序，将新消息压入到适当的位置。</p>\n<h3 id=\"出队\"><a href=\"#出队\" class=\"headerlink\" title=\"出队\"></a>出队</h3><pre class=\" language-java\"><code class=\"language-java\">Message <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextPollTimeoutMillis <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            Binder<span class=\"token punctuation\">.</span><span class=\"token function\">flushPendingCommands</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token function\">nativePollOnce</span><span class=\"token punctuation\">(</span>ptr<span class=\"token punctuation\">,</span> nextPollTimeoutMillis<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// Try to retrieve the next message.  Return if found.</span>\n            <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> now <span class=\"token operator\">=</span> SystemClock<span class=\"token punctuation\">.</span><span class=\"token function\">uptimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            Message prevMsg <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n            Message msg <span class=\"token operator\">=</span> mMessages<span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 开启同步屏障，直到找到下一个异步消息结束，目的是优先执行异步消息</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>msg <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> msg<span class=\"token punctuation\">.</span>target <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span>\n                <span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n                    prevMsg <span class=\"token operator\">=</span> msg<span class=\"token punctuation\">;</span>\n                    msg <span class=\"token operator\">=</span> msg<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>msg <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>msg<span class=\"token punctuation\">.</span><span class=\"token function\">isAsynchronous</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>msg <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>now <span class=\"token operator\">&lt;</span> msg<span class=\"token punctuation\">.</span>when<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// 为到执行时间，设置下一次系统唤醒消息需要的时间</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// Next message is not ready.  Set a timeout to wake up when it is ready.</span>\n                    nextPollTimeoutMillis <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span>when <span class=\"token operator\">-</span> now<span class=\"token punctuation\">,</span> Integer<span class=\"token punctuation\">.</span>MAX_VALUE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// Got a message.</span>\n                    mBlocked <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>prevMsg <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token comment\" spellcheck=\"true\">// prevMsg ，即是同步消息，</span>\n                        prevMsg<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> msg<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                        mMessages <span class=\"token operator\">=</span> msg<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    msg<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>DEBUG<span class=\"token punctuation\">)</span> Log<span class=\"token punctuation\">.</span><span class=\"token function\">v</span><span class=\"token punctuation\">(</span>TAG<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Returning message: \"</span> <span class=\"token operator\">+</span> msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    msg<span class=\"token punctuation\">.</span><span class=\"token function\">markInUse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">return</span> msg<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// No more messages.</span>\n                nextPollTimeoutMillis <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"同步屏障\"><a href=\"#同步屏障\" class=\"headerlink\" title=\"同步屏障\"></a>同步屏障</h4><p>一般是由系统发出，多数情况是用来处理<code>View</code> 的刷新，由<code>ViewRootImpl</code> 调用 <code>postSyncBarrier</code>，将消息插入到链表的头部，我们可以注意到 <code>msg</code> 的 <code>target</code> 对象为空，因为 每一个 <code>Message</code> 对象都持有一个 target 对象，因此这里很不合常理，但这里就是系统的黑魔法，专门用来处理同步消息，因为同步消息的优先级高于所有异步消息。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> <span class=\"token function\">postSyncBarrier</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> when<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// Enqueue a new sync barrier token.</span>\n        <span class=\"token comment\" spellcheck=\"true\">// We don't need to wake the queue because the purpose of a barrier is to stall it.</span>\n        <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> token <span class=\"token operator\">=</span> mNextBarrierToken<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 创建一个同步消息</span>\n            <span class=\"token keyword\">final</span> Message msg <span class=\"token operator\">=</span> Message<span class=\"token punctuation\">.</span><span class=\"token function\">obtain</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            msg<span class=\"token punctuation\">.</span><span class=\"token function\">markInUse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            msg<span class=\"token punctuation\">.</span>when <span class=\"token operator\">=</span> when<span class=\"token punctuation\">;</span>\n            msg<span class=\"token punctuation\">.</span>arg1 <span class=\"token operator\">=</span> token<span class=\"token punctuation\">;</span>\n\n            Message prev <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n            Message p <span class=\"token operator\">=</span> mMessages<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>when <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 队列中的消息执行时间，排序，找到消息执行时间大于当前系统时间</span>\n                <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> p<span class=\"token punctuation\">.</span>when <span class=\"token operator\">&lt;=</span> when<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    prev <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span>\n                    p <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>prev <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// invariant: p == prev.next</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 断开链表，将同步消息，插入到要立即执行的消息后面</span>\n                msg<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span>\n                prev<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> msg<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 没有要立即执行的消息，将同步消息插入到链表第一个节点</span>\n                msg<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span>\n                mMessages <span class=\"token operator\">=</span> msg<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">return</span> token<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>当我们创建一个 Handler 时，默认创建的都是一个异步的（当然也可以创建同步的，调用对应的构造器就可以），因此在这里当收到一个同步消息时，<code>ViewRootImpl</code> 会，并给 msg 的 <code>target</code> 重新赋值，优先执行。直到找到一个异步消息为止</p>\n<p>当从队列中获取一条异步消息后，我们将消息取出来，并将消息的 next 置空断开链表，标记当前消息正在使用，并且返回。如果消息还没有到达执行的时间，则会通知系统去等待，设置下一次唤醒的时间。</p>\n<h3 id=\"退出\"><a href=\"#退出\" class=\"headerlink\" title=\"退出\"></a>退出</h3><p>由 <code>loop</code> 调用，当一个 loop 被销毁时，会触发该方法，用来清空内部所有消息,并回收</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">void</span> <span class=\"token function\">quit</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span> safe<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>mQuitAllowed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalStateException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Main thread not allowed to quit.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mQuitting<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            mQuitting <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>safe<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">removeAllFutureMessagesLocked</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">removeAllMessagesLocked</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// We can assume mPtr != 0 because mQuitting was previously false.</span>\n            <span class=\"token function\">nativeWake</span><span class=\"token punctuation\">(</span>mPtr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n","site":{"data":{}},"excerpt":"<p>Handler 消息机制，在整个 Android 系统中，有着很重要的地位。</p>\n<p>他可以帮助我们实现，子线程和主线程的跨线程通信；可以帮助我们发送一些延时任务，帮助我们很好的实现一个 App.</p>\n<p>本文旨在对源码进行预览分析。</p>\n<h2 id=\"UML-类图\"><a href=\"#UML-类图\" class=\"headerlink\" title=\"UML 类图\"></a>UML 类图</h2><p>先来一张结构图，让我们清晰的了解一下，我们下面都会分析到哪些内容；也了解一下 <code>Handler</code> 机制的核心秘密。</p>\n<p><img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/Handler%20%E6%9C%BA%E5%88%B6.png?raw=true\" alt=\"Handler 类图\"></p>","more":"<h4 id=\"类图分析\"><a href=\"#类图分析\" class=\"headerlink\" title=\"类图分析\"></a><strong>类图分析</strong></h4><p>从上面的类图我们可以看出，整个 Handler 消息机制，所涉及到的核心内容，只有 3 个类</p>\n<p><strong>Message：</strong> 消息，这个是我们要执行任务的载体，当我们需要 Handler 帮我做事的时候，就会向 Handler 发送一个 Message。</p>\n<p><strong>Handler:</strong>     这个是对我们比较直观的一个类，通常都会在代码中创建一个新的 Handler 来使用</p>\n<p><strong>Looper:</strong>       这个类，如果不点进去，我们也是看不到这，它也是整个 Handler 消息通信机制的<em>大心脏</em></p>\n<h2 id=\"ActivityThread\"><a href=\"#ActivityThread\" class=\"headerlink\" title=\"ActivityThread\"></a>ActivityThread</h2><p>看过源码后我们能知道，一个 App 的启动流程的入口就在 ActivityThread 的 <code>main()</code> 方法中。</p>\n<p>在这里系统帮我做了系统进程的 fork 工作，为我们的 app 开辟了一块空间。并帮我们初始化了  <code>application</code> 和 <code>activity</code> 的工作,接下来我们看一下源码：</p>\n<pre><code class=\"java\">public static void main(String[] args) {\n    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);\n\n    // Install selective syscall interception\n    AndroidOs.install();\n\n    // CloseGuard defaults to true and can be quite spammy.  We\n    // disable it here, but selectively enable it later (via\n    // StrictMode) on debug builds, but using DropBox, not logs.\n    CloseGuard.setEnabled(false);\n\n    Environment.initForCurrentUser();\n\n    // Make sure TrustedCertificateStore looks in the right place for CA certificates\n    final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());\n    TrustedCertificateStore.setDefaultUserDirectory(configDir);\n\n    Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);\n\n    Looper.prepareMainLooper();\n\n    // Find the value for {@link #PROC_START_SEQ_IDENT} if provided on the command line.\n    // It will be in the format &quot;seq=114&quot;\n    long startSeq = 0;\n    if (args != null) {\n        for (int i = args.length - 1; i &gt;= 0; --i) {\n            if (args[i] != null &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) {\n                startSeq = Long.parseLong(\n                    args[i].substring(PROC_START_SEQ_IDENT.length()));\n            }\n        }\n    }\n    ActivityThread thread = new ActivityThread();\n    thread.attach(false, startSeq);\n\n    if (sMainThreadHandler == null) {\n        sMainThreadHandler = thread.getHandler();\n    }\n\n    if (false) {\n        Looper.myLooper().setMessageLogging(new\n                                            LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));\n    }\n\n    // End of event ActivityThreadMain.\n    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n    Looper.loop();\n\n    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);\n}\n</code></pre>\n<p>通过上面的代码，我主要分析 <code>Looper.prepareMainLooper()</code> 和 <code>Looper.loop()</code></p>\n<h2 id=\"Looper\"><a href=\"#Looper\" class=\"headerlink\" title=\"Looper\"></a>Looper</h2><h3 id=\"Looper-prepare\"><a href=\"#Looper-prepare\" class=\"headerlink\" title=\"Looper.prepare()\"></a>Looper.prepare()</h3><p>这里的标题虽然不是 <code>prepareMainLooper()</code>  的一个主要原因是他们的核心内容是一样的，只不过，<code>prepareMainLooper()</code> 是系统帮我们创建了要给不可退出的<code>Looper</code>，而 <code>prepare()</code> 方法创建的 <code>Looper</code> 是可以退出的。</p>\n<pre><code class=\"java\">/**\n     * Initialize the current thread as a looper, marking it as an\n     * application&#39;s main looper. The main looper for your application\n     * is created by the Android environment, so you should never need\n     * to call this function yourself.  See also: {@link #prepare()}\n     */\npublic static void prepareMainLooper() {\n    prepare(false);\n    synchronized (Looper.class) {\n        if (sMainLooper != null) {\n            throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);\n        }\n        sMainLooper = myLooper();\n    }\n}\n/** Initialize the current thread as a looper.\n      * This gives you a chance to create handlers that then reference\n      * this looper, before actually starting the loop. Be sure to call\n      * {@link #loop()} after calling this method, and end it by calling\n      * {@link #quit()}.\n      */\npublic static void prepare() {\n    prepare(true);\n}\n\nprivate static void prepare(boolean quitAllowed) {\n    if (sThreadLocal.get() != null) {\n        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);\n    }\n    sThreadLocal.set(new Looper(quitAllowed));\n}\n</code></pre>\n<h3 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h3><p>说到 <code>Looper</code> 的创建工作，这里就需要讲一下 <code>ThreadLocal</code> ， 它的意思是<strong>帮助我们在自己线程中保存一份它自己的本地变量</strong></p>\n<pre><code class=\"java\">@UnsupportedAppUsage\nstatic final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();\n</code></pre>\n<p>也就是说，在 Looper 创建的过程中，我们将 Looper 对象，保存到当前线程中，并做到每个线程中只有一个 Looper 对象，起到线程之间隔离作用。</p>\n<p>面试中经常会问到一个线程有且只有一个 Looper 的问题，原因也在这里。系统通过 ThreadLocal 帮我们限制了。</p>\n<h3 id=\"loop\"><a href=\"#loop\" class=\"headerlink\" title=\"loop()\"></a>loop()</h3><p>继续看源码，<code>Looper.loop();</code> 的出现，标志了系统开启了一个循环开始处理消息，跑到这里，基本上我们的 app 已经可以正常运行</p>\n<p>这部分的源码比较长，捡主要的看和说：</p>\n<pre><code class=\"java\">/**\n     * Run the message queue in this thread. Be sure to call\n     * {@link #quit()} to end the loop.\n     */\npublic static void loop() {\n    final Looper me = myLooper();\n    if (me == null) {\n        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#39;t called on this thread.&quot;);\n    }\n    //..............\n    final MessageQueue queue = me.mQueue;\n    for (;;) {\n        Message msg = queue.next(); // might block\n        if (msg == null) {\n            // No message indicates that the message queue is quitting.\n            return;\n        }\n        //..............\n        try {\n            msg.target.dispatchMessage(msg);\n        } catch (Exception exception) {\n            throw exception;\n        } finally {\n\n        }\n        // ...............\n        msg.recycleUnchecked();\n    }\n}\n</code></pre>\n<p>ActivityThread 中的 <code>main()</code> 方法，在最后一行，执行了我们的 <code>Looper.loop()</code> 方法， 进入后，我们可以看到 <code>loop()</code> 方法内部是一个死循环，当然，这里我们需要回顾一下 ActivityThread 帮我们初始化的 <code>prepareMainLooper()</code>  ，这也是系统帮我们创建的一个主线程<code>main</code> 。</p>\n<p>接下来就慢慢分析一下 <code>loop</code> 都做了什么事情</p>\n<p><img src=\"https://github.com/xiaomanwong/static_file/blob/master/images/loop%20for.png?raw=true?raw=true\" alt=\"looper.loop()\"></p>\n<p>从流程图上，我们简述了一下 <code>loop()</code> 方法，都做了些什么事情，下面就展开讲都做了什么</p>\n<ol>\n<li>首先获取当前线程的 looper 对象，如果不存在，则抛出异常</li>\n<li>接着获取当前 Looper 绑定的消息队列<code>MessageQueue</code></li>\n<li>进入循环，开始获取消息 <code>queue.next()</code></li>\n<li>调用 <code>msg.target.dispathMessage(msg)</code> 分发消息</li>\n<li>msg.recycleUnchecked()</li>\n</ol>\n<h2 id=\"Handler\"><a href=\"#Handler\" class=\"headerlink\" title=\"Handler\"></a>Handler</h2><p><strong>作用：</strong></p>\n<p><code>Handler</code> 暴露给开发这的功能一共就两块</p>\n<ul>\n<li>发送消息</li>\n<li>处理消息</li>\n</ul>\n<h3 id=\"发送消息\"><a href=\"#发送消息\" class=\"headerlink\" title=\"发送消息\"></a>发送消息</h3><ul>\n<li>sendMessage(Message msg)</li>\n<li>sendMessageEmpty()</li>\n<li>sendMessageAtTime(Message msg, long uptimeMillis)</li>\n<li>sendMessageDelay(Message msg, long delay)</li>\n<li>post(Runnable r)</li>\n<li>…</li>\n</ul>\n<p>所有的发送消息的方法，最终都会去执行<code>sendMessageAtTime(Message msg, long uptimeMillis)</code>, 当我们创建一个<code>Handler</code> 对象时, 会从当前线程的 Looper 中获取当前的消息队列<code>mQueue</code></p>\n<pre><code class=\"java\">public Handler(@Nullable Callback callback, boolean async) {\n        if (FIND_POTENTIAL_LEAKS) {\n            final Class&lt;? extends Handler&gt; klass = getClass();\n            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;\n                    (klass.getModifiers() &amp; Modifier.STATIC) == 0) {\n                Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +\n                    klass.getCanonicalName());\n            }\n        }\n\n        mLooper = Looper.myLooper();\n        if (mLooper == null) {\n            throw new RuntimeException(\n                &quot;Can&#39;t create handler inside thread &quot; + Thread.currentThread()\n                        + &quot; that has not called Looper.prepare()&quot;);\n        }\n        mQueue = mLooper.mQueue;\n        mCallback = callback;\n        mAsynchronous = async;\n    }\n</code></pre>\n<p>当我们开始发送一条消息时，调用 <code>sendMessageAtTime</code> ，会将消息压入到消息队列中，</p>\n<pre><code class=\"java\">final MessageQueue mQueue;\n\npublic boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) {\n        MessageQueue queue = mQueue;\n        if (queue == null) {\n            RuntimeException e = new RuntimeException(\n                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);\n            Log.w(&quot;Looper&quot;, e.getMessage(), e);\n            return false;\n        }\n        return enqueueMessage(queue, msg, uptimeMillis);\n    }\n\nprivate boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,\n            long uptimeMillis) {\n        msg.target = this;\n        msg.workSourceUid = ThreadLocalWorkSource.getUid();\n\n        if (mAsynchronous) {\n            msg.setAsynchronous(true);\n        }\n        return queue.enqueueMessage(msg, uptimeMillis);\n    }\n</code></pre>\n<p>通过源码我们看到，在压入队列前，我们会将当前的 <code>Handler</code> 对象赋值给 <code>Message</code> 中的 <code>target</code> ，这也就是为什么 <code>message</code> 中会持有 <code>Handler</code> 的引用的原因。</p>\n<h3 id=\"处理消息\"><a href=\"#处理消息\" class=\"headerlink\" title=\"处理消息\"></a>处理消息</h3><p>在说处理消息之前，我们先看一下 <code>Handler</code> 对<strong>消息的分发</strong></p>\n<pre><code class=\"Java\"> /**\n     * Handle system messages here.\n     */\n    public void dispatchMessage(@NonNull Message msg) {\n        if (msg.callback != null) {\n            handleCallback(msg);\n        } else {\n            if (mCallback != null) {\n                if (mCallback.handleMessage(msg)) {\n                    return;\n                }\n            }\n            handleMessage(msg);\n        }\n    }\n</code></pre>\n<ul>\n<li>当我们给 <code>Message</code> 设置了 <code>callback</code> 时，会直接触发 <code>Message</code> 的 <code>callback</code> 逻辑</li>\n<li>如果我们在创建 <code>Handler</code> 时，有设置过 <code>Callback</code> ，则会调用由我们传入进来的 <code>Callback</code> 方法</li>\n<li>如果以上两种情况都没有设置，那么会触发 <code>Handler</code> 自己 <code>handleMessage()</code> 方法</li>\n</ul>\n<pre><code class=\"java\">/**\n     * Subclasses must implement this to receive messages.\n     */\n    public void handleMessage(@NonNull Message msg) {\n    }\n</code></pre>\n<p>通过源码的注解我们可以看出，当我们继承/创建一个 <code>Handler</code> 时，需要我们必须去实现的一个方法（前提是你需要它）</p>\n<p><code>dispatchMessage</code> 最终时由 <code>loop()</code> 方法在拿取消息队列中的信息时，获取到 <code>Message</code> 对象， 通过 <code>Message</code> 持有的 <code>target</code> 调用。</p>\n<h3 id=\"移除消息\"><a href=\"#移除消息\" class=\"headerlink\" title=\"移除消息\"></a>移除消息</h3><p>这里我们需要注意，当我们使用 <code>Handler</code> 处理消息时，通常都是一些异步任务，这时创建 <code>Handler</code> 一般都为内部类，此时需要注意的是，在 Java 中，内部类是会持有外部类的引用， 那么在 Handler 中处理的消息如果长时间无法得到释放， 那么会造成 <code>Activity</code> 无法被回收的情况。处理这种情况的方案就是，在 <code>Activity</code> 销毁时，我们需要将 <code>Handler</code> 中的消息进行释放</p>\n<pre><code class=\"java\">    public final void removeCallbacksAndMessages(@Nullable Object token) {\n        mQueue.removeCallbacksAndMessages(this, token);\n    }\n</code></pre>\n<h2 id=\"Message\"><a href=\"#Message\" class=\"headerlink\" title=\"Message\"></a>Message</h2><p>一种消息的载体，其中包含 <code>handler</code> 对象和一个任意类型的对象以及两个 int 型的参数</p>\n<pre><code class=\"java\">public final class Message implements Parcelable {\n    /**\n     * 用户自定义的消息身份代码，每一个 Handler 都有它自己的命名空间，因此我们不需要担心会和其他的 Handler 混淆 \n     */\n    public int what;\n\n    /**\n     * arg1 and arg2 是一个低成本的替代方案，当我们只需要发送一些 int 型的数据时，可以使用， 避免使用 Object 增加内存的开销\n     */\n    public int arg1;\n\n     /**\n     * arg1 and arg2 是一个低成本的替代方案，当我们只需要发送一些 int 型的数据时，可以使用， 避免使用 Object 增加内存的开销\n     */\n    public int arg2;\n\n    /**\n     * 任意的消息类型载体，如果是序列化的数据，则一定不能为 null，其他的数据类型，可以使用 setData(Bundle bundle) \n     */\n    public Object obj;\n    /**\n     * 消息的执行时间\n     */\n    public long when;\n}\n</code></pre>\n<p><code>Message</code> 本身是一个<strong>链表</strong> 的数据结构，这种数据结构，在<code>MessageQueue</code> 中获取消息时，可以有效的针对 <code>Handler</code> 发送进来的消息进行排序。</p>\n<pre><code class=\"java\">    @UnsupportedAppUsage\n    /*package*/ Handler target;\n\n    @UnsupportedAppUsage\n    /*package*/ Runnable callback;\n\n    // sometimes we store linked lists of these things\n    @UnsupportedAppUsage\n    /*package*/ Message next;\n</code></pre>\n<p><code>Message</code> 持有了一个 <code>Handler</code> 对象，因此即使我们在同一个线程里面创建了多个 <code>Handler</code> 的对象， 也不会出现消息错乱的现象。</p>\n<p><strong>Callback</strong></p>\n<p>同时 Message 也支持设置 <code>Callback</code> 方便开发者在处理消息时可以快速的查看处理方案，但这种方法其实个人认为在开发阶段不适合使用。这会导致消息处理到处飞，不利于代码的管理。</p>\n<h4 id=\"构造器\"><a href=\"#构造器\" class=\"headerlink\" title=\"构造器\"></a>构造器</h4><pre><code class=\"java\">     private static Message sPool;\n    private static int sPoolSize = 0;\n\n    private static final int MAX_POOL_SIZE = 50;   \n\n    /** Constructor (but the preferred way to get a Message is to call {@link #obtain() Message.obtain()}).\n    */\n    public Message() {\n    }\n\n    public static Message obtain() {\n        synchronized (sPoolSync) {\n            if (sPool != null) {\n                Message m = sPool;\n                sPool = m.next;\n                m.next = null;\n                m.flags = 0; // clear in-use flag\n                sPoolSize--;\n                return m;\n            }\n        }\n        return new Message();\n    }\n</code></pre>\n<p><code>Message</code> 为我们提供了一个空的构造器去创建一个对象，但这种方案系统却不建议我们使用，而是建议我们通过 <code>obtain()</code> 函数去获取。通过 <code>obtain()</code> 函数我们可以看出， <code>Message</code> 自身维护了一个对象池，池的最大值为 50。因此我们不难看出，当我们通过空构造器去创建一个 <code>Message</code> 对象时，反而是增加了系统的内存开销，而 <code>Message</code> 为我们提供的利器得不到发挥。</p>\n<h4 id=\"回收\"><a href=\"#回收\" class=\"headerlink\" title=\"回收\"></a>回收</h4><pre><code class=\"java\">    public void recycle() {\n        if (isInUse()) {\n            if (gCheckRecycle) {\n                throw new IllegalStateException(&quot;This message cannot be recycled because it &quot;\n                        + &quot;is still in use.&quot;);\n            }\n            return;\n        }\n        recycleUnchecked();\n    }\n</code></pre>\n<p>当一个消息处于不在被使用（Handler 触发 remove 时），或已经使用完成（MessageQueue 触发），那么系统会清空 <code>Message</code> 中的全部内容，并将对象丢向消息池中，等待再次被使用( obtain())，当消息被回收时，我们不能在去调用它，否则会出现空指针的情况。</p>\n<h2 id=\"MessageQueue\"><a href=\"#MessageQueue\" class=\"headerlink\" title=\"MessageQueue\"></a>MessageQueue</h2><p>存放所有消息的容器，既然是 <code>Queue</code> 命名，那自然就是一个队列，拥有先入先出的特性，但消息的存放，并不是由其自己操作，而是通过与 <code>Looper</code> 关联的 <code>Handler</code> 添加</p>\n<h3 id=\"入队\"><a href=\"#入队\" class=\"headerlink\" title=\"入队\"></a>入队</h3><p>由 <code>Handler</code> 触发，将数据压入到队列中</p>\n<pre><code class=\"java\">boolean enqueueMessage(Message msg, long when) {\n\n\n        synchronized (this) {\n            msg.markInUse();\n            msg.when = when;\n            Message p = mMessages;\n            boolean needWake;\n            if (p == null || when == 0 || when &lt; p.when) {\n                // New head, wake up the event queue if blocked.\n                msg.next = p;\n                mMessages = msg;\n                needWake = mBlocked;\n            } else {\n                // Inserted within the middle of the queue.  Usually we don&#39;t have to wake\n                // up the event queue unless there is a barrier at the head of the queue\n                // and the message is the earliest asynchronous message in the queue.\n                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();\n                Message prev;\n                for (;;) {\n                    prev = p;\n                    p = p.next;\n                    if (p == null || when &lt; p.when) {\n                        break;\n                    }\n                    if (needWake &amp;&amp; p.isAsynchronous()) {\n                        needWake = false;\n                    }\n                }\n                msg.next = p; // invariant: p == prev.next\n                prev.next = msg;\n            }\n\n            // We can assume mPtr != 0 because mQuitting is false.\n            if (needWake) {\n                nativeWake(mPtr);\n            }\n        }\n        return true;\n    }\n</code></pre>\n<p>通过源码看出，在消息压入队列中时，发生了排序操作，</p>\n<p>当一条消息进来时，判断了如果当前队列内没有消息，或者传入的消息延时执行时间为0，或者传入的消息执行时间小于队列的第一条消息时，将 <code>Message</code> 放置在链表头部位置。否则则循环取出每条消息，依据消息的执行时间进行排序，将新消息压入到适当的位置。</p>\n<h3 id=\"出队\"><a href=\"#出队\" class=\"headerlink\" title=\"出队\"></a>出队</h3><pre><code class=\"java\">Message next() {\n\n    for (;;) {\n        if (nextPollTimeoutMillis != 0) {\n            Binder.flushPendingCommands();\n        }\n\n        nativePollOnce(ptr, nextPollTimeoutMillis);\n\n        synchronized (this) {\n            // Try to retrieve the next message.  Return if found.\n            final long now = SystemClock.uptimeMillis();\n            Message prevMsg = null;\n            Message msg = mMessages;\n            // 开启同步屏障，直到找到下一个异步消息结束，目的是优先执行异步消息\n            if (msg != null &amp;&amp; msg.target == null) {\n                // Stalled by a barrier.  Find the next asynchronous message in the queue.\n                do {\n                    prevMsg = msg;\n                    msg = msg.next;\n                } while (msg != null &amp;&amp; !msg.isAsynchronous());\n            }\n            if (msg != null) {\n                if (now &lt; msg.when) {\n                    // 为到执行时间，设置下一次系统唤醒消息需要的时间\n                    // Next message is not ready.  Set a timeout to wake up when it is ready.\n                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                } else {\n                    // Got a message.\n                    mBlocked = false;\n                    if (prevMsg != null) {\n                        // prevMsg ，即是同步消息，\n                        prevMsg.next = msg.next;\n                    } else {\n                        mMessages = msg.next;\n                    }\n                    msg.next = null;\n                    if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);\n                    msg.markInUse();\n                    return msg;\n                }\n            } else {\n                // No more messages.\n                nextPollTimeoutMillis = -1;\n            }\n        }\n    }\n}\n</code></pre>\n<h4 id=\"同步屏障\"><a href=\"#同步屏障\" class=\"headerlink\" title=\"同步屏障\"></a>同步屏障</h4><p>一般是由系统发出，多数情况是用来处理<code>View</code> 的刷新，由<code>ViewRootImpl</code> 调用 <code>postSyncBarrier</code>，将消息插入到链表的头部，我们可以注意到 <code>msg</code> 的 <code>target</code> 对象为空，因为 每一个 <code>Message</code> 对象都持有一个 target 对象，因此这里很不合常理，但这里就是系统的黑魔法，专门用来处理同步消息，因为同步消息的优先级高于所有异步消息。</p>\n<pre><code class=\"java\">private int postSyncBarrier(long when) {\n        // Enqueue a new sync barrier token.\n        // We don&#39;t need to wake the queue because the purpose of a barrier is to stall it.\n        synchronized (this) {\n            final int token = mNextBarrierToken++;\n            // 创建一个同步消息\n            final Message msg = Message.obtain();\n            msg.markInUse();\n            msg.when = when;\n            msg.arg1 = token;\n\n            Message prev = null;\n            Message p = mMessages;\n            if (when != 0) {\n                // 队列中的消息执行时间，排序，找到消息执行时间大于当前系统时间\n                while (p != null &amp;&amp; p.when &lt;= when) {\n                    prev = p;\n                    p = p.next;\n                }\n            }\n            if (prev != null) { // invariant: p == prev.next\n                // 断开链表，将同步消息，插入到要立即执行的消息后面\n                msg.next = p;\n                prev.next = msg;\n            } else {\n                // 没有要立即执行的消息，将同步消息插入到链表第一个节点\n                msg.next = p;\n                mMessages = msg;\n            }\n            return token;\n        }\n    }\n</code></pre>\n<p>当我们创建一个 Handler 时，默认创建的都是一个异步的（当然也可以创建同步的，调用对应的构造器就可以），因此在这里当收到一个同步消息时，<code>ViewRootImpl</code> 会，并给 msg 的 <code>target</code> 重新赋值，优先执行。直到找到一个异步消息为止</p>\n<p>当从队列中获取一条异步消息后，我们将消息取出来，并将消息的 next 置空断开链表，标记当前消息正在使用，并且返回。如果消息还没有到达执行的时间，则会通知系统去等待，设置下一次唤醒的时间。</p>\n<h3 id=\"退出\"><a href=\"#退出\" class=\"headerlink\" title=\"退出\"></a>退出</h3><p>由 <code>loop</code> 调用，当一个 loop 被销毁时，会触发该方法，用来清空内部所有消息,并回收</p>\n<pre><code class=\"java\">void quit(boolean safe) {\n        if (!mQuitAllowed) {\n            throw new IllegalStateException(&quot;Main thread not allowed to quit.&quot;);\n        }\n\n        synchronized (this) {\n            if (mQuitting) {\n                return;\n            }\n            mQuitting = true;\n\n            if (safe) {\n                removeAllFutureMessagesLocked();\n            } else {\n                removeAllMessagesLocked();\n            }\n\n            // We can assume mPtr != 0 because mQuitting was previously false.\n            nativeWake(mPtr);\n        }\n    }\n</code></pre>"},{"title":"Handler 线程通信基础流程","date":"2019-08-01T13:54:08.000Z","_content":"\n\nAndroid 中线程通信靠的就是 Handler、Looper、Message、MessageQueue 这四个。\n\n\n\n## Looper \n\n在 Looper 中，维持一个 Thread 对象以及 MessageQueue， 通过 Looper 的构造函数可以看出\n\n```java\nprivate Looper(boolean quitAllowed) {\n    mQueue = new MessageQueue(quitAllowed);// 传入的参数代表这个 Queue 是否能够被退出\n    mThread = Thread.currentThread();\n}\n```\n\nLooper 在构造函数里做了两件事儿：\n\n1. 将线程对象指向了创建的 Looper 的线程\n2. 创建了一个新的  MessageQueue\n\n分析完构造函数后，看下面两个方法\n\n1. looper.loop()\n2. looper.prepare()\n\n<!--more-->\n\n### looper.loop()\n\n在当前线程中启动一个 Message loop 机制\n\n```Java\npublic static void loop(){\n    final Looper me = myLooper();// 获取当前线程绑定的 Looper\n    if(me == null) {\n\t\tthrow new RuntimeException(\"No Looper; Looper.prepare() wasn`t called on this thread\");        \n    }\n    final MessageQueue queue = me.mQueue();// 获取与 Looper 绑定的 MessageQueue\n    // make sure the identity of this thread is that of the local process,\n    // And keep track of what that identity token actuall is.\n    Binder.clearCallingIdentity();\n    fianl long ident = Binder.clearCallingIdentity();\n    \n    // 进入死循环，不断获取对象，分发对象到 Handler 中去消费\n    for(;;) {\n        Message msg = queue.next();// 不断获取下一个 message 对象，这里可能会造成阻塞。\n        if(msg == null) {\n            // No message idicates that the message queue is quittig.\n            return;\n        }\n        \n        // This must be in a local variable, in case a UI event sets the logger\n        Printer logging = me.mLogging;\n        if(logging != null) {\n            logging.println(\">>> Dispatching to \" + msg.target + \" \" + msg.callback _ \": \" + msg.what);\n        }\n        \n        // 在这里开始分发 Message \n        msg.target.dispatchMessage(msg);\n        \n        if(logging != null) {\n            logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);\n        }\n        \n        // Make sure that during the course of dispatching the identity of the thread wasn`t corrupted.\n        \n        final long newIdent = Binder.clearCallingIdentity();\n        if(ident != null) {\n            Log.wtf(TAG, \"Thread identity changed from 0x\"\n                        + Long.toHexString(ident) + \" to 0x\"\n                        + Long.toHexString(newIdent) + \" while dispatching to \"\n                        + msg.target.getClass().getName() + \" \"\n                        + msg.callback + \" what=\" + msg.what);\n        }\n        // 当分发完 Message 后，当然要标记将该 Message 为 “正在使用”\n        msg.recycleUnchecked();\n    }\n}\n```\n\n从上面的代码可以看出，最重要的方法是：\n\n1. `queue.next()`\n2. `msg.target.dispatchMessage(msg)`\n3. `msg.recycleUnchecked()`\n\n其实 Looper 中最重要的部分都是由 Message、MessageQueue 组成的，这段代码设计到的四个对象，他们彼此的关系如下:\n\n1. MessageQueue： 装食物的容器\n2. Message ：被装的食物\n3. Handler （msg.target 实际上就是 Handler）：食物的消费者\n4. Looper：负责分发食物的人\n\n\n\n### looper.prepare() 在当前线程关联一个 Lopper 对象\n\n```java\nprivate static void prepare(boolean quitAllowed) {\n    if(sThreadLocal.get() != null) {\n        throw new RuntimeException(\"Only one Lopper may be created per thread\");\n    }\n    \n    // 在当前线程绑定一个 looper\n    mThreadLocal.set(new Looper(quiteAllowed));\n}\n```\n\n在上面的代码中，做了两件事儿：\n\n1. 判断当前线程有没有 Looper，如果有则抛出异常（在这里我们就可以知道，Android 规定一个线程只能拥有一个与自己关联的 Looper。\n2. 如果有的话，那么就设置一个新的 Looper 到当前线程。\n\n### Handler 的使用\n\n```java\nHandler handler = new Handler (){\n    // \n    @Override\n    public void handleMessage(Message msg) {\n        // handle your message\n    }\n}\n```\n\n我们先来看下 Handler 的构造：\n\n```java\n// 空参构造与之对应\npublic Handler(Callback callbacck, boolean async) {\n    // 大姨泄漏提醒log\n    ...\n    // 获取与创建 Handler 线程的 Looper\n    mLooper = Looper.myLooper();\n    if(mLooper == null) {\n        throw new RunntimeException(\"Can`t create handler inside thread that has not called Looper.prepare()\");\n    }\n    \n    // 获取 Looper 绑定的 MessageQueue\n    // 因为一个 Looper 只有一个 MessageQueue， 也就是与当前线程绑定的 MessageQueue\n    mQueue = mLooper.mQueue;\n    mCallback = callback;\n    mAsynchronous = async;\n}\n```\n\n1. Looper.loop() 死循环中的 msg.target 是什么时候被赋值的？\n2. handler.handleMessage(msg) 在什么时候被回调的？\n\n\n\n**A1:** Looper.loop() 死循环中的 msg.target 是什么赋值的呢？要分析这个问题，自然的就想到从发送消息开始，无论是 handler.sendMessage(msg)  还是 handler.sendEmptyMessage(what)， 最后都可以追溯到下面这个方法：\n\n```java\npublic boolean sendMessageAtTime(Message msg, long uptimeMillis) {\n    // 引用 Handler 中的 MessageQueue\n    // 这个 MessageQueue 就是创建 Looper 时被创建的 MessageQueue\n    MessageQueue queue = mQueue;\n    \n    if(queue == null) {\n        RuntimeException e = new RuntimeException(\n        this + \" sendMessageAtTime() called withe no mQueue\");\n        Log.w(\"Looper\", e.getMessage(), e);\n        return false;\n    }\n    // 将新来的 Message 加入到 MessageQueue 中\n    return enqueueMessage(queue, msg, uptimeMillis);\n}\n```\n\n接下来看一下 `enququeMessage(queue, msg, uptimeMillis)`:\n\n```java\nprivate boolean enququeMessage(MessageQueue, queue, Message msg, long uptimeMillis) {\n   \tmsg.target = this;\n   \tif(mAsynchronous) {\n        msg.setAsynchronous(true);\n   \t}\n   \treturn queue.enqueueMessage(msg, uptimeMillis);\n}\n```\n\n\n\n**A2**:  handler.handleMessage(msg) 在什么时候被回调？通过上面的分析，我们很明确知道， Message 中的 target 是在什么时候赋值的，我们先来分析下在 Looper.loop() 中出现过的 dispatchMessage(msg) 方法\n\n```Java\npublic void diapatchMessage(Message msg) {\n    if(msg.callback != null) {\n        handleCallback(msg);\n    } else {\n        if(mCallback != null) {\n            if(mCallback.handleMessage(msg)) {\n                return;\n            }\n        }\n        handleMessage(msg); // 开始回调\n    }\n}\n```\n\n通过上面的分析，可以清楚的知道 Handler, Looper, Message, MessageQueue 这四者的关系以及如何合作了。\n\n\n\n## 总结\n\n当我们调用 handler.sendMessage(msg)； 方法发送一个 Message 时， 实际上这个 Message 是发送到与当前线程绑定的一个 MessageQueue 中，然后与当前线程绑定的 Looper 将会不断的从 MessageQueue 中取出新的 Message， 调用 msg.target.dispatchMessage(msg) 方法将消息发送到与 Message 绑定的 handler.handleMessage() 方法中。\n\n一个 Thread 对应多个 Handler， 一个 Thread 对应一个 Looper 和 MessageQueue， Handler 与 Thread 共享 Looper 和 MessageQueue。 Message 只是消息的载体，将会被发送到与线程绑定的唯一的 MessageQueue 中，并且被与线程绑定的唯一的 Looper 分发，被其自身绑定的 Handler 消费。\n\n","source":"_posts/Android 基础/原理/Handler 线程通信基础流程.md","raw":"---\ntitle: Handler 线程通信基础流程\ndate: 2019-08-01 21:54:08\ntags: Handler\n---\n\n\nAndroid 中线程通信靠的就是 Handler、Looper、Message、MessageQueue 这四个。\n\n\n\n## Looper \n\n在 Looper 中，维持一个 Thread 对象以及 MessageQueue， 通过 Looper 的构造函数可以看出\n\n```java\nprivate Looper(boolean quitAllowed) {\n    mQueue = new MessageQueue(quitAllowed);// 传入的参数代表这个 Queue 是否能够被退出\n    mThread = Thread.currentThread();\n}\n```\n\nLooper 在构造函数里做了两件事儿：\n\n1. 将线程对象指向了创建的 Looper 的线程\n2. 创建了一个新的  MessageQueue\n\n分析完构造函数后，看下面两个方法\n\n1. looper.loop()\n2. looper.prepare()\n\n<!--more-->\n\n### looper.loop()\n\n在当前线程中启动一个 Message loop 机制\n\n```Java\npublic static void loop(){\n    final Looper me = myLooper();// 获取当前线程绑定的 Looper\n    if(me == null) {\n\t\tthrow new RuntimeException(\"No Looper; Looper.prepare() wasn`t called on this thread\");        \n    }\n    final MessageQueue queue = me.mQueue();// 获取与 Looper 绑定的 MessageQueue\n    // make sure the identity of this thread is that of the local process,\n    // And keep track of what that identity token actuall is.\n    Binder.clearCallingIdentity();\n    fianl long ident = Binder.clearCallingIdentity();\n    \n    // 进入死循环，不断获取对象，分发对象到 Handler 中去消费\n    for(;;) {\n        Message msg = queue.next();// 不断获取下一个 message 对象，这里可能会造成阻塞。\n        if(msg == null) {\n            // No message idicates that the message queue is quittig.\n            return;\n        }\n        \n        // This must be in a local variable, in case a UI event sets the logger\n        Printer logging = me.mLogging;\n        if(logging != null) {\n            logging.println(\">>> Dispatching to \" + msg.target + \" \" + msg.callback _ \": \" + msg.what);\n        }\n        \n        // 在这里开始分发 Message \n        msg.target.dispatchMessage(msg);\n        \n        if(logging != null) {\n            logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);\n        }\n        \n        // Make sure that during the course of dispatching the identity of the thread wasn`t corrupted.\n        \n        final long newIdent = Binder.clearCallingIdentity();\n        if(ident != null) {\n            Log.wtf(TAG, \"Thread identity changed from 0x\"\n                        + Long.toHexString(ident) + \" to 0x\"\n                        + Long.toHexString(newIdent) + \" while dispatching to \"\n                        + msg.target.getClass().getName() + \" \"\n                        + msg.callback + \" what=\" + msg.what);\n        }\n        // 当分发完 Message 后，当然要标记将该 Message 为 “正在使用”\n        msg.recycleUnchecked();\n    }\n}\n```\n\n从上面的代码可以看出，最重要的方法是：\n\n1. `queue.next()`\n2. `msg.target.dispatchMessage(msg)`\n3. `msg.recycleUnchecked()`\n\n其实 Looper 中最重要的部分都是由 Message、MessageQueue 组成的，这段代码设计到的四个对象，他们彼此的关系如下:\n\n1. MessageQueue： 装食物的容器\n2. Message ：被装的食物\n3. Handler （msg.target 实际上就是 Handler）：食物的消费者\n4. Looper：负责分发食物的人\n\n\n\n### looper.prepare() 在当前线程关联一个 Lopper 对象\n\n```java\nprivate static void prepare(boolean quitAllowed) {\n    if(sThreadLocal.get() != null) {\n        throw new RuntimeException(\"Only one Lopper may be created per thread\");\n    }\n    \n    // 在当前线程绑定一个 looper\n    mThreadLocal.set(new Looper(quiteAllowed));\n}\n```\n\n在上面的代码中，做了两件事儿：\n\n1. 判断当前线程有没有 Looper，如果有则抛出异常（在这里我们就可以知道，Android 规定一个线程只能拥有一个与自己关联的 Looper。\n2. 如果有的话，那么就设置一个新的 Looper 到当前线程。\n\n### Handler 的使用\n\n```java\nHandler handler = new Handler (){\n    // \n    @Override\n    public void handleMessage(Message msg) {\n        // handle your message\n    }\n}\n```\n\n我们先来看下 Handler 的构造：\n\n```java\n// 空参构造与之对应\npublic Handler(Callback callbacck, boolean async) {\n    // 大姨泄漏提醒log\n    ...\n    // 获取与创建 Handler 线程的 Looper\n    mLooper = Looper.myLooper();\n    if(mLooper == null) {\n        throw new RunntimeException(\"Can`t create handler inside thread that has not called Looper.prepare()\");\n    }\n    \n    // 获取 Looper 绑定的 MessageQueue\n    // 因为一个 Looper 只有一个 MessageQueue， 也就是与当前线程绑定的 MessageQueue\n    mQueue = mLooper.mQueue;\n    mCallback = callback;\n    mAsynchronous = async;\n}\n```\n\n1. Looper.loop() 死循环中的 msg.target 是什么时候被赋值的？\n2. handler.handleMessage(msg) 在什么时候被回调的？\n\n\n\n**A1:** Looper.loop() 死循环中的 msg.target 是什么赋值的呢？要分析这个问题，自然的就想到从发送消息开始，无论是 handler.sendMessage(msg)  还是 handler.sendEmptyMessage(what)， 最后都可以追溯到下面这个方法：\n\n```java\npublic boolean sendMessageAtTime(Message msg, long uptimeMillis) {\n    // 引用 Handler 中的 MessageQueue\n    // 这个 MessageQueue 就是创建 Looper 时被创建的 MessageQueue\n    MessageQueue queue = mQueue;\n    \n    if(queue == null) {\n        RuntimeException e = new RuntimeException(\n        this + \" sendMessageAtTime() called withe no mQueue\");\n        Log.w(\"Looper\", e.getMessage(), e);\n        return false;\n    }\n    // 将新来的 Message 加入到 MessageQueue 中\n    return enqueueMessage(queue, msg, uptimeMillis);\n}\n```\n\n接下来看一下 `enququeMessage(queue, msg, uptimeMillis)`:\n\n```java\nprivate boolean enququeMessage(MessageQueue, queue, Message msg, long uptimeMillis) {\n   \tmsg.target = this;\n   \tif(mAsynchronous) {\n        msg.setAsynchronous(true);\n   \t}\n   \treturn queue.enqueueMessage(msg, uptimeMillis);\n}\n```\n\n\n\n**A2**:  handler.handleMessage(msg) 在什么时候被回调？通过上面的分析，我们很明确知道， Message 中的 target 是在什么时候赋值的，我们先来分析下在 Looper.loop() 中出现过的 dispatchMessage(msg) 方法\n\n```Java\npublic void diapatchMessage(Message msg) {\n    if(msg.callback != null) {\n        handleCallback(msg);\n    } else {\n        if(mCallback != null) {\n            if(mCallback.handleMessage(msg)) {\n                return;\n            }\n        }\n        handleMessage(msg); // 开始回调\n    }\n}\n```\n\n通过上面的分析，可以清楚的知道 Handler, Looper, Message, MessageQueue 这四者的关系以及如何合作了。\n\n\n\n## 总结\n\n当我们调用 handler.sendMessage(msg)； 方法发送一个 Message 时， 实际上这个 Message 是发送到与当前线程绑定的一个 MessageQueue 中，然后与当前线程绑定的 Looper 将会不断的从 MessageQueue 中取出新的 Message， 调用 msg.target.dispatchMessage(msg) 方法将消息发送到与 Message 绑定的 handler.handleMessage() 方法中。\n\n一个 Thread 对应多个 Handler， 一个 Thread 对应一个 Looper 和 MessageQueue， Handler 与 Thread 共享 Looper 和 MessageQueue。 Message 只是消息的载体，将会被发送到与线程绑定的唯一的 MessageQueue 中，并且被与线程绑定的唯一的 Looper 分发，被其自身绑定的 Handler 消费。\n\n","slug":"Android 基础/原理/Handler 线程通信基础流程","published":1,"updated":"2021-01-29T15:54:28.303Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8kg0036sz5qq6qghm0l","content":"<p>Android 中线程通信靠的就是 Handler、Looper、Message、MessageQueue 这四个。</p>\n<h2 id=\"Looper\"><a href=\"#Looper\" class=\"headerlink\" title=\"Looper\"></a>Looper</h2><p>在 Looper 中，维持一个 Thread 对象以及 MessageQueue， 通过 Looper 的构造函数可以看出</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token function\">Looper</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span> quitAllowed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    mQueue <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MessageQueue</span><span class=\"token punctuation\">(</span>quitAllowed<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// 传入的参数代表这个 Queue 是否能够被退出</span>\n    mThread <span class=\"token operator\">=</span> Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>Looper 在构造函数里做了两件事儿：</p>\n<ol>\n<li>将线程对象指向了创建的 Looper 的线程</li>\n<li>创建了一个新的  MessageQueue</li>\n</ol>\n<p>分析完构造函数后，看下面两个方法</p>\n<ol>\n<li>looper.loop()</li>\n<li>looper.prepare()</li>\n</ol>\n<a id=\"more\"></a>\n<h3 id=\"looper-loop\"><a href=\"#looper-loop\" class=\"headerlink\" title=\"looper.loop()\"></a>looper.loop()</h3><p>在当前线程中启动一个 Message loop 机制</p>\n<pre class=\" language-Java\"><code class=\"language-Java\">public static void loop(){\n    final Looper me = myLooper();// 获取当前线程绑定的 Looper\n    if(me == null) {\n        throw new RuntimeException(\"No Looper; Looper.prepare() wasn`t called on this thread\");        \n    }\n    final MessageQueue queue = me.mQueue();// 获取与 Looper 绑定的 MessageQueue\n    // make sure the identity of this thread is that of the local process,\n    // And keep track of what that identity token actuall is.\n    Binder.clearCallingIdentity();\n    fianl long ident = Binder.clearCallingIdentity();\n\n    // 进入死循环，不断获取对象，分发对象到 Handler 中去消费\n    for(;;) {\n        Message msg = queue.next();// 不断获取下一个 message 对象，这里可能会造成阻塞。\n        if(msg == null) {\n            // No message idicates that the message queue is quittig.\n            return;\n        }\n\n        // This must be in a local variable, in case a UI event sets the logger\n        Printer logging = me.mLogging;\n        if(logging != null) {\n            logging.println(\">>> Dispatching to \" + msg.target + \" \" + msg.callback _ \": \" + msg.what);\n        }\n\n        // 在这里开始分发 Message \n        msg.target.dispatchMessage(msg);\n\n        if(logging != null) {\n            logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);\n        }\n\n        // Make sure that during the course of dispatching the identity of the thread wasn`t corrupted.\n\n        final long newIdent = Binder.clearCallingIdentity();\n        if(ident != null) {\n            Log.wtf(TAG, \"Thread identity changed from 0x\"\n                        + Long.toHexString(ident) + \" to 0x\"\n                        + Long.toHexString(newIdent) + \" while dispatching to \"\n                        + msg.target.getClass().getName() + \" \"\n                        + msg.callback + \" what=\" + msg.what);\n        }\n        // 当分发完 Message 后，当然要标记将该 Message 为 “正在使用”\n        msg.recycleUnchecked();\n    }\n}\n</code></pre>\n<p>从上面的代码可以看出，最重要的方法是：</p>\n<ol>\n<li><code>queue.next()</code></li>\n<li><code>msg.target.dispatchMessage(msg)</code></li>\n<li><code>msg.recycleUnchecked()</code></li>\n</ol>\n<p>其实 Looper 中最重要的部分都是由 Message、MessageQueue 组成的，这段代码设计到的四个对象，他们彼此的关系如下:</p>\n<ol>\n<li>MessageQueue： 装食物的容器</li>\n<li>Message ：被装的食物</li>\n<li>Handler （msg.target 实际上就是 Handler）：食物的消费者</li>\n<li>Looper：负责分发食物的人</li>\n</ol>\n<h3 id=\"looper-prepare-在当前线程关联一个-Lopper-对象\"><a href=\"#looper-prepare-在当前线程关联一个-Lopper-对象\" class=\"headerlink\" title=\"looper.prepare() 在当前线程关联一个 Lopper 对象\"></a>looper.prepare() 在当前线程关联一个 Lopper 对象</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">prepare</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span> quitAllowed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>sThreadLocal<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Only one Lopper may be created per thread\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 在当前线程绑定一个 looper</span>\n    mThreadLocal<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Looper</span><span class=\"token punctuation\">(</span>quiteAllowed<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>在上面的代码中，做了两件事儿：</p>\n<ol>\n<li>判断当前线程有没有 Looper，如果有则抛出异常（在这里我们就可以知道，Android 规定一个线程只能拥有一个与自己关联的 Looper。</li>\n<li>如果有的话，那么就设置一个新的 Looper 到当前线程。</li>\n</ol>\n<h3 id=\"Handler-的使用\"><a href=\"#Handler-的使用\" class=\"headerlink\" title=\"Handler 的使用\"></a>Handler 的使用</h3><pre class=\" language-java\"><code class=\"language-java\">Handler handler <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Handler</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// </span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">handleMessage</span><span class=\"token punctuation\">(</span>Message msg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// handle your message</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>我们先来看下 Handler 的构造：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// 空参构造与之对应</span>\n<span class=\"token keyword\">public</span> <span class=\"token function\">Handler</span><span class=\"token punctuation\">(</span>Callback callbacck<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> async<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 大姨泄漏提醒log</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 获取与创建 Handler 线程的 Looper</span>\n    mLooper <span class=\"token operator\">=</span> Looper<span class=\"token punctuation\">.</span><span class=\"token function\">myLooper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mLooper <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RunntimeException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Can`t create handler inside thread that has not called Looper.prepare()\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 获取 Looper 绑定的 MessageQueue</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 因为一个 Looper 只有一个 MessageQueue， 也就是与当前线程绑定的 MessageQueue</span>\n    mQueue <span class=\"token operator\">=</span> mLooper<span class=\"token punctuation\">.</span>mQueue<span class=\"token punctuation\">;</span>\n    mCallback <span class=\"token operator\">=</span> callback<span class=\"token punctuation\">;</span>\n    mAsynchronous <span class=\"token operator\">=</span> async<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<ol>\n<li>Looper.loop() 死循环中的 msg.target 是什么时候被赋值的？</li>\n<li>handler.handleMessage(msg) 在什么时候被回调的？</li>\n</ol>\n<p><strong>A1:</strong> Looper.loop() 死循环中的 msg.target 是什么赋值的呢？要分析这个问题，自然的就想到从发送消息开始，无论是 handler.sendMessage(msg)  还是 handler.sendEmptyMessage(what)， 最后都可以追溯到下面这个方法：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">sendMessageAtTime</span><span class=\"token punctuation\">(</span>Message msg<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> uptimeMillis<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 引用 Handler 中的 MessageQueue</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 这个 MessageQueue 就是创建 Looper 时被创建的 MessageQueue</span>\n    MessageQueue queue <span class=\"token operator\">=</span> mQueue<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>queue <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        RuntimeException e <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">(</span>\n        <span class=\"token keyword\">this</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" sendMessageAtTime() called withe no mQueue\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Log<span class=\"token punctuation\">.</span><span class=\"token function\">w</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Looper\"</span><span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">.</span><span class=\"token function\">getMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 将新来的 Message 加入到 MessageQueue 中</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">enqueueMessage</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">,</span> msg<span class=\"token punctuation\">,</span> uptimeMillis<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>接下来看一下 <code>enququeMessage(queue, msg, uptimeMillis)</code>:</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">enququeMessage</span><span class=\"token punctuation\">(</span>MessageQueue<span class=\"token punctuation\">,</span> queue<span class=\"token punctuation\">,</span> Message msg<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> uptimeMillis<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       msg<span class=\"token punctuation\">.</span>target <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n       <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mAsynchronous<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        msg<span class=\"token punctuation\">.</span><span class=\"token function\">setAsynchronous</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       <span class=\"token punctuation\">}</span>\n       <span class=\"token keyword\">return</span> queue<span class=\"token punctuation\">.</span><span class=\"token function\">enqueueMessage</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">,</span> uptimeMillis<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>A2</strong>:  handler.handleMessage(msg) 在什么时候被回调？通过上面的分析，我们很明确知道， Message 中的 target 是在什么时候赋值的，我们先来分析下在 Looper.loop() 中出现过的 dispatchMessage(msg) 方法</p>\n<pre class=\" language-Java\"><code class=\"language-Java\">public void diapatchMessage(Message msg) {\n    if(msg.callback != null) {\n        handleCallback(msg);\n    } else {\n        if(mCallback != null) {\n            if(mCallback.handleMessage(msg)) {\n                return;\n            }\n        }\n        handleMessage(msg); // 开始回调\n    }\n}\n</code></pre>\n<p>通过上面的分析，可以清楚的知道 Handler, Looper, Message, MessageQueue 这四者的关系以及如何合作了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>当我们调用 handler.sendMessage(msg)； 方法发送一个 Message 时， 实际上这个 Message 是发送到与当前线程绑定的一个 MessageQueue 中，然后与当前线程绑定的 Looper 将会不断的从 MessageQueue 中取出新的 Message， 调用 msg.target.dispatchMessage(msg) 方法将消息发送到与 Message 绑定的 handler.handleMessage() 方法中。</p>\n<p>一个 Thread 对应多个 Handler， 一个 Thread 对应一个 Looper 和 MessageQueue， Handler 与 Thread 共享 Looper 和 MessageQueue。 Message 只是消息的载体，将会被发送到与线程绑定的唯一的 MessageQueue 中，并且被与线程绑定的唯一的 Looper 分发，被其自身绑定的 Handler 消费。</p>\n","site":{"data":{}},"excerpt":"<p>Android 中线程通信靠的就是 Handler、Looper、Message、MessageQueue 这四个。</p>\n<h2 id=\"Looper\"><a href=\"#Looper\" class=\"headerlink\" title=\"Looper\"></a>Looper</h2><p>在 Looper 中，维持一个 Thread 对象以及 MessageQueue， 通过 Looper 的构造函数可以看出</p>\n<pre><code class=\"java\">private Looper(boolean quitAllowed) {\n    mQueue = new MessageQueue(quitAllowed);// 传入的参数代表这个 Queue 是否能够被退出\n    mThread = Thread.currentThread();\n}\n</code></pre>\n<p>Looper 在构造函数里做了两件事儿：</p>\n<ol>\n<li>将线程对象指向了创建的 Looper 的线程</li>\n<li>创建了一个新的  MessageQueue</li>\n</ol>\n<p>分析完构造函数后，看下面两个方法</p>\n<ol>\n<li>looper.loop()</li>\n<li>looper.prepare()</li>\n</ol>","more":"<h3 id=\"looper-loop\"><a href=\"#looper-loop\" class=\"headerlink\" title=\"looper.loop()\"></a>looper.loop()</h3><p>在当前线程中启动一个 Message loop 机制</p>\n<pre><code class=\"Java\">public static void loop(){\n    final Looper me = myLooper();// 获取当前线程绑定的 Looper\n    if(me == null) {\n        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn`t called on this thread&quot;);        \n    }\n    final MessageQueue queue = me.mQueue();// 获取与 Looper 绑定的 MessageQueue\n    // make sure the identity of this thread is that of the local process,\n    // And keep track of what that identity token actuall is.\n    Binder.clearCallingIdentity();\n    fianl long ident = Binder.clearCallingIdentity();\n\n    // 进入死循环，不断获取对象，分发对象到 Handler 中去消费\n    for(;;) {\n        Message msg = queue.next();// 不断获取下一个 message 对象，这里可能会造成阻塞。\n        if(msg == null) {\n            // No message idicates that the message queue is quittig.\n            return;\n        }\n\n        // This must be in a local variable, in case a UI event sets the logger\n        Printer logging = me.mLogging;\n        if(logging != null) {\n            logging.println(&quot;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback _ &quot;: &quot; + msg.what);\n        }\n\n        // 在这里开始分发 Message \n        msg.target.dispatchMessage(msg);\n\n        if(logging != null) {\n            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);\n        }\n\n        // Make sure that during the course of dispatching the identity of the thread wasn`t corrupted.\n\n        final long newIdent = Binder.clearCallingIdentity();\n        if(ident != null) {\n            Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;\n                        + Long.toHexString(ident) + &quot; to 0x&quot;\n                        + Long.toHexString(newIdent) + &quot; while dispatching to &quot;\n                        + msg.target.getClass().getName() + &quot; &quot;\n                        + msg.callback + &quot; what=&quot; + msg.what);\n        }\n        // 当分发完 Message 后，当然要标记将该 Message 为 “正在使用”\n        msg.recycleUnchecked();\n    }\n}\n</code></pre>\n<p>从上面的代码可以看出，最重要的方法是：</p>\n<ol>\n<li><code>queue.next()</code></li>\n<li><code>msg.target.dispatchMessage(msg)</code></li>\n<li><code>msg.recycleUnchecked()</code></li>\n</ol>\n<p>其实 Looper 中最重要的部分都是由 Message、MessageQueue 组成的，这段代码设计到的四个对象，他们彼此的关系如下:</p>\n<ol>\n<li>MessageQueue： 装食物的容器</li>\n<li>Message ：被装的食物</li>\n<li>Handler （msg.target 实际上就是 Handler）：食物的消费者</li>\n<li>Looper：负责分发食物的人</li>\n</ol>\n<h3 id=\"looper-prepare-在当前线程关联一个-Lopper-对象\"><a href=\"#looper-prepare-在当前线程关联一个-Lopper-对象\" class=\"headerlink\" title=\"looper.prepare() 在当前线程关联一个 Lopper 对象\"></a>looper.prepare() 在当前线程关联一个 Lopper 对象</h3><pre><code class=\"java\">private static void prepare(boolean quitAllowed) {\n    if(sThreadLocal.get() != null) {\n        throw new RuntimeException(&quot;Only one Lopper may be created per thread&quot;);\n    }\n\n    // 在当前线程绑定一个 looper\n    mThreadLocal.set(new Looper(quiteAllowed));\n}\n</code></pre>\n<p>在上面的代码中，做了两件事儿：</p>\n<ol>\n<li>判断当前线程有没有 Looper，如果有则抛出异常（在这里我们就可以知道，Android 规定一个线程只能拥有一个与自己关联的 Looper。</li>\n<li>如果有的话，那么就设置一个新的 Looper 到当前线程。</li>\n</ol>\n<h3 id=\"Handler-的使用\"><a href=\"#Handler-的使用\" class=\"headerlink\" title=\"Handler 的使用\"></a>Handler 的使用</h3><pre><code class=\"java\">Handler handler = new Handler (){\n    // \n    @Override\n    public void handleMessage(Message msg) {\n        // handle your message\n    }\n}\n</code></pre>\n<p>我们先来看下 Handler 的构造：</p>\n<pre><code class=\"java\">// 空参构造与之对应\npublic Handler(Callback callbacck, boolean async) {\n    // 大姨泄漏提醒log\n    ...\n    // 获取与创建 Handler 线程的 Looper\n    mLooper = Looper.myLooper();\n    if(mLooper == null) {\n        throw new RunntimeException(&quot;Can`t create handler inside thread that has not called Looper.prepare()&quot;);\n    }\n\n    // 获取 Looper 绑定的 MessageQueue\n    // 因为一个 Looper 只有一个 MessageQueue， 也就是与当前线程绑定的 MessageQueue\n    mQueue = mLooper.mQueue;\n    mCallback = callback;\n    mAsynchronous = async;\n}\n</code></pre>\n<ol>\n<li>Looper.loop() 死循环中的 msg.target 是什么时候被赋值的？</li>\n<li>handler.handleMessage(msg) 在什么时候被回调的？</li>\n</ol>\n<p><strong>A1:</strong> Looper.loop() 死循环中的 msg.target 是什么赋值的呢？要分析这个问题，自然的就想到从发送消息开始，无论是 handler.sendMessage(msg)  还是 handler.sendEmptyMessage(what)， 最后都可以追溯到下面这个方法：</p>\n<pre><code class=\"java\">public boolean sendMessageAtTime(Message msg, long uptimeMillis) {\n    // 引用 Handler 中的 MessageQueue\n    // 这个 MessageQueue 就是创建 Looper 时被创建的 MessageQueue\n    MessageQueue queue = mQueue;\n\n    if(queue == null) {\n        RuntimeException e = new RuntimeException(\n        this + &quot; sendMessageAtTime() called withe no mQueue&quot;);\n        Log.w(&quot;Looper&quot;, e.getMessage(), e);\n        return false;\n    }\n    // 将新来的 Message 加入到 MessageQueue 中\n    return enqueueMessage(queue, msg, uptimeMillis);\n}\n</code></pre>\n<p>接下来看一下 <code>enququeMessage(queue, msg, uptimeMillis)</code>:</p>\n<pre><code class=\"java\">private boolean enququeMessage(MessageQueue, queue, Message msg, long uptimeMillis) {\n       msg.target = this;\n       if(mAsynchronous) {\n        msg.setAsynchronous(true);\n       }\n       return queue.enqueueMessage(msg, uptimeMillis);\n}\n</code></pre>\n<p><strong>A2</strong>:  handler.handleMessage(msg) 在什么时候被回调？通过上面的分析，我们很明确知道， Message 中的 target 是在什么时候赋值的，我们先来分析下在 Looper.loop() 中出现过的 dispatchMessage(msg) 方法</p>\n<pre><code class=\"Java\">public void diapatchMessage(Message msg) {\n    if(msg.callback != null) {\n        handleCallback(msg);\n    } else {\n        if(mCallback != null) {\n            if(mCallback.handleMessage(msg)) {\n                return;\n            }\n        }\n        handleMessage(msg); // 开始回调\n    }\n}\n</code></pre>\n<p>通过上面的分析，可以清楚的知道 Handler, Looper, Message, MessageQueue 这四者的关系以及如何合作了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>当我们调用 handler.sendMessage(msg)； 方法发送一个 Message 时， 实际上这个 Message 是发送到与当前线程绑定的一个 MessageQueue 中，然后与当前线程绑定的 Looper 将会不断的从 MessageQueue 中取出新的 Message， 调用 msg.target.dispatchMessage(msg) 方法将消息发送到与 Message 绑定的 handler.handleMessage() 方法中。</p>\n<p>一个 Thread 对应多个 Handler， 一个 Thread 对应一个 Looper 和 MessageQueue， Handler 与 Thread 共享 Looper 和 MessageQueue。 Message 只是消息的载体，将会被发送到与线程绑定的唯一的 MessageQueue 中，并且被与线程绑定的唯一的 Looper 分发，被其自身绑定的 Handler 消费。</p>"},{"title":"Android 屏幕适配","_content":"\n\n\n## 为什么要适配\n\n由于 Android 系统的开放性，任何用户、开发者、 OEM 厂商、运营商都可以对 Android 进行定制，于是导致运行 Android 的设备多种多样，他们有着不同的屏幕尺寸和像素密度。\n\n尽管系统可以通过基本的缩放和调整大小使得界面适配不同的屏幕，但进一步优化，可以确保界面能够在各类屏幕上美观的呈现。\n\n![image-20210128142240773](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128142240773.png)\n\n## 基本概念\n\n### 屏幕尺寸\n\n屏幕尺寸指 **屏幕对角线的长度**，单位是 *英寸*，一英寸 = 2.54 厘米\n\n> 常见的 Android 设备尺寸有 2.4 、 2.8、3.5、3.7、4.2、5.0、5.5、6.0，目前 5.5 以上的设备偏多\n\n### 屏幕分辨率\n\n屏幕分辨率是指在 横纵方向上的像素点数，单位是 *px* ，1px = 1个像素点。\n\n一般以 纵向像素 * 横向像素，如 1920 * 1080 来表示，即 宽度方向上有 1080 个像素点，高度方向上有 1920 个像素点。\n\n> 单位:  px(pixel) ，1 px = 1像素点\n>\n> Android 手机常见的分辨率： 320 * 480    480 * 800  720 * 1280  1080 * 1920\n>\n> UI 设计图一般会以 px 作为统一的计量单位\n\n### 屏幕像素密度\n\n屏幕像素密度是指 **每英寸上的像素点**， 单位是 *dpi*, 即 “dot per inch” 的缩写。\n\n屏幕像素密度与屏幕尺寸和屏幕分辨率有关，在单一变化条件下，屏幕尺寸越小，分辨率越高，像素密度越大，反之越小。dp = px / inch\n\n> 假设设备内每英寸有 160 个像素点，那么该设备的屏幕像素密度 = 160 dpi\n\nAndroid 手机对每类手机屏幕大小都有一个相应的屏幕像素密度\n\n| 密度类型             | 代表的分辨率 px | 屏幕像素密度 dpi |\n| -------------------- | --------------- | ---------------- |\n| 低密度（ldpi）       | 240 * 320       | 120              |\n| 中密度（mdpi）       | 320 * 480       | 160              |\n| 高密度（hdpi）       | 480 * 800       | 240              |\n| 超高密度（xhdpi）    | 720 * 1280      | 320              |\n| 超超高密度（xxhdpi） | 1080 * 1920     | 480              |\n\n### 屏幕尺寸、分辨率、像素密度三者关系\n\n一部手机的分辨率是 **宽 x 高**， 屏幕大小是以寸为单位，三者关系为:\n\n密度 dp = 像素 px / 屏幕大小 inch\n\n密度（dpi） = $\\frac {\\sqrt{宽^2 + 高^2}}{屏幕大小} $\n\n1. 密度即每英寸的像素点\n2. 勾股定理求出手机的对角线物理尺寸\n3. 再储以屏幕大小即可\n\n![image-20210128150307492](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128150307492.png)\n\n### 密度无关像素\n\n`density-independent pixel` 叫做 `dp`  或 `dip` ，与终端上的实际物理像素点无关。可以保证在不同屏幕像素密度的设备上显示相同的效果。\n\n> Android 开发时用 dp 而不是 px 单位设置图片大小，是  Android 特有的单位\n>\n> 场景：假如同样是画一条屏幕一半的线，如果使用 px 作为单位，那么在 480 * 800 分辨率的设备上应为 240 px. 在 320 * 480 的设备上设置为 160 px。\n>\n> 如果使用 dp 为单位，在两种分辨率下，  160dp 都显示为屏幕一半的长度。\n\n### dp 与 px 的转换\n\n`px = dp * (dpi / 160)`\n\n| 密度类型          | 代表的分辨率 px | 屏幕密度 dpi | 换算（px/dp) | 比例 |\n| ----------------- | --------------- | ------------ | ------------ | ---- |\n| 低密度 ldpi       | 240 x 320       | 120          | 1dp = 0.75px | 3    |\n| 中密度 mdpi       | 320 x 480       | 160          | 1dp = 1px    | 4    |\n| 高密度 hdpi       | 480 x 800       | 240          | 1dp = 1.5px  | 6    |\n| 超高密度 xhdpi    | 720 x 1280      | 320          | 1dp = 2px    | 8    |\n| 超超高密度 xxhdpi | 1080 x 1920     | 480          | 1dp = 3px    | 12   |\n\n在 Android 中，规定 以 `160dpi` 即屏幕分辨率为 320 x 480 为基准：1 dp = 1 px\n\n### 独立比例像素\n\n`sp`, `scale-independent pixels`, 与 dp 类似，但是可以根据文字大小首选项进行缩放，是设置字体大小的御用单位。\n\n## 解决方案\n\n### 使用备用布局-使用限定符\n\n* 尺寸限定符\n* 使用最小宽度限定符\n* 布局别名\n* 屏幕方向限定符\n\n**最小宽度限定符： **\n\n通过将屏幕尺寸描述为密度无关像素的度量值， Android 允许创建转为具体的屏幕尺寸而设计的布局。\n\n### 创建可拉抻的九宫格位图\n\n九宫格位图接你上是一种标准的 png 文件，但带有额外的 1 像素边框。\n\n### 布局选择\n\n* 线性布局（LinearLayout)\n* 相对布局（RelativeLayout）\n* 帧布局（FrameLayout）\n* 绝对布局（AbsoluteLayout）\n* 约束布局（ConstraintLayout）\n\n### 使用自适应尺寸\n\n* wrap_content\n* match_parent\n* weight\n* dp\n\n不要使用 px\n\n### 百分比适配\n\n1. 以某一分辨率为基准，生成所有分辨率对应像素数列表\n2. 将生成像素数列表存放在 res 目录下对应的 value 文件下\n3. 根据 UI 设计师给出设计图的尺寸，找到对应像素单位，然后给控件设计就可以\n\n### 使用约束布局\n\nConstraintLayout\n\n### 今日头条适配方案\n\n`px 值 = dp 值 * metrics.density`  这里的 `density` 是手机的屏幕密度，由系统提供。不同的手机的 `density` 不同，所以我们不能直接使用系统的。","source":"_posts/Android 基础/适配/Android 屏幕适配.md","raw":"---\ntitle: Android 屏幕适配\ntag: Android 适配\n---\n\n\n\n## 为什么要适配\n\n由于 Android 系统的开放性，任何用户、开发者、 OEM 厂商、运营商都可以对 Android 进行定制，于是导致运行 Android 的设备多种多样，他们有着不同的屏幕尺寸和像素密度。\n\n尽管系统可以通过基本的缩放和调整大小使得界面适配不同的屏幕，但进一步优化，可以确保界面能够在各类屏幕上美观的呈现。\n\n![image-20210128142240773](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128142240773.png)\n\n## 基本概念\n\n### 屏幕尺寸\n\n屏幕尺寸指 **屏幕对角线的长度**，单位是 *英寸*，一英寸 = 2.54 厘米\n\n> 常见的 Android 设备尺寸有 2.4 、 2.8、3.5、3.7、4.2、5.0、5.5、6.0，目前 5.5 以上的设备偏多\n\n### 屏幕分辨率\n\n屏幕分辨率是指在 横纵方向上的像素点数，单位是 *px* ，1px = 1个像素点。\n\n一般以 纵向像素 * 横向像素，如 1920 * 1080 来表示，即 宽度方向上有 1080 个像素点，高度方向上有 1920 个像素点。\n\n> 单位:  px(pixel) ，1 px = 1像素点\n>\n> Android 手机常见的分辨率： 320 * 480    480 * 800  720 * 1280  1080 * 1920\n>\n> UI 设计图一般会以 px 作为统一的计量单位\n\n### 屏幕像素密度\n\n屏幕像素密度是指 **每英寸上的像素点**， 单位是 *dpi*, 即 “dot per inch” 的缩写。\n\n屏幕像素密度与屏幕尺寸和屏幕分辨率有关，在单一变化条件下，屏幕尺寸越小，分辨率越高，像素密度越大，反之越小。dp = px / inch\n\n> 假设设备内每英寸有 160 个像素点，那么该设备的屏幕像素密度 = 160 dpi\n\nAndroid 手机对每类手机屏幕大小都有一个相应的屏幕像素密度\n\n| 密度类型             | 代表的分辨率 px | 屏幕像素密度 dpi |\n| -------------------- | --------------- | ---------------- |\n| 低密度（ldpi）       | 240 * 320       | 120              |\n| 中密度（mdpi）       | 320 * 480       | 160              |\n| 高密度（hdpi）       | 480 * 800       | 240              |\n| 超高密度（xhdpi）    | 720 * 1280      | 320              |\n| 超超高密度（xxhdpi） | 1080 * 1920     | 480              |\n\n### 屏幕尺寸、分辨率、像素密度三者关系\n\n一部手机的分辨率是 **宽 x 高**， 屏幕大小是以寸为单位，三者关系为:\n\n密度 dp = 像素 px / 屏幕大小 inch\n\n密度（dpi） = $\\frac {\\sqrt{宽^2 + 高^2}}{屏幕大小} $\n\n1. 密度即每英寸的像素点\n2. 勾股定理求出手机的对角线物理尺寸\n3. 再储以屏幕大小即可\n\n![image-20210128150307492](https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128150307492.png)\n\n### 密度无关像素\n\n`density-independent pixel` 叫做 `dp`  或 `dip` ，与终端上的实际物理像素点无关。可以保证在不同屏幕像素密度的设备上显示相同的效果。\n\n> Android 开发时用 dp 而不是 px 单位设置图片大小，是  Android 特有的单位\n>\n> 场景：假如同样是画一条屏幕一半的线，如果使用 px 作为单位，那么在 480 * 800 分辨率的设备上应为 240 px. 在 320 * 480 的设备上设置为 160 px。\n>\n> 如果使用 dp 为单位，在两种分辨率下，  160dp 都显示为屏幕一半的长度。\n\n### dp 与 px 的转换\n\n`px = dp * (dpi / 160)`\n\n| 密度类型          | 代表的分辨率 px | 屏幕密度 dpi | 换算（px/dp) | 比例 |\n| ----------------- | --------------- | ------------ | ------------ | ---- |\n| 低密度 ldpi       | 240 x 320       | 120          | 1dp = 0.75px | 3    |\n| 中密度 mdpi       | 320 x 480       | 160          | 1dp = 1px    | 4    |\n| 高密度 hdpi       | 480 x 800       | 240          | 1dp = 1.5px  | 6    |\n| 超高密度 xhdpi    | 720 x 1280      | 320          | 1dp = 2px    | 8    |\n| 超超高密度 xxhdpi | 1080 x 1920     | 480          | 1dp = 3px    | 12   |\n\n在 Android 中，规定 以 `160dpi` 即屏幕分辨率为 320 x 480 为基准：1 dp = 1 px\n\n### 独立比例像素\n\n`sp`, `scale-independent pixels`, 与 dp 类似，但是可以根据文字大小首选项进行缩放，是设置字体大小的御用单位。\n\n## 解决方案\n\n### 使用备用布局-使用限定符\n\n* 尺寸限定符\n* 使用最小宽度限定符\n* 布局别名\n* 屏幕方向限定符\n\n**最小宽度限定符： **\n\n通过将屏幕尺寸描述为密度无关像素的度量值， Android 允许创建转为具体的屏幕尺寸而设计的布局。\n\n### 创建可拉抻的九宫格位图\n\n九宫格位图接你上是一种标准的 png 文件，但带有额外的 1 像素边框。\n\n### 布局选择\n\n* 线性布局（LinearLayout)\n* 相对布局（RelativeLayout）\n* 帧布局（FrameLayout）\n* 绝对布局（AbsoluteLayout）\n* 约束布局（ConstraintLayout）\n\n### 使用自适应尺寸\n\n* wrap_content\n* match_parent\n* weight\n* dp\n\n不要使用 px\n\n### 百分比适配\n\n1. 以某一分辨率为基准，生成所有分辨率对应像素数列表\n2. 将生成像素数列表存放在 res 目录下对应的 value 文件下\n3. 根据 UI 设计师给出设计图的尺寸，找到对应像素单位，然后给控件设计就可以\n\n### 使用约束布局\n\nConstraintLayout\n\n### 今日头条适配方案\n\n`px 值 = dp 值 * metrics.density`  这里的 `density` 是手机的屏幕密度，由系统提供。不同的手机的 `density` 不同，所以我们不能直接使用系统的。","slug":"Android 基础/适配/Android 屏幕适配","published":1,"date":"2021-01-29T15:54:28.304Z","updated":"2021-01-29T15:54:28.304Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8kh0038sz5qyric5vxb","content":"<h2 id=\"为什么要适配\"><a href=\"#为什么要适配\" class=\"headerlink\" title=\"为什么要适配\"></a>为什么要适配</h2><p>由于 Android 系统的开放性，任何用户、开发者、 OEM 厂商、运营商都可以对 Android 进行定制，于是导致运行 Android 的设备多种多样，他们有着不同的屏幕尺寸和像素密度。</p>\n<p>尽管系统可以通过基本的缩放和调整大小使得界面适配不同的屏幕，但进一步优化，可以确保界面能够在各类屏幕上美观的呈现。</p>\n<p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128142240773.png\" alt=\"image-20210128142240773\"></p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h3 id=\"屏幕尺寸\"><a href=\"#屏幕尺寸\" class=\"headerlink\" title=\"屏幕尺寸\"></a>屏幕尺寸</h3><p>屏幕尺寸指 <strong>屏幕对角线的长度</strong>，单位是 <em>英寸</em>，一英寸 = 2.54 厘米</p>\n<blockquote>\n<p>常见的 Android 设备尺寸有 2.4 、 2.8、3.5、3.7、4.2、5.0、5.5、6.0，目前 5.5 以上的设备偏多</p>\n</blockquote>\n<h3 id=\"屏幕分辨率\"><a href=\"#屏幕分辨率\" class=\"headerlink\" title=\"屏幕分辨率\"></a>屏幕分辨率</h3><p>屏幕分辨率是指在 横纵方向上的像素点数，单位是 <em>px</em> ，1px = 1个像素点。</p>\n<p>一般以 纵向像素 <em> 横向像素，如 1920 </em> 1080 来表示，即 宽度方向上有 1080 个像素点，高度方向上有 1920 个像素点。</p>\n<blockquote>\n<p>单位:  px(pixel) ，1 px = 1像素点</p>\n<p>Android 手机常见的分辨率： 320 <em> 480    480 </em> 800  720 <em> 1280  1080 </em> 1920</p>\n<p>UI 设计图一般会以 px 作为统一的计量单位</p>\n</blockquote>\n<h3 id=\"屏幕像素密度\"><a href=\"#屏幕像素密度\" class=\"headerlink\" title=\"屏幕像素密度\"></a>屏幕像素密度</h3><p>屏幕像素密度是指 <strong>每英寸上的像素点</strong>， 单位是 <em>dpi</em>, 即 “dot per inch” 的缩写。</p>\n<p>屏幕像素密度与屏幕尺寸和屏幕分辨率有关，在单一变化条件下，屏幕尺寸越小，分辨率越高，像素密度越大，反之越小。dp = px / inch</p>\n<blockquote>\n<p>假设设备内每英寸有 160 个像素点，那么该设备的屏幕像素密度 = 160 dpi</p>\n</blockquote>\n<p>Android 手机对每类手机屏幕大小都有一个相应的屏幕像素密度</p>\n<table>\n<thead>\n<tr>\n<th>密度类型</th>\n<th>代表的分辨率 px</th>\n<th>屏幕像素密度 dpi</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>低密度（ldpi）</td>\n<td>240 * 320</td>\n<td>120</td>\n</tr>\n<tr>\n<td>中密度（mdpi）</td>\n<td>320 * 480</td>\n<td>160</td>\n</tr>\n<tr>\n<td>高密度（hdpi）</td>\n<td>480 * 800</td>\n<td>240</td>\n</tr>\n<tr>\n<td>超高密度（xhdpi）</td>\n<td>720 * 1280</td>\n<td>320</td>\n</tr>\n<tr>\n<td>超超高密度（xxhdpi）</td>\n<td>1080 * 1920</td>\n<td>480</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"屏幕尺寸、分辨率、像素密度三者关系\"><a href=\"#屏幕尺寸、分辨率、像素密度三者关系\" class=\"headerlink\" title=\"屏幕尺寸、分辨率、像素密度三者关系\"></a>屏幕尺寸、分辨率、像素密度三者关系</h3><p>一部手机的分辨率是 <strong>宽 x 高</strong>， 屏幕大小是以寸为单位，三者关系为:</p>\n<p>密度 dp = 像素 px / 屏幕大小 inch</p>\n<p>密度（dpi） = $\\frac {\\sqrt{宽^2 + 高^2}}{屏幕大小} $</p>\n<ol>\n<li>密度即每英寸的像素点</li>\n<li>勾股定理求出手机的对角线物理尺寸</li>\n<li>再储以屏幕大小即可</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128150307492.png\" alt=\"image-20210128150307492\"></p>\n<h3 id=\"密度无关像素\"><a href=\"#密度无关像素\" class=\"headerlink\" title=\"密度无关像素\"></a>密度无关像素</h3><p><code>density-independent pixel</code> 叫做 <code>dp</code>  或 <code>dip</code> ，与终端上的实际物理像素点无关。可以保证在不同屏幕像素密度的设备上显示相同的效果。</p>\n<blockquote>\n<p>Android 开发时用 dp 而不是 px 单位设置图片大小，是  Android 特有的单位</p>\n<p>场景：假如同样是画一条屏幕一半的线，如果使用 px 作为单位，那么在 480 <em> 800 分辨率的设备上应为 240 px. 在 320 </em> 480 的设备上设置为 160 px。</p>\n<p>如果使用 dp 为单位，在两种分辨率下，  160dp 都显示为屏幕一半的长度。</p>\n</blockquote>\n<h3 id=\"dp-与-px-的转换\"><a href=\"#dp-与-px-的转换\" class=\"headerlink\" title=\"dp 与 px 的转换\"></a>dp 与 px 的转换</h3><p><code>px = dp * (dpi / 160)</code></p>\n<table>\n<thead>\n<tr>\n<th>密度类型</th>\n<th>代表的分辨率 px</th>\n<th>屏幕密度 dpi</th>\n<th>换算（px/dp)</th>\n<th>比例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>低密度 ldpi</td>\n<td>240 x 320</td>\n<td>120</td>\n<td>1dp = 0.75px</td>\n<td>3</td>\n</tr>\n<tr>\n<td>中密度 mdpi</td>\n<td>320 x 480</td>\n<td>160</td>\n<td>1dp = 1px</td>\n<td>4</td>\n</tr>\n<tr>\n<td>高密度 hdpi</td>\n<td>480 x 800</td>\n<td>240</td>\n<td>1dp = 1.5px</td>\n<td>6</td>\n</tr>\n<tr>\n<td>超高密度 xhdpi</td>\n<td>720 x 1280</td>\n<td>320</td>\n<td>1dp = 2px</td>\n<td>8</td>\n</tr>\n<tr>\n<td>超超高密度 xxhdpi</td>\n<td>1080 x 1920</td>\n<td>480</td>\n<td>1dp = 3px</td>\n<td>12</td>\n</tr>\n</tbody>\n</table>\n<p>在 Android 中，规定 以 <code>160dpi</code> 即屏幕分辨率为 320 x 480 为基准：1 dp = 1 px</p>\n<h3 id=\"独立比例像素\"><a href=\"#独立比例像素\" class=\"headerlink\" title=\"独立比例像素\"></a>独立比例像素</h3><p><code>sp</code>, <code>scale-independent pixels</code>, 与 dp 类似，但是可以根据文字大小首选项进行缩放，是设置字体大小的御用单位。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><h3 id=\"使用备用布局-使用限定符\"><a href=\"#使用备用布局-使用限定符\" class=\"headerlink\" title=\"使用备用布局-使用限定符\"></a>使用备用布局-使用限定符</h3><ul>\n<li>尺寸限定符</li>\n<li>使用最小宽度限定符</li>\n<li>布局别名</li>\n<li>屏幕方向限定符</li>\n</ul>\n<p><strong>最小宽度限定符： </strong></p>\n<p>通过将屏幕尺寸描述为密度无关像素的度量值， Android 允许创建转为具体的屏幕尺寸而设计的布局。</p>\n<h3 id=\"创建可拉抻的九宫格位图\"><a href=\"#创建可拉抻的九宫格位图\" class=\"headerlink\" title=\"创建可拉抻的九宫格位图\"></a>创建可拉抻的九宫格位图</h3><p>九宫格位图接你上是一种标准的 png 文件，但带有额外的 1 像素边框。</p>\n<h3 id=\"布局选择\"><a href=\"#布局选择\" class=\"headerlink\" title=\"布局选择\"></a>布局选择</h3><ul>\n<li>线性布局（LinearLayout)</li>\n<li>相对布局（RelativeLayout）</li>\n<li>帧布局（FrameLayout）</li>\n<li>绝对布局（AbsoluteLayout）</li>\n<li>约束布局（ConstraintLayout）</li>\n</ul>\n<h3 id=\"使用自适应尺寸\"><a href=\"#使用自适应尺寸\" class=\"headerlink\" title=\"使用自适应尺寸\"></a>使用自适应尺寸</h3><ul>\n<li>wrap_content</li>\n<li>match_parent</li>\n<li>weight</li>\n<li>dp</li>\n</ul>\n<p>不要使用 px</p>\n<h3 id=\"百分比适配\"><a href=\"#百分比适配\" class=\"headerlink\" title=\"百分比适配\"></a>百分比适配</h3><ol>\n<li>以某一分辨率为基准，生成所有分辨率对应像素数列表</li>\n<li>将生成像素数列表存放在 res 目录下对应的 value 文件下</li>\n<li>根据 UI 设计师给出设计图的尺寸，找到对应像素单位，然后给控件设计就可以</li>\n</ol>\n<h3 id=\"使用约束布局\"><a href=\"#使用约束布局\" class=\"headerlink\" title=\"使用约束布局\"></a>使用约束布局</h3><p>ConstraintLayout</p>\n<h3 id=\"今日头条适配方案\"><a href=\"#今日头条适配方案\" class=\"headerlink\" title=\"今日头条适配方案\"></a>今日头条适配方案</h3><p><code>px 值 = dp 值 * metrics.density</code>  这里的 <code>density</code> 是手机的屏幕密度，由系统提供。不同的手机的 <code>density</code> 不同，所以我们不能直接使用系统的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"为什么要适配\"><a href=\"#为什么要适配\" class=\"headerlink\" title=\"为什么要适配\"></a>为什么要适配</h2><p>由于 Android 系统的开放性，任何用户、开发者、 OEM 厂商、运营商都可以对 Android 进行定制，于是导致运行 Android 的设备多种多样，他们有着不同的屏幕尺寸和像素密度。</p>\n<p>尽管系统可以通过基本的缩放和调整大小使得界面适配不同的屏幕，但进一步优化，可以确保界面能够在各类屏幕上美观的呈现。</p>\n<p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128142240773.png\" alt=\"image-20210128142240773\"></p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h3 id=\"屏幕尺寸\"><a href=\"#屏幕尺寸\" class=\"headerlink\" title=\"屏幕尺寸\"></a>屏幕尺寸</h3><p>屏幕尺寸指 <strong>屏幕对角线的长度</strong>，单位是 <em>英寸</em>，一英寸 = 2.54 厘米</p>\n<blockquote>\n<p>常见的 Android 设备尺寸有 2.4 、 2.8、3.5、3.7、4.2、5.0、5.5、6.0，目前 5.5 以上的设备偏多</p>\n</blockquote>\n<h3 id=\"屏幕分辨率\"><a href=\"#屏幕分辨率\" class=\"headerlink\" title=\"屏幕分辨率\"></a>屏幕分辨率</h3><p>屏幕分辨率是指在 横纵方向上的像素点数，单位是 <em>px</em> ，1px = 1个像素点。</p>\n<p>一般以 纵向像素 <em> 横向像素，如 1920 </em> 1080 来表示，即 宽度方向上有 1080 个像素点，高度方向上有 1920 个像素点。</p>\n<blockquote>\n<p>单位:  px(pixel) ，1 px = 1像素点</p>\n<p>Android 手机常见的分辨率： 320 <em> 480    480 </em> 800  720 <em> 1280  1080 </em> 1920</p>\n<p>UI 设计图一般会以 px 作为统一的计量单位</p>\n</blockquote>\n<h3 id=\"屏幕像素密度\"><a href=\"#屏幕像素密度\" class=\"headerlink\" title=\"屏幕像素密度\"></a>屏幕像素密度</h3><p>屏幕像素密度是指 <strong>每英寸上的像素点</strong>， 单位是 <em>dpi</em>, 即 “dot per inch” 的缩写。</p>\n<p>屏幕像素密度与屏幕尺寸和屏幕分辨率有关，在单一变化条件下，屏幕尺寸越小，分辨率越高，像素密度越大，反之越小。dp = px / inch</p>\n<blockquote>\n<p>假设设备内每英寸有 160 个像素点，那么该设备的屏幕像素密度 = 160 dpi</p>\n</blockquote>\n<p>Android 手机对每类手机屏幕大小都有一个相应的屏幕像素密度</p>\n<table>\n<thead>\n<tr>\n<th>密度类型</th>\n<th>代表的分辨率 px</th>\n<th>屏幕像素密度 dpi</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>低密度（ldpi）</td>\n<td>240 * 320</td>\n<td>120</td>\n</tr>\n<tr>\n<td>中密度（mdpi）</td>\n<td>320 * 480</td>\n<td>160</td>\n</tr>\n<tr>\n<td>高密度（hdpi）</td>\n<td>480 * 800</td>\n<td>240</td>\n</tr>\n<tr>\n<td>超高密度（xhdpi）</td>\n<td>720 * 1280</td>\n<td>320</td>\n</tr>\n<tr>\n<td>超超高密度（xxhdpi）</td>\n<td>1080 * 1920</td>\n<td>480</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"屏幕尺寸、分辨率、像素密度三者关系\"><a href=\"#屏幕尺寸、分辨率、像素密度三者关系\" class=\"headerlink\" title=\"屏幕尺寸、分辨率、像素密度三者关系\"></a>屏幕尺寸、分辨率、像素密度三者关系</h3><p>一部手机的分辨率是 <strong>宽 x 高</strong>， 屏幕大小是以寸为单位，三者关系为:</p>\n<p>密度 dp = 像素 px / 屏幕大小 inch</p>\n<p>密度（dpi） = $\\frac {\\sqrt{宽^2 + 高^2}}{屏幕大小} $</p>\n<ol>\n<li>密度即每英寸的像素点</li>\n<li>勾股定理求出手机的对角线物理尺寸</li>\n<li>再储以屏幕大小即可</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/xiaomanwong/static_file/master/images/image-20210128150307492.png\" alt=\"image-20210128150307492\"></p>\n<h3 id=\"密度无关像素\"><a href=\"#密度无关像素\" class=\"headerlink\" title=\"密度无关像素\"></a>密度无关像素</h3><p><code>density-independent pixel</code> 叫做 <code>dp</code>  或 <code>dip</code> ，与终端上的实际物理像素点无关。可以保证在不同屏幕像素密度的设备上显示相同的效果。</p>\n<blockquote>\n<p>Android 开发时用 dp 而不是 px 单位设置图片大小，是  Android 特有的单位</p>\n<p>场景：假如同样是画一条屏幕一半的线，如果使用 px 作为单位，那么在 480 <em> 800 分辨率的设备上应为 240 px. 在 320 </em> 480 的设备上设置为 160 px。</p>\n<p>如果使用 dp 为单位，在两种分辨率下，  160dp 都显示为屏幕一半的长度。</p>\n</blockquote>\n<h3 id=\"dp-与-px-的转换\"><a href=\"#dp-与-px-的转换\" class=\"headerlink\" title=\"dp 与 px 的转换\"></a>dp 与 px 的转换</h3><p><code>px = dp * (dpi / 160)</code></p>\n<table>\n<thead>\n<tr>\n<th>密度类型</th>\n<th>代表的分辨率 px</th>\n<th>屏幕密度 dpi</th>\n<th>换算（px/dp)</th>\n<th>比例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>低密度 ldpi</td>\n<td>240 x 320</td>\n<td>120</td>\n<td>1dp = 0.75px</td>\n<td>3</td>\n</tr>\n<tr>\n<td>中密度 mdpi</td>\n<td>320 x 480</td>\n<td>160</td>\n<td>1dp = 1px</td>\n<td>4</td>\n</tr>\n<tr>\n<td>高密度 hdpi</td>\n<td>480 x 800</td>\n<td>240</td>\n<td>1dp = 1.5px</td>\n<td>6</td>\n</tr>\n<tr>\n<td>超高密度 xhdpi</td>\n<td>720 x 1280</td>\n<td>320</td>\n<td>1dp = 2px</td>\n<td>8</td>\n</tr>\n<tr>\n<td>超超高密度 xxhdpi</td>\n<td>1080 x 1920</td>\n<td>480</td>\n<td>1dp = 3px</td>\n<td>12</td>\n</tr>\n</tbody>\n</table>\n<p>在 Android 中，规定 以 <code>160dpi</code> 即屏幕分辨率为 320 x 480 为基准：1 dp = 1 px</p>\n<h3 id=\"独立比例像素\"><a href=\"#独立比例像素\" class=\"headerlink\" title=\"独立比例像素\"></a>独立比例像素</h3><p><code>sp</code>, <code>scale-independent pixels</code>, 与 dp 类似，但是可以根据文字大小首选项进行缩放，是设置字体大小的御用单位。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><h3 id=\"使用备用布局-使用限定符\"><a href=\"#使用备用布局-使用限定符\" class=\"headerlink\" title=\"使用备用布局-使用限定符\"></a>使用备用布局-使用限定符</h3><ul>\n<li>尺寸限定符</li>\n<li>使用最小宽度限定符</li>\n<li>布局别名</li>\n<li>屏幕方向限定符</li>\n</ul>\n<p><strong>最小宽度限定符： </strong></p>\n<p>通过将屏幕尺寸描述为密度无关像素的度量值， Android 允许创建转为具体的屏幕尺寸而设计的布局。</p>\n<h3 id=\"创建可拉抻的九宫格位图\"><a href=\"#创建可拉抻的九宫格位图\" class=\"headerlink\" title=\"创建可拉抻的九宫格位图\"></a>创建可拉抻的九宫格位图</h3><p>九宫格位图接你上是一种标准的 png 文件，但带有额外的 1 像素边框。</p>\n<h3 id=\"布局选择\"><a href=\"#布局选择\" class=\"headerlink\" title=\"布局选择\"></a>布局选择</h3><ul>\n<li>线性布局（LinearLayout)</li>\n<li>相对布局（RelativeLayout）</li>\n<li>帧布局（FrameLayout）</li>\n<li>绝对布局（AbsoluteLayout）</li>\n<li>约束布局（ConstraintLayout）</li>\n</ul>\n<h3 id=\"使用自适应尺寸\"><a href=\"#使用自适应尺寸\" class=\"headerlink\" title=\"使用自适应尺寸\"></a>使用自适应尺寸</h3><ul>\n<li>wrap_content</li>\n<li>match_parent</li>\n<li>weight</li>\n<li>dp</li>\n</ul>\n<p>不要使用 px</p>\n<h3 id=\"百分比适配\"><a href=\"#百分比适配\" class=\"headerlink\" title=\"百分比适配\"></a>百分比适配</h3><ol>\n<li>以某一分辨率为基准，生成所有分辨率对应像素数列表</li>\n<li>将生成像素数列表存放在 res 目录下对应的 value 文件下</li>\n<li>根据 UI 设计师给出设计图的尺寸，找到对应像素单位，然后给控件设计就可以</li>\n</ol>\n<h3 id=\"使用约束布局\"><a href=\"#使用约束布局\" class=\"headerlink\" title=\"使用约束布局\"></a>使用约束布局</h3><p>ConstraintLayout</p>\n<h3 id=\"今日头条适配方案\"><a href=\"#今日头条适配方案\" class=\"headerlink\" title=\"今日头条适配方案\"></a>今日头条适配方案</h3><p><code>px 值 = dp 值 * metrics.density</code>  这里的 <code>density</code> 是手机的屏幕密度，由系统提供。不同的手机的 <code>density</code> 不同，所以我们不能直接使用系统的。</p>\n"},{"title":"Android 版本适配","_content":"\n\n\n## 基本知识\n\n### targetSdkVersion\n\n`targetSdkVersion`： 目标 SDK 版本，也就是我们最高适配的 SDK 版本\n\n不同版本的 SDK ，为我们提供了不同的 API 接口使用，丰富以及方便开发者。\n\n旧的接口行为发生了变化，为了保证 APK 的行为还是和以前兼容，在源码中多了很多类似于 `ctx.getApplicatioinInfo().targetSdkVersion()` 的判断，因此只要 APK 的 `targetSdkVersion` 不变，即使 APK 安装在新的 Android 系统上，其行为也不会发生变化。\n\n<!-- more -->\n\n### compileSdkVersion\n\n`compileSdkVersion` 定义应用程序编译选择哪个 Android SDK 版本，通常设置为最新的 API，它的属性值不影响 Android 系统运行行为，仅仅是 Android 编译项目时其中的一象配置，不会打包到 APK 中，真实目的时为了 **在编译的时候检查代码的错误和警告，提示开发者修改和优化**\n\n### minSdkVersion\n\n`minSdkVersion`: 最小 SDK 版本，也就是我们最低支持的 SDK 版本\n\n* 告诉 Google Play Store 哪些 Android 版本的手机可以安装这个 APK\n* 默认情况下，lint 会对代码中的 API 调用做出提示，加入你调用的 API 在 minSdkVersion 之后才提供，它会告诉你虽然编译可以通过，但是运行时会抛出异常。\n\n如果调用的 API 是在 minSdkVersion 之后才提供的，解决方案有两种\n\n* 运行时判断 API Level， 仅在足够高，有此方法的 API Level 系统中调用\n\n  ```java\n  if(android.os.Build.VERSION_SDK_INIT >= Build.VERSION_CODES.M) {\n      // 处理逻辑\n  }\n  ```\n\n* 保证功能的完整性，通过低版本的 API 实现功能\n\n## Android 6.0 适配\n\n### 运行时权限请求\n\n从 `Android 6.0(api >= 23)` 开始，用户开始在运行时向其授予权限，而不是在应用安装时授予。系统权限分为两种\n\n* 正常权限。在 `AndroidManifest` 列出了正常权限，系统将自动授予该权限\n* 危险权限。在 `AndroidManifest` 中列出了危险权限，用户必须明确批准您的应用使用这些权限。\n\n## Android 7.0 适配\n\n### 应用间共享文件限制\n\n在 `Android 7.0` 系统上， Android 框架强制执行了 `ScrictMode API` 政策，禁止向应用外公开 `file://URI` 如果一项包含文件 `file://URI` 类型的 `Intent` 离开了你的应用，即调用 `Uri.from(file)` 传递文件路径给第三方应用，会出现 `FileUriExposedException` 异常，如调用系统相机拍照、裁切照片、打开 APK 安装界面等。\n\n如果要在 **应用见共享文件** ，可以发送 `content://URI`类型的 Uri， 并授予 Uri 临时访问全新啊，进行此授权的最简单方式是使用 `FileProvider` 类\n\n步骤如下：\n\n* 在 `AndroidManifest.xml` 清单文件中注册 `provider`\n\n  ```xml\n  <provider\n            android:name=\"android.support.v4.content.FileProvider\"\n            android:authorities=\"com.demo.***.provider\"\n            android:exported=\"false\"\n            android:grantUriPermissions=\"true\">\n  \t<meta-data\n                 android:name=\"android.support.FILE_PROVIDER_PATHS\"\n                 android:resource=\"@xml/file_provider_paths\"/>\n  </provider>\n  ```\n\n  * `export` 为 `false`\n\n  * `grantUriPermissions` 表示授予 `URI` 临时访问权限\n\n* 指定共享目录\n\n  上面的 `android:resource=\"@xml/file_provider_paths\"` 指定了共享的目录，配置如下：\n\n  ```xml\n  <path xmlns:android=\"http://schemas.android.com/apk/res/android\">\n       <!-- 代表设备的根目录 new File(\"/\") -->\n      <root-path \n                 name=\"root\"\n                 path=\".\"/>\n       <!-- 代表 content.getFilesDir()-->\n  \t<files-path\n                  name=\"captured_media\"\n                  path=\"captrued_media\"/>\n       <!-- 代表 content.getCacheDir() -->\n      <cache-path\n                  name=\"cache\"\n                  path=\"appCache\"/>\n      <!-- 代表 Environment.getExtrnalStorageDirectory() -->\n      <external-path\n                     name=\"data\"\n                     path=\"Android\"/>\n      <!-- 代表 content.getExternalFilesDirs()-->\n      <external-files-path\n                   name=\"external\"\n                   path=\"\"/>\n  \t<!-- 代表 getExternalCacheDirs() -->    \n      <external-cache-path\n                   name=\"external\"\n                   path=\"\"/>\n  </path>\n  ```\n  \n    通过 `FileProvider` 打开下载完的 APK 实例\n  \n\t```java\npublic static Intent getOpenFileIntent(Context context, DownloadResponse downloadReponse) {\n      File file = new File(downloadResponse.getParentPath(), downloadResponse.getFileName());\n      if(!file.exists()) {\n          return null;\n      }\n      Intent intent = new Intent();\n      intent.addFlag(Intent.FLAG_ACTIVITY_NEW_TASK);\n      intent.setAction(Intent.ACTION_VIEW);\n      if(Build.VERSION.SDK_INI >= Build.VERSION_CODES.N) {\n          intent.setFlag(Intern.FLAG_GRANT_READ_URI_PERMISSION);\n          Uri contentUri = FileProvider.getUriForFile(context, \"com.demo.***.provider\"， file);\n          intent.setDataAndType(contentUri, downloadResponse.getMimeType());\n      } else {\n          intent.setDataAndType(Uri.fromFile(file), downloadResponse.getMimeType());\n      }\n      \n      if(!context instanceof Activity) {\n          intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n      }\n    return intent;\n  }\n\t```\n\n### 系统广播删除\n\nAndroid N 管理了三项系统广播:*网络状态变更广播*、*拍照广播*  和 *录像广播*\n\n只有通过 **动态注册** 的方式才能收到网络变化的广播， 在 `AndroidManifest.xml` 中静态注册的无法收到\n\n## Android 8.0 适配\n\n### 通知渠道\n\n在 Android 8.0 中所有的通知都需要提供通知渠道，否则所有通知在 8.0 系统上都不能正常显示\n\n```java\nDownloadNotifier(Context context) {\n    mContext = context;\n    mManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);\n    if(Build.VERSION.SDK_INT >= Build.VERSION_CODE.O) {\n        @SuppressWarings(\"all\")\n        final NotificationChanncl channel = new NotificationChannel(CHANNEL_ID, CHANNEL_NAME, NotifationManager.IMPORTANCE_HIGH);\n        mManager.createNotificationChannel(channel)\n    }\n}\n```\n\n### 悬浮窗（工具类 APP 使用）\n\n8.0 新增了一种悬浮窗的窗口类型， `TYPE_APPLICATION_OVERLAY`, 如果应用使用 `SYSTEM_ALERT_WINDOW` 权限并且使用以下窗口类型之一在其他应用和窗口上方显示提醒窗口，都会显示在 `TYPE_APPLICATION_OVERLAY` 窗口类型的下方\n\n* TYPE_PHONE\n* TYPE_PRIORITY_PHONE\n* TYPE_SYSTEM_ALERT\n* TYPE_SYSTEM_OVERLAY\n* TYPE_SYSTEM_ERROR\n* TYPE_TOAST\n\n如果该应用的 `targetSdkVersion >= 26` ,则应用只能使用 `TYPE_APPLICATION_OVERLAY` 窗口类型来创建悬浮窗。\n\n```java\nif (Build.VERSION.SDK_INT >= 26) {//8.0新特性\n   mWindowParams.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY;\n} else {\n   mWindowParams.type = WindowManager.LayoutParams.TYPE_SYSTEM_ALERT;\n}\n```\n\n### 透明窗口不允许锁定屏幕旋转\n\n之前应用中的策划返回方案需要将窗口设为透明，但是由于没有适配横屏，因此将其屏幕方法锁定为竖屏\n\n```xml\n<activity\n          android:name=\".HomeActivity\"\n          android:configChanges=\"orientation|keyboardHidden|screenSize\"\n          android:screenOrientation=\"portrait\"\n          android:theme=\"@styple/Base.Theme.CirclePage\"/>\n```\n\n**透明窗口**+**固定屏幕方向** 会抛出异常\n\n```tex\nCaused by: java.lang.IllegalStateException: Only fullscreen opaque activities can request orientation\n```\n\n解决方案有两种：\n\n* 适配横屏，去掉固定屏幕方向的限制\n* 仅在滑动开始的时候设置窗口透明\n\n### Apk 安装需要权限\n\n在安装 APK 是需要申请安装权限 `REQUEST_INSTALL_PACKAGES`\n\n## Android 9.0 适配\n\n### 明文 HTTP 请求限制\n\n9.0 限制了铭文网络请求，非加密的 http 请求会被系统禁止\n\n* 在 `res/xml` 文件夹啊下常见 `network_security_config.xml`\n\n  ```xml\n  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n  <network-security-config>\n  \t<base-config cleartextTrafficPermitted=\"true\"/>\n  </network-security-config>\n  ```\n\n* 在 `AndroidManifest.xml` 的 `<application` 标签下配置\n\n  ```xml\n  <application\n               android:networkSecurityConfig=\"@xml/network_security_config\">\n  </application>\n  ```\n\n或者是改用 `HTTPS` 方式请求\n\n## Android 10.0 适配\n\n### 分区存储\n\n如果还没有准备好适配的功能，可以在 `AndroidManifest.xml` 中添加 `requestLegacyExternalStorage` 来暂时处理\n\n```xml\n    <application\n        android:requestLegacyExternalStorage=\"true\"/>\n```\n\nAndroid Q 在外部存储设备中为每个应用提供另一个“隔离存储沙盒”。任何其他应用都无法直接访问您应用的沙盒文件。由**于文件是私密的 ，因此不再需要任何权限即可再外部存储设备中访问和保存自己的文件。**\n\n**沙盒**就是应用专属文件夹，并且访问这个文件夹不需要权限申请。官方推荐应用再沙盒内存储文件的地址为 \n\n> Context.getExternalFilesDir() 下的文件夹，比如存储一张照片则应该放在 <font color=red>Context.getExternalFilesDir(Environment.DIRECTORY_PICTURES) </font>中\n\n**适配：**\n\n1. 访问自己文件： Q 中用更精细的媒体特定权限替换并取消了 `READ_EXTERNAL_STORAGE` 和 `WRITE_EXTERNAL_STORAGE` 权限，丙炔无需特定权限，就可以访问沙盒中的文件。\n2. 访问系统媒体文件： Q 中引入了一个新定义媒体文件的共享集合，如果要访问沙盒外的媒体共享文件，比如：照片、音乐、视频等。需要申请新的媒体权限 `READ_MEDIA_IMAGES,READ_MEDIA_VIDEO,READ_MEIDA_AUDIO`，时期内那个方法同原来的存储权限\n3. 访问系统下载文件：对于系统下载文件的访问，暂时没有限制，但是要访问其中其他应用的文件，必须允许用户使用系统的文件选择器应用来选择文件\n4. 访问其他应用沙盒文件：如需要访问其他应用再沙盒内创建的文件，\n\n### 设备唯一标识符\n\n访问设备序列号或者 IMEI 的应用，将会被限制，无法获取成功。因此，在 Android Q 上，应用必须具有 `READ_PRIVILEGED_PHONE_STATE` 签名权限才能访问设备的不可重置标识符（包含 IMEI 和序列号），原来的 `READ_PHONE_STATE` 权限已经不能获取 IMEI 和 序列号。如果想在 Q 设备上通过使用下面的代码获取设备的 ID\n\n```java\n((TelephonyManager)getActivity().getSystemService(Context.TELEPHONY_SERVICE)).getDeviceId();\n```\n\n**但是，**上面的代码会返回空值（targetASdkVersion <= P）或者报错(targetSdkVersion == Q) ，且官网所说的 `READ_PRIVILEGED_PHONE_STATE` 权限只提供给系统 app，<font color=red>**所以这个方法行不通**</font>\n\nGoogle 官方给与了设备唯一 ID 最佳方案，但是此方案给出的 ID 是可变的，可以按照具体需求具体解决。\n\n```java\npublic static String getUUID() {\n    String serial = null;\n    String m_szDevIdShort = \"35\" + \n        Build.BOARD.length() % 10 + Build.BRAND.length() % 10 + \n        Build.CPU_ABI.length() % 10 + Build.DEVICE.length() % 10 +\n        Build.DISPLAY.length() % 10 + Build.HOST.length() % 10 +\n        Build.ID.length() % 10 + Build.MANUFACTURER.length() % 10 +\n        Build.MODEL.length() % 10 + Build.PRODUCT.length() % 10 +\n        Build.TAGS.length() % 10 + Build.TYPE.length() % 10 +\n        Build.USER.length() % 10; //13 位\n    try {\n      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n        serial = android.os.Build.getSerial();\n      } else {\n        serial = Build.SERIAL;\n      }\n      //API>=9 使用serial号\n      return new UUID(m_szDevIDShort.hashCode(), serial.hashCode()).toString();\n    } catch (Exception exception) {\n    //serial需要一个初始化\n    serial = \"serial\"; // 随便一个初始化\n  }\n    //使用硬件信息拼凑出来的15位号码\n    return new UUID(m_szDevIDShort.hashCode(), serial.hashCode()).toString();\n}\n```\n\n### 非 SDK 接口限制\n\n为确保 稳定性和兼容性， Android 平台开始限制您的应用在 Android 9.0中使用哪些非 SDK 接口。\n\n**非 SDK 接口** 限制就是某些 SDK 中的私有方法，如 private 方法，你通过 Java 反射等方法获取并调用了。那么这些调用将在 `target >= P` 或者 `target >= Q` 的设备上被限制使用。","source":"_posts/Android 基础/适配/Android 版本适配.md","raw":"---\ntitle: Android 版本适配\ntag: Android 适配\n---\n\n\n\n## 基本知识\n\n### targetSdkVersion\n\n`targetSdkVersion`： 目标 SDK 版本，也就是我们最高适配的 SDK 版本\n\n不同版本的 SDK ，为我们提供了不同的 API 接口使用，丰富以及方便开发者。\n\n旧的接口行为发生了变化，为了保证 APK 的行为还是和以前兼容，在源码中多了很多类似于 `ctx.getApplicatioinInfo().targetSdkVersion()` 的判断，因此只要 APK 的 `targetSdkVersion` 不变，即使 APK 安装在新的 Android 系统上，其行为也不会发生变化。\n\n<!-- more -->\n\n### compileSdkVersion\n\n`compileSdkVersion` 定义应用程序编译选择哪个 Android SDK 版本，通常设置为最新的 API，它的属性值不影响 Android 系统运行行为，仅仅是 Android 编译项目时其中的一象配置，不会打包到 APK 中，真实目的时为了 **在编译的时候检查代码的错误和警告，提示开发者修改和优化**\n\n### minSdkVersion\n\n`minSdkVersion`: 最小 SDK 版本，也就是我们最低支持的 SDK 版本\n\n* 告诉 Google Play Store 哪些 Android 版本的手机可以安装这个 APK\n* 默认情况下，lint 会对代码中的 API 调用做出提示，加入你调用的 API 在 minSdkVersion 之后才提供，它会告诉你虽然编译可以通过，但是运行时会抛出异常。\n\n如果调用的 API 是在 minSdkVersion 之后才提供的，解决方案有两种\n\n* 运行时判断 API Level， 仅在足够高，有此方法的 API Level 系统中调用\n\n  ```java\n  if(android.os.Build.VERSION_SDK_INIT >= Build.VERSION_CODES.M) {\n      // 处理逻辑\n  }\n  ```\n\n* 保证功能的完整性，通过低版本的 API 实现功能\n\n## Android 6.0 适配\n\n### 运行时权限请求\n\n从 `Android 6.0(api >= 23)` 开始，用户开始在运行时向其授予权限，而不是在应用安装时授予。系统权限分为两种\n\n* 正常权限。在 `AndroidManifest` 列出了正常权限，系统将自动授予该权限\n* 危险权限。在 `AndroidManifest` 中列出了危险权限，用户必须明确批准您的应用使用这些权限。\n\n## Android 7.0 适配\n\n### 应用间共享文件限制\n\n在 `Android 7.0` 系统上， Android 框架强制执行了 `ScrictMode API` 政策，禁止向应用外公开 `file://URI` 如果一项包含文件 `file://URI` 类型的 `Intent` 离开了你的应用，即调用 `Uri.from(file)` 传递文件路径给第三方应用，会出现 `FileUriExposedException` 异常，如调用系统相机拍照、裁切照片、打开 APK 安装界面等。\n\n如果要在 **应用见共享文件** ，可以发送 `content://URI`类型的 Uri， 并授予 Uri 临时访问全新啊，进行此授权的最简单方式是使用 `FileProvider` 类\n\n步骤如下：\n\n* 在 `AndroidManifest.xml` 清单文件中注册 `provider`\n\n  ```xml\n  <provider\n            android:name=\"android.support.v4.content.FileProvider\"\n            android:authorities=\"com.demo.***.provider\"\n            android:exported=\"false\"\n            android:grantUriPermissions=\"true\">\n  \t<meta-data\n                 android:name=\"android.support.FILE_PROVIDER_PATHS\"\n                 android:resource=\"@xml/file_provider_paths\"/>\n  </provider>\n  ```\n\n  * `export` 为 `false`\n\n  * `grantUriPermissions` 表示授予 `URI` 临时访问权限\n\n* 指定共享目录\n\n  上面的 `android:resource=\"@xml/file_provider_paths\"` 指定了共享的目录，配置如下：\n\n  ```xml\n  <path xmlns:android=\"http://schemas.android.com/apk/res/android\">\n       <!-- 代表设备的根目录 new File(\"/\") -->\n      <root-path \n                 name=\"root\"\n                 path=\".\"/>\n       <!-- 代表 content.getFilesDir()-->\n  \t<files-path\n                  name=\"captured_media\"\n                  path=\"captrued_media\"/>\n       <!-- 代表 content.getCacheDir() -->\n      <cache-path\n                  name=\"cache\"\n                  path=\"appCache\"/>\n      <!-- 代表 Environment.getExtrnalStorageDirectory() -->\n      <external-path\n                     name=\"data\"\n                     path=\"Android\"/>\n      <!-- 代表 content.getExternalFilesDirs()-->\n      <external-files-path\n                   name=\"external\"\n                   path=\"\"/>\n  \t<!-- 代表 getExternalCacheDirs() -->    \n      <external-cache-path\n                   name=\"external\"\n                   path=\"\"/>\n  </path>\n  ```\n  \n    通过 `FileProvider` 打开下载完的 APK 实例\n  \n\t```java\npublic static Intent getOpenFileIntent(Context context, DownloadResponse downloadReponse) {\n      File file = new File(downloadResponse.getParentPath(), downloadResponse.getFileName());\n      if(!file.exists()) {\n          return null;\n      }\n      Intent intent = new Intent();\n      intent.addFlag(Intent.FLAG_ACTIVITY_NEW_TASK);\n      intent.setAction(Intent.ACTION_VIEW);\n      if(Build.VERSION.SDK_INI >= Build.VERSION_CODES.N) {\n          intent.setFlag(Intern.FLAG_GRANT_READ_URI_PERMISSION);\n          Uri contentUri = FileProvider.getUriForFile(context, \"com.demo.***.provider\"， file);\n          intent.setDataAndType(contentUri, downloadResponse.getMimeType());\n      } else {\n          intent.setDataAndType(Uri.fromFile(file), downloadResponse.getMimeType());\n      }\n      \n      if(!context instanceof Activity) {\n          intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n      }\n    return intent;\n  }\n\t```\n\n### 系统广播删除\n\nAndroid N 管理了三项系统广播:*网络状态变更广播*、*拍照广播*  和 *录像广播*\n\n只有通过 **动态注册** 的方式才能收到网络变化的广播， 在 `AndroidManifest.xml` 中静态注册的无法收到\n\n## Android 8.0 适配\n\n### 通知渠道\n\n在 Android 8.0 中所有的通知都需要提供通知渠道，否则所有通知在 8.0 系统上都不能正常显示\n\n```java\nDownloadNotifier(Context context) {\n    mContext = context;\n    mManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);\n    if(Build.VERSION.SDK_INT >= Build.VERSION_CODE.O) {\n        @SuppressWarings(\"all\")\n        final NotificationChanncl channel = new NotificationChannel(CHANNEL_ID, CHANNEL_NAME, NotifationManager.IMPORTANCE_HIGH);\n        mManager.createNotificationChannel(channel)\n    }\n}\n```\n\n### 悬浮窗（工具类 APP 使用）\n\n8.0 新增了一种悬浮窗的窗口类型， `TYPE_APPLICATION_OVERLAY`, 如果应用使用 `SYSTEM_ALERT_WINDOW` 权限并且使用以下窗口类型之一在其他应用和窗口上方显示提醒窗口，都会显示在 `TYPE_APPLICATION_OVERLAY` 窗口类型的下方\n\n* TYPE_PHONE\n* TYPE_PRIORITY_PHONE\n* TYPE_SYSTEM_ALERT\n* TYPE_SYSTEM_OVERLAY\n* TYPE_SYSTEM_ERROR\n* TYPE_TOAST\n\n如果该应用的 `targetSdkVersion >= 26` ,则应用只能使用 `TYPE_APPLICATION_OVERLAY` 窗口类型来创建悬浮窗。\n\n```java\nif (Build.VERSION.SDK_INT >= 26) {//8.0新特性\n   mWindowParams.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY;\n} else {\n   mWindowParams.type = WindowManager.LayoutParams.TYPE_SYSTEM_ALERT;\n}\n```\n\n### 透明窗口不允许锁定屏幕旋转\n\n之前应用中的策划返回方案需要将窗口设为透明，但是由于没有适配横屏，因此将其屏幕方法锁定为竖屏\n\n```xml\n<activity\n          android:name=\".HomeActivity\"\n          android:configChanges=\"orientation|keyboardHidden|screenSize\"\n          android:screenOrientation=\"portrait\"\n          android:theme=\"@styple/Base.Theme.CirclePage\"/>\n```\n\n**透明窗口**+**固定屏幕方向** 会抛出异常\n\n```tex\nCaused by: java.lang.IllegalStateException: Only fullscreen opaque activities can request orientation\n```\n\n解决方案有两种：\n\n* 适配横屏，去掉固定屏幕方向的限制\n* 仅在滑动开始的时候设置窗口透明\n\n### Apk 安装需要权限\n\n在安装 APK 是需要申请安装权限 `REQUEST_INSTALL_PACKAGES`\n\n## Android 9.0 适配\n\n### 明文 HTTP 请求限制\n\n9.0 限制了铭文网络请求，非加密的 http 请求会被系统禁止\n\n* 在 `res/xml` 文件夹啊下常见 `network_security_config.xml`\n\n  ```xml\n  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n  <network-security-config>\n  \t<base-config cleartextTrafficPermitted=\"true\"/>\n  </network-security-config>\n  ```\n\n* 在 `AndroidManifest.xml` 的 `<application` 标签下配置\n\n  ```xml\n  <application\n               android:networkSecurityConfig=\"@xml/network_security_config\">\n  </application>\n  ```\n\n或者是改用 `HTTPS` 方式请求\n\n## Android 10.0 适配\n\n### 分区存储\n\n如果还没有准备好适配的功能，可以在 `AndroidManifest.xml` 中添加 `requestLegacyExternalStorage` 来暂时处理\n\n```xml\n    <application\n        android:requestLegacyExternalStorage=\"true\"/>\n```\n\nAndroid Q 在外部存储设备中为每个应用提供另一个“隔离存储沙盒”。任何其他应用都无法直接访问您应用的沙盒文件。由**于文件是私密的 ，因此不再需要任何权限即可再外部存储设备中访问和保存自己的文件。**\n\n**沙盒**就是应用专属文件夹，并且访问这个文件夹不需要权限申请。官方推荐应用再沙盒内存储文件的地址为 \n\n> Context.getExternalFilesDir() 下的文件夹，比如存储一张照片则应该放在 <font color=red>Context.getExternalFilesDir(Environment.DIRECTORY_PICTURES) </font>中\n\n**适配：**\n\n1. 访问自己文件： Q 中用更精细的媒体特定权限替换并取消了 `READ_EXTERNAL_STORAGE` 和 `WRITE_EXTERNAL_STORAGE` 权限，丙炔无需特定权限，就可以访问沙盒中的文件。\n2. 访问系统媒体文件： Q 中引入了一个新定义媒体文件的共享集合，如果要访问沙盒外的媒体共享文件，比如：照片、音乐、视频等。需要申请新的媒体权限 `READ_MEDIA_IMAGES,READ_MEDIA_VIDEO,READ_MEIDA_AUDIO`，时期内那个方法同原来的存储权限\n3. 访问系统下载文件：对于系统下载文件的访问，暂时没有限制，但是要访问其中其他应用的文件，必须允许用户使用系统的文件选择器应用来选择文件\n4. 访问其他应用沙盒文件：如需要访问其他应用再沙盒内创建的文件，\n\n### 设备唯一标识符\n\n访问设备序列号或者 IMEI 的应用，将会被限制，无法获取成功。因此，在 Android Q 上，应用必须具有 `READ_PRIVILEGED_PHONE_STATE` 签名权限才能访问设备的不可重置标识符（包含 IMEI 和序列号），原来的 `READ_PHONE_STATE` 权限已经不能获取 IMEI 和 序列号。如果想在 Q 设备上通过使用下面的代码获取设备的 ID\n\n```java\n((TelephonyManager)getActivity().getSystemService(Context.TELEPHONY_SERVICE)).getDeviceId();\n```\n\n**但是，**上面的代码会返回空值（targetASdkVersion <= P）或者报错(targetSdkVersion == Q) ，且官网所说的 `READ_PRIVILEGED_PHONE_STATE` 权限只提供给系统 app，<font color=red>**所以这个方法行不通**</font>\n\nGoogle 官方给与了设备唯一 ID 最佳方案，但是此方案给出的 ID 是可变的，可以按照具体需求具体解决。\n\n```java\npublic static String getUUID() {\n    String serial = null;\n    String m_szDevIdShort = \"35\" + \n        Build.BOARD.length() % 10 + Build.BRAND.length() % 10 + \n        Build.CPU_ABI.length() % 10 + Build.DEVICE.length() % 10 +\n        Build.DISPLAY.length() % 10 + Build.HOST.length() % 10 +\n        Build.ID.length() % 10 + Build.MANUFACTURER.length() % 10 +\n        Build.MODEL.length() % 10 + Build.PRODUCT.length() % 10 +\n        Build.TAGS.length() % 10 + Build.TYPE.length() % 10 +\n        Build.USER.length() % 10; //13 位\n    try {\n      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n        serial = android.os.Build.getSerial();\n      } else {\n        serial = Build.SERIAL;\n      }\n      //API>=9 使用serial号\n      return new UUID(m_szDevIDShort.hashCode(), serial.hashCode()).toString();\n    } catch (Exception exception) {\n    //serial需要一个初始化\n    serial = \"serial\"; // 随便一个初始化\n  }\n    //使用硬件信息拼凑出来的15位号码\n    return new UUID(m_szDevIDShort.hashCode(), serial.hashCode()).toString();\n}\n```\n\n### 非 SDK 接口限制\n\n为确保 稳定性和兼容性， Android 平台开始限制您的应用在 Android 9.0中使用哪些非 SDK 接口。\n\n**非 SDK 接口** 限制就是某些 SDK 中的私有方法，如 private 方法，你通过 Java 反射等方法获取并调用了。那么这些调用将在 `target >= P` 或者 `target >= Q` 的设备上被限制使用。","slug":"Android 基础/适配/Android 版本适配","published":1,"date":"2021-01-29T15:54:28.304Z","updated":"2021-01-29T15:54:28.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8kj003asz5qnxf4je0l","content":"<h2 id=\"基本知识\"><a href=\"#基本知识\" class=\"headerlink\" title=\"基本知识\"></a>基本知识</h2><h3 id=\"targetSdkVersion\"><a href=\"#targetSdkVersion\" class=\"headerlink\" title=\"targetSdkVersion\"></a>targetSdkVersion</h3><p><code>targetSdkVersion</code>： 目标 SDK 版本，也就是我们最高适配的 SDK 版本</p>\n<p>不同版本的 SDK ，为我们提供了不同的 API 接口使用，丰富以及方便开发者。</p>\n<p>旧的接口行为发生了变化，为了保证 APK 的行为还是和以前兼容，在源码中多了很多类似于 <code>ctx.getApplicatioinInfo().targetSdkVersion()</code> 的判断，因此只要 APK 的 <code>targetSdkVersion</code> 不变，即使 APK 安装在新的 Android 系统上，其行为也不会发生变化。</p>\n<a id=\"more\"></a>\n<h3 id=\"compileSdkVersion\"><a href=\"#compileSdkVersion\" class=\"headerlink\" title=\"compileSdkVersion\"></a>compileSdkVersion</h3><p><code>compileSdkVersion</code> 定义应用程序编译选择哪个 Android SDK 版本，通常设置为最新的 API，它的属性值不影响 Android 系统运行行为，仅仅是 Android 编译项目时其中的一象配置，不会打包到 APK 中，真实目的时为了 <strong>在编译的时候检查代码的错误和警告，提示开发者修改和优化</strong></p>\n<h3 id=\"minSdkVersion\"><a href=\"#minSdkVersion\" class=\"headerlink\" title=\"minSdkVersion\"></a>minSdkVersion</h3><p><code>minSdkVersion</code>: 最小 SDK 版本，也就是我们最低支持的 SDK 版本</p>\n<ul>\n<li>告诉 Google Play Store 哪些 Android 版本的手机可以安装这个 APK</li>\n<li>默认情况下，lint 会对代码中的 API 调用做出提示，加入你调用的 API 在 minSdkVersion 之后才提供，它会告诉你虽然编译可以通过，但是运行时会抛出异常。</li>\n</ul>\n<p>如果调用的 API 是在 minSdkVersion 之后才提供的，解决方案有两种</p>\n<ul>\n<li><p>运行时判断 API Level， 仅在足够高，有此方法的 API Level 系统中调用</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>android<span class=\"token punctuation\">.</span>os<span class=\"token punctuation\">.</span>Build<span class=\"token punctuation\">.</span>VERSION_SDK_INIT <span class=\"token operator\">>=</span> Build<span class=\"token punctuation\">.</span>VERSION_CODES<span class=\"token punctuation\">.</span>M<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 处理逻辑</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n</li>\n<li><p>保证功能的完整性，通过低版本的 API 实现功能</p>\n</li>\n</ul>\n<h2 id=\"Android-6-0-适配\"><a href=\"#Android-6-0-适配\" class=\"headerlink\" title=\"Android 6.0 适配\"></a>Android 6.0 适配</h2><h3 id=\"运行时权限请求\"><a href=\"#运行时权限请求\" class=\"headerlink\" title=\"运行时权限请求\"></a>运行时权限请求</h3><p>从 <code>Android 6.0(api &gt;= 23)</code> 开始，用户开始在运行时向其授予权限，而不是在应用安装时授予。系统权限分为两种</p>\n<ul>\n<li>正常权限。在 <code>AndroidManifest</code> 列出了正常权限，系统将自动授予该权限</li>\n<li>危险权限。在 <code>AndroidManifest</code> 中列出了危险权限，用户必须明确批准您的应用使用这些权限。</li>\n</ul>\n<h2 id=\"Android-7-0-适配\"><a href=\"#Android-7-0-适配\" class=\"headerlink\" title=\"Android 7.0 适配\"></a>Android 7.0 适配</h2><h3 id=\"应用间共享文件限制\"><a href=\"#应用间共享文件限制\" class=\"headerlink\" title=\"应用间共享文件限制\"></a>应用间共享文件限制</h3><p>在 <code>Android 7.0</code> 系统上， Android 框架强制执行了 <code>ScrictMode API</code> 政策，禁止向应用外公开 <code>file://URI</code> 如果一项包含文件 <code>file://URI</code> 类型的 <code>Intent</code> 离开了你的应用，即调用 <code>Uri.from(file)</code> 传递文件路径给第三方应用，会出现 <code>FileUriExposedException</code> 异常，如调用系统相机拍照、裁切照片、打开 APK 安装界面等。</p>\n<p>如果要在 <strong>应用见共享文件</strong> ，可以发送 <code>content://URI</code>类型的 Uri， 并授予 Uri 临时访问全新啊，进行此授权的最简单方式是使用 <code>FileProvider</code> 类</p>\n<p>步骤如下：</p>\n<ul>\n<li><p>在 <code>AndroidManifest.xml</code> 清单文件中注册 <code>provider</code></p>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>provider</span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>android.support.v4.content.FileProvider<span class=\"token punctuation\">\"</span></span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>authorities</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>com.demo.***.provider<span class=\"token punctuation\">\"</span></span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>exported</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>false<span class=\"token punctuation\">\"</span></span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>grantUriPermissions</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>true<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta-data</span>\n               <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>android.support.FILE_PROVIDER_PATHS<span class=\"token punctuation\">\"</span></span>\n               <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>resource</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@xml/file_provider_paths<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>provider</span><span class=\"token punctuation\">></span></span>\n</code></pre>\n<ul>\n<li><p><code>export</code> 为 <code>false</code></p>\n</li>\n<li><p><code>grantUriPermissions</code> 表示授予 <code>URI</code> 临时访问权限</p>\n</li>\n</ul>\n</li>\n<li><p>指定共享目录</p>\n<p>上面的 <code>android:resource=&quot;@xml/file_provider_paths&quot;</code> 指定了共享的目录，配置如下：</p>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>path</span> <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>android</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>http://schemas.android.com/apk/res/android<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n     <span class=\"token comment\" spellcheck=\"true\">&lt;!-- 代表设备的根目录 new File(\"/\") --></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>root-path</span> \n               <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>root<span class=\"token punctuation\">\"</span></span>\n               <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>.<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n     <span class=\"token comment\" spellcheck=\"true\">&lt;!-- 代表 content.getFilesDir()--></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>files-path</span>\n                <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>captured_media<span class=\"token punctuation\">\"</span></span>\n                <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>captrued_media<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n     <span class=\"token comment\" spellcheck=\"true\">&lt;!-- 代表 content.getCacheDir() --></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>cache-path</span>\n                <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>cache<span class=\"token punctuation\">\"</span></span>\n                <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>appCache<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token comment\" spellcheck=\"true\">&lt;!-- 代表 Environment.getExtrnalStorageDirectory() --></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>external-path</span>\n                   <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>data<span class=\"token punctuation\">\"</span></span>\n                   <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>Android<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token comment\" spellcheck=\"true\">&lt;!-- 代表 content.getExternalFilesDirs()--></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>external-files-path</span>\n                 <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>external<span class=\"token punctuation\">\"</span></span>\n                 <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span><span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token comment\" spellcheck=\"true\">&lt;!-- 代表 getExternalCacheDirs() --></span>    \n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>external-cache-path</span>\n                 <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>external<span class=\"token punctuation\">\"</span></span>\n                 <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span><span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>path</span><span class=\"token punctuation\">></span></span>\n</code></pre>\n<p>  通过 <code>FileProvider</code> 打开下载完的 APK 实例</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> Intent <span class=\"token function\">getOpenFileIntent</span><span class=\"token punctuation\">(</span>Context context<span class=\"token punctuation\">,</span> DownloadResponse downloadReponse<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    File file <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">(</span>downloadResponse<span class=\"token punctuation\">.</span><span class=\"token function\">getParentPath</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> downloadResponse<span class=\"token punctuation\">.</span><span class=\"token function\">getFileName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>file<span class=\"token punctuation\">.</span><span class=\"token function\">exists</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> null<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    Intent intent <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Intent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    intent<span class=\"token punctuation\">.</span><span class=\"token function\">addFlag</span><span class=\"token punctuation\">(</span>Intent<span class=\"token punctuation\">.</span>FLAG_ACTIVITY_NEW_TASK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    intent<span class=\"token punctuation\">.</span><span class=\"token function\">setAction</span><span class=\"token punctuation\">(</span>Intent<span class=\"token punctuation\">.</span>ACTION_VIEW<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>Build<span class=\"token punctuation\">.</span>VERSION<span class=\"token punctuation\">.</span>SDK_INI <span class=\"token operator\">>=</span> Build<span class=\"token punctuation\">.</span>VERSION_CODES<span class=\"token punctuation\">.</span>N<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        intent<span class=\"token punctuation\">.</span><span class=\"token function\">setFlag</span><span class=\"token punctuation\">(</span>Intern<span class=\"token punctuation\">.</span>FLAG_GRANT_READ_URI_PERMISSION<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Uri contentUri <span class=\"token operator\">=</span> FileProvider<span class=\"token punctuation\">.</span><span class=\"token function\">getUriForFile</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> <span class=\"token string\">\"com.demo.***.provider\"</span>， file<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        intent<span class=\"token punctuation\">.</span><span class=\"token function\">setDataAndType</span><span class=\"token punctuation\">(</span>contentUri<span class=\"token punctuation\">,</span> downloadResponse<span class=\"token punctuation\">.</span><span class=\"token function\">getMimeType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        intent<span class=\"token punctuation\">.</span><span class=\"token function\">setDataAndType</span><span class=\"token punctuation\">(</span>Uri<span class=\"token punctuation\">.</span><span class=\"token function\">fromFile</span><span class=\"token punctuation\">(</span>file<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> downloadResponse<span class=\"token punctuation\">.</span><span class=\"token function\">getMimeType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>context <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Activity</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        intent<span class=\"token punctuation\">.</span><span class=\"token function\">addFlags</span><span class=\"token punctuation\">(</span>Intent<span class=\"token punctuation\">.</span>FLAG_ACTIVITY_NEW_TASK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> intent<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n</li>\n</ul>\n<h3 id=\"系统广播删除\"><a href=\"#系统广播删除\" class=\"headerlink\" title=\"系统广播删除\"></a>系统广播删除</h3><p>Android N 管理了三项系统广播:<em>网络状态变更广播</em>、<em>拍照广播</em>  和 <em>录像广播</em></p>\n<p>只有通过 <strong>动态注册</strong> 的方式才能收到网络变化的广播， 在 <code>AndroidManifest.xml</code> 中静态注册的无法收到</p>\n<h2 id=\"Android-8-0-适配\"><a href=\"#Android-8-0-适配\" class=\"headerlink\" title=\"Android 8.0 适配\"></a>Android 8.0 适配</h2><h3 id=\"通知渠道\"><a href=\"#通知渠道\" class=\"headerlink\" title=\"通知渠道\"></a>通知渠道</h3><p>在 Android 8.0 中所有的通知都需要提供通知渠道，否则所有通知在 8.0 系统上都不能正常显示</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token function\">DownloadNotifier</span><span class=\"token punctuation\">(</span>Context context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    mContext <span class=\"token operator\">=</span> context<span class=\"token punctuation\">;</span>\n    mManager <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>NotificationManager<span class=\"token punctuation\">)</span> context<span class=\"token punctuation\">.</span><span class=\"token function\">getSystemService</span><span class=\"token punctuation\">(</span>Context<span class=\"token punctuation\">.</span>NOTIFICATION_SERVICE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>Build<span class=\"token punctuation\">.</span>VERSION<span class=\"token punctuation\">.</span>SDK_INT <span class=\"token operator\">>=</span> Build<span class=\"token punctuation\">.</span>VERSION_CODE<span class=\"token punctuation\">.</span>O<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@SuppressWarings</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"all\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">final</span> NotificationChanncl channel <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NotificationChannel</span><span class=\"token punctuation\">(</span>CHANNEL_ID<span class=\"token punctuation\">,</span> CHANNEL_NAME<span class=\"token punctuation\">,</span> NotifationManager<span class=\"token punctuation\">.</span>IMPORTANCE_HIGH<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        mManager<span class=\"token punctuation\">.</span><span class=\"token function\">createNotificationChannel</span><span class=\"token punctuation\">(</span>channel<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"悬浮窗（工具类-APP-使用）\"><a href=\"#悬浮窗（工具类-APP-使用）\" class=\"headerlink\" title=\"悬浮窗（工具类 APP 使用）\"></a>悬浮窗（工具类 APP 使用）</h3><p>8.0 新增了一种悬浮窗的窗口类型， <code>TYPE_APPLICATION_OVERLAY</code>, 如果应用使用 <code>SYSTEM_ALERT_WINDOW</code> 权限并且使用以下窗口类型之一在其他应用和窗口上方显示提醒窗口，都会显示在 <code>TYPE_APPLICATION_OVERLAY</code> 窗口类型的下方</p>\n<ul>\n<li>TYPE_PHONE</li>\n<li>TYPE_PRIORITY_PHONE</li>\n<li>TYPE_SYSTEM_ALERT</li>\n<li>TYPE_SYSTEM_OVERLAY</li>\n<li>TYPE_SYSTEM_ERROR</li>\n<li>TYPE_TOAST</li>\n</ul>\n<p>如果该应用的 <code>targetSdkVersion &gt;= 26</code> ,则应用只能使用 <code>TYPE_APPLICATION_OVERLAY</code> 窗口类型来创建悬浮窗。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Build<span class=\"token punctuation\">.</span>VERSION<span class=\"token punctuation\">.</span>SDK_INT <span class=\"token operator\">>=</span> <span class=\"token number\">26</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token comment\" spellcheck=\"true\">//8.0新特性</span>\n   mWindowParams<span class=\"token punctuation\">.</span>type <span class=\"token operator\">=</span> WindowManager<span class=\"token punctuation\">.</span>LayoutParams<span class=\"token punctuation\">.</span>TYPE_APPLICATION_OVERLAY<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n   mWindowParams<span class=\"token punctuation\">.</span>type <span class=\"token operator\">=</span> WindowManager<span class=\"token punctuation\">.</span>LayoutParams<span class=\"token punctuation\">.</span>TYPE_SYSTEM_ALERT<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"透明窗口不允许锁定屏幕旋转\"><a href=\"#透明窗口不允许锁定屏幕旋转\" class=\"headerlink\" title=\"透明窗口不允许锁定屏幕旋转\"></a>透明窗口不允许锁定屏幕旋转</h3><p>之前应用中的策划返回方案需要将窗口设为透明，但是由于没有适配横屏，因此将其屏幕方法锁定为竖屏</p>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>activity</span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>.HomeActivity<span class=\"token punctuation\">\"</span></span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>configChanges</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>orientation|keyboardHidden|screenSize<span class=\"token punctuation\">\"</span></span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>screenOrientation</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>portrait<span class=\"token punctuation\">\"</span></span>\n          <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>theme</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@styple/Base.Theme.CirclePage<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n</code></pre>\n<p><strong>透明窗口</strong>+<strong>固定屏幕方向</strong> 会抛出异常</p>\n<pre class=\" language-tex\"><code class=\"language-tex\">Caused by: java.lang.IllegalStateException: Only fullscreen opaque activities can request orientation\n</code></pre>\n<p>解决方案有两种：</p>\n<ul>\n<li>适配横屏，去掉固定屏幕方向的限制</li>\n<li>仅在滑动开始的时候设置窗口透明</li>\n</ul>\n<h3 id=\"Apk-安装需要权限\"><a href=\"#Apk-安装需要权限\" class=\"headerlink\" title=\"Apk 安装需要权限\"></a>Apk 安装需要权限</h3><p>在安装 APK 是需要申请安装权限 <code>REQUEST_INSTALL_PACKAGES</code></p>\n<h2 id=\"Android-9-0-适配\"><a href=\"#Android-9-0-适配\" class=\"headerlink\" title=\"Android 9.0 适配\"></a>Android 9.0 适配</h2><h3 id=\"明文-HTTP-请求限制\"><a href=\"#明文-HTTP-请求限制\" class=\"headerlink\" title=\"明文 HTTP 请求限制\"></a>明文 HTTP 请求限制</h3><p>9.0 限制了铭文网络请求，非加密的 http 请求会被系统禁止</p>\n<ul>\n<li><p>在 <code>res/xml</code> 文件夹啊下常见 <code>network_security_config.xml</code></p>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token prolog\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>network-security-config</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>base-config</span> <span class=\"token attr-name\">cleartextTrafficPermitted</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>true<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>network-security-config</span><span class=\"token punctuation\">></span></span>\n</code></pre>\n</li>\n<li><p>在 <code>AndroidManifest.xml</code> 的 <code>&lt;application</code> 标签下配置</p>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>application</span>\n             <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>networkSecurityConfig</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@xml/network_security_config<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>application</span><span class=\"token punctuation\">></span></span>\n</code></pre>\n</li>\n</ul>\n<p>或者是改用 <code>HTTPS</code> 方式请求</p>\n<h2 id=\"Android-10-0-适配\"><a href=\"#Android-10-0-适配\" class=\"headerlink\" title=\"Android 10.0 适配\"></a>Android 10.0 适配</h2><h3 id=\"分区存储\"><a href=\"#分区存储\" class=\"headerlink\" title=\"分区存储\"></a>分区存储</h3><p>如果还没有准备好适配的功能，可以在 <code>AndroidManifest.xml</code> 中添加 <code>requestLegacyExternalStorage</code> 来暂时处理</p>\n<pre class=\" language-xml\"><code class=\"language-xml\">    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>application</span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>requestLegacyExternalStorage</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>true<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n</code></pre>\n<p>Android Q 在外部存储设备中为每个应用提供另一个“隔离存储沙盒”。任何其他应用都无法直接访问您应用的沙盒文件。由<strong>于文件是私密的 ，因此不再需要任何权限即可再外部存储设备中访问和保存自己的文件。</strong></p>\n<p><strong>沙盒</strong>就是应用专属文件夹，并且访问这个文件夹不需要权限申请。官方推荐应用再沙盒内存储文件的地址为 </p>\n<blockquote>\n<p>Context.getExternalFilesDir() 下的文件夹，比如存储一张照片则应该放在 <font color=\"red\">Context.getExternalFilesDir(Environment.DIRECTORY_PICTURES) </font>中</p>\n</blockquote>\n<p><strong>适配：</strong></p>\n<ol>\n<li>访问自己文件： Q 中用更精细的媒体特定权限替换并取消了 <code>READ_EXTERNAL_STORAGE</code> 和 <code>WRITE_EXTERNAL_STORAGE</code> 权限，丙炔无需特定权限，就可以访问沙盒中的文件。</li>\n<li>访问系统媒体文件： Q 中引入了一个新定义媒体文件的共享集合，如果要访问沙盒外的媒体共享文件，比如：照片、音乐、视频等。需要申请新的媒体权限 <code>READ_MEDIA_IMAGES,READ_MEDIA_VIDEO,READ_MEIDA_AUDIO</code>，时期内那个方法同原来的存储权限</li>\n<li>访问系统下载文件：对于系统下载文件的访问，暂时没有限制，但是要访问其中其他应用的文件，必须允许用户使用系统的文件选择器应用来选择文件</li>\n<li>访问其他应用沙盒文件：如需要访问其他应用再沙盒内创建的文件，</li>\n</ol>\n<h3 id=\"设备唯一标识符\"><a href=\"#设备唯一标识符\" class=\"headerlink\" title=\"设备唯一标识符\"></a>设备唯一标识符</h3><p>访问设备序列号或者 IMEI 的应用，将会被限制，无法获取成功。因此，在 Android Q 上，应用必须具有 <code>READ_PRIVILEGED_PHONE_STATE</code> 签名权限才能访问设备的不可重置标识符（包含 IMEI 和序列号），原来的 <code>READ_PHONE_STATE</code> 权限已经不能获取 IMEI 和 序列号。如果想在 Q 设备上通过使用下面的代码获取设备的 ID</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>TelephonyManager<span class=\"token punctuation\">)</span><span class=\"token function\">getActivity</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getSystemService</span><span class=\"token punctuation\">(</span>Context<span class=\"token punctuation\">.</span>TELEPHONY_SERVICE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getDeviceId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><strong>但是，</strong>上面的代码会返回空值（targetASdkVersion &lt;= P）或者报错(targetSdkVersion == Q) ，且官网所说的 <code>READ_PRIVILEGED_PHONE_STATE</code> 权限只提供给系统 app，<font color=\"red\"><strong>所以这个方法行不通</strong></font></p>\n<p>Google 官方给与了设备唯一 ID 最佳方案，但是此方案给出的 ID 是可变的，可以按照具体需求具体解决。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> String <span class=\"token function\">getUUID</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    String serial <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n    String m_szDevIdShort <span class=\"token operator\">=</span> <span class=\"token string\">\"35\"</span> <span class=\"token operator\">+</span> \n        Build<span class=\"token punctuation\">.</span>BOARD<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">10</span> <span class=\"token operator\">+</span> Build<span class=\"token punctuation\">.</span>BRAND<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">10</span> <span class=\"token operator\">+</span> \n        Build<span class=\"token punctuation\">.</span>CPU_ABI<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">10</span> <span class=\"token operator\">+</span> Build<span class=\"token punctuation\">.</span>DEVICE<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">10</span> <span class=\"token operator\">+</span>\n        Build<span class=\"token punctuation\">.</span>DISPLAY<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">10</span> <span class=\"token operator\">+</span> Build<span class=\"token punctuation\">.</span>HOST<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">10</span> <span class=\"token operator\">+</span>\n        Build<span class=\"token punctuation\">.</span>ID<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">10</span> <span class=\"token operator\">+</span> Build<span class=\"token punctuation\">.</span>MANUFACTURER<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">10</span> <span class=\"token operator\">+</span>\n        Build<span class=\"token punctuation\">.</span>MODEL<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">10</span> <span class=\"token operator\">+</span> Build<span class=\"token punctuation\">.</span>PRODUCT<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">10</span> <span class=\"token operator\">+</span>\n        Build<span class=\"token punctuation\">.</span>TAGS<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">10</span> <span class=\"token operator\">+</span> Build<span class=\"token punctuation\">.</span>TYPE<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">10</span> <span class=\"token operator\">+</span>\n        Build<span class=\"token punctuation\">.</span>USER<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//13 位</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Build<span class=\"token punctuation\">.</span>VERSION<span class=\"token punctuation\">.</span>SDK_INT <span class=\"token operator\">>=</span> Build<span class=\"token punctuation\">.</span>VERSION_CODES<span class=\"token punctuation\">.</span>O<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        serial <span class=\"token operator\">=</span> android<span class=\"token punctuation\">.</span>os<span class=\"token punctuation\">.</span>Build<span class=\"token punctuation\">.</span><span class=\"token function\">getSerial</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        serial <span class=\"token operator\">=</span> Build<span class=\"token punctuation\">.</span>SERIAL<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\" spellcheck=\"true\">//API>=9 使用serial号</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UUID</span><span class=\"token punctuation\">(</span>m_szDevIDShort<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> serial<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> exception<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//serial需要一个初始化</span>\n    serial <span class=\"token operator\">=</span> <span class=\"token string\">\"serial\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 随便一个初始化</span>\n  <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//使用硬件信息拼凑出来的15位号码</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UUID</span><span class=\"token punctuation\">(</span>m_szDevIDShort<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> serial<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"非-SDK-接口限制\"><a href=\"#非-SDK-接口限制\" class=\"headerlink\" title=\"非 SDK 接口限制\"></a>非 SDK 接口限制</h3><p>为确保 稳定性和兼容性， Android 平台开始限制您的应用在 Android 9.0中使用哪些非 SDK 接口。</p>\n<p><strong>非 SDK 接口</strong> 限制就是某些 SDK 中的私有方法，如 private 方法，你通过 Java 反射等方法获取并调用了。那么这些调用将在 <code>target &gt;= P</code> 或者 <code>target &gt;= Q</code> 的设备上被限制使用。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"基本知识\"><a href=\"#基本知识\" class=\"headerlink\" title=\"基本知识\"></a>基本知识</h2><h3 id=\"targetSdkVersion\"><a href=\"#targetSdkVersion\" class=\"headerlink\" title=\"targetSdkVersion\"></a>targetSdkVersion</h3><p><code>targetSdkVersion</code>： 目标 SDK 版本，也就是我们最高适配的 SDK 版本</p>\n<p>不同版本的 SDK ，为我们提供了不同的 API 接口使用，丰富以及方便开发者。</p>\n<p>旧的接口行为发生了变化，为了保证 APK 的行为还是和以前兼容，在源码中多了很多类似于 <code>ctx.getApplicatioinInfo().targetSdkVersion()</code> 的判断，因此只要 APK 的 <code>targetSdkVersion</code> 不变，即使 APK 安装在新的 Android 系统上，其行为也不会发生变化。</p>","more":"<h3 id=\"compileSdkVersion\"><a href=\"#compileSdkVersion\" class=\"headerlink\" title=\"compileSdkVersion\"></a>compileSdkVersion</h3><p><code>compileSdkVersion</code> 定义应用程序编译选择哪个 Android SDK 版本，通常设置为最新的 API，它的属性值不影响 Android 系统运行行为，仅仅是 Android 编译项目时其中的一象配置，不会打包到 APK 中，真实目的时为了 <strong>在编译的时候检查代码的错误和警告，提示开发者修改和优化</strong></p>\n<h3 id=\"minSdkVersion\"><a href=\"#minSdkVersion\" class=\"headerlink\" title=\"minSdkVersion\"></a>minSdkVersion</h3><p><code>minSdkVersion</code>: 最小 SDK 版本，也就是我们最低支持的 SDK 版本</p>\n<ul>\n<li>告诉 Google Play Store 哪些 Android 版本的手机可以安装这个 APK</li>\n<li>默认情况下，lint 会对代码中的 API 调用做出提示，加入你调用的 API 在 minSdkVersion 之后才提供，它会告诉你虽然编译可以通过，但是运行时会抛出异常。</li>\n</ul>\n<p>如果调用的 API 是在 minSdkVersion 之后才提供的，解决方案有两种</p>\n<ul>\n<li><p>运行时判断 API Level， 仅在足够高，有此方法的 API Level 系统中调用</p>\n<pre><code class=\"java\">if(android.os.Build.VERSION_SDK_INIT &gt;= Build.VERSION_CODES.M) {\n    // 处理逻辑\n}\n</code></pre>\n</li>\n<li><p>保证功能的完整性，通过低版本的 API 实现功能</p>\n</li>\n</ul>\n<h2 id=\"Android-6-0-适配\"><a href=\"#Android-6-0-适配\" class=\"headerlink\" title=\"Android 6.0 适配\"></a>Android 6.0 适配</h2><h3 id=\"运行时权限请求\"><a href=\"#运行时权限请求\" class=\"headerlink\" title=\"运行时权限请求\"></a>运行时权限请求</h3><p>从 <code>Android 6.0(api &gt;= 23)</code> 开始，用户开始在运行时向其授予权限，而不是在应用安装时授予。系统权限分为两种</p>\n<ul>\n<li>正常权限。在 <code>AndroidManifest</code> 列出了正常权限，系统将自动授予该权限</li>\n<li>危险权限。在 <code>AndroidManifest</code> 中列出了危险权限，用户必须明确批准您的应用使用这些权限。</li>\n</ul>\n<h2 id=\"Android-7-0-适配\"><a href=\"#Android-7-0-适配\" class=\"headerlink\" title=\"Android 7.0 适配\"></a>Android 7.0 适配</h2><h3 id=\"应用间共享文件限制\"><a href=\"#应用间共享文件限制\" class=\"headerlink\" title=\"应用间共享文件限制\"></a>应用间共享文件限制</h3><p>在 <code>Android 7.0</code> 系统上， Android 框架强制执行了 <code>ScrictMode API</code> 政策，禁止向应用外公开 <code>file://URI</code> 如果一项包含文件 <code>file://URI</code> 类型的 <code>Intent</code> 离开了你的应用，即调用 <code>Uri.from(file)</code> 传递文件路径给第三方应用，会出现 <code>FileUriExposedException</code> 异常，如调用系统相机拍照、裁切照片、打开 APK 安装界面等。</p>\n<p>如果要在 <strong>应用见共享文件</strong> ，可以发送 <code>content://URI</code>类型的 Uri， 并授予 Uri 临时访问全新啊，进行此授权的最简单方式是使用 <code>FileProvider</code> 类</p>\n<p>步骤如下：</p>\n<ul>\n<li><p>在 <code>AndroidManifest.xml</code> 清单文件中注册 <code>provider</code></p>\n<pre><code class=\"xml\">&lt;provider\n          android:name=&quot;android.support.v4.content.FileProvider&quot;\n          android:authorities=&quot;com.demo.***.provider&quot;\n          android:exported=&quot;false&quot;\n          android:grantUriPermissions=&quot;true&quot;&gt;\n    &lt;meta-data\n               android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;\n               android:resource=&quot;@xml/file_provider_paths&quot;/&gt;\n&lt;/provider&gt;\n</code></pre>\n<ul>\n<li><p><code>export</code> 为 <code>false</code></p>\n</li>\n<li><p><code>grantUriPermissions</code> 表示授予 <code>URI</code> 临时访问权限</p>\n</li>\n</ul>\n</li>\n<li><p>指定共享目录</p>\n<p>上面的 <code>android:resource=&quot;@xml/file_provider_paths&quot;</code> 指定了共享的目录，配置如下：</p>\n<pre><code class=\"xml\">&lt;path xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;\n     &lt;!-- 代表设备的根目录 new File(&quot;/&quot;) --&gt;\n    &lt;root-path \n               name=&quot;root&quot;\n               path=&quot;.&quot;/&gt;\n     &lt;!-- 代表 content.getFilesDir()--&gt;\n    &lt;files-path\n                name=&quot;captured_media&quot;\n                path=&quot;captrued_media&quot;/&gt;\n     &lt;!-- 代表 content.getCacheDir() --&gt;\n    &lt;cache-path\n                name=&quot;cache&quot;\n                path=&quot;appCache&quot;/&gt;\n    &lt;!-- 代表 Environment.getExtrnalStorageDirectory() --&gt;\n    &lt;external-path\n                   name=&quot;data&quot;\n                   path=&quot;Android&quot;/&gt;\n    &lt;!-- 代表 content.getExternalFilesDirs()--&gt;\n    &lt;external-files-path\n                 name=&quot;external&quot;\n                 path=&quot;&quot;/&gt;\n    &lt;!-- 代表 getExternalCacheDirs() --&gt;    \n    &lt;external-cache-path\n                 name=&quot;external&quot;\n                 path=&quot;&quot;/&gt;\n&lt;/path&gt;\n</code></pre>\n<p>  通过 <code>FileProvider</code> 打开下载完的 APK 实例</p>\n<pre><code class=\"java\">public static Intent getOpenFileIntent(Context context, DownloadResponse downloadReponse) {\n    File file = new File(downloadResponse.getParentPath(), downloadResponse.getFileName());\n    if(!file.exists()) {\n        return null;\n    }\n    Intent intent = new Intent();\n    intent.addFlag(Intent.FLAG_ACTIVITY_NEW_TASK);\n    intent.setAction(Intent.ACTION_VIEW);\n    if(Build.VERSION.SDK_INI &gt;= Build.VERSION_CODES.N) {\n        intent.setFlag(Intern.FLAG_GRANT_READ_URI_PERMISSION);\n        Uri contentUri = FileProvider.getUriForFile(context, &quot;com.demo.***.provider&quot;， file);\n        intent.setDataAndType(contentUri, downloadResponse.getMimeType());\n    } else {\n        intent.setDataAndType(Uri.fromFile(file), downloadResponse.getMimeType());\n    }\n\n    if(!context instanceof Activity) {\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n    }\n  return intent;\n}\n</code></pre>\n</li>\n</ul>\n<h3 id=\"系统广播删除\"><a href=\"#系统广播删除\" class=\"headerlink\" title=\"系统广播删除\"></a>系统广播删除</h3><p>Android N 管理了三项系统广播:<em>网络状态变更广播</em>、<em>拍照广播</em>  和 <em>录像广播</em></p>\n<p>只有通过 <strong>动态注册</strong> 的方式才能收到网络变化的广播， 在 <code>AndroidManifest.xml</code> 中静态注册的无法收到</p>\n<h2 id=\"Android-8-0-适配\"><a href=\"#Android-8-0-适配\" class=\"headerlink\" title=\"Android 8.0 适配\"></a>Android 8.0 适配</h2><h3 id=\"通知渠道\"><a href=\"#通知渠道\" class=\"headerlink\" title=\"通知渠道\"></a>通知渠道</h3><p>在 Android 8.0 中所有的通知都需要提供通知渠道，否则所有通知在 8.0 系统上都不能正常显示</p>\n<pre><code class=\"java\">DownloadNotifier(Context context) {\n    mContext = context;\n    mManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);\n    if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODE.O) {\n        @SuppressWarings(&quot;all&quot;)\n        final NotificationChanncl channel = new NotificationChannel(CHANNEL_ID, CHANNEL_NAME, NotifationManager.IMPORTANCE_HIGH);\n        mManager.createNotificationChannel(channel)\n    }\n}\n</code></pre>\n<h3 id=\"悬浮窗（工具类-APP-使用）\"><a href=\"#悬浮窗（工具类-APP-使用）\" class=\"headerlink\" title=\"悬浮窗（工具类 APP 使用）\"></a>悬浮窗（工具类 APP 使用）</h3><p>8.0 新增了一种悬浮窗的窗口类型， <code>TYPE_APPLICATION_OVERLAY</code>, 如果应用使用 <code>SYSTEM_ALERT_WINDOW</code> 权限并且使用以下窗口类型之一在其他应用和窗口上方显示提醒窗口，都会显示在 <code>TYPE_APPLICATION_OVERLAY</code> 窗口类型的下方</p>\n<ul>\n<li>TYPE_PHONE</li>\n<li>TYPE_PRIORITY_PHONE</li>\n<li>TYPE_SYSTEM_ALERT</li>\n<li>TYPE_SYSTEM_OVERLAY</li>\n<li>TYPE_SYSTEM_ERROR</li>\n<li>TYPE_TOAST</li>\n</ul>\n<p>如果该应用的 <code>targetSdkVersion &gt;= 26</code> ,则应用只能使用 <code>TYPE_APPLICATION_OVERLAY</code> 窗口类型来创建悬浮窗。</p>\n<pre><code class=\"java\">if (Build.VERSION.SDK_INT &gt;= 26) {//8.0新特性\n   mWindowParams.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY;\n} else {\n   mWindowParams.type = WindowManager.LayoutParams.TYPE_SYSTEM_ALERT;\n}\n</code></pre>\n<h3 id=\"透明窗口不允许锁定屏幕旋转\"><a href=\"#透明窗口不允许锁定屏幕旋转\" class=\"headerlink\" title=\"透明窗口不允许锁定屏幕旋转\"></a>透明窗口不允许锁定屏幕旋转</h3><p>之前应用中的策划返回方案需要将窗口设为透明，但是由于没有适配横屏，因此将其屏幕方法锁定为竖屏</p>\n<pre><code class=\"xml\">&lt;activity\n          android:name=&quot;.HomeActivity&quot;\n          android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;\n          android:screenOrientation=&quot;portrait&quot;\n          android:theme=&quot;@styple/Base.Theme.CirclePage&quot;/&gt;\n</code></pre>\n<p><strong>透明窗口</strong>+<strong>固定屏幕方向</strong> 会抛出异常</p>\n<pre><code class=\"tex\">Caused by: java.lang.IllegalStateException: Only fullscreen opaque activities can request orientation\n</code></pre>\n<p>解决方案有两种：</p>\n<ul>\n<li>适配横屏，去掉固定屏幕方向的限制</li>\n<li>仅在滑动开始的时候设置窗口透明</li>\n</ul>\n<h3 id=\"Apk-安装需要权限\"><a href=\"#Apk-安装需要权限\" class=\"headerlink\" title=\"Apk 安装需要权限\"></a>Apk 安装需要权限</h3><p>在安装 APK 是需要申请安装权限 <code>REQUEST_INSTALL_PACKAGES</code></p>\n<h2 id=\"Android-9-0-适配\"><a href=\"#Android-9-0-适配\" class=\"headerlink\" title=\"Android 9.0 适配\"></a>Android 9.0 适配</h2><h3 id=\"明文-HTTP-请求限制\"><a href=\"#明文-HTTP-请求限制\" class=\"headerlink\" title=\"明文 HTTP 请求限制\"></a>明文 HTTP 请求限制</h3><p>9.0 限制了铭文网络请求，非加密的 http 请求会被系统禁止</p>\n<ul>\n<li><p>在 <code>res/xml</code> 文件夹啊下常见 <code>network_security_config.xml</code></p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;network-security-config&gt;\n    &lt;base-config cleartextTrafficPermitted=&quot;true&quot;/&gt;\n&lt;/network-security-config&gt;\n</code></pre>\n</li>\n<li><p>在 <code>AndroidManifest.xml</code> 的 <code>&lt;application</code> 标签下配置</p>\n<pre><code class=\"xml\">&lt;application\n             android:networkSecurityConfig=&quot;@xml/network_security_config&quot;&gt;\n&lt;/application&gt;\n</code></pre>\n</li>\n</ul>\n<p>或者是改用 <code>HTTPS</code> 方式请求</p>\n<h2 id=\"Android-10-0-适配\"><a href=\"#Android-10-0-适配\" class=\"headerlink\" title=\"Android 10.0 适配\"></a>Android 10.0 适配</h2><h3 id=\"分区存储\"><a href=\"#分区存储\" class=\"headerlink\" title=\"分区存储\"></a>分区存储</h3><p>如果还没有准备好适配的功能，可以在 <code>AndroidManifest.xml</code> 中添加 <code>requestLegacyExternalStorage</code> 来暂时处理</p>\n<pre><code class=\"xml\">    &lt;application\n        android:requestLegacyExternalStorage=&quot;true&quot;/&gt;\n</code></pre>\n<p>Android Q 在外部存储设备中为每个应用提供另一个“隔离存储沙盒”。任何其他应用都无法直接访问您应用的沙盒文件。由<strong>于文件是私密的 ，因此不再需要任何权限即可再外部存储设备中访问和保存自己的文件。</strong></p>\n<p><strong>沙盒</strong>就是应用专属文件夹，并且访问这个文件夹不需要权限申请。官方推荐应用再沙盒内存储文件的地址为 </p>\n<blockquote>\n<p>Context.getExternalFilesDir() 下的文件夹，比如存储一张照片则应该放在 <font color=\"red\">Context.getExternalFilesDir(Environment.DIRECTORY_PICTURES) </font>中</p>\n</blockquote>\n<p><strong>适配：</strong></p>\n<ol>\n<li>访问自己文件： Q 中用更精细的媒体特定权限替换并取消了 <code>READ_EXTERNAL_STORAGE</code> 和 <code>WRITE_EXTERNAL_STORAGE</code> 权限，丙炔无需特定权限，就可以访问沙盒中的文件。</li>\n<li>访问系统媒体文件： Q 中引入了一个新定义媒体文件的共享集合，如果要访问沙盒外的媒体共享文件，比如：照片、音乐、视频等。需要申请新的媒体权限 <code>READ_MEDIA_IMAGES,READ_MEDIA_VIDEO,READ_MEIDA_AUDIO</code>，时期内那个方法同原来的存储权限</li>\n<li>访问系统下载文件：对于系统下载文件的访问，暂时没有限制，但是要访问其中其他应用的文件，必须允许用户使用系统的文件选择器应用来选择文件</li>\n<li>访问其他应用沙盒文件：如需要访问其他应用再沙盒内创建的文件，</li>\n</ol>\n<h3 id=\"设备唯一标识符\"><a href=\"#设备唯一标识符\" class=\"headerlink\" title=\"设备唯一标识符\"></a>设备唯一标识符</h3><p>访问设备序列号或者 IMEI 的应用，将会被限制，无法获取成功。因此，在 Android Q 上，应用必须具有 <code>READ_PRIVILEGED_PHONE_STATE</code> 签名权限才能访问设备的不可重置标识符（包含 IMEI 和序列号），原来的 <code>READ_PHONE_STATE</code> 权限已经不能获取 IMEI 和 序列号。如果想在 Q 设备上通过使用下面的代码获取设备的 ID</p>\n<pre><code class=\"java\">((TelephonyManager)getActivity().getSystemService(Context.TELEPHONY_SERVICE)).getDeviceId();\n</code></pre>\n<p><strong>但是，</strong>上面的代码会返回空值（targetASdkVersion &lt;= P）或者报错(targetSdkVersion == Q) ，且官网所说的 <code>READ_PRIVILEGED_PHONE_STATE</code> 权限只提供给系统 app，<font color=\"red\"><strong>所以这个方法行不通</strong></font></p>\n<p>Google 官方给与了设备唯一 ID 最佳方案，但是此方案给出的 ID 是可变的，可以按照具体需求具体解决。</p>\n<pre><code class=\"java\">public static String getUUID() {\n    String serial = null;\n    String m_szDevIdShort = &quot;35&quot; + \n        Build.BOARD.length() % 10 + Build.BRAND.length() % 10 + \n        Build.CPU_ABI.length() % 10 + Build.DEVICE.length() % 10 +\n        Build.DISPLAY.length() % 10 + Build.HOST.length() % 10 +\n        Build.ID.length() % 10 + Build.MANUFACTURER.length() % 10 +\n        Build.MODEL.length() % 10 + Build.PRODUCT.length() % 10 +\n        Build.TAGS.length() % 10 + Build.TYPE.length() % 10 +\n        Build.USER.length() % 10; //13 位\n    try {\n      if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {\n        serial = android.os.Build.getSerial();\n      } else {\n        serial = Build.SERIAL;\n      }\n      //API&gt;=9 使用serial号\n      return new UUID(m_szDevIDShort.hashCode(), serial.hashCode()).toString();\n    } catch (Exception exception) {\n    //serial需要一个初始化\n    serial = &quot;serial&quot;; // 随便一个初始化\n  }\n    //使用硬件信息拼凑出来的15位号码\n    return new UUID(m_szDevIDShort.hashCode(), serial.hashCode()).toString();\n}\n</code></pre>\n<h3 id=\"非-SDK-接口限制\"><a href=\"#非-SDK-接口限制\" class=\"headerlink\" title=\"非 SDK 接口限制\"></a>非 SDK 接口限制</h3><p>为确保 稳定性和兼容性， Android 平台开始限制您的应用在 Android 9.0中使用哪些非 SDK 接口。</p>\n<p><strong>非 SDK 接口</strong> 限制就是某些 SDK 中的私有方法，如 private 方法，你通过 Java 反射等方法获取并调用了。那么这些调用将在 <code>target &gt;= P</code> 或者 <code>target &gt;= Q</code> 的设备上被限制使用。</p>"},{"title":"Android Q 文件权限适配","date":"2020-03-11T12:11:41.000Z","_content":"\n随着 Android Q 的发布，随之而来的适配工作也在暗潮涌动，这里说一下 Android Q 文件存储；\nAndroid Q 在外部存储设备中为每个应用提供了一个“沙盒”，任何其他应用都无法直接访问您的沙盒文件。由于文件是您应用的私有文件，因此您不在需要任何权限即可在外部存储设备中访问和保存自己的设备。这次更新有效的保证了用户文件的隐私性，也赚少了对应应用所需要的权限数量。\n\n“沙盒”就是应用的专属文件，并且访问这个文件夹无需任何权限。Google 推荐应用的沙盒内存储文件地址为\n`Context.getExternalFilesDir()` 下的文件夹。需要传入以下参数\n\n```java\nEnvironment.DIRECTORY_MUSIC\nEnvironment.DIRECTORY_PODCASTS\nEnvironment.DIRECTORY_RINGTONES\nEnvironment.DIRECTORY_ALARMS\nEnvironment.DIRECTORY_NOTIFICATIONS\nEnvironment.DIRECTORY_PICUTRES\nEnvironment.DIRECTORY_MOVIES\n```\n<!-- more -->\n\n可根据具体需要，传入不通的参数。\n\n```java\n\n    /**\n     * 获取一个文件通过文件夹类型\n     *\n     * @param fileName\n     * @param boxType\n     * @param defaultPath\n     * @return\n     * @throws FileNotFoundException\n     */\n    default File getFile(String fileName, String boxType, String defaultPath) throws FileNotFoundException {\n        File file;\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\n            file = getCurrentContext().getExternalFilesDir(boxType + File.separator + fileName);\n        } else {\n            file = new File(defaultPath + fileName);\n        }\n        if (file == null || !file.exists()) {\n            throw new FileNotFoundException();\n        }\n\n        return file;\n    }\n```\n\n**以上代码未经测试，忘见谅**\n\n接下来说一下如何使用系统公共文件，比如相册，相机，下载目录等，这里以访问相册为例：\n\n访问沙盒外(其他应用)的文件系统时，依然需要申请文件权限，`Manifest.permission.READ_EXTERNAL_STORAGE` 和 `Manifest.permission.WRITE_EXTERNAL_STORAGE` \n\n我们来看一下获取相册资源的代码：\n```java\nfinal Uri contentUri = MediaStore.Files.getContentUri(\"external\");\n            final String sortOrder = MediaStore.Files.FileColumns.DATE_MODIFIED + \" DESC\";\n            final String selection =\n                    \"(\" + MediaStore.Files.FileColumns.MEDIA_TYPE + \"=?\"\n                            + \" OR \"\n                            + MediaStore.Files.FileColumns.MEDIA_TYPE + \"=?)\"\n                            + \" AND \"\n                            + MediaStore.MediaColumns.SIZE + \">0\";\n\n            final String[] selectionAllArgs = {String.valueOf(MediaStore.Files.FileColumns.MEDIA_TYPE_IMAGE)};\n\n            ContentResolver contentResolver = mContext.getContentResolver();\n            String[] projections;\n            projections = new String[]{MediaStore.Files.FileColumns._ID, MediaStore.MediaColumns.DATA,\n                    MediaStore.MediaColumns.DISPLAY_NAME, MediaStore.MediaColumns.DATE_MODIFIED,\n                    MediaStore.MediaColumns.MIME_TYPE, MediaStore.MediaColumns.WIDTH, MediaStore\n                    .MediaColumns.HEIGHT, MediaStore.MediaColumns.SIZE};\n\n            Cursor cursor = contentResolver.query(contentUri, projections, selection, selectionAllArgs, sortOrder);\n            \n            if (cursor != null && cursor.moveToFirst()) {\n                        int pathIndex = cursor.getColumnIndex(MediaStore.MediaColumns.DATA);\n                        int mimeTypeIndex = cursor.getColumnIndex(MediaStore.MediaColumns.MIME_TYPE);\n                        int sizeIndex = cursor.getColumnIndex(MediaStore.MediaColumns.SIZE);\n                        int widthIndex = cursor.getColumnIndex(MediaStore.MediaColumns.WIDTH);\n                        int heightIndex = cursor.getColumnIndex(MediaStore.MediaColumns.HEIGHT);\n\n                        do {\n                            long size = cursor.getLong(sizeIndex);\n                            if (size < 1) {\n                                continue;\n                            }\n\n                            String type = cursor.getString(mimeTypeIndex);\n                            String path = cursor.getString(pathIndex);\n                            if (TextUtils.isEmpty(path) || TextUtils.isEmpty(type)) {\n                                continue;\n                            }\n\n                            int width = cursor.getInt(widthIndex);\n                            int height = cursor.getInt(heightIndex);\n                            if (width < 1 || height < 1) {\n                                continue;\n                            }\n\n                            File file = new File(path);\n                            if (!file.exists() || !file.isFile()) {\n                                continue;\n                            }\n\n                            File parentFile = file.getParentFile();\n                            if (parentFile != null) {\n                                images.add(path);\n                            }\n\n                        } while (cursor.moveToNext());\n\n                        cursor.close();\n                    }\n\n\n```\n\n通过上述代码，我们就可以用图片加载工具将图片显示出来，但需要注意的是，我们需要在`AndroidManifest.xml` 中的 `<application>` 标签中加入 `android:requestLegacyExternalStorage=\"true\"` \n\n","source":"_posts/Android 基础/适配/Android-Q-文件权限适配.md","raw":"---\ntitle: Android Q 文件权限适配\ndate: 2020-03-11 20:11:41\ntags:\n---\n\n随着 Android Q 的发布，随之而来的适配工作也在暗潮涌动，这里说一下 Android Q 文件存储；\nAndroid Q 在外部存储设备中为每个应用提供了一个“沙盒”，任何其他应用都无法直接访问您的沙盒文件。由于文件是您应用的私有文件，因此您不在需要任何权限即可在外部存储设备中访问和保存自己的设备。这次更新有效的保证了用户文件的隐私性，也赚少了对应应用所需要的权限数量。\n\n“沙盒”就是应用的专属文件，并且访问这个文件夹无需任何权限。Google 推荐应用的沙盒内存储文件地址为\n`Context.getExternalFilesDir()` 下的文件夹。需要传入以下参数\n\n```java\nEnvironment.DIRECTORY_MUSIC\nEnvironment.DIRECTORY_PODCASTS\nEnvironment.DIRECTORY_RINGTONES\nEnvironment.DIRECTORY_ALARMS\nEnvironment.DIRECTORY_NOTIFICATIONS\nEnvironment.DIRECTORY_PICUTRES\nEnvironment.DIRECTORY_MOVIES\n```\n<!-- more -->\n\n可根据具体需要，传入不通的参数。\n\n```java\n\n    /**\n     * 获取一个文件通过文件夹类型\n     *\n     * @param fileName\n     * @param boxType\n     * @param defaultPath\n     * @return\n     * @throws FileNotFoundException\n     */\n    default File getFile(String fileName, String boxType, String defaultPath) throws FileNotFoundException {\n        File file;\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\n            file = getCurrentContext().getExternalFilesDir(boxType + File.separator + fileName);\n        } else {\n            file = new File(defaultPath + fileName);\n        }\n        if (file == null || !file.exists()) {\n            throw new FileNotFoundException();\n        }\n\n        return file;\n    }\n```\n\n**以上代码未经测试，忘见谅**\n\n接下来说一下如何使用系统公共文件，比如相册，相机，下载目录等，这里以访问相册为例：\n\n访问沙盒外(其他应用)的文件系统时，依然需要申请文件权限，`Manifest.permission.READ_EXTERNAL_STORAGE` 和 `Manifest.permission.WRITE_EXTERNAL_STORAGE` \n\n我们来看一下获取相册资源的代码：\n```java\nfinal Uri contentUri = MediaStore.Files.getContentUri(\"external\");\n            final String sortOrder = MediaStore.Files.FileColumns.DATE_MODIFIED + \" DESC\";\n            final String selection =\n                    \"(\" + MediaStore.Files.FileColumns.MEDIA_TYPE + \"=?\"\n                            + \" OR \"\n                            + MediaStore.Files.FileColumns.MEDIA_TYPE + \"=?)\"\n                            + \" AND \"\n                            + MediaStore.MediaColumns.SIZE + \">0\";\n\n            final String[] selectionAllArgs = {String.valueOf(MediaStore.Files.FileColumns.MEDIA_TYPE_IMAGE)};\n\n            ContentResolver contentResolver = mContext.getContentResolver();\n            String[] projections;\n            projections = new String[]{MediaStore.Files.FileColumns._ID, MediaStore.MediaColumns.DATA,\n                    MediaStore.MediaColumns.DISPLAY_NAME, MediaStore.MediaColumns.DATE_MODIFIED,\n                    MediaStore.MediaColumns.MIME_TYPE, MediaStore.MediaColumns.WIDTH, MediaStore\n                    .MediaColumns.HEIGHT, MediaStore.MediaColumns.SIZE};\n\n            Cursor cursor = contentResolver.query(contentUri, projections, selection, selectionAllArgs, sortOrder);\n            \n            if (cursor != null && cursor.moveToFirst()) {\n                        int pathIndex = cursor.getColumnIndex(MediaStore.MediaColumns.DATA);\n                        int mimeTypeIndex = cursor.getColumnIndex(MediaStore.MediaColumns.MIME_TYPE);\n                        int sizeIndex = cursor.getColumnIndex(MediaStore.MediaColumns.SIZE);\n                        int widthIndex = cursor.getColumnIndex(MediaStore.MediaColumns.WIDTH);\n                        int heightIndex = cursor.getColumnIndex(MediaStore.MediaColumns.HEIGHT);\n\n                        do {\n                            long size = cursor.getLong(sizeIndex);\n                            if (size < 1) {\n                                continue;\n                            }\n\n                            String type = cursor.getString(mimeTypeIndex);\n                            String path = cursor.getString(pathIndex);\n                            if (TextUtils.isEmpty(path) || TextUtils.isEmpty(type)) {\n                                continue;\n                            }\n\n                            int width = cursor.getInt(widthIndex);\n                            int height = cursor.getInt(heightIndex);\n                            if (width < 1 || height < 1) {\n                                continue;\n                            }\n\n                            File file = new File(path);\n                            if (!file.exists() || !file.isFile()) {\n                                continue;\n                            }\n\n                            File parentFile = file.getParentFile();\n                            if (parentFile != null) {\n                                images.add(path);\n                            }\n\n                        } while (cursor.moveToNext());\n\n                        cursor.close();\n                    }\n\n\n```\n\n通过上述代码，我们就可以用图片加载工具将图片显示出来，但需要注意的是，我们需要在`AndroidManifest.xml` 中的 `<application>` 标签中加入 `android:requestLegacyExternalStorage=\"true\"` \n\n","slug":"Android 基础/适配/Android-Q-文件权限适配","published":1,"updated":"2021-01-29T15:54:28.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8kk003bsz5q5rh1mxpo","content":"<p>随着 Android Q 的发布，随之而来的适配工作也在暗潮涌动，这里说一下 Android Q 文件存储；<br>Android Q 在外部存储设备中为每个应用提供了一个“沙盒”，任何其他应用都无法直接访问您的沙盒文件。由于文件是您应用的私有文件，因此您不在需要任何权限即可在外部存储设备中访问和保存自己的设备。这次更新有效的保证了用户文件的隐私性，也赚少了对应应用所需要的权限数量。</p>\n<p>“沙盒”就是应用的专属文件，并且访问这个文件夹无需任何权限。Google 推荐应用的沙盒内存储文件地址为<br><code>Context.getExternalFilesDir()</code> 下的文件夹。需要传入以下参数</p>\n<pre class=\" language-java\"><code class=\"language-java\">Environment<span class=\"token punctuation\">.</span>DIRECTORY_MUSIC\nEnvironment<span class=\"token punctuation\">.</span>DIRECTORY_PODCASTS\nEnvironment<span class=\"token punctuation\">.</span>DIRECTORY_RINGTONES\nEnvironment<span class=\"token punctuation\">.</span>DIRECTORY_ALARMS\nEnvironment<span class=\"token punctuation\">.</span>DIRECTORY_NOTIFICATIONS\nEnvironment<span class=\"token punctuation\">.</span>DIRECTORY_PICUTRES\nEnvironment<span class=\"token punctuation\">.</span>DIRECTORY_MOVIES\n</code></pre>\n<a id=\"more\"></a>\n<p>可根据具体需要，传入不通的参数。</p>\n<pre class=\" language-java\"><code class=\"language-java\">\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 获取一个文件通过文件夹类型\n     *\n     * @param fileName\n     * @param boxType\n     * @param defaultPath\n     * @return\n     * @throws FileNotFoundException\n     */</span>\n    <span class=\"token keyword\">default</span> File <span class=\"token function\">getFile</span><span class=\"token punctuation\">(</span>String fileName<span class=\"token punctuation\">,</span> String boxType<span class=\"token punctuation\">,</span> String defaultPath<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> FileNotFoundException <span class=\"token punctuation\">{</span>\n        File file<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Build<span class=\"token punctuation\">.</span>VERSION<span class=\"token punctuation\">.</span>SDK_INT <span class=\"token operator\">>=</span> Build<span class=\"token punctuation\">.</span>VERSION_CODES<span class=\"token punctuation\">.</span>Q<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            file <span class=\"token operator\">=</span> <span class=\"token function\">getCurrentContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getExternalFilesDir</span><span class=\"token punctuation\">(</span>boxType <span class=\"token operator\">+</span> File<span class=\"token punctuation\">.</span>separator <span class=\"token operator\">+</span> fileName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            file <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">(</span>defaultPath <span class=\"token operator\">+</span> fileName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>file <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>file<span class=\"token punctuation\">.</span><span class=\"token function\">exists</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileNotFoundException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">return</span> file<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>以上代码未经测试，忘见谅</strong></p>\n<p>接下来说一下如何使用系统公共文件，比如相册，相机，下载目录等，这里以访问相册为例：</p>\n<p>访问沙盒外(其他应用)的文件系统时，依然需要申请文件权限，<code>Manifest.permission.READ_EXTERNAL_STORAGE</code> 和 <code>Manifest.permission.WRITE_EXTERNAL_STORAGE</code> </p>\n<p>我们来看一下获取相册资源的代码：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">final</span> Uri contentUri <span class=\"token operator\">=</span> MediaStore<span class=\"token punctuation\">.</span>Files<span class=\"token punctuation\">.</span><span class=\"token function\">getContentUri</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"external\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">final</span> String sortOrder <span class=\"token operator\">=</span> MediaStore<span class=\"token punctuation\">.</span>Files<span class=\"token punctuation\">.</span>FileColumns<span class=\"token punctuation\">.</span>DATE_MODIFIED <span class=\"token operator\">+</span> <span class=\"token string\">\" DESC\"</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">final</span> String selection <span class=\"token operator\">=</span>\n                    <span class=\"token string\">\"(\"</span> <span class=\"token operator\">+</span> MediaStore<span class=\"token punctuation\">.</span>Files<span class=\"token punctuation\">.</span>FileColumns<span class=\"token punctuation\">.</span>MEDIA_TYPE <span class=\"token operator\">+</span> <span class=\"token string\">\"=?\"</span>\n                            <span class=\"token operator\">+</span> <span class=\"token string\">\" OR \"</span>\n                            <span class=\"token operator\">+</span> MediaStore<span class=\"token punctuation\">.</span>Files<span class=\"token punctuation\">.</span>FileColumns<span class=\"token punctuation\">.</span>MEDIA_TYPE <span class=\"token operator\">+</span> <span class=\"token string\">\"=?)\"</span>\n                            <span class=\"token operator\">+</span> <span class=\"token string\">\" AND \"</span>\n                            <span class=\"token operator\">+</span> MediaStore<span class=\"token punctuation\">.</span>MediaColumns<span class=\"token punctuation\">.</span>SIZE <span class=\"token operator\">+</span> <span class=\"token string\">\">0\"</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">final</span> String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> selectionAllArgs <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>MediaStore<span class=\"token punctuation\">.</span>Files<span class=\"token punctuation\">.</span>FileColumns<span class=\"token punctuation\">.</span>MEDIA_TYPE_IMAGE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n            ContentResolver contentResolver <span class=\"token operator\">=</span> mContext<span class=\"token punctuation\">.</span><span class=\"token function\">getContentResolver</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> projections<span class=\"token punctuation\">;</span>\n            projections <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">{</span>MediaStore<span class=\"token punctuation\">.</span>Files<span class=\"token punctuation\">.</span>FileColumns<span class=\"token punctuation\">.</span>_ID<span class=\"token punctuation\">,</span> MediaStore<span class=\"token punctuation\">.</span>MediaColumns<span class=\"token punctuation\">.</span>DATA<span class=\"token punctuation\">,</span>\n                    MediaStore<span class=\"token punctuation\">.</span>MediaColumns<span class=\"token punctuation\">.</span>DISPLAY_NAME<span class=\"token punctuation\">,</span> MediaStore<span class=\"token punctuation\">.</span>MediaColumns<span class=\"token punctuation\">.</span>DATE_MODIFIED<span class=\"token punctuation\">,</span>\n                    MediaStore<span class=\"token punctuation\">.</span>MediaColumns<span class=\"token punctuation\">.</span>MIME_TYPE<span class=\"token punctuation\">,</span> MediaStore<span class=\"token punctuation\">.</span>MediaColumns<span class=\"token punctuation\">.</span>WIDTH<span class=\"token punctuation\">,</span> MediaStore\n                    <span class=\"token punctuation\">.</span>MediaColumns<span class=\"token punctuation\">.</span>HEIGHT<span class=\"token punctuation\">,</span> MediaStore<span class=\"token punctuation\">.</span>MediaColumns<span class=\"token punctuation\">.</span>SIZE<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n            Cursor cursor <span class=\"token operator\">=</span> contentResolver<span class=\"token punctuation\">.</span><span class=\"token function\">query</span><span class=\"token punctuation\">(</span>contentUri<span class=\"token punctuation\">,</span> projections<span class=\"token punctuation\">,</span> selection<span class=\"token punctuation\">,</span> selectionAllArgs<span class=\"token punctuation\">,</span> sortOrder<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cursor <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> cursor<span class=\"token punctuation\">.</span><span class=\"token function\">moveToFirst</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token keyword\">int</span> pathIndex <span class=\"token operator\">=</span> cursor<span class=\"token punctuation\">.</span><span class=\"token function\">getColumnIndex</span><span class=\"token punctuation\">(</span>MediaStore<span class=\"token punctuation\">.</span>MediaColumns<span class=\"token punctuation\">.</span>DATA<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token keyword\">int</span> mimeTypeIndex <span class=\"token operator\">=</span> cursor<span class=\"token punctuation\">.</span><span class=\"token function\">getColumnIndex</span><span class=\"token punctuation\">(</span>MediaStore<span class=\"token punctuation\">.</span>MediaColumns<span class=\"token punctuation\">.</span>MIME_TYPE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token keyword\">int</span> sizeIndex <span class=\"token operator\">=</span> cursor<span class=\"token punctuation\">.</span><span class=\"token function\">getColumnIndex</span><span class=\"token punctuation\">(</span>MediaStore<span class=\"token punctuation\">.</span>MediaColumns<span class=\"token punctuation\">.</span>SIZE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token keyword\">int</span> widthIndex <span class=\"token operator\">=</span> cursor<span class=\"token punctuation\">.</span><span class=\"token function\">getColumnIndex</span><span class=\"token punctuation\">(</span>MediaStore<span class=\"token punctuation\">.</span>MediaColumns<span class=\"token punctuation\">.</span>WIDTH<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token keyword\">int</span> heightIndex <span class=\"token operator\">=</span> cursor<span class=\"token punctuation\">.</span><span class=\"token function\">getColumnIndex</span><span class=\"token punctuation\">(</span>MediaStore<span class=\"token punctuation\">.</span>MediaColumns<span class=\"token punctuation\">.</span>HEIGHT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n                        <span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n                            <span class=\"token keyword\">long</span> size <span class=\"token operator\">=</span> cursor<span class=\"token punctuation\">.</span><span class=\"token function\">getLong</span><span class=\"token punctuation\">(</span>sizeIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>size <span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                                <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n                            <span class=\"token punctuation\">}</span>\n\n                            String type <span class=\"token operator\">=</span> cursor<span class=\"token punctuation\">.</span><span class=\"token function\">getString</span><span class=\"token punctuation\">(</span>mimeTypeIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                            String path <span class=\"token operator\">=</span> cursor<span class=\"token punctuation\">.</span><span class=\"token function\">getString</span><span class=\"token punctuation\">(</span>pathIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>TextUtils<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> TextUtils<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                                <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n                            <span class=\"token punctuation\">}</span>\n\n                            <span class=\"token keyword\">int</span> width <span class=\"token operator\">=</span> cursor<span class=\"token punctuation\">.</span><span class=\"token function\">getInt</span><span class=\"token punctuation\">(</span>widthIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                            <span class=\"token keyword\">int</span> height <span class=\"token operator\">=</span> cursor<span class=\"token punctuation\">.</span><span class=\"token function\">getInt</span><span class=\"token punctuation\">(</span>heightIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>width <span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span> <span class=\"token operator\">||</span> height <span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                                <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n                            <span class=\"token punctuation\">}</span>\n\n                            File file <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>file<span class=\"token punctuation\">.</span><span class=\"token function\">exists</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>file<span class=\"token punctuation\">.</span><span class=\"token function\">isFile</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                                <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n                            <span class=\"token punctuation\">}</span>\n\n                            File parentFile <span class=\"token operator\">=</span> file<span class=\"token punctuation\">.</span><span class=\"token function\">getParentFile</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>parentFile <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                                images<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                            <span class=\"token punctuation\">}</span>\n\n                        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>cursor<span class=\"token punctuation\">.</span><span class=\"token function\">moveToNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n                        cursor<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n\n\n</code></pre>\n<p>通过上述代码，我们就可以用图片加载工具将图片显示出来，但需要注意的是，我们需要在<code>AndroidManifest.xml</code> 中的 <code>&lt;application&gt;</code> 标签中加入 <code>android:requestLegacyExternalStorage=&quot;true&quot;</code> </p>\n","site":{"data":{}},"excerpt":"<p>随着 Android Q 的发布，随之而来的适配工作也在暗潮涌动，这里说一下 Android Q 文件存储；<br>Android Q 在外部存储设备中为每个应用提供了一个“沙盒”，任何其他应用都无法直接访问您的沙盒文件。由于文件是您应用的私有文件，因此您不在需要任何权限即可在外部存储设备中访问和保存自己的设备。这次更新有效的保证了用户文件的隐私性，也赚少了对应应用所需要的权限数量。</p>\n<p>“沙盒”就是应用的专属文件，并且访问这个文件夹无需任何权限。Google 推荐应用的沙盒内存储文件地址为<br><code>Context.getExternalFilesDir()</code> 下的文件夹。需要传入以下参数</p>\n<pre><code class=\"java\">Environment.DIRECTORY_MUSIC\nEnvironment.DIRECTORY_PODCASTS\nEnvironment.DIRECTORY_RINGTONES\nEnvironment.DIRECTORY_ALARMS\nEnvironment.DIRECTORY_NOTIFICATIONS\nEnvironment.DIRECTORY_PICUTRES\nEnvironment.DIRECTORY_MOVIES\n</code></pre>","more":"<p>可根据具体需要，传入不通的参数。</p>\n<pre><code class=\"java\">\n    /**\n     * 获取一个文件通过文件夹类型\n     *\n     * @param fileName\n     * @param boxType\n     * @param defaultPath\n     * @return\n     * @throws FileNotFoundException\n     */\n    default File getFile(String fileName, String boxType, String defaultPath) throws FileNotFoundException {\n        File file;\n        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {\n            file = getCurrentContext().getExternalFilesDir(boxType + File.separator + fileName);\n        } else {\n            file = new File(defaultPath + fileName);\n        }\n        if (file == null || !file.exists()) {\n            throw new FileNotFoundException();\n        }\n\n        return file;\n    }\n</code></pre>\n<p><strong>以上代码未经测试，忘见谅</strong></p>\n<p>接下来说一下如何使用系统公共文件，比如相册，相机，下载目录等，这里以访问相册为例：</p>\n<p>访问沙盒外(其他应用)的文件系统时，依然需要申请文件权限，<code>Manifest.permission.READ_EXTERNAL_STORAGE</code> 和 <code>Manifest.permission.WRITE_EXTERNAL_STORAGE</code> </p>\n<p>我们来看一下获取相册资源的代码：</p>\n<pre><code class=\"java\">final Uri contentUri = MediaStore.Files.getContentUri(&quot;external&quot;);\n            final String sortOrder = MediaStore.Files.FileColumns.DATE_MODIFIED + &quot; DESC&quot;;\n            final String selection =\n                    &quot;(&quot; + MediaStore.Files.FileColumns.MEDIA_TYPE + &quot;=?&quot;\n                            + &quot; OR &quot;\n                            + MediaStore.Files.FileColumns.MEDIA_TYPE + &quot;=?)&quot;\n                            + &quot; AND &quot;\n                            + MediaStore.MediaColumns.SIZE + &quot;&gt;0&quot;;\n\n            final String[] selectionAllArgs = {String.valueOf(MediaStore.Files.FileColumns.MEDIA_TYPE_IMAGE)};\n\n            ContentResolver contentResolver = mContext.getContentResolver();\n            String[] projections;\n            projections = new String[]{MediaStore.Files.FileColumns._ID, MediaStore.MediaColumns.DATA,\n                    MediaStore.MediaColumns.DISPLAY_NAME, MediaStore.MediaColumns.DATE_MODIFIED,\n                    MediaStore.MediaColumns.MIME_TYPE, MediaStore.MediaColumns.WIDTH, MediaStore\n                    .MediaColumns.HEIGHT, MediaStore.MediaColumns.SIZE};\n\n            Cursor cursor = contentResolver.query(contentUri, projections, selection, selectionAllArgs, sortOrder);\n\n            if (cursor != null &amp;&amp; cursor.moveToFirst()) {\n                        int pathIndex = cursor.getColumnIndex(MediaStore.MediaColumns.DATA);\n                        int mimeTypeIndex = cursor.getColumnIndex(MediaStore.MediaColumns.MIME_TYPE);\n                        int sizeIndex = cursor.getColumnIndex(MediaStore.MediaColumns.SIZE);\n                        int widthIndex = cursor.getColumnIndex(MediaStore.MediaColumns.WIDTH);\n                        int heightIndex = cursor.getColumnIndex(MediaStore.MediaColumns.HEIGHT);\n\n                        do {\n                            long size = cursor.getLong(sizeIndex);\n                            if (size &lt; 1) {\n                                continue;\n                            }\n\n                            String type = cursor.getString(mimeTypeIndex);\n                            String path = cursor.getString(pathIndex);\n                            if (TextUtils.isEmpty(path) || TextUtils.isEmpty(type)) {\n                                continue;\n                            }\n\n                            int width = cursor.getInt(widthIndex);\n                            int height = cursor.getInt(heightIndex);\n                            if (width &lt; 1 || height &lt; 1) {\n                                continue;\n                            }\n\n                            File file = new File(path);\n                            if (!file.exists() || !file.isFile()) {\n                                continue;\n                            }\n\n                            File parentFile = file.getParentFile();\n                            if (parentFile != null) {\n                                images.add(path);\n                            }\n\n                        } while (cursor.moveToNext());\n\n                        cursor.close();\n                    }\n\n\n</code></pre>\n<p>通过上述代码，我们就可以用图片加载工具将图片显示出来，但需要注意的是，我们需要在<code>AndroidManifest.xml</code> 中的 <code>&lt;application&gt;</code> 标签中加入 <code>android:requestLegacyExternalStorage=&quot;true&quot;</code> </p>"},{"title":"Java 枚举","_content":"\n\n\n枚举是一种特殊类，他和普通类一样可以使用构造器、定义成员变量和方法，也嫩南瓜实现一个或多个接口，但枚举不能继承其他类。\n\n**使用`enum` 来标识枚举类**\n\n## 特点\n\n1. 必须使用 `enum` 关键字声明\n2. 除了初始化，不能通过任何方式手动创建枚举实例\n3. 不可以被继承\n4. JVM 保证线程安全\n5. 无法继承其他类\n<!-- more-->\n## 原理分析\n\n**常量枚举**\n\n```Java\npublic enum Color {\n    RED, GREEN, BLUE;\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(Color.RED);\n    }\n}\n\n// 结果\n// RED\n```\n\n上述代码是枚举的简单使用方法，不能看出枚举的特点和枚举的具体实现。\n\n通过字节码分析 `Color.class`\n\n```java\n// final 修饰，不能被继承\npublic final class Color extends Enum {\n        \n    // 声明的变量，都对应一个枚举实例对象\n    public static final Color RED;\n    public static final Color GREEN;\n    public static final Color BLUE;\n    \n    private static final Color $VALUES[];\n    \n    // 返回原数组的副本，防止数组的修改，引起内部 values 值的改变\n    public static Color[] values(){\n        return (Color[])$VALUE.clone();\n    }\n    \n    // 按照名字获取枚举实例\n    public static Color valueOf(String name) {\n        return (Color)Enum.valueOf(com/example/Color, name);\n    }\n    \n    // 私有构造\n    private Color(String name, int ordinal) {\n        super(name, ordinal);\n    }\n\n    \n    // 静态初始化\n    // 在类加载的 clinit 阶段就被实例化， JVM 能够保证类加载过程的线程安全\n    static {\n        RED = new Color(\"RED\", 0);\n        GREEN = new Color(\"GREEN\", 1);\n        BLUE =  new Color(\"BLUE\", 2);\n        \n        $VALUES = (new Color[] {\n            RED, GREEN, BLUE\n        });\n    }\n}\n\n```\n\n从反编译的类中可以看出，`enum` 关键字编写的类，在编译阶段编译器会自动帮外卖生成一份真正在 `jvm` 中运行的代码\n\n`Enum` 类接受一个继承自 `Enum` 的泛型（反编译阶段，`Java`中没有具体体现泛型，是应为泛型在编译阶段就会被 `JVM` 进行泛型擦除，替换为具体实现）\n\n从枚举类以及反编译出来的字节码可以看出，枚举类第一个 `;` 前的变量，都会在字节码中体现为一个 `Color` 实例，且在 `clinit` 静态代码块中进行初始化。而静态块在类加载阶段，`JVM` 会保证枚举对象的线程安全。\n\n生成的 `$VALUES[] ` 可通过 `values()` 方法被外部获取实例。\n\n## 枚举 Enum 类分析\n\n```java\npublic abstract class Enum<E extends Enum<E>> implements Comparable<E>, Serializable {\n        \n    private final String name;\n    private final int ordinal;\n    \n    public final int compareTo(E var1) {\n        if (this.getClass() != var1.getClass() && this.getDeclaringClass() != var1.getDeclaringClass()) {\n            throw new ClassCastException();\n        } else {\n            return this.ordinal - var1.ordinal;\n        }\n    }\n    \n    public final boolean equals(Object var1) {\n        return this == var1;\n    }\n\n}\n```\n\n`Enum` 类实现了 `Comparable` 接口，表明它是支持排序的，实现 `compareTo` ，方法定义为 `final` 且实现以来 `ordinal` 字段也是 `final` 类型，说明只能依据 `ordinal` 排序，排序规则不可变.\n\n**ordinal:** 表示枚举的顺序，从 `Color` 类中可以看出他是从 0 开始自然顺序增长，且其值是 `final` 类型，外部无法改变。\n\n**name:** 表示枚举的名字，它的值就是我们枚举实例的名称（自然，我们也可以通过构造方法进行修改）\n\n**equals():**  使用 `==` 判断两个枚举是否相等\n\n## 每个枚举类型及其定义的枚举变量在 JVM 中都是唯一的\n\n枚举类型它拥有的实例在编写的时候，就已经确定，不能通过其他手段进行创建，且枚举变量在 `JVM` 中有且只有一个对应的实例\n\n*为达到这种效果，枚举通过下面的方式来完成*\n\n1. 类加载时创建，保证线程安全\n\n   枚举对象在静态块中创建，由类加载时进行初始化，`JVM` 保证线程安全，这样就能保证枚举对象 不会因为并发请求同时请求而错误的创建多个实例\n\n2. 对序列化进行特殊处理，防止反序列化时创建对象\n\n   一旦实现 `Serializable` 接口之后，反序列化时每次调用 `readObject()` 方法返回的都是一个新创建出来的对象\n\n   而枚举在序列化时，`Java` 仅仅是将枚举对象的 `name` 属性输出到结果中，反序列化时则是通过枚举的 `valueOf()` 方法来根据名字查找枚举对象。同时，编译器不允许任何对这种序列化进行定制\n\n   ```java\n   public static <T extends Enum<T>> T valueOf(Class<T> var0, String var1) {\n           Enum var2 = (Enum)var0.enumConstantDirectory().get(var1);\n           if (var2 != null) {\n               return var2;\n           } else if (var1 == null) {\n               throw new NullPointerException(\"Name is null\");\n           } else {\n               throw new IllegalArgumentException(\"No enum constant \" + var0.getCanonicalName() + \".\" + var1);\n           }\n       }\n   \n   private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException {\n           throw new InvalidObjectException(\"can't deserialize enum\");\n       }\n   private void readObjectNoData() throws ObjectStreamException {\n           throw new InvalidObjectException(\"can't deserialize enum\");\n       }\n   ```\n\n3. 私有构造函数，无法正常 new 出对象\n\n4. 无法通过 `clone()` 方法， 克隆对象\n\n   ```java\n   protected final Object clone() throws CloneNotSupportedException {\n           throw new CloneNotSupportedException();\n   }\n   ```\n\n5. 无法通过反射的方式创建枚举对象\n\n   枚举类型在 `JVM` 层面上，禁止通过反射构造枚举实例的行为，如果尝试通过反射创建，会爆出 `Cannot reflectively create enum objects`\n\n   ```java\n   void reflectTest() throws Exception{\n       // 获取类对象\n       Class<?> cls = Class.forName(\"com.example.Color\");\n       // 获取构造函数\n       Constructor<?> constructor = cls.getDeclaredConstructor(String.class, int.class);\n       // 设置访问权限\n       constructor.setAccessible(true);\n       // 实例化对象\n       Object refObj = constructor.newInstance(\"name\", 0);\n   }\n   \n   // Exception\n   Exception in thread \"main\" java.lang.IllegalArgumentException: Cannot reflectively create enum objects\n   ```\n\n   \n\n## 枚举的使用\n\n### 枚举与单例模式\n\n传统的单例模式通过饿汉式、懒汉式、双重检查、内部静态类等方式，都无法完全保证单例在 JVM 中保证唯一\n\n```java\npublic enum Singleton {\n    INSTANCE;\n    public void func1(){\n        // todo...\n    }\n}\n```\n\n枚举实现的单例，是非常完美和简洁的，但枚举初始化会由时间成本和空间成本。\n\n在 `Android` 设备上，尽量避免选择使用枚举单例（当然现在的设备，已经很优秀了，这一点可以酌情考虑），除了枚举单例还是可以选择 **双重检查锁**，**静态内部类** 的方式实现单例\n\n","source":"_posts/Java/基础知识/Java 枚举.md","raw":"---\ntitle: Java 枚举\ntag: Java\n---\n\n\n\n枚举是一种特殊类，他和普通类一样可以使用构造器、定义成员变量和方法，也嫩南瓜实现一个或多个接口，但枚举不能继承其他类。\n\n**使用`enum` 来标识枚举类**\n\n## 特点\n\n1. 必须使用 `enum` 关键字声明\n2. 除了初始化，不能通过任何方式手动创建枚举实例\n3. 不可以被继承\n4. JVM 保证线程安全\n5. 无法继承其他类\n<!-- more-->\n## 原理分析\n\n**常量枚举**\n\n```Java\npublic enum Color {\n    RED, GREEN, BLUE;\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(Color.RED);\n    }\n}\n\n// 结果\n// RED\n```\n\n上述代码是枚举的简单使用方法，不能看出枚举的特点和枚举的具体实现。\n\n通过字节码分析 `Color.class`\n\n```java\n// final 修饰，不能被继承\npublic final class Color extends Enum {\n        \n    // 声明的变量，都对应一个枚举实例对象\n    public static final Color RED;\n    public static final Color GREEN;\n    public static final Color BLUE;\n    \n    private static final Color $VALUES[];\n    \n    // 返回原数组的副本，防止数组的修改，引起内部 values 值的改变\n    public static Color[] values(){\n        return (Color[])$VALUE.clone();\n    }\n    \n    // 按照名字获取枚举实例\n    public static Color valueOf(String name) {\n        return (Color)Enum.valueOf(com/example/Color, name);\n    }\n    \n    // 私有构造\n    private Color(String name, int ordinal) {\n        super(name, ordinal);\n    }\n\n    \n    // 静态初始化\n    // 在类加载的 clinit 阶段就被实例化， JVM 能够保证类加载过程的线程安全\n    static {\n        RED = new Color(\"RED\", 0);\n        GREEN = new Color(\"GREEN\", 1);\n        BLUE =  new Color(\"BLUE\", 2);\n        \n        $VALUES = (new Color[] {\n            RED, GREEN, BLUE\n        });\n    }\n}\n\n```\n\n从反编译的类中可以看出，`enum` 关键字编写的类，在编译阶段编译器会自动帮外卖生成一份真正在 `jvm` 中运行的代码\n\n`Enum` 类接受一个继承自 `Enum` 的泛型（反编译阶段，`Java`中没有具体体现泛型，是应为泛型在编译阶段就会被 `JVM` 进行泛型擦除，替换为具体实现）\n\n从枚举类以及反编译出来的字节码可以看出，枚举类第一个 `;` 前的变量，都会在字节码中体现为一个 `Color` 实例，且在 `clinit` 静态代码块中进行初始化。而静态块在类加载阶段，`JVM` 会保证枚举对象的线程安全。\n\n生成的 `$VALUES[] ` 可通过 `values()` 方法被外部获取实例。\n\n## 枚举 Enum 类分析\n\n```java\npublic abstract class Enum<E extends Enum<E>> implements Comparable<E>, Serializable {\n        \n    private final String name;\n    private final int ordinal;\n    \n    public final int compareTo(E var1) {\n        if (this.getClass() != var1.getClass() && this.getDeclaringClass() != var1.getDeclaringClass()) {\n            throw new ClassCastException();\n        } else {\n            return this.ordinal - var1.ordinal;\n        }\n    }\n    \n    public final boolean equals(Object var1) {\n        return this == var1;\n    }\n\n}\n```\n\n`Enum` 类实现了 `Comparable` 接口，表明它是支持排序的，实现 `compareTo` ，方法定义为 `final` 且实现以来 `ordinal` 字段也是 `final` 类型，说明只能依据 `ordinal` 排序，排序规则不可变.\n\n**ordinal:** 表示枚举的顺序，从 `Color` 类中可以看出他是从 0 开始自然顺序增长，且其值是 `final` 类型，外部无法改变。\n\n**name:** 表示枚举的名字，它的值就是我们枚举实例的名称（自然，我们也可以通过构造方法进行修改）\n\n**equals():**  使用 `==` 判断两个枚举是否相等\n\n## 每个枚举类型及其定义的枚举变量在 JVM 中都是唯一的\n\n枚举类型它拥有的实例在编写的时候，就已经确定，不能通过其他手段进行创建，且枚举变量在 `JVM` 中有且只有一个对应的实例\n\n*为达到这种效果，枚举通过下面的方式来完成*\n\n1. 类加载时创建，保证线程安全\n\n   枚举对象在静态块中创建，由类加载时进行初始化，`JVM` 保证线程安全，这样就能保证枚举对象 不会因为并发请求同时请求而错误的创建多个实例\n\n2. 对序列化进行特殊处理，防止反序列化时创建对象\n\n   一旦实现 `Serializable` 接口之后，反序列化时每次调用 `readObject()` 方法返回的都是一个新创建出来的对象\n\n   而枚举在序列化时，`Java` 仅仅是将枚举对象的 `name` 属性输出到结果中，反序列化时则是通过枚举的 `valueOf()` 方法来根据名字查找枚举对象。同时，编译器不允许任何对这种序列化进行定制\n\n   ```java\n   public static <T extends Enum<T>> T valueOf(Class<T> var0, String var1) {\n           Enum var2 = (Enum)var0.enumConstantDirectory().get(var1);\n           if (var2 != null) {\n               return var2;\n           } else if (var1 == null) {\n               throw new NullPointerException(\"Name is null\");\n           } else {\n               throw new IllegalArgumentException(\"No enum constant \" + var0.getCanonicalName() + \".\" + var1);\n           }\n       }\n   \n   private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException {\n           throw new InvalidObjectException(\"can't deserialize enum\");\n       }\n   private void readObjectNoData() throws ObjectStreamException {\n           throw new InvalidObjectException(\"can't deserialize enum\");\n       }\n   ```\n\n3. 私有构造函数，无法正常 new 出对象\n\n4. 无法通过 `clone()` 方法， 克隆对象\n\n   ```java\n   protected final Object clone() throws CloneNotSupportedException {\n           throw new CloneNotSupportedException();\n   }\n   ```\n\n5. 无法通过反射的方式创建枚举对象\n\n   枚举类型在 `JVM` 层面上，禁止通过反射构造枚举实例的行为，如果尝试通过反射创建，会爆出 `Cannot reflectively create enum objects`\n\n   ```java\n   void reflectTest() throws Exception{\n       // 获取类对象\n       Class<?> cls = Class.forName(\"com.example.Color\");\n       // 获取构造函数\n       Constructor<?> constructor = cls.getDeclaredConstructor(String.class, int.class);\n       // 设置访问权限\n       constructor.setAccessible(true);\n       // 实例化对象\n       Object refObj = constructor.newInstance(\"name\", 0);\n   }\n   \n   // Exception\n   Exception in thread \"main\" java.lang.IllegalArgumentException: Cannot reflectively create enum objects\n   ```\n\n   \n\n## 枚举的使用\n\n### 枚举与单例模式\n\n传统的单例模式通过饿汉式、懒汉式、双重检查、内部静态类等方式，都无法完全保证单例在 JVM 中保证唯一\n\n```java\npublic enum Singleton {\n    INSTANCE;\n    public void func1(){\n        // todo...\n    }\n}\n```\n\n枚举实现的单例，是非常完美和简洁的，但枚举初始化会由时间成本和空间成本。\n\n在 `Android` 设备上，尽量避免选择使用枚举单例（当然现在的设备，已经很优秀了，这一点可以酌情考虑），除了枚举单例还是可以选择 **双重检查锁**，**静态内部类** 的方式实现单例\n\n","slug":"Java/基础知识/Java 枚举","published":1,"date":"2021-01-29T15:54:28.309Z","updated":"2021-01-29T16:16:51.163Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8ko003csz5qrzg7v2aq","content":"<p>枚举是一种特殊类，他和普通类一样可以使用构造器、定义成员变量和方法，也嫩南瓜实现一个或多个接口，但枚举不能继承其他类。</p>\n<p><strong>使用<code>enum</code> 来标识枚举类</strong></p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ol>\n<li>必须使用 <code>enum</code> 关键字声明</li>\n<li>除了初始化，不能通过任何方式手动创建枚举实例</li>\n<li>不可以被继承</li>\n<li>JVM 保证线程安全</li>\n<li>无法继承其他类<a id=\"more\"></a>\n<h2 id=\"原理分析\"><a href=\"#原理分析\" class=\"headerlink\" title=\"原理分析\"></a>原理分析</h2></li>\n</ol>\n<p><strong>常量枚举</strong></p>\n<pre class=\" language-Java\"><code class=\"language-Java\">public enum Color {\n    RED, GREEN, BLUE;\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(Color.RED);\n    }\n}\n\n// 结果\n// RED\n</code></pre>\n<p>上述代码是枚举的简单使用方法，不能看出枚举的特点和枚举的具体实现。</p>\n<p>通过字节码分析 <code>Color.class</code></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// final 修饰，不能被继承</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Color</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Enum</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 声明的变量，都对应一个枚举实例对象</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> Color RED<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> Color GREEN<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> Color BLUE<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> Color $VALUES<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 返回原数组的副本，防止数组的修改，引起内部 values 值的改变</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> Color<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">values</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>Color<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>$VALUE<span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 按照名字获取枚举实例</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> Color <span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>String name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>Color<span class=\"token punctuation\">)</span>Enum<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>com<span class=\"token operator\">/</span>example<span class=\"token operator\">/</span>Color<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 私有构造</span>\n    <span class=\"token keyword\">private</span> <span class=\"token function\">Color</span><span class=\"token punctuation\">(</span>String name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> ordinal<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> ordinal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n\n    <span class=\"token comment\" spellcheck=\"true\">// 静态初始化</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 在类加载的 clinit 阶段就被实例化， JVM 能够保证类加载过程的线程安全</span>\n    <span class=\"token keyword\">static</span> <span class=\"token punctuation\">{</span>\n        RED <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Color</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"RED\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        GREEN <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Color</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"GREEN\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        BLUE <span class=\"token operator\">=</span>  <span class=\"token keyword\">new</span> <span class=\"token class-name\">Color</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"BLUE\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        $VALUES <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Color</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n            RED<span class=\"token punctuation\">,</span> GREEN<span class=\"token punctuation\">,</span> BLUE\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>从反编译的类中可以看出，<code>enum</code> 关键字编写的类，在编译阶段编译器会自动帮外卖生成一份真正在 <code>jvm</code> 中运行的代码</p>\n<p><code>Enum</code> 类接受一个继承自 <code>Enum</code> 的泛型（反编译阶段，<code>Java</code>中没有具体体现泛型，是应为泛型在编译阶段就会被 <code>JVM</code> 进行泛型擦除，替换为具体实现）</p>\n<p>从枚举类以及反编译出来的字节码可以看出，枚举类第一个 <code>;</code> 前的变量，都会在字节码中体现为一个 <code>Color</code> 实例，且在 <code>clinit</code> 静态代码块中进行初始化。而静态块在类加载阶段，<code>JVM</code> 会保证枚举对象的线程安全。</p>\n<p>生成的 <code>$VALUES[]</code> 可通过 <code>values()</code> 方法被外部获取实例。</p>\n<h2 id=\"枚举-Enum-类分析\"><a href=\"#枚举-Enum-类分析\" class=\"headerlink\" title=\"枚举 Enum 类分析\"></a>枚举 Enum 类分析</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Enum</span><span class=\"token operator\">&lt;</span>E <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Enum</span><span class=\"token operator\">&lt;</span>E<span class=\"token operator\">>></span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Comparable</span><span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span><span class=\"token punctuation\">,</span> Serializable <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> String name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> ordinal<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span>E var1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> var1<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">getDeclaringClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> var1<span class=\"token punctuation\">.</span><span class=\"token function\">getDeclaringClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ClassCastException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>ordinal <span class=\"token operator\">-</span> var1<span class=\"token punctuation\">.</span>ordinal<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>Object var1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span> <span class=\"token operator\">==</span> var1<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><code>Enum</code> 类实现了 <code>Comparable</code> 接口，表明它是支持排序的，实现 <code>compareTo</code> ，方法定义为 <code>final</code> 且实现以来 <code>ordinal</code> 字段也是 <code>final</code> 类型，说明只能依据 <code>ordinal</code> 排序，排序规则不可变.</p>\n<p><strong>ordinal:</strong> 表示枚举的顺序，从 <code>Color</code> 类中可以看出他是从 0 开始自然顺序增长，且其值是 <code>final</code> 类型，外部无法改变。</p>\n<p><strong>name:</strong> 表示枚举的名字，它的值就是我们枚举实例的名称（自然，我们也可以通过构造方法进行修改）</p>\n<p><strong>equals():</strong>  使用 <code>==</code> 判断两个枚举是否相等</p>\n<h2 id=\"每个枚举类型及其定义的枚举变量在-JVM-中都是唯一的\"><a href=\"#每个枚举类型及其定义的枚举变量在-JVM-中都是唯一的\" class=\"headerlink\" title=\"每个枚举类型及其定义的枚举变量在 JVM 中都是唯一的\"></a>每个枚举类型及其定义的枚举变量在 JVM 中都是唯一的</h2><p>枚举类型它拥有的实例在编写的时候，就已经确定，不能通过其他手段进行创建，且枚举变量在 <code>JVM</code> 中有且只有一个对应的实例</p>\n<p><em>为达到这种效果，枚举通过下面的方式来完成</em></p>\n<ol>\n<li><p>类加载时创建，保证线程安全</p>\n<p>枚举对象在静态块中创建，由类加载时进行初始化，<code>JVM</code> 保证线程安全，这样就能保证枚举对象 不会因为并发请求同时请求而错误的创建多个实例</p>\n</li>\n<li><p>对序列化进行特殊处理，防止反序列化时创建对象</p>\n<p>一旦实现 <code>Serializable</code> 接口之后，反序列化时每次调用 <code>readObject()</code> 方法返回的都是一个新创建出来的对象</p>\n<p>而枚举在序列化时，<code>Java</code> 仅仅是将枚举对象的 <code>name</code> 属性输出到结果中，反序列化时则是通过枚举的 <code>valueOf()</code> 方法来根据名字查找枚举对象。同时，编译器不允许任何对这种序列化进行定制</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token operator\">&lt;</span>T <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Enum</span><span class=\"token operator\">&lt;</span>T<span class=\"token operator\">>></span> T <span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>Class<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> var0<span class=\"token punctuation\">,</span> String var1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Enum var2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Enum<span class=\"token punctuation\">)</span>var0<span class=\"token punctuation\">.</span><span class=\"token function\">enumConstantDirectory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>var1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>var2 <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> var2<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>var1 <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NullPointerException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Name is null\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"No enum constant \"</span> <span class=\"token operator\">+</span> var0<span class=\"token punctuation\">.</span><span class=\"token function\">getCanonicalName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\".\"</span> <span class=\"token operator\">+</span> var1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">readObject</span><span class=\"token punctuation\">(</span>ObjectInputStream var1<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> IOException<span class=\"token punctuation\">,</span> ClassNotFoundException <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">InvalidObjectException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"can't deserialize enum\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">readObjectNoData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> ObjectStreamException <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">InvalidObjectException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"can't deserialize enum\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n</li>\n<li><p>私有构造函数，无法正常 new 出对象</p>\n</li>\n<li><p>无法通过 <code>clone()</code> 方法， 克隆对象</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> Object <span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> CloneNotSupportedException <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CloneNotSupportedException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n</li>\n<li><p>无法通过反射的方式创建枚举对象</p>\n<p>枚举类型在 <code>JVM</code> 层面上，禁止通过反射构造枚举实例的行为，如果尝试通过反射创建，会爆出 <code>Cannot reflectively create enum objects</code></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">void</span> <span class=\"token function\">reflectTest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 获取类对象</span>\n    Class<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> cls <span class=\"token operator\">=</span> Class<span class=\"token punctuation\">.</span><span class=\"token function\">forName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"com.example.Color\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 获取构造函数</span>\n    Constructor<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> constructor <span class=\"token operator\">=</span> cls<span class=\"token punctuation\">.</span><span class=\"token function\">getDeclaredConstructor</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 设置访问权限</span>\n    constructor<span class=\"token punctuation\">.</span><span class=\"token function\">setAccessible</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 实例化对象</span>\n    Object refObj <span class=\"token operator\">=</span> constructor<span class=\"token punctuation\">.</span><span class=\"token function\">newInstance</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// Exception</span>\nException in thread <span class=\"token string\">\"main\"</span> java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>IllegalArgumentException<span class=\"token operator\">:</span> Cannot reflectively create <span class=\"token keyword\">enum</span> objects\n</code></pre>\n</li>\n</ol>\n<h2 id=\"枚举的使用\"><a href=\"#枚举的使用\" class=\"headerlink\" title=\"枚举的使用\"></a>枚举的使用</h2><h3 id=\"枚举与单例模式\"><a href=\"#枚举与单例模式\" class=\"headerlink\" title=\"枚举与单例模式\"></a>枚举与单例模式</h3><p>传统的单例模式通过饿汉式、懒汉式、双重检查、内部静态类等方式，都无法完全保证单例在 JVM 中保证唯一</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">enum</span> Singleton <span class=\"token punctuation\">{</span>\n    INSTANCE<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">func1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// todo...</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>枚举实现的单例，是非常完美和简洁的，但枚举初始化会由时间成本和空间成本。</p>\n<p>在 <code>Android</code> 设备上，尽量避免选择使用枚举单例（当然现在的设备，已经很优秀了，这一点可以酌情考虑），除了枚举单例还是可以选择 <strong>双重检查锁</strong>，<strong>静态内部类</strong> 的方式实现单例</p>\n","site":{"data":{}},"excerpt":"<p>枚举是一种特殊类，他和普通类一样可以使用构造器、定义成员变量和方法，也嫩南瓜实现一个或多个接口，但枚举不能继承其他类。</p>\n<p><strong>使用<code>enum</code> 来标识枚举类</strong></p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ol>\n<li>必须使用 <code>enum</code> 关键字声明</li>\n<li>除了初始化，不能通过任何方式手动创建枚举实例</li>\n<li>不可以被继承</li>\n<li>JVM 保证线程安全</li>\n<li>无法继承其他类","more":"<h2 id=\"原理分析\"><a href=\"#原理分析\" class=\"headerlink\" title=\"原理分析\"></a>原理分析</h2></li>\n</ol>\n<p><strong>常量枚举</strong></p>\n<pre><code class=\"Java\">public enum Color {\n    RED, GREEN, BLUE;\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(Color.RED);\n    }\n}\n\n// 结果\n// RED\n</code></pre>\n<p>上述代码是枚举的简单使用方法，不能看出枚举的特点和枚举的具体实现。</p>\n<p>通过字节码分析 <code>Color.class</code></p>\n<pre><code class=\"java\">// final 修饰，不能被继承\npublic final class Color extends Enum {\n\n    // 声明的变量，都对应一个枚举实例对象\n    public static final Color RED;\n    public static final Color GREEN;\n    public static final Color BLUE;\n\n    private static final Color $VALUES[];\n\n    // 返回原数组的副本，防止数组的修改，引起内部 values 值的改变\n    public static Color[] values(){\n        return (Color[])$VALUE.clone();\n    }\n\n    // 按照名字获取枚举实例\n    public static Color valueOf(String name) {\n        return (Color)Enum.valueOf(com/example/Color, name);\n    }\n\n    // 私有构造\n    private Color(String name, int ordinal) {\n        super(name, ordinal);\n    }\n\n\n    // 静态初始化\n    // 在类加载的 clinit 阶段就被实例化， JVM 能够保证类加载过程的线程安全\n    static {\n        RED = new Color(&quot;RED&quot;, 0);\n        GREEN = new Color(&quot;GREEN&quot;, 1);\n        BLUE =  new Color(&quot;BLUE&quot;, 2);\n\n        $VALUES = (new Color[] {\n            RED, GREEN, BLUE\n        });\n    }\n}\n\n</code></pre>\n<p>从反编译的类中可以看出，<code>enum</code> 关键字编写的类，在编译阶段编译器会自动帮外卖生成一份真正在 <code>jvm</code> 中运行的代码</p>\n<p><code>Enum</code> 类接受一个继承自 <code>Enum</code> 的泛型（反编译阶段，<code>Java</code>中没有具体体现泛型，是应为泛型在编译阶段就会被 <code>JVM</code> 进行泛型擦除，替换为具体实现）</p>\n<p>从枚举类以及反编译出来的字节码可以看出，枚举类第一个 <code>;</code> 前的变量，都会在字节码中体现为一个 <code>Color</code> 实例，且在 <code>clinit</code> 静态代码块中进行初始化。而静态块在类加载阶段，<code>JVM</code> 会保证枚举对象的线程安全。</p>\n<p>生成的 <code>$VALUES[]</code> 可通过 <code>values()</code> 方法被外部获取实例。</p>\n<h2 id=\"枚举-Enum-类分析\"><a href=\"#枚举-Enum-类分析\" class=\"headerlink\" title=\"枚举 Enum 类分析\"></a>枚举 Enum 类分析</h2><pre><code class=\"java\">public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable {\n\n    private final String name;\n    private final int ordinal;\n\n    public final int compareTo(E var1) {\n        if (this.getClass() != var1.getClass() &amp;&amp; this.getDeclaringClass() != var1.getDeclaringClass()) {\n            throw new ClassCastException();\n        } else {\n            return this.ordinal - var1.ordinal;\n        }\n    }\n\n    public final boolean equals(Object var1) {\n        return this == var1;\n    }\n\n}\n</code></pre>\n<p><code>Enum</code> 类实现了 <code>Comparable</code> 接口，表明它是支持排序的，实现 <code>compareTo</code> ，方法定义为 <code>final</code> 且实现以来 <code>ordinal</code> 字段也是 <code>final</code> 类型，说明只能依据 <code>ordinal</code> 排序，排序规则不可变.</p>\n<p><strong>ordinal:</strong> 表示枚举的顺序，从 <code>Color</code> 类中可以看出他是从 0 开始自然顺序增长，且其值是 <code>final</code> 类型，外部无法改变。</p>\n<p><strong>name:</strong> 表示枚举的名字，它的值就是我们枚举实例的名称（自然，我们也可以通过构造方法进行修改）</p>\n<p><strong>equals():</strong>  使用 <code>==</code> 判断两个枚举是否相等</p>\n<h2 id=\"每个枚举类型及其定义的枚举变量在-JVM-中都是唯一的\"><a href=\"#每个枚举类型及其定义的枚举变量在-JVM-中都是唯一的\" class=\"headerlink\" title=\"每个枚举类型及其定义的枚举变量在 JVM 中都是唯一的\"></a>每个枚举类型及其定义的枚举变量在 JVM 中都是唯一的</h2><p>枚举类型它拥有的实例在编写的时候，就已经确定，不能通过其他手段进行创建，且枚举变量在 <code>JVM</code> 中有且只有一个对应的实例</p>\n<p><em>为达到这种效果，枚举通过下面的方式来完成</em></p>\n<ol>\n<li><p>类加载时创建，保证线程安全</p>\n<p>枚举对象在静态块中创建，由类加载时进行初始化，<code>JVM</code> 保证线程安全，这样就能保证枚举对象 不会因为并发请求同时请求而错误的创建多个实例</p>\n</li>\n<li><p>对序列化进行特殊处理，防止反序列化时创建对象</p>\n<p>一旦实现 <code>Serializable</code> 接口之后，反序列化时每次调用 <code>readObject()</code> 方法返回的都是一个新创建出来的对象</p>\n<p>而枚举在序列化时，<code>Java</code> 仅仅是将枚举对象的 <code>name</code> 属性输出到结果中，反序列化时则是通过枚举的 <code>valueOf()</code> 方法来根据名字查找枚举对象。同时，编译器不允许任何对这种序列化进行定制</p>\n<pre><code class=\"java\">public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; var0, String var1) {\n        Enum var2 = (Enum)var0.enumConstantDirectory().get(var1);\n        if (var2 != null) {\n            return var2;\n        } else if (var1 == null) {\n            throw new NullPointerException(&quot;Name is null&quot;);\n        } else {\n            throw new IllegalArgumentException(&quot;No enum constant &quot; + var0.getCanonicalName() + &quot;.&quot; + var1);\n        }\n    }\n\nprivate void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException {\n        throw new InvalidObjectException(&quot;can&#39;t deserialize enum&quot;);\n    }\nprivate void readObjectNoData() throws ObjectStreamException {\n        throw new InvalidObjectException(&quot;can&#39;t deserialize enum&quot;);\n    }\n</code></pre>\n</li>\n<li><p>私有构造函数，无法正常 new 出对象</p>\n</li>\n<li><p>无法通过 <code>clone()</code> 方法， 克隆对象</p>\n<pre><code class=\"java\">protected final Object clone() throws CloneNotSupportedException {\n        throw new CloneNotSupportedException();\n}\n</code></pre>\n</li>\n<li><p>无法通过反射的方式创建枚举对象</p>\n<p>枚举类型在 <code>JVM</code> 层面上，禁止通过反射构造枚举实例的行为，如果尝试通过反射创建，会爆出 <code>Cannot reflectively create enum objects</code></p>\n<pre><code class=\"java\">void reflectTest() throws Exception{\n    // 获取类对象\n    Class&lt;?&gt; cls = Class.forName(&quot;com.example.Color&quot;);\n    // 获取构造函数\n    Constructor&lt;?&gt; constructor = cls.getDeclaredConstructor(String.class, int.class);\n    // 设置访问权限\n    constructor.setAccessible(true);\n    // 实例化对象\n    Object refObj = constructor.newInstance(&quot;name&quot;, 0);\n}\n\n// Exception\nException in thread &quot;main&quot; java.lang.IllegalArgumentException: Cannot reflectively create enum objects\n</code></pre>\n</li>\n</ol>\n<h2 id=\"枚举的使用\"><a href=\"#枚举的使用\" class=\"headerlink\" title=\"枚举的使用\"></a>枚举的使用</h2><h3 id=\"枚举与单例模式\"><a href=\"#枚举与单例模式\" class=\"headerlink\" title=\"枚举与单例模式\"></a>枚举与单例模式</h3><p>传统的单例模式通过饿汉式、懒汉式、双重检查、内部静态类等方式，都无法完全保证单例在 JVM 中保证唯一</p>\n<pre><code class=\"java\">public enum Singleton {\n    INSTANCE;\n    public void func1(){\n        // todo...\n    }\n}\n</code></pre>\n<p>枚举实现的单例，是非常完美和简洁的，但枚举初始化会由时间成本和空间成本。</p>\n<p>在 <code>Android</code> 设备上，尽量避免选择使用枚举单例（当然现在的设备，已经很优秀了，这一点可以酌情考虑），除了枚举单例还是可以选择 <strong>双重检查锁</strong>，<strong>静态内部类</strong> 的方式实现单例</p>"},{"title":"Java 泛型","_content":"\n\n泛型，即 **参数化类型**。我们比较熟悉的就是定义方法时有形参，然后调用方法时传递实参。\n\n参数化类型，就是将类型由原来具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数类型，然后再调用/使用时传入具体的类型。\n\n泛型再使用过程中，操作的数据类型被指定为一个参数，可以用在类、接口和方法中。分别被成为泛型类、泛型接口、泛型方法。\n<!-- more-->\n## 三种泛型方式\n\n```java\n// 泛型类\npublic class TypeClass<T> {\n    private T data;\n    public TypeClass(T data) {\n        this.data = data;\n    }\n}\n\n// 泛型接口\npublic interface TypeInterface<T> {\n    T next();\n}\n\n// 泛型方法\n// \npublic <T> T typeMethod(T t){\n    \n}\n```\n\n## 泛型的作用\n\n1. 使得代码更健壮\n2. 代码更简洁\n3. 更灵活、可复用\n\n## 限定类型变量\n\n有时候我们需要对类型变量加约束，比如计算量i盎格变量的最大，最小值。\n\n```java\npublic static <T> T min(T a, T b) {\n    if(a.compareTo(b) > 0) \n        return a; \n    else  \n        return b;\n}\n```\n\n那么如上代码，如果我们传入的两个变量没有实现 `Comparable` 会如何呢？那一定是调用不到 `compareTo()` 的，那么我们对其加上约束\n\n```java\npublic static <T extends Comparable> T min (T a, T b){\n    if(a.compareTo(b) > 0) \n        return a; \n    else  \n        return b;\n}\n```\n\n` T extends Comparable` 中，T 表示应该绑定的子类型， `Comparable` 则表示绑定类型，子类型和绑定类型可以是接口也可以是类。\n\n如果我们传入一个没有实现 `Comparable` 接口的实例，则会发生编译错误。\n\n**同时 `extends` 左右都允许有多个，比如 `T, V extends Comparable & serializable` ，限定类型中，只允许有一个类，而且如果有类，必须再限定列表的第一个**\n\n#### 约束和局限性\n\n* 不能使用基本类习数据类型做参数，只能使用包装器类型\n* 运行时类型查询只时用于原始类型\n* 反射对泛型擦除增加了风险\n* 泛型类型中的方法冲突（同名方法，泛型参数做参数变量时，在泛型擦除后，会造成同名方法冲突）\n* 静态块/静态方法中不能使用泛型\n* 不能创建参数化类型的数组\n* 不能实例化类型变量\n* 不能捕获泛型类的实例\n\n## 泛型的继承规则\n\n```java\nclass Employee {}\nclass Worker exrends Employee{}\n\nclass Pair<T> {}\n\n```\n\n泛型类可以继承或者扩展其他泛型类，比如 `List` 和 `ArrayList`\n\n### 通配符\n\n```java\nclass Fruit {}\n\nclass Orange extends Fruit {}\n\nclass Apple extends Fruit {}\n\nclass HongFuShi extends Fruit{}\n\npublic static void println(GenericType<Fruit> p) {\n    System.out.println(p.getData().getColor());\n}\n\npublic void use () {\n    GenericType<Fruit> a = new GenericType(); // 可以\n    GenericType<Apple> b = new GenericType();// 不允许d \n}\n```\n\n因为上面的方案不被 SDK 允许，于是提出了一个通配符类型\n\n* `? extends X` 表示类型的上界，类型参数是 X 的子类\n* `? super X` 表示类型的下界，类型参数是 X 的父类\n\n#### ? extends X，可读不可写\n\n表示传递给方法的参数，必须是 X 的子类（包括 X 本身）\n\n```java\npublic static void println(GenericType<? extends Fruit> p){\n    System.out.println(p.getData().getColor());\n}\n```\n\n但对于泛型类 `GenericType` 来说，如果其中提供了 get 和 set 类型参数变量的方法的话， set 方法是不允许调用的（只能查看，不能修改）\n\n因为 `? extends X` 表示类型的上界，类型参数是 X 的子类，那么可定的说， get 方法返回的一定是 X (不管是 X 还是 X 的子类)，编译器是可以确定知道的。但是 set 方法只知道传入的是个 X，至于具体是哪一个子类，并不知道。\n\n#### ? super X ，可写不可读\n\n表示传递给方法的参数，必须是 X 的父类（包括 X 本身）\n\n```java\npublic static void println(GenericType<? super Apple> p) {\n    System.out.println(po.getData());\n}\n```\n\n但对于泛型类 `GenericType` 来说，如果其中提供了 get 和 set  类型的变量方法的话，set 方法可以被调用， 且传入的参数只能是 X 或者 X 的子类。\n\nget 方法只返回一个 Object 类型的值。\n因为  `? super X` 表示类型的下界，参数类型是 X  的父类（包括其本身）那么可以肯定的说， get 方法返回的一定格式 X 的父类，那么具体是哪个父类，并不知道。但  Object 一定是它的父类，所以 get  方法返回的是一个 Object ，编译器可以确定知道。但是 set 方法，编译器不知道它需要的确切类型，但是 X 和 X 的子类可以安全的转换 X。\n\n### 无限通配符 ?，只是为了说明用法\n\n表示类型没有限制，可以把 `?` 看成所有类型的父类，如： Pair<?>\n\n`ArrayList<T> al = new ArrayList<T>()` 指定集合元素只能是 T 类型\n\n`ArrayList<?> al = new ArrayList<?>()` 集合元素可以是任意类型。\n\n## 虚拟机是如何实现的\n\nJava 语言中的泛型，再程序源码中存在，再编译后的字节码文件中，就已经替换为原来的远程类型（Raw Type）并且再相应的地方插入了强制转换代码，因此对于运行期间的 Java 语言来说，`ArrayList<int>` 与 `ArrayList<String>` 就是同一个类，所以泛型技术实际上是 Java 语言的语法糖， Java 语言中的泛型实现方法成为泛型擦除，基于这种方法实现的泛型称为**伪泛型**\n\n## 泛型擦除\n\n因为虚拟机实现原理，就是泛型擦除，因此 **泛型信息只能存在于代码的编译阶段，编译成子接码之后，与类型相关的信息会被擦除掉，变为 Object**\n\n**步骤**\n\n1. 检查泛型类型，获取目标泛型\n2. 擦除类型变量，并替换为限定类型\n   1. 如果泛型类型的类型变量没有限定`<T>` 则用 Object 原始类型表示\n   2. 如果有限定类型`<T extends XClass> `则用，`XClass` 作为原始类型\n   3. 如果有多个限定`<T extends XClass & XClass2>` 则使用第一个作为原始类型\n3. 在必要时插入类型转换以保证类型安全\n4. 生成**桥方法** 以再扩展时保持多态\n\n","source":"_posts/Java/基础知识/Java-泛型.md","raw":"---\ntitle: Java 泛型\ntag: Java\n---\n\n\n泛型，即 **参数化类型**。我们比较熟悉的就是定义方法时有形参，然后调用方法时传递实参。\n\n参数化类型，就是将类型由原来具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数类型，然后再调用/使用时传入具体的类型。\n\n泛型再使用过程中，操作的数据类型被指定为一个参数，可以用在类、接口和方法中。分别被成为泛型类、泛型接口、泛型方法。\n<!-- more-->\n## 三种泛型方式\n\n```java\n// 泛型类\npublic class TypeClass<T> {\n    private T data;\n    public TypeClass(T data) {\n        this.data = data;\n    }\n}\n\n// 泛型接口\npublic interface TypeInterface<T> {\n    T next();\n}\n\n// 泛型方法\n// \npublic <T> T typeMethod(T t){\n    \n}\n```\n\n## 泛型的作用\n\n1. 使得代码更健壮\n2. 代码更简洁\n3. 更灵活、可复用\n\n## 限定类型变量\n\n有时候我们需要对类型变量加约束，比如计算量i盎格变量的最大，最小值。\n\n```java\npublic static <T> T min(T a, T b) {\n    if(a.compareTo(b) > 0) \n        return a; \n    else  \n        return b;\n}\n```\n\n那么如上代码，如果我们传入的两个变量没有实现 `Comparable` 会如何呢？那一定是调用不到 `compareTo()` 的，那么我们对其加上约束\n\n```java\npublic static <T extends Comparable> T min (T a, T b){\n    if(a.compareTo(b) > 0) \n        return a; \n    else  \n        return b;\n}\n```\n\n` T extends Comparable` 中，T 表示应该绑定的子类型， `Comparable` 则表示绑定类型，子类型和绑定类型可以是接口也可以是类。\n\n如果我们传入一个没有实现 `Comparable` 接口的实例，则会发生编译错误。\n\n**同时 `extends` 左右都允许有多个，比如 `T, V extends Comparable & serializable` ，限定类型中，只允许有一个类，而且如果有类，必须再限定列表的第一个**\n\n#### 约束和局限性\n\n* 不能使用基本类习数据类型做参数，只能使用包装器类型\n* 运行时类型查询只时用于原始类型\n* 反射对泛型擦除增加了风险\n* 泛型类型中的方法冲突（同名方法，泛型参数做参数变量时，在泛型擦除后，会造成同名方法冲突）\n* 静态块/静态方法中不能使用泛型\n* 不能创建参数化类型的数组\n* 不能实例化类型变量\n* 不能捕获泛型类的实例\n\n## 泛型的继承规则\n\n```java\nclass Employee {}\nclass Worker exrends Employee{}\n\nclass Pair<T> {}\n\n```\n\n泛型类可以继承或者扩展其他泛型类，比如 `List` 和 `ArrayList`\n\n### 通配符\n\n```java\nclass Fruit {}\n\nclass Orange extends Fruit {}\n\nclass Apple extends Fruit {}\n\nclass HongFuShi extends Fruit{}\n\npublic static void println(GenericType<Fruit> p) {\n    System.out.println(p.getData().getColor());\n}\n\npublic void use () {\n    GenericType<Fruit> a = new GenericType(); // 可以\n    GenericType<Apple> b = new GenericType();// 不允许d \n}\n```\n\n因为上面的方案不被 SDK 允许，于是提出了一个通配符类型\n\n* `? extends X` 表示类型的上界，类型参数是 X 的子类\n* `? super X` 表示类型的下界，类型参数是 X 的父类\n\n#### ? extends X，可读不可写\n\n表示传递给方法的参数，必须是 X 的子类（包括 X 本身）\n\n```java\npublic static void println(GenericType<? extends Fruit> p){\n    System.out.println(p.getData().getColor());\n}\n```\n\n但对于泛型类 `GenericType` 来说，如果其中提供了 get 和 set 类型参数变量的方法的话， set 方法是不允许调用的（只能查看，不能修改）\n\n因为 `? extends X` 表示类型的上界，类型参数是 X 的子类，那么可定的说， get 方法返回的一定是 X (不管是 X 还是 X 的子类)，编译器是可以确定知道的。但是 set 方法只知道传入的是个 X，至于具体是哪一个子类，并不知道。\n\n#### ? super X ，可写不可读\n\n表示传递给方法的参数，必须是 X 的父类（包括 X 本身）\n\n```java\npublic static void println(GenericType<? super Apple> p) {\n    System.out.println(po.getData());\n}\n```\n\n但对于泛型类 `GenericType` 来说，如果其中提供了 get 和 set  类型的变量方法的话，set 方法可以被调用， 且传入的参数只能是 X 或者 X 的子类。\n\nget 方法只返回一个 Object 类型的值。\n因为  `? super X` 表示类型的下界，参数类型是 X  的父类（包括其本身）那么可以肯定的说， get 方法返回的一定格式 X 的父类，那么具体是哪个父类，并不知道。但  Object 一定是它的父类，所以 get  方法返回的是一个 Object ，编译器可以确定知道。但是 set 方法，编译器不知道它需要的确切类型，但是 X 和 X 的子类可以安全的转换 X。\n\n### 无限通配符 ?，只是为了说明用法\n\n表示类型没有限制，可以把 `?` 看成所有类型的父类，如： Pair<?>\n\n`ArrayList<T> al = new ArrayList<T>()` 指定集合元素只能是 T 类型\n\n`ArrayList<?> al = new ArrayList<?>()` 集合元素可以是任意类型。\n\n## 虚拟机是如何实现的\n\nJava 语言中的泛型，再程序源码中存在，再编译后的字节码文件中，就已经替换为原来的远程类型（Raw Type）并且再相应的地方插入了强制转换代码，因此对于运行期间的 Java 语言来说，`ArrayList<int>` 与 `ArrayList<String>` 就是同一个类，所以泛型技术实际上是 Java 语言的语法糖， Java 语言中的泛型实现方法成为泛型擦除，基于这种方法实现的泛型称为**伪泛型**\n\n## 泛型擦除\n\n因为虚拟机实现原理，就是泛型擦除，因此 **泛型信息只能存在于代码的编译阶段，编译成子接码之后，与类型相关的信息会被擦除掉，变为 Object**\n\n**步骤**\n\n1. 检查泛型类型，获取目标泛型\n2. 擦除类型变量，并替换为限定类型\n   1. 如果泛型类型的类型变量没有限定`<T>` 则用 Object 原始类型表示\n   2. 如果有限定类型`<T extends XClass> `则用，`XClass` 作为原始类型\n   3. 如果有多个限定`<T extends XClass & XClass2>` 则使用第一个作为原始类型\n3. 在必要时插入类型转换以保证类型安全\n4. 生成**桥方法** 以再扩展时保持多态\n\n","slug":"Java/基础知识/Java-泛型","published":1,"date":"2021-01-29T15:54:28.310Z","updated":"2021-01-29T16:16:59.570Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8kp003fsz5q8pttr0ew","content":"<p>泛型，即 <strong>参数化类型</strong>。我们比较熟悉的就是定义方法时有形参，然后调用方法时传递实参。</p>\n<p>参数化类型，就是将类型由原来具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数类型，然后再调用/使用时传入具体的类型。</p>\n<p>泛型再使用过程中，操作的数据类型被指定为一个参数，可以用在类、接口和方法中。分别被成为泛型类、泛型接口、泛型方法。<br><a id=\"more\"></a></p>\n<h2 id=\"三种泛型方式\"><a href=\"#三种泛型方式\" class=\"headerlink\" title=\"三种泛型方式\"></a>三种泛型方式</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// 泛型类</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TypeClass</span><span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> T data<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">TypeClass</span><span class=\"token punctuation\">(</span>T data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>data <span class=\"token operator\">=</span> data<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 泛型接口</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">TypeInterface</span><span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    T <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 泛型方法</span>\n<span class=\"token comment\" spellcheck=\"true\">// </span>\n<span class=\"token keyword\">public</span> <span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> T <span class=\"token function\">typeMethod</span><span class=\"token punctuation\">(</span>T t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"泛型的作用\"><a href=\"#泛型的作用\" class=\"headerlink\" title=\"泛型的作用\"></a>泛型的作用</h2><ol>\n<li>使得代码更健壮</li>\n<li>代码更简洁</li>\n<li>更灵活、可复用</li>\n</ol>\n<h2 id=\"限定类型变量\"><a href=\"#限定类型变量\" class=\"headerlink\" title=\"限定类型变量\"></a>限定类型变量</h2><p>有时候我们需要对类型变量加约束，比如计算量i盎格变量的最大，最小值。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> T <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>T a<span class=\"token punctuation\">,</span> T b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> \n        <span class=\"token keyword\">return</span> a<span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">else</span>  \n        <span class=\"token keyword\">return</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>那么如上代码，如果我们传入的两个变量没有实现 <code>Comparable</code> 会如何呢？那一定是调用不到 <code>compareTo()</code> 的，那么我们对其加上约束</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token operator\">&lt;</span>T <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Comparable</span><span class=\"token operator\">></span> T <span class=\"token function\">min</span> <span class=\"token punctuation\">(</span>T a<span class=\"token punctuation\">,</span> T b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span><span class=\"token function\">compareTo</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> \n        <span class=\"token keyword\">return</span> a<span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">else</span>  \n        <span class=\"token keyword\">return</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><code>T extends Comparable</code> 中，T 表示应该绑定的子类型， <code>Comparable</code> 则表示绑定类型，子类型和绑定类型可以是接口也可以是类。</p>\n<p>如果我们传入一个没有实现 <code>Comparable</code> 接口的实例，则会发生编译错误。</p>\n<p><strong>同时 <code>extends</code> 左右都允许有多个，比如 <code>T, V extends Comparable &amp; serializable</code> ，限定类型中，只允许有一个类，而且如果有类，必须再限定列表的第一个</strong></p>\n<h4 id=\"约束和局限性\"><a href=\"#约束和局限性\" class=\"headerlink\" title=\"约束和局限性\"></a>约束和局限性</h4><ul>\n<li>不能使用基本类习数据类型做参数，只能使用包装器类型</li>\n<li>运行时类型查询只时用于原始类型</li>\n<li>反射对泛型擦除增加了风险</li>\n<li>泛型类型中的方法冲突（同名方法，泛型参数做参数变量时，在泛型擦除后，会造成同名方法冲突）</li>\n<li>静态块/静态方法中不能使用泛型</li>\n<li>不能创建参数化类型的数组</li>\n<li>不能实例化类型变量</li>\n<li>不能捕获泛型类的实例</li>\n</ul>\n<h2 id=\"泛型的继承规则\"><a href=\"#泛型的继承规则\" class=\"headerlink\" title=\"泛型的继承规则\"></a>泛型的继承规则</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Employee</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Worker</span> exrends Employee<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Pair</span><span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>泛型类可以继承或者扩展其他泛型类，比如 <code>List</code> 和 <code>ArrayList</code></p>\n<h3 id=\"通配符\"><a href=\"#通配符\" class=\"headerlink\" title=\"通配符\"></a>通配符</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Fruit</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Orange</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Fruit</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Apple</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Fruit</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">HongFuShi</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Fruit</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>GenericType<span class=\"token operator\">&lt;</span>Fruit<span class=\"token operator\">></span> p<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">getData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getColor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">use</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    GenericType<span class=\"token operator\">&lt;</span>Fruit<span class=\"token operator\">></span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">GenericType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 可以</span>\n    GenericType<span class=\"token operator\">&lt;</span>Apple<span class=\"token operator\">></span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">GenericType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// 不允许d </span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>因为上面的方案不被 SDK 允许，于是提出了一个通配符类型</p>\n<ul>\n<li><code>? extends X</code> 表示类型的上界，类型参数是 X 的子类</li>\n<li><code>? super X</code> 表示类型的下界，类型参数是 X 的父类</li>\n</ul>\n<h4 id=\"extends-X，可读不可写\"><a href=\"#extends-X，可读不可写\" class=\"headerlink\" title=\"? extends X，可读不可写\"></a>? extends X，可读不可写</h4><p>表示传递给方法的参数，必须是 X 的子类（包括 X 本身）</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>GenericType<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Fruit</span><span class=\"token operator\">></span> p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">getData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getColor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>但对于泛型类 <code>GenericType</code> 来说，如果其中提供了 get 和 set 类型参数变量的方法的话， set 方法是不允许调用的（只能查看，不能修改）</p>\n<p>因为 <code>? extends X</code> 表示类型的上界，类型参数是 X 的子类，那么可定的说， get 方法返回的一定是 X (不管是 X 还是 X 的子类)，编译器是可以确定知道的。但是 set 方法只知道传入的是个 X，至于具体是哪一个子类，并不知道。</p>\n<h4 id=\"super-X-，可写不可读\"><a href=\"#super-X-，可写不可读\" class=\"headerlink\" title=\"? super X ，可写不可读\"></a>? super X ，可写不可读</h4><p>表示传递给方法的参数，必须是 X 的父类（包括 X 本身）</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>GenericType<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> Apple<span class=\"token operator\">></span> p<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>po<span class=\"token punctuation\">.</span><span class=\"token function\">getData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>但对于泛型类 <code>GenericType</code> 来说，如果其中提供了 get 和 set  类型的变量方法的话，set 方法可以被调用， 且传入的参数只能是 X 或者 X 的子类。</p>\n<p>get 方法只返回一个 Object 类型的值。<br>因为  <code>? super X</code> 表示类型的下界，参数类型是 X  的父类（包括其本身）那么可以肯定的说， get 方法返回的一定格式 X 的父类，那么具体是哪个父类，并不知道。但  Object 一定是它的父类，所以 get  方法返回的是一个 Object ，编译器可以确定知道。但是 set 方法，编译器不知道它需要的确切类型，但是 X 和 X 的子类可以安全的转换 X。</p>\n<h3 id=\"无限通配符-，只是为了说明用法\"><a href=\"#无限通配符-，只是为了说明用法\" class=\"headerlink\" title=\"无限通配符 ?，只是为了说明用法\"></a>无限通配符 ?，只是为了说明用法</h3><p>表示类型没有限制，可以把 <code>?</code> 看成所有类型的父类，如： Pair&lt;?&gt;</p>\n<p><code>ArrayList&lt;T&gt; al = new ArrayList&lt;T&gt;()</code> 指定集合元素只能是 T 类型</p>\n<p><code>ArrayList&lt;?&gt; al = new ArrayList&lt;?&gt;()</code> 集合元素可以是任意类型。</p>\n<h2 id=\"虚拟机是如何实现的\"><a href=\"#虚拟机是如何实现的\" class=\"headerlink\" title=\"虚拟机是如何实现的\"></a>虚拟机是如何实现的</h2><p>Java 语言中的泛型，再程序源码中存在，再编译后的字节码文件中，就已经替换为原来的远程类型（Raw Type）并且再相应的地方插入了强制转换代码，因此对于运行期间的 Java 语言来说，<code>ArrayList&lt;int&gt;</code> 与 <code>ArrayList&lt;String&gt;</code> 就是同一个类，所以泛型技术实际上是 Java 语言的语法糖， Java 语言中的泛型实现方法成为泛型擦除，基于这种方法实现的泛型称为<strong>伪泛型</strong></p>\n<h2 id=\"泛型擦除\"><a href=\"#泛型擦除\" class=\"headerlink\" title=\"泛型擦除\"></a>泛型擦除</h2><p>因为虚拟机实现原理，就是泛型擦除，因此 <strong>泛型信息只能存在于代码的编译阶段，编译成子接码之后，与类型相关的信息会被擦除掉，变为 Object</strong></p>\n<p><strong>步骤</strong></p>\n<ol>\n<li>检查泛型类型，获取目标泛型</li>\n<li>擦除类型变量，并替换为限定类型<ol>\n<li>如果泛型类型的类型变量没有限定<code>&lt;T&gt;</code> 则用 Object 原始类型表示</li>\n<li>如果有限定类型<code>&lt;T extends XClass&gt;</code>则用，<code>XClass</code> 作为原始类型</li>\n<li>如果有多个限定<code>&lt;T extends XClass &amp; XClass2&gt;</code> 则使用第一个作为原始类型</li>\n</ol>\n</li>\n<li>在必要时插入类型转换以保证类型安全</li>\n<li>生成<strong>桥方法</strong> 以再扩展时保持多态</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>泛型，即 <strong>参数化类型</strong>。我们比较熟悉的就是定义方法时有形参，然后调用方法时传递实参。</p>\n<p>参数化类型，就是将类型由原来具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数类型，然后再调用/使用时传入具体的类型。</p>\n<p>泛型再使用过程中，操作的数据类型被指定为一个参数，可以用在类、接口和方法中。分别被成为泛型类、泛型接口、泛型方法。<br>","more":"</p>\n<h2 id=\"三种泛型方式\"><a href=\"#三种泛型方式\" class=\"headerlink\" title=\"三种泛型方式\"></a>三种泛型方式</h2><pre><code class=\"java\">// 泛型类\npublic class TypeClass&lt;T&gt; {\n    private T data;\n    public TypeClass(T data) {\n        this.data = data;\n    }\n}\n\n// 泛型接口\npublic interface TypeInterface&lt;T&gt; {\n    T next();\n}\n\n// 泛型方法\n// \npublic &lt;T&gt; T typeMethod(T t){\n\n}\n</code></pre>\n<h2 id=\"泛型的作用\"><a href=\"#泛型的作用\" class=\"headerlink\" title=\"泛型的作用\"></a>泛型的作用</h2><ol>\n<li>使得代码更健壮</li>\n<li>代码更简洁</li>\n<li>更灵活、可复用</li>\n</ol>\n<h2 id=\"限定类型变量\"><a href=\"#限定类型变量\" class=\"headerlink\" title=\"限定类型变量\"></a>限定类型变量</h2><p>有时候我们需要对类型变量加约束，比如计算量i盎格变量的最大，最小值。</p>\n<pre><code class=\"java\">public static &lt;T&gt; T min(T a, T b) {\n    if(a.compareTo(b) &gt; 0) \n        return a; \n    else  \n        return b;\n}\n</code></pre>\n<p>那么如上代码，如果我们传入的两个变量没有实现 <code>Comparable</code> 会如何呢？那一定是调用不到 <code>compareTo()</code> 的，那么我们对其加上约束</p>\n<pre><code class=\"java\">public static &lt;T extends Comparable&gt; T min (T a, T b){\n    if(a.compareTo(b) &gt; 0) \n        return a; \n    else  \n        return b;\n}\n</code></pre>\n<p><code>T extends Comparable</code> 中，T 表示应该绑定的子类型， <code>Comparable</code> 则表示绑定类型，子类型和绑定类型可以是接口也可以是类。</p>\n<p>如果我们传入一个没有实现 <code>Comparable</code> 接口的实例，则会发生编译错误。</p>\n<p><strong>同时 <code>extends</code> 左右都允许有多个，比如 <code>T, V extends Comparable &amp; serializable</code> ，限定类型中，只允许有一个类，而且如果有类，必须再限定列表的第一个</strong></p>\n<h4 id=\"约束和局限性\"><a href=\"#约束和局限性\" class=\"headerlink\" title=\"约束和局限性\"></a>约束和局限性</h4><ul>\n<li>不能使用基本类习数据类型做参数，只能使用包装器类型</li>\n<li>运行时类型查询只时用于原始类型</li>\n<li>反射对泛型擦除增加了风险</li>\n<li>泛型类型中的方法冲突（同名方法，泛型参数做参数变量时，在泛型擦除后，会造成同名方法冲突）</li>\n<li>静态块/静态方法中不能使用泛型</li>\n<li>不能创建参数化类型的数组</li>\n<li>不能实例化类型变量</li>\n<li>不能捕获泛型类的实例</li>\n</ul>\n<h2 id=\"泛型的继承规则\"><a href=\"#泛型的继承规则\" class=\"headerlink\" title=\"泛型的继承规则\"></a>泛型的继承规则</h2><pre><code class=\"java\">class Employee {}\nclass Worker exrends Employee{}\n\nclass Pair&lt;T&gt; {}\n\n</code></pre>\n<p>泛型类可以继承或者扩展其他泛型类，比如 <code>List</code> 和 <code>ArrayList</code></p>\n<h3 id=\"通配符\"><a href=\"#通配符\" class=\"headerlink\" title=\"通配符\"></a>通配符</h3><pre><code class=\"java\">class Fruit {}\n\nclass Orange extends Fruit {}\n\nclass Apple extends Fruit {}\n\nclass HongFuShi extends Fruit{}\n\npublic static void println(GenericType&lt;Fruit&gt; p) {\n    System.out.println(p.getData().getColor());\n}\n\npublic void use () {\n    GenericType&lt;Fruit&gt; a = new GenericType(); // 可以\n    GenericType&lt;Apple&gt; b = new GenericType();// 不允许d \n}\n</code></pre>\n<p>因为上面的方案不被 SDK 允许，于是提出了一个通配符类型</p>\n<ul>\n<li><code>? extends X</code> 表示类型的上界，类型参数是 X 的子类</li>\n<li><code>? super X</code> 表示类型的下界，类型参数是 X 的父类</li>\n</ul>\n<h4 id=\"extends-X，可读不可写\"><a href=\"#extends-X，可读不可写\" class=\"headerlink\" title=\"? extends X，可读不可写\"></a>? extends X，可读不可写</h4><p>表示传递给方法的参数，必须是 X 的子类（包括 X 本身）</p>\n<pre><code class=\"java\">public static void println(GenericType&lt;? extends Fruit&gt; p){\n    System.out.println(p.getData().getColor());\n}\n</code></pre>\n<p>但对于泛型类 <code>GenericType</code> 来说，如果其中提供了 get 和 set 类型参数变量的方法的话， set 方法是不允许调用的（只能查看，不能修改）</p>\n<p>因为 <code>? extends X</code> 表示类型的上界，类型参数是 X 的子类，那么可定的说， get 方法返回的一定是 X (不管是 X 还是 X 的子类)，编译器是可以确定知道的。但是 set 方法只知道传入的是个 X，至于具体是哪一个子类，并不知道。</p>\n<h4 id=\"super-X-，可写不可读\"><a href=\"#super-X-，可写不可读\" class=\"headerlink\" title=\"? super X ，可写不可读\"></a>? super X ，可写不可读</h4><p>表示传递给方法的参数，必须是 X 的父类（包括 X 本身）</p>\n<pre><code class=\"java\">public static void println(GenericType&lt;? super Apple&gt; p) {\n    System.out.println(po.getData());\n}\n</code></pre>\n<p>但对于泛型类 <code>GenericType</code> 来说，如果其中提供了 get 和 set  类型的变量方法的话，set 方法可以被调用， 且传入的参数只能是 X 或者 X 的子类。</p>\n<p>get 方法只返回一个 Object 类型的值。<br>因为  <code>? super X</code> 表示类型的下界，参数类型是 X  的父类（包括其本身）那么可以肯定的说， get 方法返回的一定格式 X 的父类，那么具体是哪个父类，并不知道。但  Object 一定是它的父类，所以 get  方法返回的是一个 Object ，编译器可以确定知道。但是 set 方法，编译器不知道它需要的确切类型，但是 X 和 X 的子类可以安全的转换 X。</p>\n<h3 id=\"无限通配符-，只是为了说明用法\"><a href=\"#无限通配符-，只是为了说明用法\" class=\"headerlink\" title=\"无限通配符 ?，只是为了说明用法\"></a>无限通配符 ?，只是为了说明用法</h3><p>表示类型没有限制，可以把 <code>?</code> 看成所有类型的父类，如： Pair&lt;?&gt;</p>\n<p><code>ArrayList&lt;T&gt; al = new ArrayList&lt;T&gt;()</code> 指定集合元素只能是 T 类型</p>\n<p><code>ArrayList&lt;?&gt; al = new ArrayList&lt;?&gt;()</code> 集合元素可以是任意类型。</p>\n<h2 id=\"虚拟机是如何实现的\"><a href=\"#虚拟机是如何实现的\" class=\"headerlink\" title=\"虚拟机是如何实现的\"></a>虚拟机是如何实现的</h2><p>Java 语言中的泛型，再程序源码中存在，再编译后的字节码文件中，就已经替换为原来的远程类型（Raw Type）并且再相应的地方插入了强制转换代码，因此对于运行期间的 Java 语言来说，<code>ArrayList&lt;int&gt;</code> 与 <code>ArrayList&lt;String&gt;</code> 就是同一个类，所以泛型技术实际上是 Java 语言的语法糖， Java 语言中的泛型实现方法成为泛型擦除，基于这种方法实现的泛型称为<strong>伪泛型</strong></p>\n<h2 id=\"泛型擦除\"><a href=\"#泛型擦除\" class=\"headerlink\" title=\"泛型擦除\"></a>泛型擦除</h2><p>因为虚拟机实现原理，就是泛型擦除，因此 <strong>泛型信息只能存在于代码的编译阶段，编译成子接码之后，与类型相关的信息会被擦除掉，变为 Object</strong></p>\n<p><strong>步骤</strong></p>\n<ol>\n<li>检查泛型类型，获取目标泛型</li>\n<li>擦除类型变量，并替换为限定类型<ol>\n<li>如果泛型类型的类型变量没有限定<code>&lt;T&gt;</code> 则用 Object 原始类型表示</li>\n<li>如果有限定类型<code>&lt;T extends XClass&gt;</code>则用，<code>XClass</code> 作为原始类型</li>\n<li>如果有多个限定<code>&lt;T extends XClass &amp; XClass2&gt;</code> 则使用第一个作为原始类型</li>\n</ol>\n</li>\n<li>在必要时插入类型转换以保证类型安全</li>\n<li>生成<strong>桥方法</strong> 以再扩展时保持多态</li>\n</ol>"},{"title":"Java 反射","_content":"\n\n\n**什么是反射？**\n\n反射使程序代码能够接入装载到 JVM 中的类的内部信息，允许在编写与执行时，而不是源代码中选定的类协作的代码，是以开发效率换运行效率的一种手段。\n\n一般情况下，我们使用某个类时，必定知道它是什么类，用来做什么，于是我们直接实例化，之后使用这个类对象进行操作\n\n反射则是一开始并不知道我们要初始化的类对象是什么，自然也无法通过 `new` 关键字来创建对象。\n<!-- more-->\n**反射的作用**\n\n1. 实现跨平台兼容，比如 JDK 中的 SocketImpl 的实现\n2. 通过 xml 或者注解，实现依赖注入（DI) ，注解处理，动态代理，单元测试等功能。如 Rotifit、 Spring 、Dagger \n\n**Java Class 的文件结构**\n\n```c\ntypedef struct {\n    u4 magic;\n    u2 minor_version;\n    u2 major_version;\n    u2 constant_pool_count;\n    cp_info constant_pool[constant_pool_count - 1 ];\n    u2 access_flags;\n    u2 this_class;\n    u2 super_class;\n    u2 interfaces_count;\n    u2 interfaces[interfaces_count];\n    // 重要\n    u2 fields_count;\n    field_info fields[field_count];\n    // 重要\n    u2 methods_count;\n    method_info methods[methods_count];\n    u2 attributes_count;\n    attribute_info attributes[attributes_count];\n}ClassBlock\n```\n\n**field 字段结构**\n\n```c\ntypedef struct fieldblock {\n    char *name;\n    char *type;\n    char *signature;\n    u2 access_flag;\n    u2 constant;\n    union {\n        union {\n            char data[8];\n            uintptr_t u;\n            long long l;\n            void *p;\n            int i;\n        } static_value;\n        u4 offset;\n    }u;\n}FieldBlock;\n```\n\n**method** \n\n提供了 descriptor, access_flags, Code 等索引，并指向常量池；\n\n```c\nmethod_info {\n    u2 access_flags;\n    u2 name_index;\n    // the paramters that the method takes and the value that it return\n    u2 descriptor_index;\n    u2 attributes_count;\n    attribute_info attributes[attributes_count];\n}\n```\n\n\n\n### 类的加载顺序\n\n**ClassLoader：**\n\n 用于加载、连接、缓存 Class，可以通过纯  Java 或者 native 进行实现。在 JVM 的 native 中， ClassLoader 内部维护着一个线程安全的 `HashTable<String, Class>` 用于实现堆 Class 字节流节码后的缓存，如果 `HashTable` 中有缓存，则直接返回缓存；反之，在获得类名后，通过读取文件，网络上的 class 字节流反序列化为 JVM 中的 native 的 C 结构体，接着分配 ( malloc ) 内存，并将指针缓存在 HashTable 中。\n\n**初始化过程**\n\n当 ClassLoader 加载 Class 结束后，将进行 Class 的初始化工作，主要执行 `clinit()> ` 中的静态块与静态属性（取决于编码顺序）\n\n```java\npublic class Smaple {\n    // step 1\n    static int b dddddddddddddddddddddddddddddddddddddddddddd= 2;\n    // step 2\n    static  {\n       b = 3; \n    }\n    \n    public static void main (String[] args) {\n        Sample s = new Sample();\n        System.out.println(s.b);\n        // b = 3\n    }\n}\n```\n\n**Class.forName**\n\n`Class.forName()` 可以通过报名寻找到 Class 对象，比如： `Class.forName(\"java.lang.String\")`\n\n**getDeclaredFields**\n\n`class.getDeclaredFields()` 方法实际调用的是 `native` 方法 `getDeclaredFields0()` 它在  JVM 主要实现步骤如下\n\n1. 根据 Class 结构体信息，获取 `field_count` 和 `fields[]` 字段，这个字段在 load 过程就被放入了\n2. 根据 `field_count` 的大小分配内存和创建数组\n3. 将数组进行 `forEach` 循环，通过 `fields[]` 中的信息一次创建 Object 对象。\n4. 返回数组指针\n\n这个过程比较耗时：\n\n1. 创建、计算、分配数组对象\n2. 对字段进行循环赋值\n\n**Method.invoke**\n\n创建 Frame\n\n如果对象 flag 为 native，交给 native_handler 进行处理\n\n在 frame 中执行 Java 代码\n\n弹出 Frame\n\n返回执行结果的指针\n\n主要慢在\n\n1. 需要完全执行 ByteCode 而缺少 JIT 等优化\n2. 检查参数非常多，本来可以在编译器或者加载时完成\n\n**class.newInstance**\n\n检测权限，预分配空间大小等参数\n\n创建 Object 对象，并分配空间\n\n通过`Method.invoke()` 调用构造函数\n\n返回 Object 指针\n\n主要慢在：\n\n1. 参数检查不能优化或者一口\n2. 构造函数 Method.invoke 本身耗时\n\n","source":"_posts/Java/基础知识/Java-反射.md","raw":"---\ntitle: Java 反射\ntag: Java\n\n---\n\n\n\n**什么是反射？**\n\n反射使程序代码能够接入装载到 JVM 中的类的内部信息，允许在编写与执行时，而不是源代码中选定的类协作的代码，是以开发效率换运行效率的一种手段。\n\n一般情况下，我们使用某个类时，必定知道它是什么类，用来做什么，于是我们直接实例化，之后使用这个类对象进行操作\n\n反射则是一开始并不知道我们要初始化的类对象是什么，自然也无法通过 `new` 关键字来创建对象。\n<!-- more-->\n**反射的作用**\n\n1. 实现跨平台兼容，比如 JDK 中的 SocketImpl 的实现\n2. 通过 xml 或者注解，实现依赖注入（DI) ，注解处理，动态代理，单元测试等功能。如 Rotifit、 Spring 、Dagger \n\n**Java Class 的文件结构**\n\n```c\ntypedef struct {\n    u4 magic;\n    u2 minor_version;\n    u2 major_version;\n    u2 constant_pool_count;\n    cp_info constant_pool[constant_pool_count - 1 ];\n    u2 access_flags;\n    u2 this_class;\n    u2 super_class;\n    u2 interfaces_count;\n    u2 interfaces[interfaces_count];\n    // 重要\n    u2 fields_count;\n    field_info fields[field_count];\n    // 重要\n    u2 methods_count;\n    method_info methods[methods_count];\n    u2 attributes_count;\n    attribute_info attributes[attributes_count];\n}ClassBlock\n```\n\n**field 字段结构**\n\n```c\ntypedef struct fieldblock {\n    char *name;\n    char *type;\n    char *signature;\n    u2 access_flag;\n    u2 constant;\n    union {\n        union {\n            char data[8];\n            uintptr_t u;\n            long long l;\n            void *p;\n            int i;\n        } static_value;\n        u4 offset;\n    }u;\n}FieldBlock;\n```\n\n**method** \n\n提供了 descriptor, access_flags, Code 等索引，并指向常量池；\n\n```c\nmethod_info {\n    u2 access_flags;\n    u2 name_index;\n    // the paramters that the method takes and the value that it return\n    u2 descriptor_index;\n    u2 attributes_count;\n    attribute_info attributes[attributes_count];\n}\n```\n\n\n\n### 类的加载顺序\n\n**ClassLoader：**\n\n 用于加载、连接、缓存 Class，可以通过纯  Java 或者 native 进行实现。在 JVM 的 native 中， ClassLoader 内部维护着一个线程安全的 `HashTable<String, Class>` 用于实现堆 Class 字节流节码后的缓存，如果 `HashTable` 中有缓存，则直接返回缓存；反之，在获得类名后，通过读取文件，网络上的 class 字节流反序列化为 JVM 中的 native 的 C 结构体，接着分配 ( malloc ) 内存，并将指针缓存在 HashTable 中。\n\n**初始化过程**\n\n当 ClassLoader 加载 Class 结束后，将进行 Class 的初始化工作，主要执行 `clinit()> ` 中的静态块与静态属性（取决于编码顺序）\n\n```java\npublic class Smaple {\n    // step 1\n    static int b dddddddddddddddddddddddddddddddddddddddddddd= 2;\n    // step 2\n    static  {\n       b = 3; \n    }\n    \n    public static void main (String[] args) {\n        Sample s = new Sample();\n        System.out.println(s.b);\n        // b = 3\n    }\n}\n```\n\n**Class.forName**\n\n`Class.forName()` 可以通过报名寻找到 Class 对象，比如： `Class.forName(\"java.lang.String\")`\n\n**getDeclaredFields**\n\n`class.getDeclaredFields()` 方法实际调用的是 `native` 方法 `getDeclaredFields0()` 它在  JVM 主要实现步骤如下\n\n1. 根据 Class 结构体信息，获取 `field_count` 和 `fields[]` 字段，这个字段在 load 过程就被放入了\n2. 根据 `field_count` 的大小分配内存和创建数组\n3. 将数组进行 `forEach` 循环，通过 `fields[]` 中的信息一次创建 Object 对象。\n4. 返回数组指针\n\n这个过程比较耗时：\n\n1. 创建、计算、分配数组对象\n2. 对字段进行循环赋值\n\n**Method.invoke**\n\n创建 Frame\n\n如果对象 flag 为 native，交给 native_handler 进行处理\n\n在 frame 中执行 Java 代码\n\n弹出 Frame\n\n返回执行结果的指针\n\n主要慢在\n\n1. 需要完全执行 ByteCode 而缺少 JIT 等优化\n2. 检查参数非常多，本来可以在编译器或者加载时完成\n\n**class.newInstance**\n\n检测权限，预分配空间大小等参数\n\n创建 Object 对象，并分配空间\n\n通过`Method.invoke()` 调用构造函数\n\n返回 Object 指针\n\n主要慢在：\n\n1. 参数检查不能优化或者一口\n2. 构造函数 Method.invoke 本身耗时\n\n","slug":"Java/基础知识/Java-反射","published":1,"date":"2021-01-29T15:54:28.309Z","updated":"2021-01-29T16:16:57.117Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8kq003hsz5qwiuqdc4p","content":"<p><strong>什么是反射？</strong></p>\n<p>反射使程序代码能够接入装载到 JVM 中的类的内部信息，允许在编写与执行时，而不是源代码中选定的类协作的代码，是以开发效率换运行效率的一种手段。</p>\n<p>一般情况下，我们使用某个类时，必定知道它是什么类，用来做什么，于是我们直接实例化，之后使用这个类对象进行操作</p>\n<p>反射则是一开始并不知道我们要初始化的类对象是什么，自然也无法通过 <code>new</code> 关键字来创建对象。<br><a id=\"more\"></a><br><strong>反射的作用</strong></p>\n<ol>\n<li>实现跨平台兼容，比如 JDK 中的 SocketImpl 的实现</li>\n<li>通过 xml 或者注解，实现依赖注入（DI) ，注解处理，动态代理，单元测试等功能。如 Rotifit、 Spring 、Dagger </li>\n</ol>\n<p><strong>Java Class 的文件结构</strong></p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    u4 magic<span class=\"token punctuation\">;</span>\n    u2 minor_version<span class=\"token punctuation\">;</span>\n    u2 major_version<span class=\"token punctuation\">;</span>\n    u2 constant_pool_count<span class=\"token punctuation\">;</span>\n    cp_info constant_pool<span class=\"token punctuation\">[</span>constant_pool_count <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    u2 access_flags<span class=\"token punctuation\">;</span>\n    u2 this_class<span class=\"token punctuation\">;</span>\n    u2 super_class<span class=\"token punctuation\">;</span>\n    u2 interfaces_count<span class=\"token punctuation\">;</span>\n    u2 interfaces<span class=\"token punctuation\">[</span>interfaces_count<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 重要</span>\n    u2 fields_count<span class=\"token punctuation\">;</span>\n    field_info fields<span class=\"token punctuation\">[</span>field_count<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 重要</span>\n    u2 methods_count<span class=\"token punctuation\">;</span>\n    method_info methods<span class=\"token punctuation\">[</span>methods_count<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    u2 attributes_count<span class=\"token punctuation\">;</span>\n    attribute_info attributes<span class=\"token punctuation\">[</span>attributes_count<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>ClassBlock\n</code></pre>\n<p><strong>field 字段结构</strong></p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> fieldblock <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>type<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>signature<span class=\"token punctuation\">;</span>\n    u2 access_flag<span class=\"token punctuation\">;</span>\n    u2 constant<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">union</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">union</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">char</span> data<span class=\"token punctuation\">[</span><span class=\"token number\">8</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            uintptr_t u<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span> l<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> static_value<span class=\"token punctuation\">;</span>\n        u4 offset<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>u<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>FieldBlock<span class=\"token punctuation\">;</span>\n</code></pre>\n<p><strong>method</strong> </p>\n<p>提供了 descriptor, access_flags, Code 等索引，并指向常量池；</p>\n<pre class=\" language-c\"><code class=\"language-c\">method_info <span class=\"token punctuation\">{</span>\n    u2 access_flags<span class=\"token punctuation\">;</span>\n    u2 name_index<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// the paramters that the method takes and the value that it return</span>\n    u2 descriptor_index<span class=\"token punctuation\">;</span>\n    u2 attributes_count<span class=\"token punctuation\">;</span>\n    attribute_info attributes<span class=\"token punctuation\">[</span>attributes_count<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"类的加载顺序\"><a href=\"#类的加载顺序\" class=\"headerlink\" title=\"类的加载顺序\"></a>类的加载顺序</h3><p><strong>ClassLoader：</strong></p>\n<p> 用于加载、连接、缓存 Class，可以通过纯  Java 或者 native 进行实现。在 JVM 的 native 中， ClassLoader 内部维护着一个线程安全的 <code>HashTable&lt;String, Class&gt;</code> 用于实现堆 Class 字节流节码后的缓存，如果 <code>HashTable</code> 中有缓存，则直接返回缓存；反之，在获得类名后，通过读取文件，网络上的 class 字节流反序列化为 JVM 中的 native 的 C 结构体，接着分配 ( malloc ) 内存，并将指针缓存在 HashTable 中。</p>\n<p><strong>初始化过程</strong></p>\n<p>当 ClassLoader 加载 Class 结束后，将进行 Class 的初始化工作，主要执行 <code>clinit()&gt;</code> 中的静态块与静态属性（取决于编码顺序）</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Smaple</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// step 1</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> b dddddddddddddddddddddddddddddddddddddddddddd<span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// step 2</span>\n    <span class=\"token keyword\">static</span>  <span class=\"token punctuation\">{</span>\n       b <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> \n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span> <span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Sample s <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Sample</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// b = 3</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>Class.forName</strong></p>\n<p><code>Class.forName()</code> 可以通过报名寻找到 Class 对象，比如： <code>Class.forName(&quot;java.lang.String&quot;)</code></p>\n<p><strong>getDeclaredFields</strong></p>\n<p><code>class.getDeclaredFields()</code> 方法实际调用的是 <code>native</code> 方法 <code>getDeclaredFields0()</code> 它在  JVM 主要实现步骤如下</p>\n<ol>\n<li>根据 Class 结构体信息，获取 <code>field_count</code> 和 <code>fields[]</code> 字段，这个字段在 load 过程就被放入了</li>\n<li>根据 <code>field_count</code> 的大小分配内存和创建数组</li>\n<li>将数组进行 <code>forEach</code> 循环，通过 <code>fields[]</code> 中的信息一次创建 Object 对象。</li>\n<li>返回数组指针</li>\n</ol>\n<p>这个过程比较耗时：</p>\n<ol>\n<li>创建、计算、分配数组对象</li>\n<li>对字段进行循环赋值</li>\n</ol>\n<p><strong>Method.invoke</strong></p>\n<p>创建 Frame</p>\n<p>如果对象 flag 为 native，交给 native_handler 进行处理</p>\n<p>在 frame 中执行 Java 代码</p>\n<p>弹出 Frame</p>\n<p>返回执行结果的指针</p>\n<p>主要慢在</p>\n<ol>\n<li>需要完全执行 ByteCode 而缺少 JIT 等优化</li>\n<li>检查参数非常多，本来可以在编译器或者加载时完成</li>\n</ol>\n<p><strong>class.newInstance</strong></p>\n<p>检测权限，预分配空间大小等参数</p>\n<p>创建 Object 对象，并分配空间</p>\n<p>通过<code>Method.invoke()</code> 调用构造函数</p>\n<p>返回 Object 指针</p>\n<p>主要慢在：</p>\n<ol>\n<li>参数检查不能优化或者一口</li>\n<li>构造函数 Method.invoke 本身耗时</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p><strong>什么是反射？</strong></p>\n<p>反射使程序代码能够接入装载到 JVM 中的类的内部信息，允许在编写与执行时，而不是源代码中选定的类协作的代码，是以开发效率换运行效率的一种手段。</p>\n<p>一般情况下，我们使用某个类时，必定知道它是什么类，用来做什么，于是我们直接实例化，之后使用这个类对象进行操作</p>\n<p>反射则是一开始并不知道我们要初始化的类对象是什么，自然也无法通过 <code>new</code> 关键字来创建对象。<br>","more":"<br><strong>反射的作用</strong></p>\n<ol>\n<li>实现跨平台兼容，比如 JDK 中的 SocketImpl 的实现</li>\n<li>通过 xml 或者注解，实现依赖注入（DI) ，注解处理，动态代理，单元测试等功能。如 Rotifit、 Spring 、Dagger </li>\n</ol>\n<p><strong>Java Class 的文件结构</strong></p>\n<pre><code class=\"c\">typedef struct {\n    u4 magic;\n    u2 minor_version;\n    u2 major_version;\n    u2 constant_pool_count;\n    cp_info constant_pool[constant_pool_count - 1 ];\n    u2 access_flags;\n    u2 this_class;\n    u2 super_class;\n    u2 interfaces_count;\n    u2 interfaces[interfaces_count];\n    // 重要\n    u2 fields_count;\n    field_info fields[field_count];\n    // 重要\n    u2 methods_count;\n    method_info methods[methods_count];\n    u2 attributes_count;\n    attribute_info attributes[attributes_count];\n}ClassBlock\n</code></pre>\n<p><strong>field 字段结构</strong></p>\n<pre><code class=\"c\">typedef struct fieldblock {\n    char *name;\n    char *type;\n    char *signature;\n    u2 access_flag;\n    u2 constant;\n    union {\n        union {\n            char data[8];\n            uintptr_t u;\n            long long l;\n            void *p;\n            int i;\n        } static_value;\n        u4 offset;\n    }u;\n}FieldBlock;\n</code></pre>\n<p><strong>method</strong> </p>\n<p>提供了 descriptor, access_flags, Code 等索引，并指向常量池；</p>\n<pre><code class=\"c\">method_info {\n    u2 access_flags;\n    u2 name_index;\n    // the paramters that the method takes and the value that it return\n    u2 descriptor_index;\n    u2 attributes_count;\n    attribute_info attributes[attributes_count];\n}\n</code></pre>\n<h3 id=\"类的加载顺序\"><a href=\"#类的加载顺序\" class=\"headerlink\" title=\"类的加载顺序\"></a>类的加载顺序</h3><p><strong>ClassLoader：</strong></p>\n<p> 用于加载、连接、缓存 Class，可以通过纯  Java 或者 native 进行实现。在 JVM 的 native 中， ClassLoader 内部维护着一个线程安全的 <code>HashTable&lt;String, Class&gt;</code> 用于实现堆 Class 字节流节码后的缓存，如果 <code>HashTable</code> 中有缓存，则直接返回缓存；反之，在获得类名后，通过读取文件，网络上的 class 字节流反序列化为 JVM 中的 native 的 C 结构体，接着分配 ( malloc ) 内存，并将指针缓存在 HashTable 中。</p>\n<p><strong>初始化过程</strong></p>\n<p>当 ClassLoader 加载 Class 结束后，将进行 Class 的初始化工作，主要执行 <code>clinit()&gt;</code> 中的静态块与静态属性（取决于编码顺序）</p>\n<pre><code class=\"java\">public class Smaple {\n    // step 1\n    static int b dddddddddddddddddddddddddddddddddddddddddddd= 2;\n    // step 2\n    static  {\n       b = 3; \n    }\n\n    public static void main (String[] args) {\n        Sample s = new Sample();\n        System.out.println(s.b);\n        // b = 3\n    }\n}\n</code></pre>\n<p><strong>Class.forName</strong></p>\n<p><code>Class.forName()</code> 可以通过报名寻找到 Class 对象，比如： <code>Class.forName(&quot;java.lang.String&quot;)</code></p>\n<p><strong>getDeclaredFields</strong></p>\n<p><code>class.getDeclaredFields()</code> 方法实际调用的是 <code>native</code> 方法 <code>getDeclaredFields0()</code> 它在  JVM 主要实现步骤如下</p>\n<ol>\n<li>根据 Class 结构体信息，获取 <code>field_count</code> 和 <code>fields[]</code> 字段，这个字段在 load 过程就被放入了</li>\n<li>根据 <code>field_count</code> 的大小分配内存和创建数组</li>\n<li>将数组进行 <code>forEach</code> 循环，通过 <code>fields[]</code> 中的信息一次创建 Object 对象。</li>\n<li>返回数组指针</li>\n</ol>\n<p>这个过程比较耗时：</p>\n<ol>\n<li>创建、计算、分配数组对象</li>\n<li>对字段进行循环赋值</li>\n</ol>\n<p><strong>Method.invoke</strong></p>\n<p>创建 Frame</p>\n<p>如果对象 flag 为 native，交给 native_handler 进行处理</p>\n<p>在 frame 中执行 Java 代码</p>\n<p>弹出 Frame</p>\n<p>返回执行结果的指针</p>\n<p>主要慢在</p>\n<ol>\n<li>需要完全执行 ByteCode 而缺少 JIT 等优化</li>\n<li>检查参数非常多，本来可以在编译器或者加载时完成</li>\n</ol>\n<p><strong>class.newInstance</strong></p>\n<p>检测权限，预分配空间大小等参数</p>\n<p>创建 Object 对象，并分配空间</p>\n<p>通过<code>Method.invoke()</code> 调用构造函数</p>\n<p>返回 Object 指针</p>\n<p>主要慢在：</p>\n<ol>\n<li>参数检查不能优化或者一口</li>\n<li>构造函数 Method.invoke 本身耗时</li>\n</ol>"},{"_content":"# Object 类\n\n* Object 类是所有 Java 类的父类。每个类都使用  Object 作为 super 类，所有对象都实现这个类的方法\n\n* 可以使用 Object 类型的变量指向任意类型的 super 类\n* Object 类有一个默认构造方法 `public Object()` ，在构造子类实例时，都会先调用这个默认构造方法\n* Object 类的变量只能用作各种值得通用持有者。要对他们进行任何专门操作，都需要知道他们得原始类型并进行转换\n<!-- more-->\n## API \n\n* Object () ： 默认构造方法\n* clone() : 创建并返回此对象得一个副本\n* equals(Object obj) :  指示某个其他对象是否与此对象相等（Object 判断的是内存地址）\n* finalize() : 当垃圾回收器确定不存在该对象得更多引用时，由对象得垃圾回收器调用此方法\n* getClass(): 返回一个对象得运行时类\n* hashCode(): 返回该对象得 哈希值\n* notify(): 唤醒在此对象监视器上等待得单个线程\n* notifyAll() : 唤醒在此对象监视器上等待得所有线程\n* toString(): 返回该对象得字符串标识\n* wait(): 导致当前的线程等待，知道其他线程调用此对象的 notify 方法或 notifyAll() 方法\n* wait(long timeout): 导致当前线程等待，直到其他线程调用此对象的 notify() 或 notifyAll() 方法，或者超过指定的时间量\n* wait(long timeout, int nanos): 导致当前的线程等待， 直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法， 或者其他某个线程中断当前线程， 或者已超过某个实际时间量  \n\n","source":"_posts/Java/基础知识/Object 类.md","raw":"# Object 类\n\n* Object 类是所有 Java 类的父类。每个类都使用  Object 作为 super 类，所有对象都实现这个类的方法\n\n* 可以使用 Object 类型的变量指向任意类型的 super 类\n* Object 类有一个默认构造方法 `public Object()` ，在构造子类实例时，都会先调用这个默认构造方法\n* Object 类的变量只能用作各种值得通用持有者。要对他们进行任何专门操作，都需要知道他们得原始类型并进行转换\n<!-- more-->\n## API \n\n* Object () ： 默认构造方法\n* clone() : 创建并返回此对象得一个副本\n* equals(Object obj) :  指示某个其他对象是否与此对象相等（Object 判断的是内存地址）\n* finalize() : 当垃圾回收器确定不存在该对象得更多引用时，由对象得垃圾回收器调用此方法\n* getClass(): 返回一个对象得运行时类\n* hashCode(): 返回该对象得 哈希值\n* notify(): 唤醒在此对象监视器上等待得单个线程\n* notifyAll() : 唤醒在此对象监视器上等待得所有线程\n* toString(): 返回该对象得字符串标识\n* wait(): 导致当前的线程等待，知道其他线程调用此对象的 notify 方法或 notifyAll() 方法\n* wait(long timeout): 导致当前线程等待，直到其他线程调用此对象的 notify() 或 notifyAll() 方法，或者超过指定的时间量\n* wait(long timeout, int nanos): 导致当前的线程等待， 直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法， 或者其他某个线程中断当前线程， 或者已超过某个实际时间量  \n\n","slug":"Java/基础知识/Object 类","published":1,"date":"2021-01-29T15:54:28.311Z","updated":"2021-01-29T16:17:04.099Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8kw003ksz5qyjfkkxmc","content":"<h1 id=\"Object-类\"><a href=\"#Object-类\" class=\"headerlink\" title=\"Object 类\"></a>Object 类</h1><ul>\n<li><p>Object 类是所有 Java 类的父类。每个类都使用  Object 作为 super 类，所有对象都实现这个类的方法</p>\n</li>\n<li><p>可以使用 Object 类型的变量指向任意类型的 super 类</p>\n</li>\n<li>Object 类有一个默认构造方法 <code>public Object()</code> ，在构造子类实例时，都会先调用这个默认构造方法</li>\n<li><p>Object 类的变量只能用作各种值得通用持有者。要对他们进行任何专门操作，都需要知道他们得原始类型并进行转换</p>\n<a id=\"more\"></a>\n<h2 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h2></li>\n<li><p>Object () ： 默认构造方法</p>\n</li>\n<li>clone() : 创建并返回此对象得一个副本</li>\n<li>equals(Object obj) :  指示某个其他对象是否与此对象相等（Object 判断的是内存地址）</li>\n<li>finalize() : 当垃圾回收器确定不存在该对象得更多引用时，由对象得垃圾回收器调用此方法</li>\n<li>getClass(): 返回一个对象得运行时类</li>\n<li>hashCode(): 返回该对象得 哈希值</li>\n<li>notify(): 唤醒在此对象监视器上等待得单个线程</li>\n<li>notifyAll() : 唤醒在此对象监视器上等待得所有线程</li>\n<li>toString(): 返回该对象得字符串标识</li>\n<li>wait(): 导致当前的线程等待，知道其他线程调用此对象的 notify 方法或 notifyAll() 方法</li>\n<li>wait(long timeout): 导致当前线程等待，直到其他线程调用此对象的 notify() 或 notifyAll() 方法，或者超过指定的时间量</li>\n<li>wait(long timeout, int nanos): 导致当前的线程等待， 直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法， 或者其他某个线程中断当前线程， 或者已超过某个实际时间量  </li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"Object-类\"><a href=\"#Object-类\" class=\"headerlink\" title=\"Object 类\"></a>Object 类</h1><ul>\n<li><p>Object 类是所有 Java 类的父类。每个类都使用  Object 作为 super 类，所有对象都实现这个类的方法</p>\n</li>\n<li><p>可以使用 Object 类型的变量指向任意类型的 super 类</p>\n</li>\n<li>Object 类有一个默认构造方法 <code>public Object()</code> ，在构造子类实例时，都会先调用这个默认构造方法</li>\n<li><p>Object 类的变量只能用作各种值得通用持有者。要对他们进行任何专门操作，都需要知道他们得原始类型并进行转换</p>","more":"<h2 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h2></li>\n<li><p>Object () ： 默认构造方法</p>\n</li>\n<li>clone() : 创建并返回此对象得一个副本</li>\n<li>equals(Object obj) :  指示某个其他对象是否与此对象相等（Object 判断的是内存地址）</li>\n<li>finalize() : 当垃圾回收器确定不存在该对象得更多引用时，由对象得垃圾回收器调用此方法</li>\n<li>getClass(): 返回一个对象得运行时类</li>\n<li>hashCode(): 返回该对象得 哈希值</li>\n<li>notify(): 唤醒在此对象监视器上等待得单个线程</li>\n<li>notifyAll() : 唤醒在此对象监视器上等待得所有线程</li>\n<li>toString(): 返回该对象得字符串标识</li>\n<li>wait(): 导致当前的线程等待，知道其他线程调用此对象的 notify 方法或 notifyAll() 方法</li>\n<li>wait(long timeout): 导致当前线程等待，直到其他线程调用此对象的 notify() 或 notifyAll() 方法，或者超过指定的时间量</li>\n<li>wait(long timeout, int nanos): 导致当前的线程等待， 直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法， 或者其他某个线程中断当前线程， 或者已超过某个实际时间量  </li>\n</ul>"},{"title":"Java 注解","_content":"\nJava 注解又称标注。注解是元数据的一种形式，提供有关于程序但不属于程序本身的数据。注解对他们注解的代码的操作没有直接影响。\n\n## 声明注解\n\nJava 中所有的注解，默认实现接口 `Annotation` 接口\n<!-- more-->\n```java\npublic interface Annotation {\n    boolean equals(Object obj);\n    \n    int hashCode();\n    \n    String toString();\n    \n    Class<? extends Annotation> annotationType();\n}\n```\n\n与生命一个  Class 不同，注解的使用使用 `@interface` 管检测\n\n```java\npublic @interface Login {}\n```\n\n## 元注解\n\n在定义注解时，注解类也能够使用其他的注解声明，对注解类型进行注解的注解类。\n\n## Target\n\n注解标记另一个注解，以限制可以应用注解的 Java 元素类型。目标注解指定以下元素类型之一作为其值\n\n* ElementType.ANNOTATION_TYPE 可以用于注解类型\n* ElementType.CONSTRUCTOR 可以用于构造函数\n* ElementType.FIELD 可以用于字段或属性\n* ElementType.LOCAL_VARIABLE 可以用于局部变量\n* ElementType.METHOD 可以应用于方法级注解\n* ElementType.PACKAGE 可以应用于包生命\n* ELementType.PARAMETER 方法参数\n* ElementType.TYPE 用于类的任何元素\n\n## Retention\n\n注解指定标记注解的存储方式（作用域）：\n\n* RetentionPolicy.SOUTRCE 标记注解仅保留在源码级别中，并被编译器忽略\n* RetentionPolicy.CLASS 标记注解在编译时由编译器保留，但 Java 虚拟机会忽略\n* RetentionPolicy.RUNTIME 标记的注解由 JVM 保留，因此运行时环境可以使用\n\n\n\n## 应用场景\n\n按照作用域来讲，注解可以被三种场景使用\n\n### SOURCE\n\n`RetentionPolicy.SOURCE` 作用于源码级别的注解，可提供给 IDE 语法检查， APT 等场景使用\n\n**语法检查：**\n\n在 `Adnroid `开发中，`support-annotations` 与 `androidx.annotation` 中均提供了 `@IntDef` 注解，\n\n```java\n@Retention(SOURCE)\n@Target({ANNOTATION_TYPE}) \npublic @interface IntDef {\n    int[] value() default {};\n    boolean flag() default false;\n    boolean open() default false;\n}\n```\n\n此注解的意义在于能够取代枚举，实现如方法入参限制\n\n如：我们定义 test 方法，只接收 Teacher 参数，\n\n```java\npublic enum Teacher {\n    LILY, MARY\n}\n\npublic void test(Teacher teacher) {}\n```\n\n而现在为了内存优化，我们现在不再使用枚举，则方法定义为\n\n```java\npublic static final int LILY = 1;\npublic static final int MARY = 2;\n\npublic void test(int teacher){}\n```\n\n然而 `test` 方法由于采用基本数据类型 `int` ，讲无法进行类型限定。此时我们使用 `@IntDef` 增加自定义注解\n\n```java\npublic static final int LILY = 1;\npublic static final int MARY = 2;\n\n@IntDef(value = {LILY, MARY}) // 限定为 LILY, MARY\n@Target(ElementType.PARAMETER) // 作用于参数的注解\n@Retention(RetentionPolicy.SOURCE) \npublic @interface Teacher{}\n\npublic void test(@Teacher int teacher) {}\n```\n\n此时，我们再去调用 `test` 方法，如果传递的参数不时 LILY, 和  MARY 则会显示 `Inspection` 警告\n\n**APT 注解处理器**\n\napt 是 “Annotation Processor Tools” ，意为注解处理器。顾名思义，用于处理注解，编写好的 Java 源文件，需要经过 Javac 编译，翻译为虚拟机能够加载解析的字节码 class 文件。注解处理器是 Javac 自带的一个工具，用来编译时期扫描处理注解信息。\n\n\n\n### Class\n\n定义为 Class 的注解，会保留在 class 文件中，但是会被虚拟机忽略（无法在运行期反射获取注解）。此时需要符合此种注解的应用场景为字节码操作。像 AspectJ, 热修复等\n\n所谓字节码操作，就是直接修改字节码 Class 文件以达到修改代码逻辑的目的，在程序中有多处需要进行是否登录判断。\n\n我们借助 AOP （面向切面编程）的思想，将程序的功能点划分为：*需要登录* 和 *不需要登录* 即两个切面，对于切面的区分可采用注解\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.CLASS)\npublic @interface LoginAspect{}\n\n@LoginAspect\npublic void jumpA(){\n    startActivity(new Intent(this, AActivity.class));\n}\n\npublic void jumpB(){\n    startActivity(new Intent(this, BActivity.class));\n}\n```\n\n### Runtime\n\n注解保留到运行期，意味着我们能够在运行期间结合反射技术获取注解中的所有信息。\n\n","source":"_posts/Java/基础知识/Java-注解.md","raw":"---\ntitle: Java 注解\ntag: Java\n---\n\nJava 注解又称标注。注解是元数据的一种形式，提供有关于程序但不属于程序本身的数据。注解对他们注解的代码的操作没有直接影响。\n\n## 声明注解\n\nJava 中所有的注解，默认实现接口 `Annotation` 接口\n<!-- more-->\n```java\npublic interface Annotation {\n    boolean equals(Object obj);\n    \n    int hashCode();\n    \n    String toString();\n    \n    Class<? extends Annotation> annotationType();\n}\n```\n\n与生命一个  Class 不同，注解的使用使用 `@interface` 管检测\n\n```java\npublic @interface Login {}\n```\n\n## 元注解\n\n在定义注解时，注解类也能够使用其他的注解声明，对注解类型进行注解的注解类。\n\n## Target\n\n注解标记另一个注解，以限制可以应用注解的 Java 元素类型。目标注解指定以下元素类型之一作为其值\n\n* ElementType.ANNOTATION_TYPE 可以用于注解类型\n* ElementType.CONSTRUCTOR 可以用于构造函数\n* ElementType.FIELD 可以用于字段或属性\n* ElementType.LOCAL_VARIABLE 可以用于局部变量\n* ElementType.METHOD 可以应用于方法级注解\n* ElementType.PACKAGE 可以应用于包生命\n* ELementType.PARAMETER 方法参数\n* ElementType.TYPE 用于类的任何元素\n\n## Retention\n\n注解指定标记注解的存储方式（作用域）：\n\n* RetentionPolicy.SOUTRCE 标记注解仅保留在源码级别中，并被编译器忽略\n* RetentionPolicy.CLASS 标记注解在编译时由编译器保留，但 Java 虚拟机会忽略\n* RetentionPolicy.RUNTIME 标记的注解由 JVM 保留，因此运行时环境可以使用\n\n\n\n## 应用场景\n\n按照作用域来讲，注解可以被三种场景使用\n\n### SOURCE\n\n`RetentionPolicy.SOURCE` 作用于源码级别的注解，可提供给 IDE 语法检查， APT 等场景使用\n\n**语法检查：**\n\n在 `Adnroid `开发中，`support-annotations` 与 `androidx.annotation` 中均提供了 `@IntDef` 注解，\n\n```java\n@Retention(SOURCE)\n@Target({ANNOTATION_TYPE}) \npublic @interface IntDef {\n    int[] value() default {};\n    boolean flag() default false;\n    boolean open() default false;\n}\n```\n\n此注解的意义在于能够取代枚举，实现如方法入参限制\n\n如：我们定义 test 方法，只接收 Teacher 参数，\n\n```java\npublic enum Teacher {\n    LILY, MARY\n}\n\npublic void test(Teacher teacher) {}\n```\n\n而现在为了内存优化，我们现在不再使用枚举，则方法定义为\n\n```java\npublic static final int LILY = 1;\npublic static final int MARY = 2;\n\npublic void test(int teacher){}\n```\n\n然而 `test` 方法由于采用基本数据类型 `int` ，讲无法进行类型限定。此时我们使用 `@IntDef` 增加自定义注解\n\n```java\npublic static final int LILY = 1;\npublic static final int MARY = 2;\n\n@IntDef(value = {LILY, MARY}) // 限定为 LILY, MARY\n@Target(ElementType.PARAMETER) // 作用于参数的注解\n@Retention(RetentionPolicy.SOURCE) \npublic @interface Teacher{}\n\npublic void test(@Teacher int teacher) {}\n```\n\n此时，我们再去调用 `test` 方法，如果传递的参数不时 LILY, 和  MARY 则会显示 `Inspection` 警告\n\n**APT 注解处理器**\n\napt 是 “Annotation Processor Tools” ，意为注解处理器。顾名思义，用于处理注解，编写好的 Java 源文件，需要经过 Javac 编译，翻译为虚拟机能够加载解析的字节码 class 文件。注解处理器是 Javac 自带的一个工具，用来编译时期扫描处理注解信息。\n\n\n\n### Class\n\n定义为 Class 的注解，会保留在 class 文件中，但是会被虚拟机忽略（无法在运行期反射获取注解）。此时需要符合此种注解的应用场景为字节码操作。像 AspectJ, 热修复等\n\n所谓字节码操作，就是直接修改字节码 Class 文件以达到修改代码逻辑的目的，在程序中有多处需要进行是否登录判断。\n\n我们借助 AOP （面向切面编程）的思想，将程序的功能点划分为：*需要登录* 和 *不需要登录* 即两个切面，对于切面的区分可采用注解\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.CLASS)\npublic @interface LoginAspect{}\n\n@LoginAspect\npublic void jumpA(){\n    startActivity(new Intent(this, AActivity.class));\n}\n\npublic void jumpB(){\n    startActivity(new Intent(this, BActivity.class));\n}\n```\n\n### Runtime\n\n注解保留到运行期，意味着我们能够在运行期间结合反射技术获取注解中的所有信息。\n\n","slug":"Java/基础知识/Java-注解","published":1,"date":"2021-01-29T15:54:28.310Z","updated":"2021-01-29T16:17:01.851Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8l3003msz5qi3tccnj9","content":"<p>Java 注解又称标注。注解是元数据的一种形式，提供有关于程序但不属于程序本身的数据。注解对他们注解的代码的操作没有直接影响。</p>\n<h2 id=\"声明注解\"><a href=\"#声明注解\" class=\"headerlink\" title=\"声明注解\"></a>声明注解</h2><p>Java 中所有的注解，默认实现接口 <code>Annotation</code> 接口<br><a id=\"more\"></a></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Annotation</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">boolean</span> <span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>Object obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">int</span> <span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    String <span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    Class<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Annotation</span><span class=\"token operator\">></span> <span class=\"token function\">annotationType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>与生命一个  Class 不同，注解的使用使用 <code>@interface</code> 管检测</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> @<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Login</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"元注解\"><a href=\"#元注解\" class=\"headerlink\" title=\"元注解\"></a>元注解</h2><p>在定义注解时，注解类也能够使用其他的注解声明，对注解类型进行注解的注解类。</p>\n<h2 id=\"Target\"><a href=\"#Target\" class=\"headerlink\" title=\"Target\"></a>Target</h2><p>注解标记另一个注解，以限制可以应用注解的 Java 元素类型。目标注解指定以下元素类型之一作为其值</p>\n<ul>\n<li>ElementType.ANNOTATION_TYPE 可以用于注解类型</li>\n<li>ElementType.CONSTRUCTOR 可以用于构造函数</li>\n<li>ElementType.FIELD 可以用于字段或属性</li>\n<li>ElementType.LOCAL_VARIABLE 可以用于局部变量</li>\n<li>ElementType.METHOD 可以应用于方法级注解</li>\n<li>ElementType.PACKAGE 可以应用于包生命</li>\n<li>ELementType.PARAMETER 方法参数</li>\n<li>ElementType.TYPE 用于类的任何元素</li>\n</ul>\n<h2 id=\"Retention\"><a href=\"#Retention\" class=\"headerlink\" title=\"Retention\"></a>Retention</h2><p>注解指定标记注解的存储方式（作用域）：</p>\n<ul>\n<li>RetentionPolicy.SOUTRCE 标记注解仅保留在源码级别中，并被编译器忽略</li>\n<li>RetentionPolicy.CLASS 标记注解在编译时由编译器保留，但 Java 虚拟机会忽略</li>\n<li>RetentionPolicy.RUNTIME 标记的注解由 JVM 保留，因此运行时环境可以使用</li>\n</ul>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>按照作用域来讲，注解可以被三种场景使用</p>\n<h3 id=\"SOURCE\"><a href=\"#SOURCE\" class=\"headerlink\" title=\"SOURCE\"></a>SOURCE</h3><p><code>RetentionPolicy.SOURCE</code> 作用于源码级别的注解，可提供给 IDE 语法检查， APT 等场景使用</p>\n<p><strong>语法检查：</strong></p>\n<p>在 <code>Adnroid</code>开发中，<code>support-annotations</code> 与 <code>androidx.annotation</code> 中均提供了 <code>@IntDef</code> 注解，</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Retention</span><span class=\"token punctuation\">(</span>SOURCE<span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Target</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>ANNOTATION_TYPE<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> \n<span class=\"token keyword\">public</span> @<span class=\"token keyword\">interface</span> <span class=\"token class-name\">IntDef</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">boolean</span> <span class=\"token function\">flag</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">default</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">boolean</span> <span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">default</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>此注解的意义在于能够取代枚举，实现如方法入参限制</p>\n<p>如：我们定义 test 方法，只接收 Teacher 参数，</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">enum</span> Teacher <span class=\"token punctuation\">{</span>\n    LILY<span class=\"token punctuation\">,</span> MARY\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span>Teacher teacher<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n</code></pre>\n<p>而现在为了内存优化，我们现在不再使用枚举，则方法定义为</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> LILY <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> MARY <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> teacher<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n</code></pre>\n<p>然而 <code>test</code> 方法由于采用基本数据类型 <code>int</code> ，讲无法进行类型限定。此时我们使用 <code>@IntDef</code> 增加自定义注解</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> LILY <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> MARY <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token annotation punctuation\">@IntDef</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>LILY<span class=\"token punctuation\">,</span> MARY<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 限定为 LILY, MARY</span>\n<span class=\"token annotation punctuation\">@Target</span><span class=\"token punctuation\">(</span>ElementType<span class=\"token punctuation\">.</span>PARAMETER<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 作用于参数的注解</span>\n<span class=\"token annotation punctuation\">@Retention</span><span class=\"token punctuation\">(</span>RetentionPolicy<span class=\"token punctuation\">.</span>SOURCE<span class=\"token punctuation\">)</span> \n<span class=\"token keyword\">public</span> @<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Teacher</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@Teacher</span> <span class=\"token keyword\">int</span> teacher<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n</code></pre>\n<p>此时，我们再去调用 <code>test</code> 方法，如果传递的参数不时 LILY, 和  MARY 则会显示 <code>Inspection</code> 警告</p>\n<p><strong>APT 注解处理器</strong></p>\n<p>apt 是 “Annotation Processor Tools” ，意为注解处理器。顾名思义，用于处理注解，编写好的 Java 源文件，需要经过 Javac 编译，翻译为虚拟机能够加载解析的字节码 class 文件。注解处理器是 Javac 自带的一个工具，用来编译时期扫描处理注解信息。</p>\n<h3 id=\"Class\"><a href=\"#Class\" class=\"headerlink\" title=\"Class\"></a>Class</h3><p>定义为 Class 的注解，会保留在 class 文件中，但是会被虚拟机忽略（无法在运行期反射获取注解）。此时需要符合此种注解的应用场景为字节码操作。像 AspectJ, 热修复等</p>\n<p>所谓字节码操作，就是直接修改字节码 Class 文件以达到修改代码逻辑的目的，在程序中有多处需要进行是否登录判断。</p>\n<p>我们借助 AOP （面向切面编程）的思想，将程序的功能点划分为：<em>需要登录</em> 和 <em>不需要登录</em> 即两个切面，对于切面的区分可采用注解</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Target</span><span class=\"token punctuation\">(</span>ElementType<span class=\"token punctuation\">.</span>METHOD<span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Retention</span><span class=\"token punctuation\">(</span>RetentionPolicy<span class=\"token punctuation\">.</span>CLASS<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> @<span class=\"token keyword\">interface</span> <span class=\"token class-name\">LoginAspect</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@LoginAspect</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">jumpA</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">startActivity</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Intent</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> AActivity<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">jumpB</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">startActivity</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Intent</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> BActivity<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"Runtime\"><a href=\"#Runtime\" class=\"headerlink\" title=\"Runtime\"></a>Runtime</h3><p>注解保留到运行期，意味着我们能够在运行期间结合反射技术获取注解中的所有信息。</p>\n","site":{"data":{}},"excerpt":"<p>Java 注解又称标注。注解是元数据的一种形式，提供有关于程序但不属于程序本身的数据。注解对他们注解的代码的操作没有直接影响。</p>\n<h2 id=\"声明注解\"><a href=\"#声明注解\" class=\"headerlink\" title=\"声明注解\"></a>声明注解</h2><p>Java 中所有的注解，默认实现接口 <code>Annotation</code> 接口<br>","more":"</p>\n<pre><code class=\"java\">public interface Annotation {\n    boolean equals(Object obj);\n\n    int hashCode();\n\n    String toString();\n\n    Class&lt;? extends Annotation&gt; annotationType();\n}\n</code></pre>\n<p>与生命一个  Class 不同，注解的使用使用 <code>@interface</code> 管检测</p>\n<pre><code class=\"java\">public @interface Login {}\n</code></pre>\n<h2 id=\"元注解\"><a href=\"#元注解\" class=\"headerlink\" title=\"元注解\"></a>元注解</h2><p>在定义注解时，注解类也能够使用其他的注解声明，对注解类型进行注解的注解类。</p>\n<h2 id=\"Target\"><a href=\"#Target\" class=\"headerlink\" title=\"Target\"></a>Target</h2><p>注解标记另一个注解，以限制可以应用注解的 Java 元素类型。目标注解指定以下元素类型之一作为其值</p>\n<ul>\n<li>ElementType.ANNOTATION_TYPE 可以用于注解类型</li>\n<li>ElementType.CONSTRUCTOR 可以用于构造函数</li>\n<li>ElementType.FIELD 可以用于字段或属性</li>\n<li>ElementType.LOCAL_VARIABLE 可以用于局部变量</li>\n<li>ElementType.METHOD 可以应用于方法级注解</li>\n<li>ElementType.PACKAGE 可以应用于包生命</li>\n<li>ELementType.PARAMETER 方法参数</li>\n<li>ElementType.TYPE 用于类的任何元素</li>\n</ul>\n<h2 id=\"Retention\"><a href=\"#Retention\" class=\"headerlink\" title=\"Retention\"></a>Retention</h2><p>注解指定标记注解的存储方式（作用域）：</p>\n<ul>\n<li>RetentionPolicy.SOUTRCE 标记注解仅保留在源码级别中，并被编译器忽略</li>\n<li>RetentionPolicy.CLASS 标记注解在编译时由编译器保留，但 Java 虚拟机会忽略</li>\n<li>RetentionPolicy.RUNTIME 标记的注解由 JVM 保留，因此运行时环境可以使用</li>\n</ul>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>按照作用域来讲，注解可以被三种场景使用</p>\n<h3 id=\"SOURCE\"><a href=\"#SOURCE\" class=\"headerlink\" title=\"SOURCE\"></a>SOURCE</h3><p><code>RetentionPolicy.SOURCE</code> 作用于源码级别的注解，可提供给 IDE 语法检查， APT 等场景使用</p>\n<p><strong>语法检查：</strong></p>\n<p>在 <code>Adnroid</code>开发中，<code>support-annotations</code> 与 <code>androidx.annotation</code> 中均提供了 <code>@IntDef</code> 注解，</p>\n<pre><code class=\"java\">@Retention(SOURCE)\n@Target({ANNOTATION_TYPE}) \npublic @interface IntDef {\n    int[] value() default {};\n    boolean flag() default false;\n    boolean open() default false;\n}\n</code></pre>\n<p>此注解的意义在于能够取代枚举，实现如方法入参限制</p>\n<p>如：我们定义 test 方法，只接收 Teacher 参数，</p>\n<pre><code class=\"java\">public enum Teacher {\n    LILY, MARY\n}\n\npublic void test(Teacher teacher) {}\n</code></pre>\n<p>而现在为了内存优化，我们现在不再使用枚举，则方法定义为</p>\n<pre><code class=\"java\">public static final int LILY = 1;\npublic static final int MARY = 2;\n\npublic void test(int teacher){}\n</code></pre>\n<p>然而 <code>test</code> 方法由于采用基本数据类型 <code>int</code> ，讲无法进行类型限定。此时我们使用 <code>@IntDef</code> 增加自定义注解</p>\n<pre><code class=\"java\">public static final int LILY = 1;\npublic static final int MARY = 2;\n\n@IntDef(value = {LILY, MARY}) // 限定为 LILY, MARY\n@Target(ElementType.PARAMETER) // 作用于参数的注解\n@Retention(RetentionPolicy.SOURCE) \npublic @interface Teacher{}\n\npublic void test(@Teacher int teacher) {}\n</code></pre>\n<p>此时，我们再去调用 <code>test</code> 方法，如果传递的参数不时 LILY, 和  MARY 则会显示 <code>Inspection</code> 警告</p>\n<p><strong>APT 注解处理器</strong></p>\n<p>apt 是 “Annotation Processor Tools” ，意为注解处理器。顾名思义，用于处理注解，编写好的 Java 源文件，需要经过 Javac 编译，翻译为虚拟机能够加载解析的字节码 class 文件。注解处理器是 Javac 自带的一个工具，用来编译时期扫描处理注解信息。</p>\n<h3 id=\"Class\"><a href=\"#Class\" class=\"headerlink\" title=\"Class\"></a>Class</h3><p>定义为 Class 的注解，会保留在 class 文件中，但是会被虚拟机忽略（无法在运行期反射获取注解）。此时需要符合此种注解的应用场景为字节码操作。像 AspectJ, 热修复等</p>\n<p>所谓字节码操作，就是直接修改字节码 Class 文件以达到修改代码逻辑的目的，在程序中有多处需要进行是否登录判断。</p>\n<p>我们借助 AOP （面向切面编程）的思想，将程序的功能点划分为：<em>需要登录</em> 和 <em>不需要登录</em> 即两个切面，对于切面的区分可采用注解</p>\n<pre><code class=\"java\">@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.CLASS)\npublic @interface LoginAspect{}\n\n@LoginAspect\npublic void jumpA(){\n    startActivity(new Intent(this, AActivity.class));\n}\n\npublic void jumpB(){\n    startActivity(new Intent(this, BActivity.class));\n}\n</code></pre>\n<h3 id=\"Runtime\"><a href=\"#Runtime\" class=\"headerlink\" title=\"Runtime\"></a>Runtime</h3><p>注解保留到运行期，意味着我们能够在运行期间结合反射技术获取注解中的所有信息。</p>"},{"title":"协程入门","_content":"\n* 协程是一种非抢占式或者说是协作式的计算机程序并发调度的实现方案，程序可以主动挂起或者回复执行。\n* 线程当中的代码逻辑在线程抢占到 CPU 的时间片的时候才可以执行，否则就写着\n* 协程更轻量的意思是，协程并不会映射成内核线程或者其他资源，他的调用在用户态就可以搞定，任务之间是协作式，并非抢占式。\n* 协程的三要素：上下文、启动模式、协程体\n* 多个协程可以共用一个线程\n\n* 协程的本质\n  * 协程的挂起函数本质上就是一个回调，回调类型就是`Continuation`\n  * 协程体的执行就是一个*状态机*，每一次遇到挂起函数，都是一次状态转移\n\n<!-- more-->\n\n## 通过 Retrofit 请求\n\n通过 `Retrofit` 发送一个网络请求\n\n```kotlin\ninterface GitHubServiceApi {\n    @GET(\"users/{login}\")\n\tfun getUser(@Path(\"login\") login:String):Call<User>\n}\n\ndata class User(val id:String, val name:String, val url:String)\n```\n\n`Retrofit` 初始化如下\n\n```kotlin\nval githubServiceApi by lazy {\n    val retorfit = retrofit2.Retrofit.Builder()\n        .baseUrl(\"https//api.github.com\")\n        .addConverterFacetory(GsonConverterFactory.create())\n        .build()\n    retrofit.create(GitHUbServiceApi::class.java)\n}\n```\n\n发起网络请求\n\n```kotlin\ngithubServiceApi.getUser(\"small\")\n.enqueue(object: Callback<User> {\n    override fun onFailure(call: Call<User>, t: Throwable) {\n        handler.post{showError(t)}\n    }\n    \n    override fun onSuccess(call: Call<User>, response: Response<User>) {\n        handler.post{\n            response.body()?.let(::showUser) ?: showError(NullPointerException())\n        }\n    }\n})\n```\n\n\n\n## 改造为携程\n\n对于 `Retrofit` 改造为协程的方式有两种，分别通过 `CallAdapter` 和 `suspend` 函数\n\n### CallAdapter \n\n该方法的本质是让接口的方法返回一个协程的 `Job`\n\n```kotlin\ninterface GitHubServiceApi {\n    @GET(\"users/{login}\")\n    fun getUser(@Path(\"login\")login:String):Deferred<User>\n}\n```\n\n> Deferred 是 Job 的子接口\n\n同时需要为 `Retrofit` 添加对 `Deferred` 的支持\n\n```groovy\nimplementation 'com.jakewharton.retrofit:retrofit2-kotlin-coroutines-adapter:0.9.2'\n```\n\n对构造 `Retorfit` 的实例添加\n\n```kotlin\nval githubServiceApi by lazy {\n    val retorfit = retrofit2.Retrofit.Builder()\n        .baseUrl(\"https//api.github.com\")\n        .addConverterFactory(GsonConverterFactory.create())\n        .addCallAdapterFactory(CoroutineCallAdapterFactroy())\n        .build()\n    retrofit.create(GitHubServiceApi::class.java)\n}\n```\n\n通过上面的修改，那么我们的请求就可以这样写\n\n```kotlin\nGlobalScope.launch(Dispatchers.Main) {\n    try{\n        showUser(githubServiceApi.getUser(\"small\").await())\n    } catch (e: Exception) {\n        shwoError(e)\n    }\n}\n```\n\n**Note:**  我们首先通过 `launch` 启动了一个协程，这类似于我们启动一个线程，`launch` 的参数有三个: 协程上下文、协程启动模式、协程体\n\n```kotlin\npublic fun CorountineScope.launch(\n\tcontext:CorountineContext = EmptyCouroutineContext,// 上下文\n    start: CoroutineStart = CoroutineStart.DEFGAULT, // 启动模式\n    block: suspend CorountineScope.() -> UNit // 协程体\n) :Job\n```\n\n**启动模式** 不是一个复杂的概念，默认直接俄允许调度执行\n\n**上下文**可以有很多作用，包括*携带参数*、*拦截协程执行*等等，多数情况下我们不需要自己去实现上下文，只需要使用系统提供的就好。上下文有一个重要的作用就是切换线程，`Dispatchers.Main` 就是一个官方提供的上下文，它可以确保`launch` 启动的协程体运行在 UI 线程当中（除非你自己再 `launch` 的新和成提内部进行线程切换，或者启动运行再其他有线程切换能力的上下文的协程）\n\n换句话说，在例子当中的整个 `launch` 内部，你看到的代码都是运行在UI线程中的，尽管 `getUser` 在执行的时候确实切换了线程，但返回结果的时候会再次切回来。直觉告诉我们 `getUser` 返回了要给 `Deferred` 类型，他的 `await` 方法会返回一个 `User` 对象，意味着 `await` 需要等待请求结果返回才可以继续执行，那么`await` 不会阻塞 UI 线程嘛？\n\n当然不会。不然 `Deferred` 于 `Future`  又有上面区别的，这里`await`  很可疑。因为实际上是要给 `suspend` 函数。整个函数只能在协程体或者其他 `suspend` 函数内部被调用，就像是回调的语法糖一样，通过一个叫 `Continuation` 的接口来实现返回结果``\n\n```kotlin\n@SinceKotlin(\"1.3\")\npublic interface Continuation<in T> {\n    public val context:CoroutineContext\n    public fun resumeWith(result:Result<T>)\n}\n\n@SinceKotlin(\"1.1\")\npublic interface Continuation<in T> {\n    public val context:CorouineContext\n    public fun resume(value: T)\n    public fun resumeWithException(exception: Throwable)\n}\n\n```\n\n其实就是要给回调，有结果正常返回， `Continuation` 调用 `resume` 返回结果，否则调用 `resumeWithException` 来抛出异常。\n\n因此，请求的代码执行流程本质上是一个异步回调\n\n而之所以可以看起来是同步的，那就是编译器的黑魔法了\n\n在虚拟机上 `await` 函数的真实样子是这样的\n\n```\nkotlin/coroutines/Deferred.await (Lkotlin/coroutines/Cotinuation;) LJava/lang/Object\n```\n\n即接收一个 `Continuation` 实例，返回 `Object` 这么一个函数，所以前面的代码可以理解为\n\n```kotlin\n// 不是正确代码，仅用来理解协程使用\nGlobalScope.launch(Dispathcers.Main) {\n    githubServiceApi.getUser(\"small\").await(object: Continuation<User>{\n        override fun resume(value: User) {\n            showUser(value)\n        }\n        \n        override fun resumeWithException(exception: Throwable) {\n            showError(exception)\n        }\n    })\n}\n```\n\n在 `await` 当中大致就是：\n\n```kotlin\n// 不是正确代码，仅用来理解协程使用\nfun awiat(continuation:Continuation<user>):Any{\n    ...// 切到非 UI 线程中执行，等待结果返回\n    try {\n        val user = ....// 这里执行任务\n        handler.post {\n            continuation.resume(user)\n        }\n    } catch(e: Exception) {\n        handler.post{continuation.resumeWithException(e)}\n    }\n}\n```\n\n> 从运行机制上来讲，协程和回调没有本质的区别\n\n### suspend  方式\n\n`suspend` 函数是 Kotlin 编译器对协程支持的黑魔法，还是先看如何在Retrofit 中如何使用\n\n> Retrofit 在 release 2.5.0 之后才会支持 suspend 函数\n\n首先修改一下接口方法\n\n```kotlin\n@GET(\"users/{login}\")\nsuspend fun getUser(@Path(\"login\")login:String): User\n```\n\n这种情况下， `Retrofit` 会根据接口方法的生命来构造`Continuation` ，并且在内部封装了一个 `Call` 的异步请求(使用 `enqueue`) ，进而得到 User 实例。\n\n```kotlin\nGlobalScope.launch {\n    try {\n        showUser(githubServiceApi.getUser(\"small\"))\n    } catch (e: Exception) {\n        showError(e)\n    }\n}\n```\n\n## 协程到底是什么\n\n以前我们使用 Java 进行开发的时候，经常会遇到 *回调地域* ，使得代码的可读性急剧降低；也通过大量复杂的异步调用处理逻辑、异常；因为回调的存在，还得经常处理线程切换。随着代码体量的增加，各种问题频频爆发。\n\n而 **协程** 可以帮我们优雅的处理掉这些\n\n协程本身是一个脱离语言实现的概念。简单来说就是：\n\n协程是一种非抢占式或者说协作式的计算机程序并发调度的实现，程序可以主动挂起或者恢复执行。经常听到的所谓的协程更轻量的意思是，协程并不会映射成内核线程或者其他重的资源，它的调度在用户态就可以搞定，任务之间的调度并非抢占式，而是协作式。\n\n### Job\n\n```kotlin\npublic interface Job: CoroutineContext.Element {\n    ...\n    public val isActive: Boolean\n    public val isCompleted: Boolean\n    public val isCancelled: Boolean\n    \n    public fun start():Boolean\n    public fun cancel(cause: CancellationException? = null)\n    public suspend fun join()\n    ...\n}\n```\n\n我们看一下 **Thread** 的定义\n\n```java\npublic class Thread implements Runnable {\n    ...\n    public final native boolean isAlive();\n    public synchronized void start(){}\n    \n    @Deprecated\n    public final void stop(){}\n    public final void join() throws InterruptedException{}\n}\n```\n\nThread 和 Job 的基本功能是一致的，他们都承载着一段代码逻辑，也都包含了这段代码的运行状态。\n\n","source":"_posts/Kotlin/协程/协程-入门.md","raw":"---\ntitle: 协程入门\ntag: Kotlin\n---\n\n* 协程是一种非抢占式或者说是协作式的计算机程序并发调度的实现方案，程序可以主动挂起或者回复执行。\n* 线程当中的代码逻辑在线程抢占到 CPU 的时间片的时候才可以执行，否则就写着\n* 协程更轻量的意思是，协程并不会映射成内核线程或者其他资源，他的调用在用户态就可以搞定，任务之间是协作式，并非抢占式。\n* 协程的三要素：上下文、启动模式、协程体\n* 多个协程可以共用一个线程\n\n* 协程的本质\n  * 协程的挂起函数本质上就是一个回调，回调类型就是`Continuation`\n  * 协程体的执行就是一个*状态机*，每一次遇到挂起函数，都是一次状态转移\n\n<!-- more-->\n\n## 通过 Retrofit 请求\n\n通过 `Retrofit` 发送一个网络请求\n\n```kotlin\ninterface GitHubServiceApi {\n    @GET(\"users/{login}\")\n\tfun getUser(@Path(\"login\") login:String):Call<User>\n}\n\ndata class User(val id:String, val name:String, val url:String)\n```\n\n`Retrofit` 初始化如下\n\n```kotlin\nval githubServiceApi by lazy {\n    val retorfit = retrofit2.Retrofit.Builder()\n        .baseUrl(\"https//api.github.com\")\n        .addConverterFacetory(GsonConverterFactory.create())\n        .build()\n    retrofit.create(GitHUbServiceApi::class.java)\n}\n```\n\n发起网络请求\n\n```kotlin\ngithubServiceApi.getUser(\"small\")\n.enqueue(object: Callback<User> {\n    override fun onFailure(call: Call<User>, t: Throwable) {\n        handler.post{showError(t)}\n    }\n    \n    override fun onSuccess(call: Call<User>, response: Response<User>) {\n        handler.post{\n            response.body()?.let(::showUser) ?: showError(NullPointerException())\n        }\n    }\n})\n```\n\n\n\n## 改造为携程\n\n对于 `Retrofit` 改造为协程的方式有两种，分别通过 `CallAdapter` 和 `suspend` 函数\n\n### CallAdapter \n\n该方法的本质是让接口的方法返回一个协程的 `Job`\n\n```kotlin\ninterface GitHubServiceApi {\n    @GET(\"users/{login}\")\n    fun getUser(@Path(\"login\")login:String):Deferred<User>\n}\n```\n\n> Deferred 是 Job 的子接口\n\n同时需要为 `Retrofit` 添加对 `Deferred` 的支持\n\n```groovy\nimplementation 'com.jakewharton.retrofit:retrofit2-kotlin-coroutines-adapter:0.9.2'\n```\n\n对构造 `Retorfit` 的实例添加\n\n```kotlin\nval githubServiceApi by lazy {\n    val retorfit = retrofit2.Retrofit.Builder()\n        .baseUrl(\"https//api.github.com\")\n        .addConverterFactory(GsonConverterFactory.create())\n        .addCallAdapterFactory(CoroutineCallAdapterFactroy())\n        .build()\n    retrofit.create(GitHubServiceApi::class.java)\n}\n```\n\n通过上面的修改，那么我们的请求就可以这样写\n\n```kotlin\nGlobalScope.launch(Dispatchers.Main) {\n    try{\n        showUser(githubServiceApi.getUser(\"small\").await())\n    } catch (e: Exception) {\n        shwoError(e)\n    }\n}\n```\n\n**Note:**  我们首先通过 `launch` 启动了一个协程，这类似于我们启动一个线程，`launch` 的参数有三个: 协程上下文、协程启动模式、协程体\n\n```kotlin\npublic fun CorountineScope.launch(\n\tcontext:CorountineContext = EmptyCouroutineContext,// 上下文\n    start: CoroutineStart = CoroutineStart.DEFGAULT, // 启动模式\n    block: suspend CorountineScope.() -> UNit // 协程体\n) :Job\n```\n\n**启动模式** 不是一个复杂的概念，默认直接俄允许调度执行\n\n**上下文**可以有很多作用，包括*携带参数*、*拦截协程执行*等等，多数情况下我们不需要自己去实现上下文，只需要使用系统提供的就好。上下文有一个重要的作用就是切换线程，`Dispatchers.Main` 就是一个官方提供的上下文，它可以确保`launch` 启动的协程体运行在 UI 线程当中（除非你自己再 `launch` 的新和成提内部进行线程切换，或者启动运行再其他有线程切换能力的上下文的协程）\n\n换句话说，在例子当中的整个 `launch` 内部，你看到的代码都是运行在UI线程中的，尽管 `getUser` 在执行的时候确实切换了线程，但返回结果的时候会再次切回来。直觉告诉我们 `getUser` 返回了要给 `Deferred` 类型，他的 `await` 方法会返回一个 `User` 对象，意味着 `await` 需要等待请求结果返回才可以继续执行，那么`await` 不会阻塞 UI 线程嘛？\n\n当然不会。不然 `Deferred` 于 `Future`  又有上面区别的，这里`await`  很可疑。因为实际上是要给 `suspend` 函数。整个函数只能在协程体或者其他 `suspend` 函数内部被调用，就像是回调的语法糖一样，通过一个叫 `Continuation` 的接口来实现返回结果``\n\n```kotlin\n@SinceKotlin(\"1.3\")\npublic interface Continuation<in T> {\n    public val context:CoroutineContext\n    public fun resumeWith(result:Result<T>)\n}\n\n@SinceKotlin(\"1.1\")\npublic interface Continuation<in T> {\n    public val context:CorouineContext\n    public fun resume(value: T)\n    public fun resumeWithException(exception: Throwable)\n}\n\n```\n\n其实就是要给回调，有结果正常返回， `Continuation` 调用 `resume` 返回结果，否则调用 `resumeWithException` 来抛出异常。\n\n因此，请求的代码执行流程本质上是一个异步回调\n\n而之所以可以看起来是同步的，那就是编译器的黑魔法了\n\n在虚拟机上 `await` 函数的真实样子是这样的\n\n```\nkotlin/coroutines/Deferred.await (Lkotlin/coroutines/Cotinuation;) LJava/lang/Object\n```\n\n即接收一个 `Continuation` 实例，返回 `Object` 这么一个函数，所以前面的代码可以理解为\n\n```kotlin\n// 不是正确代码，仅用来理解协程使用\nGlobalScope.launch(Dispathcers.Main) {\n    githubServiceApi.getUser(\"small\").await(object: Continuation<User>{\n        override fun resume(value: User) {\n            showUser(value)\n        }\n        \n        override fun resumeWithException(exception: Throwable) {\n            showError(exception)\n        }\n    })\n}\n```\n\n在 `await` 当中大致就是：\n\n```kotlin\n// 不是正确代码，仅用来理解协程使用\nfun awiat(continuation:Continuation<user>):Any{\n    ...// 切到非 UI 线程中执行，等待结果返回\n    try {\n        val user = ....// 这里执行任务\n        handler.post {\n            continuation.resume(user)\n        }\n    } catch(e: Exception) {\n        handler.post{continuation.resumeWithException(e)}\n    }\n}\n```\n\n> 从运行机制上来讲，协程和回调没有本质的区别\n\n### suspend  方式\n\n`suspend` 函数是 Kotlin 编译器对协程支持的黑魔法，还是先看如何在Retrofit 中如何使用\n\n> Retrofit 在 release 2.5.0 之后才会支持 suspend 函数\n\n首先修改一下接口方法\n\n```kotlin\n@GET(\"users/{login}\")\nsuspend fun getUser(@Path(\"login\")login:String): User\n```\n\n这种情况下， `Retrofit` 会根据接口方法的生命来构造`Continuation` ，并且在内部封装了一个 `Call` 的异步请求(使用 `enqueue`) ，进而得到 User 实例。\n\n```kotlin\nGlobalScope.launch {\n    try {\n        showUser(githubServiceApi.getUser(\"small\"))\n    } catch (e: Exception) {\n        showError(e)\n    }\n}\n```\n\n## 协程到底是什么\n\n以前我们使用 Java 进行开发的时候，经常会遇到 *回调地域* ，使得代码的可读性急剧降低；也通过大量复杂的异步调用处理逻辑、异常；因为回调的存在，还得经常处理线程切换。随着代码体量的增加，各种问题频频爆发。\n\n而 **协程** 可以帮我们优雅的处理掉这些\n\n协程本身是一个脱离语言实现的概念。简单来说就是：\n\n协程是一种非抢占式或者说协作式的计算机程序并发调度的实现，程序可以主动挂起或者恢复执行。经常听到的所谓的协程更轻量的意思是，协程并不会映射成内核线程或者其他重的资源，它的调度在用户态就可以搞定，任务之间的调度并非抢占式，而是协作式。\n\n### Job\n\n```kotlin\npublic interface Job: CoroutineContext.Element {\n    ...\n    public val isActive: Boolean\n    public val isCompleted: Boolean\n    public val isCancelled: Boolean\n    \n    public fun start():Boolean\n    public fun cancel(cause: CancellationException? = null)\n    public suspend fun join()\n    ...\n}\n```\n\n我们看一下 **Thread** 的定义\n\n```java\npublic class Thread implements Runnable {\n    ...\n    public final native boolean isAlive();\n    public synchronized void start(){}\n    \n    @Deprecated\n    public final void stop(){}\n    public final void join() throws InterruptedException{}\n}\n```\n\nThread 和 Job 的基本功能是一致的，他们都承载着一段代码逻辑，也都包含了这段代码的运行状态。\n\n","slug":"Kotlin/协程/协程-入门","published":1,"date":"2021-01-29T15:54:28.315Z","updated":"2021-01-29T16:16:18.533Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8l4003osz5q9jump8g2","content":"<ul>\n<li>协程是一种非抢占式或者说是协作式的计算机程序并发调度的实现方案，程序可以主动挂起或者回复执行。</li>\n<li>线程当中的代码逻辑在线程抢占到 CPU 的时间片的时候才可以执行，否则就写着</li>\n<li>协程更轻量的意思是，协程并不会映射成内核线程或者其他资源，他的调用在用户态就可以搞定，任务之间是协作式，并非抢占式。</li>\n<li>协程的三要素：上下文、启动模式、协程体</li>\n<li><p>多个协程可以共用一个线程</p>\n</li>\n<li><p>协程的本质</p>\n<ul>\n<li>协程的挂起函数本质上就是一个回调，回调类型就是<code>Continuation</code></li>\n<li>协程体的执行就是一个<em>状态机</em>，每一次遇到挂起函数，都是一次状态转移</li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"通过-Retrofit-请求\"><a href=\"#通过-Retrofit-请求\" class=\"headerlink\" title=\"通过 Retrofit 请求\"></a>通过 Retrofit 请求</h2><p>通过 <code>Retrofit</code> 发送一个网络请求</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">interface</span> GitHubServiceApi <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation builtin\">@GET</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"users/{login}\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">getUser</span><span class=\"token punctuation\">(</span><span class=\"token annotation builtin\">@Path</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"login\"</span><span class=\"token punctuation\">)</span> login<span class=\"token operator\">:</span>String<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>Call<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">data</span> <span class=\"token keyword\">class</span> <span class=\"token function\">User</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">val</span> id<span class=\"token operator\">:</span>String<span class=\"token punctuation\">,</span> <span class=\"token keyword\">val</span> name<span class=\"token operator\">:</span>String<span class=\"token punctuation\">,</span> <span class=\"token keyword\">val</span> url<span class=\"token operator\">:</span>String<span class=\"token punctuation\">)</span>\n</code></pre>\n<p><code>Retrofit</code> 初始化如下</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> githubServiceApi <span class=\"token keyword\">by</span> lazy <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> retorfit <span class=\"token operator\">=</span> retrofit2<span class=\"token punctuation\">.</span>Retrofit<span class=\"token punctuation\">.</span><span class=\"token function\">Builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">baseUrl</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"https//api.github.com\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">addConverterFacetory</span><span class=\"token punctuation\">(</span>GsonConverterFactory<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    retrofit<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>GitHUbServiceApi<span class=\"token operator\">::</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">.</span>java<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>发起网络请求</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\">githubServiceApi<span class=\"token punctuation\">.</span><span class=\"token function\">getUser</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"small\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">.</span><span class=\"token function\">enqueue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">object</span><span class=\"token operator\">:</span> Callback<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">onFailure</span><span class=\"token punctuation\">(</span>call<span class=\"token operator\">:</span> Call<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span><span class=\"token punctuation\">,</span> t<span class=\"token operator\">:</span> Throwable<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        handler<span class=\"token punctuation\">.</span><span class=\"token function\">post</span><span class=\"token punctuation\">{</span><span class=\"token function\">showError</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">onSuccess</span><span class=\"token punctuation\">(</span>call<span class=\"token operator\">:</span> Call<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span><span class=\"token punctuation\">,</span> response<span class=\"token operator\">:</span> Response<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        handler<span class=\"token punctuation\">.</span><span class=\"token function\">post</span><span class=\"token punctuation\">{</span>\n            response<span class=\"token punctuation\">.</span><span class=\"token function\">body</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">let</span><span class=\"token punctuation\">(</span><span class=\"token operator\">::</span>showUser<span class=\"token punctuation\">)</span> <span class=\"token operator\">?:</span> <span class=\"token function\">showError</span><span class=\"token punctuation\">(</span><span class=\"token function\">NullPointerException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<h2 id=\"改造为携程\"><a href=\"#改造为携程\" class=\"headerlink\" title=\"改造为携程\"></a>改造为携程</h2><p>对于 <code>Retrofit</code> 改造为协程的方式有两种，分别通过 <code>CallAdapter</code> 和 <code>suspend</code> 函数</p>\n<h3 id=\"CallAdapter\"><a href=\"#CallAdapter\" class=\"headerlink\" title=\"CallAdapter\"></a>CallAdapter</h3><p>该方法的本质是让接口的方法返回一个协程的 <code>Job</code></p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">interface</span> GitHubServiceApi <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation builtin\">@GET</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"users/{login}\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">getUser</span><span class=\"token punctuation\">(</span><span class=\"token annotation builtin\">@Path</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"login\"</span><span class=\"token punctuation\">)</span>login<span class=\"token operator\">:</span>String<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>Deferred<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<blockquote>\n<p>Deferred 是 Job 的子接口</p>\n</blockquote>\n<p>同时需要为 <code>Retrofit</code> 添加对 <code>Deferred</code> 的支持</p>\n<pre class=\" language-groovy\"><code class=\"language-groovy\">implementation <span class=\"token string\">'com.jakewharton.retrofit:retrofit2-kotlin-coroutines-adapter:0.9.2'</span>\n</code></pre>\n<p>对构造 <code>Retorfit</code> 的实例添加</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> githubServiceApi <span class=\"token keyword\">by</span> lazy <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> retorfit <span class=\"token operator\">=</span> retrofit2<span class=\"token punctuation\">.</span>Retrofit<span class=\"token punctuation\">.</span><span class=\"token function\">Builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">baseUrl</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"https//api.github.com\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">addConverterFactory</span><span class=\"token punctuation\">(</span>GsonConverterFactory<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">addCallAdapterFactory</span><span class=\"token punctuation\">(</span><span class=\"token function\">CoroutineCallAdapterFactroy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    retrofit<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>GitHubServiceApi<span class=\"token operator\">::</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">.</span>java<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>通过上面的修改，那么我们的请求就可以这样写</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\">GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span><span class=\"token punctuation\">(</span>Dispatchers<span class=\"token punctuation\">.</span>Main<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">showUser</span><span class=\"token punctuation\">(</span>githubServiceApi<span class=\"token punctuation\">.</span><span class=\"token function\">getUser</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"small\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token operator\">:</span> Exception<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">shwoError</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>Note:</strong>  我们首先通过 <code>launch</code> 启动了一个协程，这类似于我们启动一个线程，<code>launch</code> 的参数有三个: 协程上下文、协程启动模式、协程体</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">fun</span> CorountineScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span><span class=\"token punctuation\">(</span>\n    context<span class=\"token operator\">:</span>CorountineContext <span class=\"token operator\">=</span> EmptyCouroutineContext<span class=\"token punctuation\">,</span><span class=\"token comment\" spellcheck=\"true\">// 上下文</span>\n    start<span class=\"token operator\">:</span> CoroutineStart <span class=\"token operator\">=</span> CoroutineStart<span class=\"token punctuation\">.</span>DEFGAULT<span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">// 启动模式</span>\n    block<span class=\"token operator\">:</span> suspend CorountineScope<span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> UNit <span class=\"token comment\" spellcheck=\"true\">// 协程体</span>\n<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span>Job\n</code></pre>\n<p><strong>启动模式</strong> 不是一个复杂的概念，默认直接俄允许调度执行</p>\n<p><strong>上下文</strong>可以有很多作用，包括<em>携带参数</em>、<em>拦截协程执行</em>等等，多数情况下我们不需要自己去实现上下文，只需要使用系统提供的就好。上下文有一个重要的作用就是切换线程，<code>Dispatchers.Main</code> 就是一个官方提供的上下文，它可以确保<code>launch</code> 启动的协程体运行在 UI 线程当中（除非你自己再 <code>launch</code> 的新和成提内部进行线程切换，或者启动运行再其他有线程切换能力的上下文的协程）</p>\n<p>换句话说，在例子当中的整个 <code>launch</code> 内部，你看到的代码都是运行在UI线程中的，尽管 <code>getUser</code> 在执行的时候确实切换了线程，但返回结果的时候会再次切回来。直觉告诉我们 <code>getUser</code> 返回了要给 <code>Deferred</code> 类型，他的 <code>await</code> 方法会返回一个 <code>User</code> 对象，意味着 <code>await</code> 需要等待请求结果返回才可以继续执行，那么<code>await</code> 不会阻塞 UI 线程嘛？</p>\n<p>当然不会。不然 <code>Deferred</code> 于 <code>Future</code>  又有上面区别的，这里<code>await</code>  很可疑。因为实际上是要给 <code>suspend</code> 函数。整个函数只能在协程体或者其他 <code>suspend</code> 函数内部被调用，就像是回调的语法糖一样，通过一个叫 <code>Continuation</code> 的接口来实现返回结果<code></code></p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@SinceKotlin</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1.3\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> Continuation<span class=\"token operator\">&lt;</span><span class=\"token keyword\">in</span> T<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">val</span> context<span class=\"token operator\">:</span>CoroutineContext\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">resumeWith</span><span class=\"token punctuation\">(</span>result<span class=\"token operator\">:</span>Result<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation builtin\">@SinceKotlin</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1.1\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> Continuation<span class=\"token operator\">&lt;</span><span class=\"token keyword\">in</span> T<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">val</span> context<span class=\"token operator\">:</span>CorouineContext\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">resume</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> T<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">resumeWithException</span><span class=\"token punctuation\">(</span>exception<span class=\"token operator\">:</span> Throwable<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre>\n<p>其实就是要给回调，有结果正常返回， <code>Continuation</code> 调用 <code>resume</code> 返回结果，否则调用 <code>resumeWithException</code> 来抛出异常。</p>\n<p>因此，请求的代码执行流程本质上是一个异步回调</p>\n<p>而之所以可以看起来是同步的，那就是编译器的黑魔法了</p>\n<p>在虚拟机上 <code>await</code> 函数的真实样子是这样的</p>\n<pre><code>kotlin/coroutines/Deferred.await (Lkotlin/coroutines/Cotinuation;) LJava/lang/Object\n</code></pre><p>即接收一个 <code>Continuation</code> 实例，返回 <code>Object</code> 这么一个函数，所以前面的代码可以理解为</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token comment\" spellcheck=\"true\">// 不是正确代码，仅用来理解协程使用</span>\nGlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span><span class=\"token punctuation\">(</span>Dispathcers<span class=\"token punctuation\">.</span>Main<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    githubServiceApi<span class=\"token punctuation\">.</span><span class=\"token function\">getUser</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"small\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">object</span><span class=\"token operator\">:</span> Continuation<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">resume</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> User<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">showUser</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">resumeWithException</span><span class=\"token punctuation\">(</span>exception<span class=\"token operator\">:</span> Throwable<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">showError</span><span class=\"token punctuation\">(</span>exception<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>在 <code>await</code> 当中大致就是：</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token comment\" spellcheck=\"true\">// 不是正确代码，仅用来理解协程使用</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">awiat</span><span class=\"token punctuation\">(</span>continuation<span class=\"token operator\">:</span>Continuation<span class=\"token operator\">&lt;</span>user<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>Any<span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">..</span><span class=\"token punctuation\">.</span><span class=\"token comment\" spellcheck=\"true\">// 切到非 UI 线程中执行，等待结果返回</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">val</span> user <span class=\"token operator\">=</span> <span class=\"token operator\">..</span><span class=\"token operator\">..</span><span class=\"token comment\" spellcheck=\"true\">// 这里执行任务</span>\n        handler<span class=\"token punctuation\">.</span><span class=\"token function\">post</span> <span class=\"token punctuation\">{</span>\n            continuation<span class=\"token punctuation\">.</span><span class=\"token function\">resume</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>e<span class=\"token operator\">:</span> Exception<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        handler<span class=\"token punctuation\">.</span><span class=\"token function\">post</span><span class=\"token punctuation\">{</span>continuation<span class=\"token punctuation\">.</span><span class=\"token function\">resumeWithException</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<blockquote>\n<p>从运行机制上来讲，协程和回调没有本质的区别</p>\n</blockquote>\n<h3 id=\"suspend-方式\"><a href=\"#suspend-方式\" class=\"headerlink\" title=\"suspend  方式\"></a>suspend  方式</h3><p><code>suspend</code> 函数是 Kotlin 编译器对协程支持的黑魔法，还是先看如何在Retrofit 中如何使用</p>\n<blockquote>\n<p>Retrofit 在 release 2.5.0 之后才会支持 suspend 函数</p>\n</blockquote>\n<p>首先修改一下接口方法</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@GET</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"users/{login}\"</span><span class=\"token punctuation\">)</span>\nsuspend <span class=\"token keyword\">fun</span> <span class=\"token function\">getUser</span><span class=\"token punctuation\">(</span><span class=\"token annotation builtin\">@Path</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"login\"</span><span class=\"token punctuation\">)</span>login<span class=\"token operator\">:</span>String<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> User\n</code></pre>\n<p>这种情况下， <code>Retrofit</code> 会根据接口方法的生命来构造<code>Continuation</code> ，并且在内部封装了一个 <code>Call</code> 的异步请求(使用 <code>enqueue</code>) ，进而得到 User 实例。</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\">GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">showUser</span><span class=\"token punctuation\">(</span>githubServiceApi<span class=\"token punctuation\">.</span><span class=\"token function\">getUser</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"small\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token operator\">:</span> Exception<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">showError</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"协程到底是什么\"><a href=\"#协程到底是什么\" class=\"headerlink\" title=\"协程到底是什么\"></a>协程到底是什么</h2><p>以前我们使用 Java 进行开发的时候，经常会遇到 <em>回调地域</em> ，使得代码的可读性急剧降低；也通过大量复杂的异步调用处理逻辑、异常；因为回调的存在，还得经常处理线程切换。随着代码体量的增加，各种问题频频爆发。</p>\n<p>而 <strong>协程</strong> 可以帮我们优雅的处理掉这些</p>\n<p>协程本身是一个脱离语言实现的概念。简单来说就是：</p>\n<p>协程是一种非抢占式或者说协作式的计算机程序并发调度的实现，程序可以主动挂起或者恢复执行。经常听到的所谓的协程更轻量的意思是，协程并不会映射成内核线程或者其他重的资源，它的调度在用户态就可以搞定，任务之间的调度并非抢占式，而是协作式。</p>\n<h3 id=\"Job\"><a href=\"#Job\" class=\"headerlink\" title=\"Job\"></a>Job</h3><pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> Job<span class=\"token operator\">:</span> CoroutineContext<span class=\"token punctuation\">.</span><span class=\"token function\">Element</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">..</span><span class=\"token punctuation\">.</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">val</span> isActive<span class=\"token operator\">:</span> Boolean\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">val</span> isCompleted<span class=\"token operator\">:</span> Boolean\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">val</span> isCancelled<span class=\"token operator\">:</span> Boolean\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>Boolean\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">cancel</span><span class=\"token punctuation\">(</span>cause<span class=\"token operator\">:</span> CancellationException<span class=\"token operator\">?</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> suspend <span class=\"token keyword\">fun</span> <span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token operator\">..</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>我们看一下 <strong>Thread</strong> 的定义</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Thread</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Runnable</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">native</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isAlive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">void</span> <span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Deprecated</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">stop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>Thread 和 Job 的基本功能是一致的，他们都承载着一段代码逻辑，也都包含了这段代码的运行状态。</p>\n","site":{"data":{}},"excerpt":"<ul>\n<li>协程是一种非抢占式或者说是协作式的计算机程序并发调度的实现方案，程序可以主动挂起或者回复执行。</li>\n<li>线程当中的代码逻辑在线程抢占到 CPU 的时间片的时候才可以执行，否则就写着</li>\n<li>协程更轻量的意思是，协程并不会映射成内核线程或者其他资源，他的调用在用户态就可以搞定，任务之间是协作式，并非抢占式。</li>\n<li>协程的三要素：上下文、启动模式、协程体</li>\n<li><p>多个协程可以共用一个线程</p>\n</li>\n<li><p>协程的本质</p>\n<ul>\n<li>协程的挂起函数本质上就是一个回调，回调类型就是<code>Continuation</code></li>\n<li>协程体的执行就是一个<em>状态机</em>，每一次遇到挂起函数，都是一次状态转移</li>\n</ul>\n</li>\n</ul>","more":"<h2 id=\"通过-Retrofit-请求\"><a href=\"#通过-Retrofit-请求\" class=\"headerlink\" title=\"通过 Retrofit 请求\"></a>通过 Retrofit 请求</h2><p>通过 <code>Retrofit</code> 发送一个网络请求</p>\n<pre><code class=\"kotlin\">interface GitHubServiceApi {\n    @GET(&quot;users/{login}&quot;)\n    fun getUser(@Path(&quot;login&quot;) login:String):Call&lt;User&gt;\n}\n\ndata class User(val id:String, val name:String, val url:String)\n</code></pre>\n<p><code>Retrofit</code> 初始化如下</p>\n<pre><code class=\"kotlin\">val githubServiceApi by lazy {\n    val retorfit = retrofit2.Retrofit.Builder()\n        .baseUrl(&quot;https//api.github.com&quot;)\n        .addConverterFacetory(GsonConverterFactory.create())\n        .build()\n    retrofit.create(GitHUbServiceApi::class.java)\n}\n</code></pre>\n<p>发起网络请求</p>\n<pre><code class=\"kotlin\">githubServiceApi.getUser(&quot;small&quot;)\n.enqueue(object: Callback&lt;User&gt; {\n    override fun onFailure(call: Call&lt;User&gt;, t: Throwable) {\n        handler.post{showError(t)}\n    }\n\n    override fun onSuccess(call: Call&lt;User&gt;, response: Response&lt;User&gt;) {\n        handler.post{\n            response.body()?.let(::showUser) ?: showError(NullPointerException())\n        }\n    }\n})\n</code></pre>\n<h2 id=\"改造为携程\"><a href=\"#改造为携程\" class=\"headerlink\" title=\"改造为携程\"></a>改造为携程</h2><p>对于 <code>Retrofit</code> 改造为协程的方式有两种，分别通过 <code>CallAdapter</code> 和 <code>suspend</code> 函数</p>\n<h3 id=\"CallAdapter\"><a href=\"#CallAdapter\" class=\"headerlink\" title=\"CallAdapter\"></a>CallAdapter</h3><p>该方法的本质是让接口的方法返回一个协程的 <code>Job</code></p>\n<pre><code class=\"kotlin\">interface GitHubServiceApi {\n    @GET(&quot;users/{login}&quot;)\n    fun getUser(@Path(&quot;login&quot;)login:String):Deferred&lt;User&gt;\n}\n</code></pre>\n<blockquote>\n<p>Deferred 是 Job 的子接口</p>\n</blockquote>\n<p>同时需要为 <code>Retrofit</code> 添加对 <code>Deferred</code> 的支持</p>\n<pre><code class=\"groovy\">implementation &#39;com.jakewharton.retrofit:retrofit2-kotlin-coroutines-adapter:0.9.2&#39;\n</code></pre>\n<p>对构造 <code>Retorfit</code> 的实例添加</p>\n<pre><code class=\"kotlin\">val githubServiceApi by lazy {\n    val retorfit = retrofit2.Retrofit.Builder()\n        .baseUrl(&quot;https//api.github.com&quot;)\n        .addConverterFactory(GsonConverterFactory.create())\n        .addCallAdapterFactory(CoroutineCallAdapterFactroy())\n        .build()\n    retrofit.create(GitHubServiceApi::class.java)\n}\n</code></pre>\n<p>通过上面的修改，那么我们的请求就可以这样写</p>\n<pre><code class=\"kotlin\">GlobalScope.launch(Dispatchers.Main) {\n    try{\n        showUser(githubServiceApi.getUser(&quot;small&quot;).await())\n    } catch (e: Exception) {\n        shwoError(e)\n    }\n}\n</code></pre>\n<p><strong>Note:</strong>  我们首先通过 <code>launch</code> 启动了一个协程，这类似于我们启动一个线程，<code>launch</code> 的参数有三个: 协程上下文、协程启动模式、协程体</p>\n<pre><code class=\"kotlin\">public fun CorountineScope.launch(\n    context:CorountineContext = EmptyCouroutineContext,// 上下文\n    start: CoroutineStart = CoroutineStart.DEFGAULT, // 启动模式\n    block: suspend CorountineScope.() -&gt; UNit // 协程体\n) :Job\n</code></pre>\n<p><strong>启动模式</strong> 不是一个复杂的概念，默认直接俄允许调度执行</p>\n<p><strong>上下文</strong>可以有很多作用，包括<em>携带参数</em>、<em>拦截协程执行</em>等等，多数情况下我们不需要自己去实现上下文，只需要使用系统提供的就好。上下文有一个重要的作用就是切换线程，<code>Dispatchers.Main</code> 就是一个官方提供的上下文，它可以确保<code>launch</code> 启动的协程体运行在 UI 线程当中（除非你自己再 <code>launch</code> 的新和成提内部进行线程切换，或者启动运行再其他有线程切换能力的上下文的协程）</p>\n<p>换句话说，在例子当中的整个 <code>launch</code> 内部，你看到的代码都是运行在UI线程中的，尽管 <code>getUser</code> 在执行的时候确实切换了线程，但返回结果的时候会再次切回来。直觉告诉我们 <code>getUser</code> 返回了要给 <code>Deferred</code> 类型，他的 <code>await</code> 方法会返回一个 <code>User</code> 对象，意味着 <code>await</code> 需要等待请求结果返回才可以继续执行，那么<code>await</code> 不会阻塞 UI 线程嘛？</p>\n<p>当然不会。不然 <code>Deferred</code> 于 <code>Future</code>  又有上面区别的，这里<code>await</code>  很可疑。因为实际上是要给 <code>suspend</code> 函数。整个函数只能在协程体或者其他 <code>suspend</code> 函数内部被调用，就像是回调的语法糖一样，通过一个叫 <code>Continuation</code> 的接口来实现返回结果<code></code></p>\n<pre><code class=\"kotlin\">@SinceKotlin(&quot;1.3&quot;)\npublic interface Continuation&lt;in T&gt; {\n    public val context:CoroutineContext\n    public fun resumeWith(result:Result&lt;T&gt;)\n}\n\n@SinceKotlin(&quot;1.1&quot;)\npublic interface Continuation&lt;in T&gt; {\n    public val context:CorouineContext\n    public fun resume(value: T)\n    public fun resumeWithException(exception: Throwable)\n}\n\n</code></pre>\n<p>其实就是要给回调，有结果正常返回， <code>Continuation</code> 调用 <code>resume</code> 返回结果，否则调用 <code>resumeWithException</code> 来抛出异常。</p>\n<p>因此，请求的代码执行流程本质上是一个异步回调</p>\n<p>而之所以可以看起来是同步的，那就是编译器的黑魔法了</p>\n<p>在虚拟机上 <code>await</code> 函数的真实样子是这样的</p>\n<pre><code>kotlin/coroutines/Deferred.await (Lkotlin/coroutines/Cotinuation;) LJava/lang/Object\n</code></pre><p>即接收一个 <code>Continuation</code> 实例，返回 <code>Object</code> 这么一个函数，所以前面的代码可以理解为</p>\n<pre><code class=\"kotlin\">// 不是正确代码，仅用来理解协程使用\nGlobalScope.launch(Dispathcers.Main) {\n    githubServiceApi.getUser(&quot;small&quot;).await(object: Continuation&lt;User&gt;{\n        override fun resume(value: User) {\n            showUser(value)\n        }\n\n        override fun resumeWithException(exception: Throwable) {\n            showError(exception)\n        }\n    })\n}\n</code></pre>\n<p>在 <code>await</code> 当中大致就是：</p>\n<pre><code class=\"kotlin\">// 不是正确代码，仅用来理解协程使用\nfun awiat(continuation:Continuation&lt;user&gt;):Any{\n    ...// 切到非 UI 线程中执行，等待结果返回\n    try {\n        val user = ....// 这里执行任务\n        handler.post {\n            continuation.resume(user)\n        }\n    } catch(e: Exception) {\n        handler.post{continuation.resumeWithException(e)}\n    }\n}\n</code></pre>\n<blockquote>\n<p>从运行机制上来讲，协程和回调没有本质的区别</p>\n</blockquote>\n<h3 id=\"suspend-方式\"><a href=\"#suspend-方式\" class=\"headerlink\" title=\"suspend  方式\"></a>suspend  方式</h3><p><code>suspend</code> 函数是 Kotlin 编译器对协程支持的黑魔法，还是先看如何在Retrofit 中如何使用</p>\n<blockquote>\n<p>Retrofit 在 release 2.5.0 之后才会支持 suspend 函数</p>\n</blockquote>\n<p>首先修改一下接口方法</p>\n<pre><code class=\"kotlin\">@GET(&quot;users/{login}&quot;)\nsuspend fun getUser(@Path(&quot;login&quot;)login:String): User\n</code></pre>\n<p>这种情况下， <code>Retrofit</code> 会根据接口方法的生命来构造<code>Continuation</code> ，并且在内部封装了一个 <code>Call</code> 的异步请求(使用 <code>enqueue</code>) ，进而得到 User 实例。</p>\n<pre><code class=\"kotlin\">GlobalScope.launch {\n    try {\n        showUser(githubServiceApi.getUser(&quot;small&quot;))\n    } catch (e: Exception) {\n        showError(e)\n    }\n}\n</code></pre>\n<h2 id=\"协程到底是什么\"><a href=\"#协程到底是什么\" class=\"headerlink\" title=\"协程到底是什么\"></a>协程到底是什么</h2><p>以前我们使用 Java 进行开发的时候，经常会遇到 <em>回调地域</em> ，使得代码的可读性急剧降低；也通过大量复杂的异步调用处理逻辑、异常；因为回调的存在，还得经常处理线程切换。随着代码体量的增加，各种问题频频爆发。</p>\n<p>而 <strong>协程</strong> 可以帮我们优雅的处理掉这些</p>\n<p>协程本身是一个脱离语言实现的概念。简单来说就是：</p>\n<p>协程是一种非抢占式或者说协作式的计算机程序并发调度的实现，程序可以主动挂起或者恢复执行。经常听到的所谓的协程更轻量的意思是，协程并不会映射成内核线程或者其他重的资源，它的调度在用户态就可以搞定，任务之间的调度并非抢占式，而是协作式。</p>\n<h3 id=\"Job\"><a href=\"#Job\" class=\"headerlink\" title=\"Job\"></a>Job</h3><pre><code class=\"kotlin\">public interface Job: CoroutineContext.Element {\n    ...\n    public val isActive: Boolean\n    public val isCompleted: Boolean\n    public val isCancelled: Boolean\n\n    public fun start():Boolean\n    public fun cancel(cause: CancellationException? = null)\n    public suspend fun join()\n    ...\n}\n</code></pre>\n<p>我们看一下 <strong>Thread</strong> 的定义</p>\n<pre><code class=\"java\">public class Thread implements Runnable {\n    ...\n    public final native boolean isAlive();\n    public synchronized void start(){}\n\n    @Deprecated\n    public final void stop(){}\n    public final void join() throws InterruptedException{}\n}\n</code></pre>\n<p>Thread 和 Job 的基本功能是一致的，他们都承载着一段代码逻辑，也都包含了这段代码的运行状态。</p>"},{"title":"协程取消","_content":"\n> 协程的任务取消需要协程内部调用的协作支持，类似于线程中断中对中断状态的响应一样\n\n## 线程的中断\n\n当我们执行一个任务时,很快就后悔了,怎么办?\n<!-- more-->\n```kotlin\nval thread = thread {\n    try {\n        Thread.sleep(1000)\n    } catch(e :Exception) {\n        log(\"interrupted, do cleaning stuff\")\n    }\n}\nthread.interrupt()\n```\n\n当线程被标记为中断状态,就会抛出 `InterruptedException` ,我们可以进行捕获做资源清理.\n\n所以,所谓的协作式任务种植,协程的取消也是`cancel`机制的设计思路.\n\n## 协程的取消\n\n```kotlin\nfun main()= runBlocking {\n    val job1 = launch{\n        log(1)\n        delay(1000)\n        log(2)\n    }\n    \n    delay(100)\n    log(3)\n    job1.cancel()\n    log(4)\n}\n```\n\n`delay` 与线程中的 `sleep ` 不同,它不会阻塞线程,可以认为它实际上就是触发了一个延时任务,告诉协程调度系统 1000ms  后再来执行后面的代码;而再这期间,我们对刚刚启动的协程进行了取消,因此 `delay` 还没有回调的时候,协程就被取消了,因为 `delay` 可以影响取消,因此 `delay` 后面的代码就不会再次调度,直接抛出一个 `CancellationException`\n\n**完善前面的一个例子**\n\n```kotlin\nsuspend fun getUserCoroutine() = suspendCoroutine<User> {continuation -> \n\tgetUser(object: Callback<User>{\n        override fun onSuccess(value: String) {\n            continuation.resume(value)\n        }\n        \n        override fun onFailed(e:Throwable) {\n            continuation.resumeWithException(e)\n        }\n    })\n}\n```\n\n加上取消逻辑\n\n```kotlin\nsuspend fun getUserCoroutine() = suspendCancellableCoroutine<User> { continuation-> \n\tval call = OkHttpClient().newCall(...)\n    continuation.invokeOnCancellation{\n\t\tlog()\n         call.cancel()\n\t}\n \tcall.enqueue(object : okhttp3.Callback{\n        override fun onFailure(call: Call, e: Exception) {\n            log(\"onFailure: $e\")\n            continuation.resumeWithException(e)\n        }\n        \n        override fun onResponse(call: Call, response: Response) {\n            log(\"onResponse: ${response.code()}\")\n            response.body()?.let {\n                try {\n                    continuation.resume(User.from(it.string()))\n                } catch(e: Exception) {\n                    continuation.resumeWithException(e)\n                }\n            } ?: continuation.resumeWithException(NullPointerException(\"ResponseBody is null\"))\n        }\n    })\n}\n```\n\n`suspendCancellableCoroutine`  是为了让我们的挂起函数支持协程的取消.该方法将获取到的`Continuation` 包装成了一个`CacncellableContinuation` 通过调用 `invokeOnCancellation` 方法可以设置一个取消时间的回调,一旦被调用,意味着 `getUserCoroutine` 调用所在的协程将被取消,我们也应该相应的做出取消操作.\n\n```kotlin\nval job1 = launch {\n    log(1)\n    val user = getUserCoroutine()\n    log(user)\n    log(2)\n}\n\ndelayt(10)\nlog(3)\njob1.cancel()\nlog(4)\n```\n\n```tex\n1\n3\ninvokeOnCancellation: cancel the request.\n4\nonFilure: java.io.IOException: Canceled\n```\n\n取消的回调被调用了, OkHttp 在收到我们的取消指令之后,也确实停止了网络请求,并且给我们一个 IO 异常.此时,我们的协程已经取消,在处于取消状态的携程上调用`continuation.resume` `continuation.resumeWithException` `continuation.resumtWith`  都会被忽略,因此 OkHttp 回调中我们收到 IO 异常后,调用的 `continuation.resumeWithException(e)`  不会有任何副作用.\n\n","source":"_posts/Kotlin/协程/协程-取消.md","raw":"---\ntitle: 协程取消\ntag: Kotlin\n---\n\n> 协程的任务取消需要协程内部调用的协作支持，类似于线程中断中对中断状态的响应一样\n\n## 线程的中断\n\n当我们执行一个任务时,很快就后悔了,怎么办?\n<!-- more-->\n```kotlin\nval thread = thread {\n    try {\n        Thread.sleep(1000)\n    } catch(e :Exception) {\n        log(\"interrupted, do cleaning stuff\")\n    }\n}\nthread.interrupt()\n```\n\n当线程被标记为中断状态,就会抛出 `InterruptedException` ,我们可以进行捕获做资源清理.\n\n所以,所谓的协作式任务种植,协程的取消也是`cancel`机制的设计思路.\n\n## 协程的取消\n\n```kotlin\nfun main()= runBlocking {\n    val job1 = launch{\n        log(1)\n        delay(1000)\n        log(2)\n    }\n    \n    delay(100)\n    log(3)\n    job1.cancel()\n    log(4)\n}\n```\n\n`delay` 与线程中的 `sleep ` 不同,它不会阻塞线程,可以认为它实际上就是触发了一个延时任务,告诉协程调度系统 1000ms  后再来执行后面的代码;而再这期间,我们对刚刚启动的协程进行了取消,因此 `delay` 还没有回调的时候,协程就被取消了,因为 `delay` 可以影响取消,因此 `delay` 后面的代码就不会再次调度,直接抛出一个 `CancellationException`\n\n**完善前面的一个例子**\n\n```kotlin\nsuspend fun getUserCoroutine() = suspendCoroutine<User> {continuation -> \n\tgetUser(object: Callback<User>{\n        override fun onSuccess(value: String) {\n            continuation.resume(value)\n        }\n        \n        override fun onFailed(e:Throwable) {\n            continuation.resumeWithException(e)\n        }\n    })\n}\n```\n\n加上取消逻辑\n\n```kotlin\nsuspend fun getUserCoroutine() = suspendCancellableCoroutine<User> { continuation-> \n\tval call = OkHttpClient().newCall(...)\n    continuation.invokeOnCancellation{\n\t\tlog()\n         call.cancel()\n\t}\n \tcall.enqueue(object : okhttp3.Callback{\n        override fun onFailure(call: Call, e: Exception) {\n            log(\"onFailure: $e\")\n            continuation.resumeWithException(e)\n        }\n        \n        override fun onResponse(call: Call, response: Response) {\n            log(\"onResponse: ${response.code()}\")\n            response.body()?.let {\n                try {\n                    continuation.resume(User.from(it.string()))\n                } catch(e: Exception) {\n                    continuation.resumeWithException(e)\n                }\n            } ?: continuation.resumeWithException(NullPointerException(\"ResponseBody is null\"))\n        }\n    })\n}\n```\n\n`suspendCancellableCoroutine`  是为了让我们的挂起函数支持协程的取消.该方法将获取到的`Continuation` 包装成了一个`CacncellableContinuation` 通过调用 `invokeOnCancellation` 方法可以设置一个取消时间的回调,一旦被调用,意味着 `getUserCoroutine` 调用所在的协程将被取消,我们也应该相应的做出取消操作.\n\n```kotlin\nval job1 = launch {\n    log(1)\n    val user = getUserCoroutine()\n    log(user)\n    log(2)\n}\n\ndelayt(10)\nlog(3)\njob1.cancel()\nlog(4)\n```\n\n```tex\n1\n3\ninvokeOnCancellation: cancel the request.\n4\nonFilure: java.io.IOException: Canceled\n```\n\n取消的回调被调用了, OkHttp 在收到我们的取消指令之后,也确实停止了网络请求,并且给我们一个 IO 异常.此时,我们的协程已经取消,在处于取消状态的携程上调用`continuation.resume` `continuation.resumeWithException` `continuation.resumtWith`  都会被忽略,因此 OkHttp 回调中我们收到 IO 异常后,调用的 `continuation.resumeWithException(e)`  不会有任何副作用.\n\n","slug":"Kotlin/协程/协程-取消","published":1,"date":"2021-01-29T15:54:28.316Z","updated":"2021-01-29T16:16:13.323Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8l5003qsz5qgovs8qje","content":"<blockquote>\n<p>协程的任务取消需要协程内部调用的协作支持，类似于线程中断中对中断状态的响应一样</p>\n</blockquote>\n<h2 id=\"线程的中断\"><a href=\"#线程的中断\" class=\"headerlink\" title=\"线程的中断\"></a>线程的中断</h2><p>当我们执行一个任务时,很快就后悔了,怎么办?<br><a id=\"more\"></a></p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> thread <span class=\"token operator\">=</span> thread <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        Thread<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">:</span>Exception<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"interrupted, do cleaning stuff\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\nthread<span class=\"token punctuation\">.</span><span class=\"token function\">interrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>当线程被标记为中断状态,就会抛出 <code>InterruptedException</code> ,我们可以进行捕获做资源清理.</p>\n<p>所以,所谓的协作式任务种植,协程的取消也是<code>cancel</code>机制的设计思路.</p>\n<h2 id=\"协程的取消\"><a href=\"#协程的取消\" class=\"headerlink\" title=\"协程的取消\"></a>协程的取消</h2><pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=</span> runBlocking <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> job1 <span class=\"token operator\">=</span> launch<span class=\"token punctuation\">{</span>\n        <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n    job1<span class=\"token punctuation\">.</span><span class=\"token function\">cancel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><code>delay</code> 与线程中的 <code>sleep</code> 不同,它不会阻塞线程,可以认为它实际上就是触发了一个延时任务,告诉协程调度系统 1000ms  后再来执行后面的代码;而再这期间,我们对刚刚启动的协程进行了取消,因此 <code>delay</code> 还没有回调的时候,协程就被取消了,因为 <code>delay</code> 可以影响取消,因此 <code>delay</code> 后面的代码就不会再次调度,直接抛出一个 <code>CancellationException</code></p>\n<p><strong>完善前面的一个例子</strong></p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\">suspend <span class=\"token keyword\">fun</span> <span class=\"token function\">getUserCoroutine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> suspendCoroutine<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>continuation <span class=\"token operator\">-></span> \n    <span class=\"token function\">getUser</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">object</span><span class=\"token operator\">:</span> Callback<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">onSuccess</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> String<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            continuation<span class=\"token punctuation\">.</span><span class=\"token function\">resume</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">onFailed</span><span class=\"token punctuation\">(</span>e<span class=\"token operator\">:</span>Throwable<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            continuation<span class=\"token punctuation\">.</span><span class=\"token function\">resumeWithException</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>加上取消逻辑</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\">suspend <span class=\"token keyword\">fun</span> <span class=\"token function\">getUserCoroutine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> suspendCancellableCoroutine<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> continuation<span class=\"token operator\">-></span> \n    <span class=\"token keyword\">val</span> call <span class=\"token operator\">=</span> <span class=\"token function\">OkHttpClient</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">newCall</span><span class=\"token punctuation\">(</span><span class=\"token operator\">..</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span>\n    continuation<span class=\"token punctuation\">.</span><span class=\"token function\">invokeOnCancellation</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n         call<span class=\"token punctuation\">.</span><span class=\"token function\">cancel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n     call<span class=\"token punctuation\">.</span><span class=\"token function\">enqueue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">object</span> <span class=\"token operator\">:</span> okhttp3<span class=\"token punctuation\">.</span><span class=\"token function\">Callback</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">onFailure</span><span class=\"token punctuation\">(</span>call<span class=\"token operator\">:</span> Call<span class=\"token punctuation\">,</span> e<span class=\"token operator\">:</span> Exception<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"onFailure: <span class=\"token interpolation variable\">$e</span>\"</span><span class=\"token punctuation\">)</span>\n            continuation<span class=\"token punctuation\">.</span><span class=\"token function\">resumeWithException</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">onResponse</span><span class=\"token punctuation\">(</span>call<span class=\"token operator\">:</span> Call<span class=\"token punctuation\">,</span> response<span class=\"token operator\">:</span> Response<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"onResponse: <span class=\"token interpolation\"><span class=\"token delimiter variable\">${</span>response<span class=\"token punctuation\">.</span><span class=\"token function\">code</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token delimiter variable\">}</span></span>\"</span><span class=\"token punctuation\">)</span>\n            response<span class=\"token punctuation\">.</span><span class=\"token function\">body</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">let</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                    continuation<span class=\"token punctuation\">.</span><span class=\"token function\">resume</span><span class=\"token punctuation\">(</span>User<span class=\"token punctuation\">.</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span>it<span class=\"token punctuation\">.</span><span class=\"token function\">string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>e<span class=\"token operator\">:</span> Exception<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    continuation<span class=\"token punctuation\">.</span><span class=\"token function\">resumeWithException</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token operator\">?:</span> continuation<span class=\"token punctuation\">.</span><span class=\"token function\">resumeWithException</span><span class=\"token punctuation\">(</span><span class=\"token function\">NullPointerException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ResponseBody is null\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><code>suspendCancellableCoroutine</code>  是为了让我们的挂起函数支持协程的取消.该方法将获取到的<code>Continuation</code> 包装成了一个<code>CacncellableContinuation</code> 通过调用 <code>invokeOnCancellation</code> 方法可以设置一个取消时间的回调,一旦被调用,意味着 <code>getUserCoroutine</code> 调用所在的协程将被取消,我们也应该相应的做出取消操作.</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> job1 <span class=\"token operator\">=</span> launch <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">val</span> user <span class=\"token operator\">=</span> <span class=\"token function\">getUserCoroutine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">log</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">delayt</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\njob1<span class=\"token punctuation\">.</span><span class=\"token function\">cancel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<pre class=\" language-tex\"><code class=\"language-tex\">1\n3\ninvokeOnCancellation: cancel the request.\n4\nonFilure: java.io.IOException: Canceled\n</code></pre>\n<p>取消的回调被调用了, OkHttp 在收到我们的取消指令之后,也确实停止了网络请求,并且给我们一个 IO 异常.此时,我们的协程已经取消,在处于取消状态的携程上调用<code>continuation.resume</code> <code>continuation.resumeWithException</code> <code>continuation.resumtWith</code>  都会被忽略,因此 OkHttp 回调中我们收到 IO 异常后,调用的 <code>continuation.resumeWithException(e)</code>  不会有任何副作用.</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>协程的任务取消需要协程内部调用的协作支持，类似于线程中断中对中断状态的响应一样</p>\n</blockquote>\n<h2 id=\"线程的中断\"><a href=\"#线程的中断\" class=\"headerlink\" title=\"线程的中断\"></a>线程的中断</h2><p>当我们执行一个任务时,很快就后悔了,怎么办?<br>","more":"</p>\n<pre><code class=\"kotlin\">val thread = thread {\n    try {\n        Thread.sleep(1000)\n    } catch(e :Exception) {\n        log(&quot;interrupted, do cleaning stuff&quot;)\n    }\n}\nthread.interrupt()\n</code></pre>\n<p>当线程被标记为中断状态,就会抛出 <code>InterruptedException</code> ,我们可以进行捕获做资源清理.</p>\n<p>所以,所谓的协作式任务种植,协程的取消也是<code>cancel</code>机制的设计思路.</p>\n<h2 id=\"协程的取消\"><a href=\"#协程的取消\" class=\"headerlink\" title=\"协程的取消\"></a>协程的取消</h2><pre><code class=\"kotlin\">fun main()= runBlocking {\n    val job1 = launch{\n        log(1)\n        delay(1000)\n        log(2)\n    }\n\n    delay(100)\n    log(3)\n    job1.cancel()\n    log(4)\n}\n</code></pre>\n<p><code>delay</code> 与线程中的 <code>sleep</code> 不同,它不会阻塞线程,可以认为它实际上就是触发了一个延时任务,告诉协程调度系统 1000ms  后再来执行后面的代码;而再这期间,我们对刚刚启动的协程进行了取消,因此 <code>delay</code> 还没有回调的时候,协程就被取消了,因为 <code>delay</code> 可以影响取消,因此 <code>delay</code> 后面的代码就不会再次调度,直接抛出一个 <code>CancellationException</code></p>\n<p><strong>完善前面的一个例子</strong></p>\n<pre><code class=\"kotlin\">suspend fun getUserCoroutine() = suspendCoroutine&lt;User&gt; {continuation -&gt; \n    getUser(object: Callback&lt;User&gt;{\n        override fun onSuccess(value: String) {\n            continuation.resume(value)\n        }\n\n        override fun onFailed(e:Throwable) {\n            continuation.resumeWithException(e)\n        }\n    })\n}\n</code></pre>\n<p>加上取消逻辑</p>\n<pre><code class=\"kotlin\">suspend fun getUserCoroutine() = suspendCancellableCoroutine&lt;User&gt; { continuation-&gt; \n    val call = OkHttpClient().newCall(...)\n    continuation.invokeOnCancellation{\n        log()\n         call.cancel()\n    }\n     call.enqueue(object : okhttp3.Callback{\n        override fun onFailure(call: Call, e: Exception) {\n            log(&quot;onFailure: $e&quot;)\n            continuation.resumeWithException(e)\n        }\n\n        override fun onResponse(call: Call, response: Response) {\n            log(&quot;onResponse: ${response.code()}&quot;)\n            response.body()?.let {\n                try {\n                    continuation.resume(User.from(it.string()))\n                } catch(e: Exception) {\n                    continuation.resumeWithException(e)\n                }\n            } ?: continuation.resumeWithException(NullPointerException(&quot;ResponseBody is null&quot;))\n        }\n    })\n}\n</code></pre>\n<p><code>suspendCancellableCoroutine</code>  是为了让我们的挂起函数支持协程的取消.该方法将获取到的<code>Continuation</code> 包装成了一个<code>CacncellableContinuation</code> 通过调用 <code>invokeOnCancellation</code> 方法可以设置一个取消时间的回调,一旦被调用,意味着 <code>getUserCoroutine</code> 调用所在的协程将被取消,我们也应该相应的做出取消操作.</p>\n<pre><code class=\"kotlin\">val job1 = launch {\n    log(1)\n    val user = getUserCoroutine()\n    log(user)\n    log(2)\n}\n\ndelayt(10)\nlog(3)\njob1.cancel()\nlog(4)\n</code></pre>\n<pre><code class=\"tex\">1\n3\ninvokeOnCancellation: cancel the request.\n4\nonFilure: java.io.IOException: Canceled\n</code></pre>\n<p>取消的回调被调用了, OkHttp 在收到我们的取消指令之后,也确实停止了网络请求,并且给我们一个 IO 异常.此时,我们的协程已经取消,在处于取消状态的携程上调用<code>continuation.resume</code> <code>continuation.resumeWithException</code> <code>continuation.resumtWith</code>  都会被忽略,因此 OkHttp 回调中我们收到 IO 异常后,调用的 <code>continuation.resumeWithException(e)</code>  不会有任何副作用.</p>"},{"title":"协程启动","_content":"\n# 协程-启动\n\n**启动模式**\n\n1. DEFAULT： 立即执行\n2. LAZY： 需要时执行\n3. ATOMIC： 立即执行，但开始前不会被取消\n4. UNDISPATCHED： 立即执行，直到第一个 suspend 挂起\n\n<!-- more-->\n\n## Thread\n\n```kotlin\nval thread = object : Thread() {\n    override fun run(){\n        super.run()\n        //do something\n    }\n}\nthread.start()\n```\n\n上面是线程的启动方法，通常还会忘记去写 `start()` ，那再 kotlin 中\n\n```kotlin\nval myThread = thread(start = true) {\n    //do you wang\n}\n```\n\n`start()` 方法是默认被开启自动会执行的，为我们省去了很多麻煩\n\n## 协程启动\n\n```kotlin\nGlobalScope.launch {\n    // do you want\n}\n```\n\n## 启动模式\n\n```kotlin\npublic enum class CoroutineStart {\n    DEFAULT,\n    LAZY,\n    @ExperimentalCoroutinesApi\n    ATOMIC，\n    @ExperimentalCoroutinesApi\n    UNDISPATCHED；\n}\n```\n\n| 模式         | 功能                                              |\n| ------------ | ------------------------------------------------- |\n| DEFAULT      | 立即执行协程体                                    |\n| ATOMIC       | 立即执行协程体，但在开始运行之前无法取消          |\n| UNDISPATCHED | 立即在当前线程执行协程体，直到第一个 suspend 调用 |\n| LAZY         | 只有在需要的情况下运行                            |\n\n### DEFAULT\n\n四种启动模式中，常用的其实是`DEFAULT` 和 `LAZY`\n\n`DEFAULT` 是饿汉式启动，`launch` 调用后，会立即进入叼住状态，一旦调度器 OK 就可以开始执行。\n\n```KOTLIN\nsuspend fun main() {\n    log(1)\n    val job = GlobalScope.launch{\n        log(2)\n    }\n    log(3)\n    job.join()\n    log(4)\n}\n```\n\n采用默认的启动模式，由于没有指定调度器，因此调度器也是默认的，在 JVM 上，默认调度器的实现和其他语言的是离线类似，它在后台专门会有一个线程处理异步任务，上述程序的结果可能是\n\n```tex\n[main] 1\n[main] 3\n[DefaultDispatcher-worker-1] 2\n[main] 4\n```\n\n它取决于 CPU 对于当前线程和后台线程的调度顺序\n\n### LAZY\n\n`LAZY` 是懒汉式启动，`launch` 后，并不会有任何调度行为，协程体也自然不会进入执行状态，直到我们需要它执行的时候。`launch` 后会返回一个 `job` 实例，因此我们可以通过 `job` 来实现\n\n* 调用 `Job.start()` 主动触发协程的调度\n* 调用 `Job.join()` 隐式的触发协程的调度\n\n```kotlin\nlog(1)\nval job = GlobalScope.launch(start = CoroutineStart.LAZY) {\n    log(2)\n}\nlog(3)\njob.start()\nlog(4)\n```\n\n其输出结果可能为\n\n```tex\n[main] 1\n[main] 3\n[main] 4\n[DefaultDispatcher-worker-1] 2\n```\n\n运气好话，2 也可能在 4  的前面，而对于 `join()`\n\n```kotlin\nlog(1)\nval job = GlobalScope.launch(start = CoroutineStart.LAZY) {\n    log(2)\n}\nlog(3)\njob.join()\nlog(4)\n```\n\n因为要等待协程执行完毕，因此数据结果一定是\n\n```tex\n[main] 1\n[main] 3\n[DefaultDispatcher-worker-1] 2\n[main] 4\n```\n\n### ATOMIC\n\n`ATOMIC` 只有涉及到 `cancel` 的时候才有意义， `cancel` 本身也是有一个值得讨论的话题，取消后，不会再被执行。在调用 `cancel` 的时机不同，结果也有差异的，例如在调度之前、开始调度但尚未执行、已经开始执行、执行完毕等等\n\n```kotlin\nlog(1)\nval job = GlobalScope.launch(start = CoroutineStart.ATOMIC) {\n    log(2)\n}\njob.cancel()\nlog(3)\n```\n\n我们创建写成后立即 `cancel` 但由于 `ATOMIC` 模式，因此协程一定会被调度，因此 1,2,3一定会输出，只是 2 和 3 的顺序难说\n\n对应的，如果是 `DEFAULT` 模式，在第一次调度该协程时，如果 `cancel` 就已经调用，那么协程就会被直接 `cancel` 而不会有任何调度。\n\n> 需要注意， `cancel` 调用一定会将 job 的状态设置为 cancelling, 只不过 `ATOMIC` 模式的协程在启动时无视了这一状态。\n\n```kotlin\nlog(1)\nval job = GlobalScope.launch(start = CoroutineStart.ATOMIC) {\n    log(2)\n    delay(1000)\n    log(3)\n}\njob.cancel()\nlog(4)\njob.join()\n```\n\n2 和 3 之间加了一个 `delay` ，`delay` 会使得协程体的执行被挂起， 1s 之后再次调度后面的部分，因此 3 会在 2 执行之后1 s 输出，。对于 `ATOMIC` 模式，它的协程体一定会被启动，实际上在遇到第一个挂起点之前，它的执行是不会停止的，而 `delay` 是一个 `suspend` 函数，此时程序迎来了第一个挂起点，恰好 `delay` 是支持 `cancel` 的，因此后面的 3 将不会打印。\n\n#### UNDISPATCHED\n\n协程在这种模式下会直接开始在当前线程下执行，直到第一个挂起点，这一点和 `ATOMIC` 很像，不同在于 `DISPATCHED` 不经过任何调度器即开始执行协程体。当遇到挂起点之后的执行就取决于挂起点本身的逻辑以及上下文中的调度器\n\n```kotlin\nlog(1)\nval job = GlobalScope.launch(start = CoroutineStart.UNDISPATCHED) {\n    log(2)\n    delay(1000)\n    log(3)\n}\nlog(4)\njob.join()\nlog(5)\n```\n\n","source":"_posts/Kotlin/协程/协程-启动.md","raw":"---\ntitle: 协程启动\ntag: Kotlin\n---\n\n# 协程-启动\n\n**启动模式**\n\n1. DEFAULT： 立即执行\n2. LAZY： 需要时执行\n3. ATOMIC： 立即执行，但开始前不会被取消\n4. UNDISPATCHED： 立即执行，直到第一个 suspend 挂起\n\n<!-- more-->\n\n## Thread\n\n```kotlin\nval thread = object : Thread() {\n    override fun run(){\n        super.run()\n        //do something\n    }\n}\nthread.start()\n```\n\n上面是线程的启动方法，通常还会忘记去写 `start()` ，那再 kotlin 中\n\n```kotlin\nval myThread = thread(start = true) {\n    //do you wang\n}\n```\n\n`start()` 方法是默认被开启自动会执行的，为我们省去了很多麻煩\n\n## 协程启动\n\n```kotlin\nGlobalScope.launch {\n    // do you want\n}\n```\n\n## 启动模式\n\n```kotlin\npublic enum class CoroutineStart {\n    DEFAULT,\n    LAZY,\n    @ExperimentalCoroutinesApi\n    ATOMIC，\n    @ExperimentalCoroutinesApi\n    UNDISPATCHED；\n}\n```\n\n| 模式         | 功能                                              |\n| ------------ | ------------------------------------------------- |\n| DEFAULT      | 立即执行协程体                                    |\n| ATOMIC       | 立即执行协程体，但在开始运行之前无法取消          |\n| UNDISPATCHED | 立即在当前线程执行协程体，直到第一个 suspend 调用 |\n| LAZY         | 只有在需要的情况下运行                            |\n\n### DEFAULT\n\n四种启动模式中，常用的其实是`DEFAULT` 和 `LAZY`\n\n`DEFAULT` 是饿汉式启动，`launch` 调用后，会立即进入叼住状态，一旦调度器 OK 就可以开始执行。\n\n```KOTLIN\nsuspend fun main() {\n    log(1)\n    val job = GlobalScope.launch{\n        log(2)\n    }\n    log(3)\n    job.join()\n    log(4)\n}\n```\n\n采用默认的启动模式，由于没有指定调度器，因此调度器也是默认的，在 JVM 上，默认调度器的实现和其他语言的是离线类似，它在后台专门会有一个线程处理异步任务，上述程序的结果可能是\n\n```tex\n[main] 1\n[main] 3\n[DefaultDispatcher-worker-1] 2\n[main] 4\n```\n\n它取决于 CPU 对于当前线程和后台线程的调度顺序\n\n### LAZY\n\n`LAZY` 是懒汉式启动，`launch` 后，并不会有任何调度行为，协程体也自然不会进入执行状态，直到我们需要它执行的时候。`launch` 后会返回一个 `job` 实例，因此我们可以通过 `job` 来实现\n\n* 调用 `Job.start()` 主动触发协程的调度\n* 调用 `Job.join()` 隐式的触发协程的调度\n\n```kotlin\nlog(1)\nval job = GlobalScope.launch(start = CoroutineStart.LAZY) {\n    log(2)\n}\nlog(3)\njob.start()\nlog(4)\n```\n\n其输出结果可能为\n\n```tex\n[main] 1\n[main] 3\n[main] 4\n[DefaultDispatcher-worker-1] 2\n```\n\n运气好话，2 也可能在 4  的前面，而对于 `join()`\n\n```kotlin\nlog(1)\nval job = GlobalScope.launch(start = CoroutineStart.LAZY) {\n    log(2)\n}\nlog(3)\njob.join()\nlog(4)\n```\n\n因为要等待协程执行完毕，因此数据结果一定是\n\n```tex\n[main] 1\n[main] 3\n[DefaultDispatcher-worker-1] 2\n[main] 4\n```\n\n### ATOMIC\n\n`ATOMIC` 只有涉及到 `cancel` 的时候才有意义， `cancel` 本身也是有一个值得讨论的话题，取消后，不会再被执行。在调用 `cancel` 的时机不同，结果也有差异的，例如在调度之前、开始调度但尚未执行、已经开始执行、执行完毕等等\n\n```kotlin\nlog(1)\nval job = GlobalScope.launch(start = CoroutineStart.ATOMIC) {\n    log(2)\n}\njob.cancel()\nlog(3)\n```\n\n我们创建写成后立即 `cancel` 但由于 `ATOMIC` 模式，因此协程一定会被调度，因此 1,2,3一定会输出，只是 2 和 3 的顺序难说\n\n对应的，如果是 `DEFAULT` 模式，在第一次调度该协程时，如果 `cancel` 就已经调用，那么协程就会被直接 `cancel` 而不会有任何调度。\n\n> 需要注意， `cancel` 调用一定会将 job 的状态设置为 cancelling, 只不过 `ATOMIC` 模式的协程在启动时无视了这一状态。\n\n```kotlin\nlog(1)\nval job = GlobalScope.launch(start = CoroutineStart.ATOMIC) {\n    log(2)\n    delay(1000)\n    log(3)\n}\njob.cancel()\nlog(4)\njob.join()\n```\n\n2 和 3 之间加了一个 `delay` ，`delay` 会使得协程体的执行被挂起， 1s 之后再次调度后面的部分，因此 3 会在 2 执行之后1 s 输出，。对于 `ATOMIC` 模式，它的协程体一定会被启动，实际上在遇到第一个挂起点之前，它的执行是不会停止的，而 `delay` 是一个 `suspend` 函数，此时程序迎来了第一个挂起点，恰好 `delay` 是支持 `cancel` 的，因此后面的 3 将不会打印。\n\n#### UNDISPATCHED\n\n协程在这种模式下会直接开始在当前线程下执行，直到第一个挂起点，这一点和 `ATOMIC` 很像，不同在于 `DISPATCHED` 不经过任何调度器即开始执行协程体。当遇到挂起点之后的执行就取决于挂起点本身的逻辑以及上下文中的调度器\n\n```kotlin\nlog(1)\nval job = GlobalScope.launch(start = CoroutineStart.UNDISPATCHED) {\n    log(2)\n    delay(1000)\n    log(3)\n}\nlog(4)\njob.join()\nlog(5)\n```\n\n","slug":"Kotlin/协程/协程-启动","published":1,"date":"2021-01-29T15:54:28.317Z","updated":"2021-01-29T16:16:09.837Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8l7003tsz5qsk8mkiiv","content":"<h1 id=\"协程-启动\"><a href=\"#协程-启动\" class=\"headerlink\" title=\"协程-启动\"></a>协程-启动</h1><p><strong>启动模式</strong></p>\n<ol>\n<li>DEFAULT： 立即执行</li>\n<li>LAZY： 需要时执行</li>\n<li>ATOMIC： 立即执行，但开始前不会被取消</li>\n<li>UNDISPATCHED： 立即执行，直到第一个 suspend 挂起</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"Thread\"><a href=\"#Thread\" class=\"headerlink\" title=\"Thread\"></a>Thread</h2><pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> thread <span class=\"token operator\">=</span> <span class=\"token keyword\">object</span> <span class=\"token operator\">:</span> <span class=\"token function\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\" spellcheck=\"true\">//do something</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\nthread<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>上面是线程的启动方法，通常还会忘记去写 <code>start()</code> ，那再 kotlin 中</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> myThread <span class=\"token operator\">=</span> <span class=\"token function\">thread</span><span class=\"token punctuation\">(</span>start <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//do you wang</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><code>start()</code> 方法是默认被开启自动会执行的，为我们省去了很多麻煩</p>\n<h2 id=\"协程启动\"><a href=\"#协程启动\" class=\"headerlink\" title=\"协程启动\"></a>协程启动</h2><pre class=\" language-kotlin\"><code class=\"language-kotlin\">GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// do you want</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"启动模式\"><a href=\"#启动模式\" class=\"headerlink\" title=\"启动模式\"></a>启动模式</h2><pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">enum</span> <span class=\"token keyword\">class</span> CoroutineStart <span class=\"token punctuation\">{</span>\n    DEFAULT<span class=\"token punctuation\">,</span>\n    LAZY<span class=\"token punctuation\">,</span>\n    <span class=\"token annotation builtin\">@ExperimentalCoroutinesApi</span>\n    ATOMIC，\n    <span class=\"token annotation builtin\">@ExperimentalCoroutinesApi</span>\n    UNDISPATCHED；\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DEFAULT</td>\n<td>立即执行协程体</td>\n</tr>\n<tr>\n<td>ATOMIC</td>\n<td>立即执行协程体，但在开始运行之前无法取消</td>\n</tr>\n<tr>\n<td>UNDISPATCHED</td>\n<td>立即在当前线程执行协程体，直到第一个 suspend 调用</td>\n</tr>\n<tr>\n<td>LAZY</td>\n<td>只有在需要的情况下运行</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"DEFAULT\"><a href=\"#DEFAULT\" class=\"headerlink\" title=\"DEFAULT\"></a>DEFAULT</h3><p>四种启动模式中，常用的其实是<code>DEFAULT</code> 和 <code>LAZY</code></p>\n<p><code>DEFAULT</code> 是饿汉式启动，<code>launch</code> 调用后，会立即进入叼住状态，一旦调度器 OK 就可以开始执行。</p>\n<pre class=\" language-KOTLIN\"><code class=\"language-KOTLIN\">suspend fun main() {\n    log(1)\n    val job = GlobalScope.launch{\n        log(2)\n    }\n    log(3)\n    job.join()\n    log(4)\n}\n</code></pre>\n<p>采用默认的启动模式，由于没有指定调度器，因此调度器也是默认的，在 JVM 上，默认调度器的实现和其他语言的是离线类似，它在后台专门会有一个线程处理异步任务，上述程序的结果可能是</p>\n<pre class=\" language-tex\"><code class=\"language-tex\">[main] 1\n[main] 3\n[DefaultDispatcher-worker-1] 2\n[main] 4\n</code></pre>\n<p>它取决于 CPU 对于当前线程和后台线程的调度顺序</p>\n<h3 id=\"LAZY\"><a href=\"#LAZY\" class=\"headerlink\" title=\"LAZY\"></a>LAZY</h3><p><code>LAZY</code> 是懒汉式启动，<code>launch</code> 后，并不会有任何调度行为，协程体也自然不会进入执行状态，直到我们需要它执行的时候。<code>launch</code> 后会返回一个 <code>job</code> 实例，因此我们可以通过 <code>job</code> 来实现</p>\n<ul>\n<li>调用 <code>Job.start()</code> 主动触发协程的调度</li>\n<li>调用 <code>Job.join()</code> 隐式的触发协程的调度</li>\n</ul>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> job <span class=\"token operator\">=</span> GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span><span class=\"token punctuation\">(</span>start <span class=\"token operator\">=</span> CoroutineStart<span class=\"token punctuation\">.</span>LAZY<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\njob<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>其输出结果可能为</p>\n<pre class=\" language-tex\"><code class=\"language-tex\">[main] 1\n[main] 3\n[main] 4\n[DefaultDispatcher-worker-1] 2\n</code></pre>\n<p>运气好话，2 也可能在 4  的前面，而对于 <code>join()</code></p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> job <span class=\"token operator\">=</span> GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span><span class=\"token punctuation\">(</span>start <span class=\"token operator\">=</span> CoroutineStart<span class=\"token punctuation\">.</span>LAZY<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\njob<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>因为要等待协程执行完毕，因此数据结果一定是</p>\n<pre class=\" language-tex\"><code class=\"language-tex\">[main] 1\n[main] 3\n[DefaultDispatcher-worker-1] 2\n[main] 4\n</code></pre>\n<h3 id=\"ATOMIC\"><a href=\"#ATOMIC\" class=\"headerlink\" title=\"ATOMIC\"></a>ATOMIC</h3><p><code>ATOMIC</code> 只有涉及到 <code>cancel</code> 的时候才有意义， <code>cancel</code> 本身也是有一个值得讨论的话题，取消后，不会再被执行。在调用 <code>cancel</code> 的时机不同，结果也有差异的，例如在调度之前、开始调度但尚未执行、已经开始执行、执行完毕等等</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> job <span class=\"token operator\">=</span> GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span><span class=\"token punctuation\">(</span>start <span class=\"token operator\">=</span> CoroutineStart<span class=\"token punctuation\">.</span>ATOMIC<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\njob<span class=\"token punctuation\">.</span><span class=\"token function\">cancel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>我们创建写成后立即 <code>cancel</code> 但由于 <code>ATOMIC</code> 模式，因此协程一定会被调度，因此 1,2,3一定会输出，只是 2 和 3 的顺序难说</p>\n<p>对应的，如果是 <code>DEFAULT</code> 模式，在第一次调度该协程时，如果 <code>cancel</code> 就已经调用，那么协程就会被直接 <code>cancel</code> 而不会有任何调度。</p>\n<blockquote>\n<p>需要注意， <code>cancel</code> 调用一定会将 job 的状态设置为 cancelling, 只不过 <code>ATOMIC</code> 模式的协程在启动时无视了这一状态。</p>\n</blockquote>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> job <span class=\"token operator\">=</span> GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span><span class=\"token punctuation\">(</span>start <span class=\"token operator\">=</span> CoroutineStart<span class=\"token punctuation\">.</span>ATOMIC<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\njob<span class=\"token punctuation\">.</span><span class=\"token function\">cancel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span>\njob<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>2 和 3 之间加了一个 <code>delay</code> ，<code>delay</code> 会使得协程体的执行被挂起， 1s 之后再次调度后面的部分，因此 3 会在 2 执行之后1 s 输出，。对于 <code>ATOMIC</code> 模式，它的协程体一定会被启动，实际上在遇到第一个挂起点之前，它的执行是不会停止的，而 <code>delay</code> 是一个 <code>suspend</code> 函数，此时程序迎来了第一个挂起点，恰好 <code>delay</code> 是支持 <code>cancel</code> 的，因此后面的 3 将不会打印。</p>\n<h4 id=\"UNDISPATCHED\"><a href=\"#UNDISPATCHED\" class=\"headerlink\" title=\"UNDISPATCHED\"></a>UNDISPATCHED</h4><p>协程在这种模式下会直接开始在当前线程下执行，直到第一个挂起点，这一点和 <code>ATOMIC</code> 很像，不同在于 <code>DISPATCHED</code> 不经过任何调度器即开始执行协程体。当遇到挂起点之后的执行就取决于挂起点本身的逻辑以及上下文中的调度器</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> job <span class=\"token operator\">=</span> GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span><span class=\"token punctuation\">(</span>start <span class=\"token operator\">=</span> CoroutineStart<span class=\"token punctuation\">.</span>UNDISPATCHED<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span>\njob<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n</code></pre>\n","site":{"data":{}},"excerpt":"<h1 id=\"协程-启动\"><a href=\"#协程-启动\" class=\"headerlink\" title=\"协程-启动\"></a>协程-启动</h1><p><strong>启动模式</strong></p>\n<ol>\n<li>DEFAULT： 立即执行</li>\n<li>LAZY： 需要时执行</li>\n<li>ATOMIC： 立即执行，但开始前不会被取消</li>\n<li>UNDISPATCHED： 立即执行，直到第一个 suspend 挂起</li>\n</ol>","more":"<h2 id=\"Thread\"><a href=\"#Thread\" class=\"headerlink\" title=\"Thread\"></a>Thread</h2><pre><code class=\"kotlin\">val thread = object : Thread() {\n    override fun run(){\n        super.run()\n        //do something\n    }\n}\nthread.start()\n</code></pre>\n<p>上面是线程的启动方法，通常还会忘记去写 <code>start()</code> ，那再 kotlin 中</p>\n<pre><code class=\"kotlin\">val myThread = thread(start = true) {\n    //do you wang\n}\n</code></pre>\n<p><code>start()</code> 方法是默认被开启自动会执行的，为我们省去了很多麻煩</p>\n<h2 id=\"协程启动\"><a href=\"#协程启动\" class=\"headerlink\" title=\"协程启动\"></a>协程启动</h2><pre><code class=\"kotlin\">GlobalScope.launch {\n    // do you want\n}\n</code></pre>\n<h2 id=\"启动模式\"><a href=\"#启动模式\" class=\"headerlink\" title=\"启动模式\"></a>启动模式</h2><pre><code class=\"kotlin\">public enum class CoroutineStart {\n    DEFAULT,\n    LAZY,\n    @ExperimentalCoroutinesApi\n    ATOMIC，\n    @ExperimentalCoroutinesApi\n    UNDISPATCHED；\n}\n</code></pre>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DEFAULT</td>\n<td>立即执行协程体</td>\n</tr>\n<tr>\n<td>ATOMIC</td>\n<td>立即执行协程体，但在开始运行之前无法取消</td>\n</tr>\n<tr>\n<td>UNDISPATCHED</td>\n<td>立即在当前线程执行协程体，直到第一个 suspend 调用</td>\n</tr>\n<tr>\n<td>LAZY</td>\n<td>只有在需要的情况下运行</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"DEFAULT\"><a href=\"#DEFAULT\" class=\"headerlink\" title=\"DEFAULT\"></a>DEFAULT</h3><p>四种启动模式中，常用的其实是<code>DEFAULT</code> 和 <code>LAZY</code></p>\n<p><code>DEFAULT</code> 是饿汉式启动，<code>launch</code> 调用后，会立即进入叼住状态，一旦调度器 OK 就可以开始执行。</p>\n<pre><code class=\"KOTLIN\">suspend fun main() {\n    log(1)\n    val job = GlobalScope.launch{\n        log(2)\n    }\n    log(3)\n    job.join()\n    log(4)\n}\n</code></pre>\n<p>采用默认的启动模式，由于没有指定调度器，因此调度器也是默认的，在 JVM 上，默认调度器的实现和其他语言的是离线类似，它在后台专门会有一个线程处理异步任务，上述程序的结果可能是</p>\n<pre><code class=\"tex\">[main] 1\n[main] 3\n[DefaultDispatcher-worker-1] 2\n[main] 4\n</code></pre>\n<p>它取决于 CPU 对于当前线程和后台线程的调度顺序</p>\n<h3 id=\"LAZY\"><a href=\"#LAZY\" class=\"headerlink\" title=\"LAZY\"></a>LAZY</h3><p><code>LAZY</code> 是懒汉式启动，<code>launch</code> 后，并不会有任何调度行为，协程体也自然不会进入执行状态，直到我们需要它执行的时候。<code>launch</code> 后会返回一个 <code>job</code> 实例，因此我们可以通过 <code>job</code> 来实现</p>\n<ul>\n<li>调用 <code>Job.start()</code> 主动触发协程的调度</li>\n<li>调用 <code>Job.join()</code> 隐式的触发协程的调度</li>\n</ul>\n<pre><code class=\"kotlin\">log(1)\nval job = GlobalScope.launch(start = CoroutineStart.LAZY) {\n    log(2)\n}\nlog(3)\njob.start()\nlog(4)\n</code></pre>\n<p>其输出结果可能为</p>\n<pre><code class=\"tex\">[main] 1\n[main] 3\n[main] 4\n[DefaultDispatcher-worker-1] 2\n</code></pre>\n<p>运气好话，2 也可能在 4  的前面，而对于 <code>join()</code></p>\n<pre><code class=\"kotlin\">log(1)\nval job = GlobalScope.launch(start = CoroutineStart.LAZY) {\n    log(2)\n}\nlog(3)\njob.join()\nlog(4)\n</code></pre>\n<p>因为要等待协程执行完毕，因此数据结果一定是</p>\n<pre><code class=\"tex\">[main] 1\n[main] 3\n[DefaultDispatcher-worker-1] 2\n[main] 4\n</code></pre>\n<h3 id=\"ATOMIC\"><a href=\"#ATOMIC\" class=\"headerlink\" title=\"ATOMIC\"></a>ATOMIC</h3><p><code>ATOMIC</code> 只有涉及到 <code>cancel</code> 的时候才有意义， <code>cancel</code> 本身也是有一个值得讨论的话题，取消后，不会再被执行。在调用 <code>cancel</code> 的时机不同，结果也有差异的，例如在调度之前、开始调度但尚未执行、已经开始执行、执行完毕等等</p>\n<pre><code class=\"kotlin\">log(1)\nval job = GlobalScope.launch(start = CoroutineStart.ATOMIC) {\n    log(2)\n}\njob.cancel()\nlog(3)\n</code></pre>\n<p>我们创建写成后立即 <code>cancel</code> 但由于 <code>ATOMIC</code> 模式，因此协程一定会被调度，因此 1,2,3一定会输出，只是 2 和 3 的顺序难说</p>\n<p>对应的，如果是 <code>DEFAULT</code> 模式，在第一次调度该协程时，如果 <code>cancel</code> 就已经调用，那么协程就会被直接 <code>cancel</code> 而不会有任何调度。</p>\n<blockquote>\n<p>需要注意， <code>cancel</code> 调用一定会将 job 的状态设置为 cancelling, 只不过 <code>ATOMIC</code> 模式的协程在启动时无视了这一状态。</p>\n</blockquote>\n<pre><code class=\"kotlin\">log(1)\nval job = GlobalScope.launch(start = CoroutineStart.ATOMIC) {\n    log(2)\n    delay(1000)\n    log(3)\n}\njob.cancel()\nlog(4)\njob.join()\n</code></pre>\n<p>2 和 3 之间加了一个 <code>delay</code> ，<code>delay</code> 会使得协程体的执行被挂起， 1s 之后再次调度后面的部分，因此 3 会在 2 执行之后1 s 输出，。对于 <code>ATOMIC</code> 模式，它的协程体一定会被启动，实际上在遇到第一个挂起点之前，它的执行是不会停止的，而 <code>delay</code> 是一个 <code>suspend</code> 函数，此时程序迎来了第一个挂起点，恰好 <code>delay</code> 是支持 <code>cancel</code> 的，因此后面的 3 将不会打印。</p>\n<h4 id=\"UNDISPATCHED\"><a href=\"#UNDISPATCHED\" class=\"headerlink\" title=\"UNDISPATCHED\"></a>UNDISPATCHED</h4><p>协程在这种模式下会直接开始在当前线程下执行，直到第一个挂起点，这一点和 <code>ATOMIC</code> 很像，不同在于 <code>DISPATCHED</code> 不经过任何调度器即开始执行协程体。当遇到挂起点之后的执行就取决于挂起点本身的逻辑以及上下文中的调度器</p>\n<pre><code class=\"kotlin\">log(1)\nval job = GlobalScope.launch(start = CoroutineStart.UNDISPATCHED) {\n    log(2)\n    delay(1000)\n    log(3)\n}\nlog(4)\njob.join()\nlog(5)\n</code></pre>"},{"title":"协程异常处理","_content":"\n1. **协程内部异常处理流程**： \n\n   `launch` 会在内部出现未捕获的异常时尝试触发对父协程的取消，能否取消要看其作用域的定义，如果取消成功，那么异常传递给其父协程，否则传递给启动时上下文配置的 `CoroutineExceptionHandler` 中，如果没有配置，会查找全局（JVM）上的`CoroutineExceptionHandler` 处理，\n<!-- more-->\n    `async` 在未捕获异常的出现时同样会尝试取消其父协程，但不管是否能够取消成功都不会进行后续的异常处理，直到用户主动调用 `await` 时抛出\n\n2. **异常在作用域内传播**\n\n   当协程出现异常时，会根据当前作用域触发异常传递\n\n   `GlobalScope` 会创建一个独立的作用域，**自成一派**\n\n   `coroutineScope`  当中的协程异常会触发父协程的取消，将整个协程作用域取消掉，如果对 `coroutineScope` 整体进行捕获，也可以捕获到该异常，**一损俱损**\n\n   `supervisorScope` 子协程的异常不会向上传递， **自作自受**\n\n3. **join** 和 **await**\n\n   `join `  只关心是否执行完， `await ` 则关心运行的结果\n\n   因此 `join` 在协程出现异常时也不会抛出该异常，而 `await` 则会直接抛出异常；\n\n   **Note:** 考虑到作用域的问题，如果协程抛出异常，可能导致父协程的取消，因此调用 `join` 时，尽管不会对协程本身的异常进行抛出，但如果 `join` 调用所在的协程被取消，就会抛出 *取消异常*\n\n\n\n当我们进行异步请求时，必然会有失败的情况发生，那么我们继续上一个例子完善它\n\n```kotlin\ninterface Callback<T> {\n    fun onSuccess(value: T)\n    fun onError(t: Throwable)\n}\n\nfun getUser(callback: Callback){}\nsuspend fun getUserCoroutine() = suspendCoroutine<User> {continuation->\n\tgetUser(object: Callback<User> {\n        override fun onSuccess(user: User) {\n            continuation.resume(resume)\n        } \n        \n        override fun onError(e: Throwable) {\n            continuation.resumeWithException(t)\n        }\n    })                                                        \n}\n\nGlobalScope.launch(Dispatchers.Main) {\n    try {\n        userNameView.text = getUserCoroutine().name\n    } catch(e:Exception) {\n        userNameView.text = \"Get user error: $e\"\n    }\n}\n```\n\n## 全局异常处理\n\n线程也好，RxJava 也好，都会有全局处理异常的方式\n\n```kotlin\nfun main(){\n    Thread.setDefaultUncaughtExceptionHandler{t: Thread, e: Throwable ->\n    \t// handle exception here\n\t\tprintln(\"Thread '${t.name}' throws an exception with mesage '${e.message}'\")\n\t}\n    throw ArithmeticException(\"Hey!\")\n}\n```\n\nRxJava 设置全局异常捕获\n\n```java\nRxJavaPlugins.setErrorHandler(e-> {\n    println(\"Throws an exception with message '${e.message}'\")\n})\n```\n\n**协程也可以设置**，类似于通过 `Thread.setUnCaughtExceptionHandler` 为线程设置一个异常捕获器，同时也可以为每一个协程单独设置 `CoroutineExceptionHandler` 这样协程内未捕获的异常既可以通过它来捕获\n\n```kotlin\nprivate suspend fun main(){\n    val exceptionHandler = CoroutineExceptionHandler{ coroutineContext, throwable -> \n\t\tprintln(\"Throws an exception with message: '${throwable.message}'\")\n\t}\n    \n    GlobalScope.launch(exceptionHandler) {\n        throw ArithemticException(\"Hey!\")\n    }.join()\n}\n```\n\n`ConroutineExceptionHandler` 也是一个上下文。当然上面的只能捕获对应协程内未捕获的异常，真正的全局捕获，在JVM上我们可以自己定义一个实现\n\n```kotlin\nclass GlobalCoroutineExceptionHandler: CoroutineExceptionHandler {\n    override val key: CoroutineContext.Key<*> = CoroutineExceptinHandler\n    \n    override fun handleException(context, CoroutineContext, exception: Throwable) {\n        println(\"coroutine exceptino: $exception\")\n    }\n}\n```\n\n然后在 `classpath` 中创建 `META-INFO/services/kotlinx.coroutines.CoroutineExceptionHandler` 的全类名，文件内容就写我们的实现类的全名\n\n```tex\ncom.***.***.exceptions.GlobalCoroutineExceptionHandler\n```\n\n## 异常传播\n\n### 协程作用域\n\n当我们启动协程的时候，一直都在用 `GlobalScope` ，意味着这是要给独立的顶级协程作用域，此外还有`coroutineScope{}` 及 `supervisorScope{}`\n\n* 通过 `GlobalScope` 启动的协程单独启动一个协程作用域，内部的子协程遵循默认的作用域规则。通过 `GlobalScope` 启动的协程自成一派\n* `coroutineScope` 是继承外部 `Job` 的上下文创建作用域，在其内部的取消操作是双向传播的，子协程未捕获的异常会向上传递给它的父协程。它更适合一系列对等的协程并发的完成一项工作，**任何一个子协程异常退出，那么整体都将退出**， **一损俱损** ，同时这也是协程内部再启动子协程的默认作用域\n* `supervisorScope` 同样继承外部作用域的上下文，但其内部的取消操作是单项传播的，父协程向子协程传播，反过来不行。意味着**子协程出现了异常并不会影响父协程以及其他兄弟协程**，它更适合一些独立不相干的任务，任何一个任务出问题，并不会影响其他任务的工作，**自作自受**。`supervisorScope` 内部启动的子协程再启动子协程，如无明确指出，则遵循默认作用域规则，**即`supervosorScope` 只作用其直接子协程**\n\n```kotlin\nsuspend fun main (){\n    log(1)\n    try {\n        coroutineScope {\n            log(2)\n            launch {\n                log(3)\n                launch {\n                    log(4)\n                    delay(100)\n                    throw ArithmeticException(\"Hello\")\n                }\n                log(5)\n            }\n            log(6)\n            val job = launch {\n                log(7)\n                delay(1000)\n            }\n            try {\n                log(8)\n                job.join()\n                log(9)\n            } catch (e: Exception) {\n                log(\"10 $e\")\n            }\n        }\n        log(11)\n    } catch (e: Exception) {\n        log(\"12 $e\")\n    }\n    log(13)\n}\n```\n\n```tex\n1\n2\n6\n3\n5\n4\n8\n7\n10 kotlinx.coroutines.JobCancellationException: ScopeCoroutine is cancelling; job=ScopeCoroutine{Cancelling}@695fd68b\n12 java.lang.ArithmeticException: Hello\n13\n```\n\n从上面的程序和结果我们可以看出，**10**  这里，我们调用 `join` 收到了一个取消异常，在协程当中支持取消的操作的 `suspend` 函数在取消是抛出一个 `CancellationException`。\n\n协程 3 抛出了，未捕获异常，进入异常完成状态，它与父协程 2 之间遵循默认的作用域规则，因此 3 会通知它的父协程取消， 2 根据作用域规则通知父协程 1 ，也就是整个作用域取消，自下向上传播。在 1 中的 `job.join()` 调用就会抛出异常，也就是 10 出的结果。最终由 3 抛出的异常在 12 出被捕获。\n\n我们将 `coroutineScope` 换成 `supervisorScope` ，其他不变\n\n```tex\n1\n2\n6\n3\n5\n4\n8\n7\nException in thread \"DefaultDispatcher-worker-3\" java.lang.ArithmeticException: Hello\n\tat com.hachi.common.GlobalExceptionHandlerKt$main$2$1$1.invokeSuspend(GlobalExceptionHandler.kt:69)\n\tat kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)\n\tat kotlinx.coroutines.DispatchedTask.run(Dispatched.kt:241)\n\tat kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:594)\n\tat kotlinx.coroutines.scheduling.CoroutineScheduler.access$runSafely(CoroutineScheduler.kt:60)\n\tat kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:740)\n9\n11\n13\n```\n\n我们可以看出，1-8 的输出没有区别，顺序上的差异是线程调度造成的，并不会影响协程的语义。\n\n我们为内部协程增加啊一个 `CoroutineExceptionHandler` 就可以证明我们一个结论\n\n```kotlin\nval exceptionHandler = CoroutineExceptioHandler {coroutineContext, throwable -> \n           log(\"${coroutineContext[CoroutineName]} $throwable\")                                     }\n```\n\n```kotlin\nsuspend fun main (){\n    log(1)\n    try {\n        superisorScope {\n            log(2)\n            launch(exceptionHandler + CoroutineName(\"2\")) {\n                log(3)\n                launch (exceptionHandler + CoroutineName(\"3\")){\n                    log(4)\n                    delay(100)\n                    throw ArithmeticException(\"Hello\")\n                }\n                log(5)\n            }\n            log(6)\n            val job = launch {\n                log(7)\n                delay(1000)\n            }\n            try {\n                log(8)\n                job.join()\n                log(9)\n            } catch (e: Exception) {\n                log(\"10 $e\")\n            }\n        }\n        log(11)\n    } catch (e: Exception) {\n        log(\"12 $e\")\n    }\n    log(13)\n}\n```\n\n```tex\n1\n2\n6\n3\n5\n4\n8\n7\nCoroutineName(2) java.lang.ArithmeticException: Hello\n9\n11\n13\n```\n\n我们看到，触发`CoroutineExceptionHandler` 的是协程 2。\n\n### 如何使用 scope\n\n* 对于没有协程作用域，但需要启动协程的时候，适合用 **GlobalScope**\n* 对于已经由协程作用域的情况，直接用协程启动器启动\n* 对于明确要求子协程之间互相独立不干扰时，使用 **supervisorScope**\n* 对于通过标准库 API 创建的协程，这样的协程比较底层，没有 `Job` 作用域等概念的支撑，例如 `suspernd main` ，有限考虑通过 `coroutineScope` 创建作用域\n\n## join 和 await\n\n前面的例子一直是用 `launch` 启动协程常用的还有 `async`, `actor` `produce` 其中 `actor` 和 `launch` 的行为类似，在未捕获异常出现以后，会抛出。而 `async` 和 `produce` 则主要是用来输出结果的，它们内部的异常只在外部消费他们的记过时才抛出。\n\n### 什么是消费结果\n\n两组协程启动器，我们可以分别认为是 *消费者* 和 *生产者* \n\n消费者异常立即抛出；生产者只有结果异常时抛出\n\n### **async 和 await**\n\n```kotlin\nsuspend fun main() {\n    val deferred = GlobalScope.async<Int> {\n        throw ArithmeticException()\n    }\n    try {\n        val value = deferred.await()\n        log(\"1. $value\")\n    } catch (e: Exception) {\n        log(\"2. $e\")\n    }\n}\n```\n\n当我们调用 `await` 时，期望 `deferred` 能够给我们一个合适的结果，但是它发生了异常，没有办法左到， 随后就抛出一个异常给我们\n\n```tex\n2. java.lang.ArithmeticException\n```\n\n### join\n\n`join` 则和 `await` 不同， `join` 只关心是否执行完，至于为什么完成，它不关心。将上面的 `await` 替换成 `join` 后 \n\n```tex\n1. kotlin.Unit\n```\n\n异常信息被吞掉了，用 `launch` 替换 `async` ，`join` 处仍然不会有任何响应。\n\n`launch` 中未捕获的异常与 `aysync` 的处理方式不同， `launch` 会直接抛出异常给父协程，如果没有父协程或者处于 `supervisorScope` 中父协程不响应，那么就会交给上下文中执行的 `CoroutineExceptionHandler` 处理，如果没有指定，那就传给全局的 `CoroutineExcetionHandler` 等等。而 `async`  则要等 `await` 来消费\n\n","source":"_posts/Kotlin/协程/协程-异常处理.md","raw":"---\ntitle: 协程异常处理\ntag: Kotlin\n---\n\n1. **协程内部异常处理流程**： \n\n   `launch` 会在内部出现未捕获的异常时尝试触发对父协程的取消，能否取消要看其作用域的定义，如果取消成功，那么异常传递给其父协程，否则传递给启动时上下文配置的 `CoroutineExceptionHandler` 中，如果没有配置，会查找全局（JVM）上的`CoroutineExceptionHandler` 处理，\n<!-- more-->\n    `async` 在未捕获异常的出现时同样会尝试取消其父协程，但不管是否能够取消成功都不会进行后续的异常处理，直到用户主动调用 `await` 时抛出\n\n2. **异常在作用域内传播**\n\n   当协程出现异常时，会根据当前作用域触发异常传递\n\n   `GlobalScope` 会创建一个独立的作用域，**自成一派**\n\n   `coroutineScope`  当中的协程异常会触发父协程的取消，将整个协程作用域取消掉，如果对 `coroutineScope` 整体进行捕获，也可以捕获到该异常，**一损俱损**\n\n   `supervisorScope` 子协程的异常不会向上传递， **自作自受**\n\n3. **join** 和 **await**\n\n   `join `  只关心是否执行完， `await ` 则关心运行的结果\n\n   因此 `join` 在协程出现异常时也不会抛出该异常，而 `await` 则会直接抛出异常；\n\n   **Note:** 考虑到作用域的问题，如果协程抛出异常，可能导致父协程的取消，因此调用 `join` 时，尽管不会对协程本身的异常进行抛出，但如果 `join` 调用所在的协程被取消，就会抛出 *取消异常*\n\n\n\n当我们进行异步请求时，必然会有失败的情况发生，那么我们继续上一个例子完善它\n\n```kotlin\ninterface Callback<T> {\n    fun onSuccess(value: T)\n    fun onError(t: Throwable)\n}\n\nfun getUser(callback: Callback){}\nsuspend fun getUserCoroutine() = suspendCoroutine<User> {continuation->\n\tgetUser(object: Callback<User> {\n        override fun onSuccess(user: User) {\n            continuation.resume(resume)\n        } \n        \n        override fun onError(e: Throwable) {\n            continuation.resumeWithException(t)\n        }\n    })                                                        \n}\n\nGlobalScope.launch(Dispatchers.Main) {\n    try {\n        userNameView.text = getUserCoroutine().name\n    } catch(e:Exception) {\n        userNameView.text = \"Get user error: $e\"\n    }\n}\n```\n\n## 全局异常处理\n\n线程也好，RxJava 也好，都会有全局处理异常的方式\n\n```kotlin\nfun main(){\n    Thread.setDefaultUncaughtExceptionHandler{t: Thread, e: Throwable ->\n    \t// handle exception here\n\t\tprintln(\"Thread '${t.name}' throws an exception with mesage '${e.message}'\")\n\t}\n    throw ArithmeticException(\"Hey!\")\n}\n```\n\nRxJava 设置全局异常捕获\n\n```java\nRxJavaPlugins.setErrorHandler(e-> {\n    println(\"Throws an exception with message '${e.message}'\")\n})\n```\n\n**协程也可以设置**，类似于通过 `Thread.setUnCaughtExceptionHandler` 为线程设置一个异常捕获器，同时也可以为每一个协程单独设置 `CoroutineExceptionHandler` 这样协程内未捕获的异常既可以通过它来捕获\n\n```kotlin\nprivate suspend fun main(){\n    val exceptionHandler = CoroutineExceptionHandler{ coroutineContext, throwable -> \n\t\tprintln(\"Throws an exception with message: '${throwable.message}'\")\n\t}\n    \n    GlobalScope.launch(exceptionHandler) {\n        throw ArithemticException(\"Hey!\")\n    }.join()\n}\n```\n\n`ConroutineExceptionHandler` 也是一个上下文。当然上面的只能捕获对应协程内未捕获的异常，真正的全局捕获，在JVM上我们可以自己定义一个实现\n\n```kotlin\nclass GlobalCoroutineExceptionHandler: CoroutineExceptionHandler {\n    override val key: CoroutineContext.Key<*> = CoroutineExceptinHandler\n    \n    override fun handleException(context, CoroutineContext, exception: Throwable) {\n        println(\"coroutine exceptino: $exception\")\n    }\n}\n```\n\n然后在 `classpath` 中创建 `META-INFO/services/kotlinx.coroutines.CoroutineExceptionHandler` 的全类名，文件内容就写我们的实现类的全名\n\n```tex\ncom.***.***.exceptions.GlobalCoroutineExceptionHandler\n```\n\n## 异常传播\n\n### 协程作用域\n\n当我们启动协程的时候，一直都在用 `GlobalScope` ，意味着这是要给独立的顶级协程作用域，此外还有`coroutineScope{}` 及 `supervisorScope{}`\n\n* 通过 `GlobalScope` 启动的协程单独启动一个协程作用域，内部的子协程遵循默认的作用域规则。通过 `GlobalScope` 启动的协程自成一派\n* `coroutineScope` 是继承外部 `Job` 的上下文创建作用域，在其内部的取消操作是双向传播的，子协程未捕获的异常会向上传递给它的父协程。它更适合一系列对等的协程并发的完成一项工作，**任何一个子协程异常退出，那么整体都将退出**， **一损俱损** ，同时这也是协程内部再启动子协程的默认作用域\n* `supervisorScope` 同样继承外部作用域的上下文，但其内部的取消操作是单项传播的，父协程向子协程传播，反过来不行。意味着**子协程出现了异常并不会影响父协程以及其他兄弟协程**，它更适合一些独立不相干的任务，任何一个任务出问题，并不会影响其他任务的工作，**自作自受**。`supervisorScope` 内部启动的子协程再启动子协程，如无明确指出，则遵循默认作用域规则，**即`supervosorScope` 只作用其直接子协程**\n\n```kotlin\nsuspend fun main (){\n    log(1)\n    try {\n        coroutineScope {\n            log(2)\n            launch {\n                log(3)\n                launch {\n                    log(4)\n                    delay(100)\n                    throw ArithmeticException(\"Hello\")\n                }\n                log(5)\n            }\n            log(6)\n            val job = launch {\n                log(7)\n                delay(1000)\n            }\n            try {\n                log(8)\n                job.join()\n                log(9)\n            } catch (e: Exception) {\n                log(\"10 $e\")\n            }\n        }\n        log(11)\n    } catch (e: Exception) {\n        log(\"12 $e\")\n    }\n    log(13)\n}\n```\n\n```tex\n1\n2\n6\n3\n5\n4\n8\n7\n10 kotlinx.coroutines.JobCancellationException: ScopeCoroutine is cancelling; job=ScopeCoroutine{Cancelling}@695fd68b\n12 java.lang.ArithmeticException: Hello\n13\n```\n\n从上面的程序和结果我们可以看出，**10**  这里，我们调用 `join` 收到了一个取消异常，在协程当中支持取消的操作的 `suspend` 函数在取消是抛出一个 `CancellationException`。\n\n协程 3 抛出了，未捕获异常，进入异常完成状态，它与父协程 2 之间遵循默认的作用域规则，因此 3 会通知它的父协程取消， 2 根据作用域规则通知父协程 1 ，也就是整个作用域取消，自下向上传播。在 1 中的 `job.join()` 调用就会抛出异常，也就是 10 出的结果。最终由 3 抛出的异常在 12 出被捕获。\n\n我们将 `coroutineScope` 换成 `supervisorScope` ，其他不变\n\n```tex\n1\n2\n6\n3\n5\n4\n8\n7\nException in thread \"DefaultDispatcher-worker-3\" java.lang.ArithmeticException: Hello\n\tat com.hachi.common.GlobalExceptionHandlerKt$main$2$1$1.invokeSuspend(GlobalExceptionHandler.kt:69)\n\tat kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)\n\tat kotlinx.coroutines.DispatchedTask.run(Dispatched.kt:241)\n\tat kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:594)\n\tat kotlinx.coroutines.scheduling.CoroutineScheduler.access$runSafely(CoroutineScheduler.kt:60)\n\tat kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:740)\n9\n11\n13\n```\n\n我们可以看出，1-8 的输出没有区别，顺序上的差异是线程调度造成的，并不会影响协程的语义。\n\n我们为内部协程增加啊一个 `CoroutineExceptionHandler` 就可以证明我们一个结论\n\n```kotlin\nval exceptionHandler = CoroutineExceptioHandler {coroutineContext, throwable -> \n           log(\"${coroutineContext[CoroutineName]} $throwable\")                                     }\n```\n\n```kotlin\nsuspend fun main (){\n    log(1)\n    try {\n        superisorScope {\n            log(2)\n            launch(exceptionHandler + CoroutineName(\"2\")) {\n                log(3)\n                launch (exceptionHandler + CoroutineName(\"3\")){\n                    log(4)\n                    delay(100)\n                    throw ArithmeticException(\"Hello\")\n                }\n                log(5)\n            }\n            log(6)\n            val job = launch {\n                log(7)\n                delay(1000)\n            }\n            try {\n                log(8)\n                job.join()\n                log(9)\n            } catch (e: Exception) {\n                log(\"10 $e\")\n            }\n        }\n        log(11)\n    } catch (e: Exception) {\n        log(\"12 $e\")\n    }\n    log(13)\n}\n```\n\n```tex\n1\n2\n6\n3\n5\n4\n8\n7\nCoroutineName(2) java.lang.ArithmeticException: Hello\n9\n11\n13\n```\n\n我们看到，触发`CoroutineExceptionHandler` 的是协程 2。\n\n### 如何使用 scope\n\n* 对于没有协程作用域，但需要启动协程的时候，适合用 **GlobalScope**\n* 对于已经由协程作用域的情况，直接用协程启动器启动\n* 对于明确要求子协程之间互相独立不干扰时，使用 **supervisorScope**\n* 对于通过标准库 API 创建的协程，这样的协程比较底层，没有 `Job` 作用域等概念的支撑，例如 `suspernd main` ，有限考虑通过 `coroutineScope` 创建作用域\n\n## join 和 await\n\n前面的例子一直是用 `launch` 启动协程常用的还有 `async`, `actor` `produce` 其中 `actor` 和 `launch` 的行为类似，在未捕获异常出现以后，会抛出。而 `async` 和 `produce` 则主要是用来输出结果的，它们内部的异常只在外部消费他们的记过时才抛出。\n\n### 什么是消费结果\n\n两组协程启动器，我们可以分别认为是 *消费者* 和 *生产者* \n\n消费者异常立即抛出；生产者只有结果异常时抛出\n\n### **async 和 await**\n\n```kotlin\nsuspend fun main() {\n    val deferred = GlobalScope.async<Int> {\n        throw ArithmeticException()\n    }\n    try {\n        val value = deferred.await()\n        log(\"1. $value\")\n    } catch (e: Exception) {\n        log(\"2. $e\")\n    }\n}\n```\n\n当我们调用 `await` 时，期望 `deferred` 能够给我们一个合适的结果，但是它发生了异常，没有办法左到， 随后就抛出一个异常给我们\n\n```tex\n2. java.lang.ArithmeticException\n```\n\n### join\n\n`join` 则和 `await` 不同， `join` 只关心是否执行完，至于为什么完成，它不关心。将上面的 `await` 替换成 `join` 后 \n\n```tex\n1. kotlin.Unit\n```\n\n异常信息被吞掉了，用 `launch` 替换 `async` ，`join` 处仍然不会有任何响应。\n\n`launch` 中未捕获的异常与 `aysync` 的处理方式不同， `launch` 会直接抛出异常给父协程，如果没有父协程或者处于 `supervisorScope` 中父协程不响应，那么就会交给上下文中执行的 `CoroutineExceptionHandler` 处理，如果没有指定，那就传给全局的 `CoroutineExcetionHandler` 等等。而 `async`  则要等 `await` 来消费\n\n","slug":"Kotlin/协程/协程-异常处理","published":1,"date":"2021-01-29T15:54:28.318Z","updated":"2021-01-29T16:16:07.965Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8l9003usz5qluu5u01i","content":"<ol>\n<li><p><strong>协程内部异常处理流程</strong>： </p>\n<p><code>launch</code> 会在内部出现未捕获的异常时尝试触发对父协程的取消，能否取消要看其作用域的定义，如果取消成功，那么异常传递给其父协程，否则传递给启动时上下文配置的 <code>CoroutineExceptionHandler</code> 中，如果没有配置，会查找全局（JVM）上的<code>CoroutineExceptionHandler</code> 处理，</p>\n<a id=\"more\"></a>\n<p> <code>async</code> 在未捕获异常的出现时同样会尝试取消其父协程，但不管是否能够取消成功都不会进行后续的异常处理，直到用户主动调用 <code>await</code> 时抛出</p>\n</li>\n<li><p><strong>异常在作用域内传播</strong></p>\n<p>当协程出现异常时，会根据当前作用域触发异常传递</p>\n<p><code>GlobalScope</code> 会创建一个独立的作用域，<strong>自成一派</strong></p>\n<p><code>coroutineScope</code>  当中的协程异常会触发父协程的取消，将整个协程作用域取消掉，如果对 <code>coroutineScope</code> 整体进行捕获，也可以捕获到该异常，<strong>一损俱损</strong></p>\n<p><code>supervisorScope</code> 子协程的异常不会向上传递， <strong>自作自受</strong></p>\n</li>\n<li><p><strong>join</strong> 和 <strong>await</strong></p>\n<p><code>join</code>  只关心是否执行完， <code>await</code> 则关心运行的结果</p>\n<p>因此 <code>join</code> 在协程出现异常时也不会抛出该异常，而 <code>await</code> 则会直接抛出异常；</p>\n<p><strong>Note:</strong> 考虑到作用域的问题，如果协程抛出异常，可能导致父协程的取消，因此调用 <code>join</code> 时，尽管不会对协程本身的异常进行抛出，但如果 <code>join</code> 调用所在的协程被取消，就会抛出 <em>取消异常</em></p>\n</li>\n</ol>\n<p>当我们进行异步请求时，必然会有失败的情况发生，那么我们继续上一个例子完善它</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">interface</span> Callback<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">onSuccess</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> T<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">onError</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">:</span> Throwable<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">getUser</span><span class=\"token punctuation\">(</span>callback<span class=\"token operator\">:</span> Callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\nsuspend <span class=\"token keyword\">fun</span> <span class=\"token function\">getUserCoroutine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> suspendCoroutine<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>continuation<span class=\"token operator\">-></span>\n    <span class=\"token function\">getUser</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">object</span><span class=\"token operator\">:</span> Callback<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">onSuccess</span><span class=\"token punctuation\">(</span>user<span class=\"token operator\">:</span> User<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            continuation<span class=\"token punctuation\">.</span><span class=\"token function\">resume</span><span class=\"token punctuation\">(</span>resume<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span> \n\n        <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">onError</span><span class=\"token punctuation\">(</span>e<span class=\"token operator\">:</span> Throwable<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            continuation<span class=\"token punctuation\">.</span><span class=\"token function\">resumeWithException</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>                                                        \n<span class=\"token punctuation\">}</span>\n\nGlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span><span class=\"token punctuation\">(</span>Dispatchers<span class=\"token punctuation\">.</span>Main<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        userNameView<span class=\"token punctuation\">.</span>text <span class=\"token operator\">=</span> <span class=\"token function\">getUserCoroutine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>name\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>e<span class=\"token operator\">:</span>Exception<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        userNameView<span class=\"token punctuation\">.</span>text <span class=\"token operator\">=</span> <span class=\"token string\">\"Get user error: <span class=\"token interpolation variable\">$e</span>\"</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"全局异常处理\"><a href=\"#全局异常处理\" class=\"headerlink\" title=\"全局异常处理\"></a>全局异常处理</h2><p>线程也好，RxJava 也好，都会有全局处理异常的方式</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    Thread<span class=\"token punctuation\">.</span><span class=\"token function\">setDefaultUncaughtExceptionHandler</span><span class=\"token punctuation\">{</span>t<span class=\"token operator\">:</span> Thread<span class=\"token punctuation\">,</span> e<span class=\"token operator\">:</span> Throwable <span class=\"token operator\">-></span>\n        <span class=\"token comment\" spellcheck=\"true\">// handle exception here</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Thread '<span class=\"token interpolation\"><span class=\"token delimiter variable\">${</span>t<span class=\"token punctuation\">.</span>name<span class=\"token delimiter variable\">}</span></span>' throws an exception with mesage '<span class=\"token interpolation\"><span class=\"token delimiter variable\">${</span>e<span class=\"token punctuation\">.</span>message<span class=\"token delimiter variable\">}</span></span>'\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token function\">ArithmeticException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hey!\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>RxJava 设置全局异常捕获</p>\n<pre class=\" language-java\"><code class=\"language-java\">RxJavaPlugins<span class=\"token punctuation\">.</span><span class=\"token function\">setErrorHandler</span><span class=\"token punctuation\">(</span>e<span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Throws an exception with message '${e.message}'\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p><strong>协程也可以设置</strong>，类似于通过 <code>Thread.setUnCaughtExceptionHandler</code> 为线程设置一个异常捕获器，同时也可以为每一个协程单独设置 <code>CoroutineExceptionHandler</code> 这样协程内未捕获的异常既可以通过它来捕获</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">private</span> suspend <span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> exceptionHandler <span class=\"token operator\">=</span> CoroutineExceptionHandler<span class=\"token punctuation\">{</span> coroutineContext<span class=\"token punctuation\">,</span> throwable <span class=\"token operator\">-></span> \n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Throws an exception with message: '<span class=\"token interpolation\"><span class=\"token delimiter variable\">${</span>throwable<span class=\"token punctuation\">.</span>message<span class=\"token delimiter variable\">}</span></span>'\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span><span class=\"token punctuation\">(</span>exceptionHandler<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token function\">ArithemticException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hey!\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><code>ConroutineExceptionHandler</code> 也是一个上下文。当然上面的只能捕获对应协程内未捕获的异常，真正的全局捕获，在JVM上我们可以自己定义一个实现</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">class</span> GlobalCoroutineExceptionHandler<span class=\"token operator\">:</span> CoroutineExceptionHandler <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">val</span> key<span class=\"token operator\">:</span> CoroutineContext<span class=\"token punctuation\">.</span>Key<span class=\"token operator\">&lt;</span><span class=\"token operator\">*</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> CoroutineExceptinHandler\n\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">handleException</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> CoroutineContext<span class=\"token punctuation\">,</span> exception<span class=\"token operator\">:</span> Throwable<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"coroutine exceptino: <span class=\"token interpolation variable\">$exception</span>\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>然后在 <code>classpath</code> 中创建 <code>META-INFO/services/kotlinx.coroutines.CoroutineExceptionHandler</code> 的全类名，文件内容就写我们的实现类的全名</p>\n<pre class=\" language-tex\"><code class=\"language-tex\">com.***.***.exceptions.GlobalCoroutineExceptionHandler\n</code></pre>\n<h2 id=\"异常传播\"><a href=\"#异常传播\" class=\"headerlink\" title=\"异常传播\"></a>异常传播</h2><h3 id=\"协程作用域\"><a href=\"#协程作用域\" class=\"headerlink\" title=\"协程作用域\"></a>协程作用域</h3><p>当我们启动协程的时候，一直都在用 <code>GlobalScope</code> ，意味着这是要给独立的顶级协程作用域，此外还有<code>coroutineScope{}</code> 及 <code>supervisorScope{}</code></p>\n<ul>\n<li>通过 <code>GlobalScope</code> 启动的协程单独启动一个协程作用域，内部的子协程遵循默认的作用域规则。通过 <code>GlobalScope</code> 启动的协程自成一派</li>\n<li><code>coroutineScope</code> 是继承外部 <code>Job</code> 的上下文创建作用域，在其内部的取消操作是双向传播的，子协程未捕获的异常会向上传递给它的父协程。它更适合一系列对等的协程并发的完成一项工作，<strong>任何一个子协程异常退出，那么整体都将退出</strong>， <strong>一损俱损</strong> ，同时这也是协程内部再启动子协程的默认作用域</li>\n<li><code>supervisorScope</code> 同样继承外部作用域的上下文，但其内部的取消操作是单项传播的，父协程向子协程传播，反过来不行。意味着<strong>子协程出现了异常并不会影响父协程以及其他兄弟协程</strong>，它更适合一些独立不相干的任务，任何一个任务出问题，并不会影响其他任务的工作，<strong>自作自受</strong>。<code>supervisorScope</code> 内部启动的子协程再启动子协程，如无明确指出，则遵循默认作用域规则，<strong>即<code>supervosorScope</code> 只作用其直接子协程</strong></li>\n</ul>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\">suspend <span class=\"token keyword\">fun</span> <span class=\"token function\">main</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        coroutineScope <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n            launch <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n                launch <span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">throw</span> <span class=\"token function\">ArithmeticException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">val</span> job <span class=\"token operator\">=</span> launch <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span>\n                <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span>\n                job<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">9</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token operator\">:</span> Exception<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"10 <span class=\"token interpolation variable\">$e</span>\"</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token operator\">:</span> Exception<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"12 <span class=\"token interpolation variable\">$e</span>\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">13</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<pre class=\" language-tex\"><code class=\"language-tex\">1\n2\n6\n3\n5\n4\n8\n7\n10 kotlinx.coroutines.JobCancellationException: ScopeCoroutine is cancelling; job=ScopeCoroutine{Cancelling}@695fd68b\n12 java.lang.ArithmeticException: Hello\n13\n</code></pre>\n<p>从上面的程序和结果我们可以看出，<strong>10</strong>  这里，我们调用 <code>join</code> 收到了一个取消异常，在协程当中支持取消的操作的 <code>suspend</code> 函数在取消是抛出一个 <code>CancellationException</code>。</p>\n<p>协程 3 抛出了，未捕获异常，进入异常完成状态，它与父协程 2 之间遵循默认的作用域规则，因此 3 会通知它的父协程取消， 2 根据作用域规则通知父协程 1 ，也就是整个作用域取消，自下向上传播。在 1 中的 <code>job.join()</code> 调用就会抛出异常，也就是 10 出的结果。最终由 3 抛出的异常在 12 出被捕获。</p>\n<p>我们将 <code>coroutineScope</code> 换成 <code>supervisorScope</code> ，其他不变</p>\n<pre class=\" language-tex\"><code class=\"language-tex\">1\n2\n6\n3\n5\n4\n8\n7\nException in thread \"DefaultDispatcher-worker-3\" java.lang.ArithmeticException: Hello\n    at com.hachi.common.GlobalExceptionHandlerKt$main$2$1$1.invokeSuspend(GlobalExceptionHandler.kt:69)\n    at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)\n    at kotlinx.coroutines.DispatchedTask.run(Dispatched.kt:241)\n    at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:594)\n    at kotlinx.coroutines.scheduling.CoroutineScheduler.access$runSafely(CoroutineScheduler.kt:60)\n    at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:740)\n9\n11\n13\n</code></pre>\n<p>我们可以看出，1-8 的输出没有区别，顺序上的差异是线程调度造成的，并不会影响协程的语义。</p>\n<p>我们为内部协程增加啊一个 <code>CoroutineExceptionHandler</code> 就可以证明我们一个结论</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> exceptionHandler <span class=\"token operator\">=</span> CoroutineExceptioHandler <span class=\"token punctuation\">{</span>coroutineContext<span class=\"token punctuation\">,</span> throwable <span class=\"token operator\">-></span> \n           <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"<span class=\"token interpolation\"><span class=\"token delimiter variable\">${</span>coroutineContext<span class=\"token punctuation\">[</span>CoroutineName<span class=\"token punctuation\">]</span><span class=\"token delimiter variable\">}</span></span> <span class=\"token interpolation variable\">$throwable</span>\"</span><span class=\"token punctuation\">)</span>                                     <span class=\"token punctuation\">}</span>\n</code></pre>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\">suspend <span class=\"token keyword\">fun</span> <span class=\"token function\">main</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        superisorScope <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">launch</span><span class=\"token punctuation\">(</span>exceptionHandler <span class=\"token operator\">+</span> <span class=\"token function\">CoroutineName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n                <span class=\"token function\">launch</span> <span class=\"token punctuation\">(</span>exceptionHandler <span class=\"token operator\">+</span> <span class=\"token function\">CoroutineName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"3\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">throw</span> <span class=\"token function\">ArithmeticException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">val</span> job <span class=\"token operator\">=</span> launch <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span>\n                <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span>\n                job<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">9</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token operator\">:</span> Exception<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"10 <span class=\"token interpolation variable\">$e</span>\"</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token operator\">:</span> Exception<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"12 <span class=\"token interpolation variable\">$e</span>\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">13</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<pre class=\" language-tex\"><code class=\"language-tex\">1\n2\n6\n3\n5\n4\n8\n7\nCoroutineName(2) java.lang.ArithmeticException: Hello\n9\n11\n13\n</code></pre>\n<p>我们看到，触发<code>CoroutineExceptionHandler</code> 的是协程 2。</p>\n<h3 id=\"如何使用-scope\"><a href=\"#如何使用-scope\" class=\"headerlink\" title=\"如何使用 scope\"></a>如何使用 scope</h3><ul>\n<li>对于没有协程作用域，但需要启动协程的时候，适合用 <strong>GlobalScope</strong></li>\n<li>对于已经由协程作用域的情况，直接用协程启动器启动</li>\n<li>对于明确要求子协程之间互相独立不干扰时，使用 <strong>supervisorScope</strong></li>\n<li>对于通过标准库 API 创建的协程，这样的协程比较底层，没有 <code>Job</code> 作用域等概念的支撑，例如 <code>suspernd main</code> ，有限考虑通过 <code>coroutineScope</code> 创建作用域</li>\n</ul>\n<h2 id=\"join-和-await\"><a href=\"#join-和-await\" class=\"headerlink\" title=\"join 和 await\"></a>join 和 await</h2><p>前面的例子一直是用 <code>launch</code> 启动协程常用的还有 <code>async</code>, <code>actor</code> <code>produce</code> 其中 <code>actor</code> 和 <code>launch</code> 的行为类似，在未捕获异常出现以后，会抛出。而 <code>async</code> 和 <code>produce</code> 则主要是用来输出结果的，它们内部的异常只在外部消费他们的记过时才抛出。</p>\n<h3 id=\"什么是消费结果\"><a href=\"#什么是消费结果\" class=\"headerlink\" title=\"什么是消费结果\"></a>什么是消费结果</h3><p>两组协程启动器，我们可以分别认为是 <em>消费者</em> 和 <em>生产者</em> </p>\n<p>消费者异常立即抛出；生产者只有结果异常时抛出</p>\n<h3 id=\"async-和-await\"><a href=\"#async-和-await\" class=\"headerlink\" title=\"async 和 await\"></a><strong>async 和 await</strong></h3><pre class=\" language-kotlin\"><code class=\"language-kotlin\">suspend <span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> deferred <span class=\"token operator\">=</span> GlobalScope<span class=\"token punctuation\">.</span>async<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token function\">ArithmeticException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">val</span> value <span class=\"token operator\">=</span> deferred<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1. <span class=\"token interpolation variable\">$value</span>\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token operator\">:</span> Exception<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"2. <span class=\"token interpolation variable\">$e</span>\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>当我们调用 <code>await</code> 时，期望 <code>deferred</code> 能够给我们一个合适的结果，但是它发生了异常，没有办法左到， 随后就抛出一个异常给我们</p>\n<pre class=\" language-tex\"><code class=\"language-tex\">2. java.lang.ArithmeticException\n</code></pre>\n<h3 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join\"></a>join</h3><p><code>join</code> 则和 <code>await</code> 不同， <code>join</code> 只关心是否执行完，至于为什么完成，它不关心。将上面的 <code>await</code> 替换成 <code>join</code> 后 </p>\n<pre class=\" language-tex\"><code class=\"language-tex\">1. kotlin.Unit\n</code></pre>\n<p>异常信息被吞掉了，用 <code>launch</code> 替换 <code>async</code> ，<code>join</code> 处仍然不会有任何响应。</p>\n<p><code>launch</code> 中未捕获的异常与 <code>aysync</code> 的处理方式不同， <code>launch</code> 会直接抛出异常给父协程，如果没有父协程或者处于 <code>supervisorScope</code> 中父协程不响应，那么就会交给上下文中执行的 <code>CoroutineExceptionHandler</code> 处理，如果没有指定，那就传给全局的 <code>CoroutineExcetionHandler</code> 等等。而 <code>async</code>  则要等 <code>await</code> 来消费</p>\n","site":{"data":{}},"excerpt":"<ol>\n<li><p><strong>协程内部异常处理流程</strong>： </p>\n<p><code>launch</code> 会在内部出现未捕获的异常时尝试触发对父协程的取消，能否取消要看其作用域的定义，如果取消成功，那么异常传递给其父协程，否则传递给启动时上下文配置的 <code>CoroutineExceptionHandler</code> 中，如果没有配置，会查找全局（JVM）上的<code>CoroutineExceptionHandler</code> 处理，</p>","more":"<p> <code>async</code> 在未捕获异常的出现时同样会尝试取消其父协程，但不管是否能够取消成功都不会进行后续的异常处理，直到用户主动调用 <code>await</code> 时抛出</p>\n</li>\n<li><p><strong>异常在作用域内传播</strong></p>\n<p>当协程出现异常时，会根据当前作用域触发异常传递</p>\n<p><code>GlobalScope</code> 会创建一个独立的作用域，<strong>自成一派</strong></p>\n<p><code>coroutineScope</code>  当中的协程异常会触发父协程的取消，将整个协程作用域取消掉，如果对 <code>coroutineScope</code> 整体进行捕获，也可以捕获到该异常，<strong>一损俱损</strong></p>\n<p><code>supervisorScope</code> 子协程的异常不会向上传递， <strong>自作自受</strong></p>\n</li>\n<li><p><strong>join</strong> 和 <strong>await</strong></p>\n<p><code>join</code>  只关心是否执行完， <code>await</code> 则关心运行的结果</p>\n<p>因此 <code>join</code> 在协程出现异常时也不会抛出该异常，而 <code>await</code> 则会直接抛出异常；</p>\n<p><strong>Note:</strong> 考虑到作用域的问题，如果协程抛出异常，可能导致父协程的取消，因此调用 <code>join</code> 时，尽管不会对协程本身的异常进行抛出，但如果 <code>join</code> 调用所在的协程被取消，就会抛出 <em>取消异常</em></p>\n</li>\n</ol>\n<p>当我们进行异步请求时，必然会有失败的情况发生，那么我们继续上一个例子完善它</p>\n<pre><code class=\"kotlin\">interface Callback&lt;T&gt; {\n    fun onSuccess(value: T)\n    fun onError(t: Throwable)\n}\n\nfun getUser(callback: Callback){}\nsuspend fun getUserCoroutine() = suspendCoroutine&lt;User&gt; {continuation-&gt;\n    getUser(object: Callback&lt;User&gt; {\n        override fun onSuccess(user: User) {\n            continuation.resume(resume)\n        } \n\n        override fun onError(e: Throwable) {\n            continuation.resumeWithException(t)\n        }\n    })                                                        \n}\n\nGlobalScope.launch(Dispatchers.Main) {\n    try {\n        userNameView.text = getUserCoroutine().name\n    } catch(e:Exception) {\n        userNameView.text = &quot;Get user error: $e&quot;\n    }\n}\n</code></pre>\n<h2 id=\"全局异常处理\"><a href=\"#全局异常处理\" class=\"headerlink\" title=\"全局异常处理\"></a>全局异常处理</h2><p>线程也好，RxJava 也好，都会有全局处理异常的方式</p>\n<pre><code class=\"kotlin\">fun main(){\n    Thread.setDefaultUncaughtExceptionHandler{t: Thread, e: Throwable -&gt;\n        // handle exception here\n        println(&quot;Thread &#39;${t.name}&#39; throws an exception with mesage &#39;${e.message}&#39;&quot;)\n    }\n    throw ArithmeticException(&quot;Hey!&quot;)\n}\n</code></pre>\n<p>RxJava 设置全局异常捕获</p>\n<pre><code class=\"java\">RxJavaPlugins.setErrorHandler(e-&gt; {\n    println(&quot;Throws an exception with message &#39;${e.message}&#39;&quot;)\n})\n</code></pre>\n<p><strong>协程也可以设置</strong>，类似于通过 <code>Thread.setUnCaughtExceptionHandler</code> 为线程设置一个异常捕获器，同时也可以为每一个协程单独设置 <code>CoroutineExceptionHandler</code> 这样协程内未捕获的异常既可以通过它来捕获</p>\n<pre><code class=\"kotlin\">private suspend fun main(){\n    val exceptionHandler = CoroutineExceptionHandler{ coroutineContext, throwable -&gt; \n        println(&quot;Throws an exception with message: &#39;${throwable.message}&#39;&quot;)\n    }\n\n    GlobalScope.launch(exceptionHandler) {\n        throw ArithemticException(&quot;Hey!&quot;)\n    }.join()\n}\n</code></pre>\n<p><code>ConroutineExceptionHandler</code> 也是一个上下文。当然上面的只能捕获对应协程内未捕获的异常，真正的全局捕获，在JVM上我们可以自己定义一个实现</p>\n<pre><code class=\"kotlin\">class GlobalCoroutineExceptionHandler: CoroutineExceptionHandler {\n    override val key: CoroutineContext.Key&lt;*&gt; = CoroutineExceptinHandler\n\n    override fun handleException(context, CoroutineContext, exception: Throwable) {\n        println(&quot;coroutine exceptino: $exception&quot;)\n    }\n}\n</code></pre>\n<p>然后在 <code>classpath</code> 中创建 <code>META-INFO/services/kotlinx.coroutines.CoroutineExceptionHandler</code> 的全类名，文件内容就写我们的实现类的全名</p>\n<pre><code class=\"tex\">com.***.***.exceptions.GlobalCoroutineExceptionHandler\n</code></pre>\n<h2 id=\"异常传播\"><a href=\"#异常传播\" class=\"headerlink\" title=\"异常传播\"></a>异常传播</h2><h3 id=\"协程作用域\"><a href=\"#协程作用域\" class=\"headerlink\" title=\"协程作用域\"></a>协程作用域</h3><p>当我们启动协程的时候，一直都在用 <code>GlobalScope</code> ，意味着这是要给独立的顶级协程作用域，此外还有<code>coroutineScope{}</code> 及 <code>supervisorScope{}</code></p>\n<ul>\n<li>通过 <code>GlobalScope</code> 启动的协程单独启动一个协程作用域，内部的子协程遵循默认的作用域规则。通过 <code>GlobalScope</code> 启动的协程自成一派</li>\n<li><code>coroutineScope</code> 是继承外部 <code>Job</code> 的上下文创建作用域，在其内部的取消操作是双向传播的，子协程未捕获的异常会向上传递给它的父协程。它更适合一系列对等的协程并发的完成一项工作，<strong>任何一个子协程异常退出，那么整体都将退出</strong>， <strong>一损俱损</strong> ，同时这也是协程内部再启动子协程的默认作用域</li>\n<li><code>supervisorScope</code> 同样继承外部作用域的上下文，但其内部的取消操作是单项传播的，父协程向子协程传播，反过来不行。意味着<strong>子协程出现了异常并不会影响父协程以及其他兄弟协程</strong>，它更适合一些独立不相干的任务，任何一个任务出问题，并不会影响其他任务的工作，<strong>自作自受</strong>。<code>supervisorScope</code> 内部启动的子协程再启动子协程，如无明确指出，则遵循默认作用域规则，<strong>即<code>supervosorScope</code> 只作用其直接子协程</strong></li>\n</ul>\n<pre><code class=\"kotlin\">suspend fun main (){\n    log(1)\n    try {\n        coroutineScope {\n            log(2)\n            launch {\n                log(3)\n                launch {\n                    log(4)\n                    delay(100)\n                    throw ArithmeticException(&quot;Hello&quot;)\n                }\n                log(5)\n            }\n            log(6)\n            val job = launch {\n                log(7)\n                delay(1000)\n            }\n            try {\n                log(8)\n                job.join()\n                log(9)\n            } catch (e: Exception) {\n                log(&quot;10 $e&quot;)\n            }\n        }\n        log(11)\n    } catch (e: Exception) {\n        log(&quot;12 $e&quot;)\n    }\n    log(13)\n}\n</code></pre>\n<pre><code class=\"tex\">1\n2\n6\n3\n5\n4\n8\n7\n10 kotlinx.coroutines.JobCancellationException: ScopeCoroutine is cancelling; job=ScopeCoroutine{Cancelling}@695fd68b\n12 java.lang.ArithmeticException: Hello\n13\n</code></pre>\n<p>从上面的程序和结果我们可以看出，<strong>10</strong>  这里，我们调用 <code>join</code> 收到了一个取消异常，在协程当中支持取消的操作的 <code>suspend</code> 函数在取消是抛出一个 <code>CancellationException</code>。</p>\n<p>协程 3 抛出了，未捕获异常，进入异常完成状态，它与父协程 2 之间遵循默认的作用域规则，因此 3 会通知它的父协程取消， 2 根据作用域规则通知父协程 1 ，也就是整个作用域取消，自下向上传播。在 1 中的 <code>job.join()</code> 调用就会抛出异常，也就是 10 出的结果。最终由 3 抛出的异常在 12 出被捕获。</p>\n<p>我们将 <code>coroutineScope</code> 换成 <code>supervisorScope</code> ，其他不变</p>\n<pre><code class=\"tex\">1\n2\n6\n3\n5\n4\n8\n7\nException in thread &quot;DefaultDispatcher-worker-3&quot; java.lang.ArithmeticException: Hello\n    at com.hachi.common.GlobalExceptionHandlerKt$main$2$1$1.invokeSuspend(GlobalExceptionHandler.kt:69)\n    at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)\n    at kotlinx.coroutines.DispatchedTask.run(Dispatched.kt:241)\n    at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:594)\n    at kotlinx.coroutines.scheduling.CoroutineScheduler.access$runSafely(CoroutineScheduler.kt:60)\n    at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:740)\n9\n11\n13\n</code></pre>\n<p>我们可以看出，1-8 的输出没有区别，顺序上的差异是线程调度造成的，并不会影响协程的语义。</p>\n<p>我们为内部协程增加啊一个 <code>CoroutineExceptionHandler</code> 就可以证明我们一个结论</p>\n<pre><code class=\"kotlin\">val exceptionHandler = CoroutineExceptioHandler {coroutineContext, throwable -&gt; \n           log(&quot;${coroutineContext[CoroutineName]} $throwable&quot;)                                     }\n</code></pre>\n<pre><code class=\"kotlin\">suspend fun main (){\n    log(1)\n    try {\n        superisorScope {\n            log(2)\n            launch(exceptionHandler + CoroutineName(&quot;2&quot;)) {\n                log(3)\n                launch (exceptionHandler + CoroutineName(&quot;3&quot;)){\n                    log(4)\n                    delay(100)\n                    throw ArithmeticException(&quot;Hello&quot;)\n                }\n                log(5)\n            }\n            log(6)\n            val job = launch {\n                log(7)\n                delay(1000)\n            }\n            try {\n                log(8)\n                job.join()\n                log(9)\n            } catch (e: Exception) {\n                log(&quot;10 $e&quot;)\n            }\n        }\n        log(11)\n    } catch (e: Exception) {\n        log(&quot;12 $e&quot;)\n    }\n    log(13)\n}\n</code></pre>\n<pre><code class=\"tex\">1\n2\n6\n3\n5\n4\n8\n7\nCoroutineName(2) java.lang.ArithmeticException: Hello\n9\n11\n13\n</code></pre>\n<p>我们看到，触发<code>CoroutineExceptionHandler</code> 的是协程 2。</p>\n<h3 id=\"如何使用-scope\"><a href=\"#如何使用-scope\" class=\"headerlink\" title=\"如何使用 scope\"></a>如何使用 scope</h3><ul>\n<li>对于没有协程作用域，但需要启动协程的时候，适合用 <strong>GlobalScope</strong></li>\n<li>对于已经由协程作用域的情况，直接用协程启动器启动</li>\n<li>对于明确要求子协程之间互相独立不干扰时，使用 <strong>supervisorScope</strong></li>\n<li>对于通过标准库 API 创建的协程，这样的协程比较底层，没有 <code>Job</code> 作用域等概念的支撑，例如 <code>suspernd main</code> ，有限考虑通过 <code>coroutineScope</code> 创建作用域</li>\n</ul>\n<h2 id=\"join-和-await\"><a href=\"#join-和-await\" class=\"headerlink\" title=\"join 和 await\"></a>join 和 await</h2><p>前面的例子一直是用 <code>launch</code> 启动协程常用的还有 <code>async</code>, <code>actor</code> <code>produce</code> 其中 <code>actor</code> 和 <code>launch</code> 的行为类似，在未捕获异常出现以后，会抛出。而 <code>async</code> 和 <code>produce</code> 则主要是用来输出结果的，它们内部的异常只在外部消费他们的记过时才抛出。</p>\n<h3 id=\"什么是消费结果\"><a href=\"#什么是消费结果\" class=\"headerlink\" title=\"什么是消费结果\"></a>什么是消费结果</h3><p>两组协程启动器，我们可以分别认为是 <em>消费者</em> 和 <em>生产者</em> </p>\n<p>消费者异常立即抛出；生产者只有结果异常时抛出</p>\n<h3 id=\"async-和-await\"><a href=\"#async-和-await\" class=\"headerlink\" title=\"async 和 await\"></a><strong>async 和 await</strong></h3><pre><code class=\"kotlin\">suspend fun main() {\n    val deferred = GlobalScope.async&lt;Int&gt; {\n        throw ArithmeticException()\n    }\n    try {\n        val value = deferred.await()\n        log(&quot;1. $value&quot;)\n    } catch (e: Exception) {\n        log(&quot;2. $e&quot;)\n    }\n}\n</code></pre>\n<p>当我们调用 <code>await</code> 时，期望 <code>deferred</code> 能够给我们一个合适的结果，但是它发生了异常，没有办法左到， 随后就抛出一个异常给我们</p>\n<pre><code class=\"tex\">2. java.lang.ArithmeticException\n</code></pre>\n<h3 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join\"></a>join</h3><p><code>join</code> 则和 <code>await</code> 不同， <code>join</code> 只关心是否执行完，至于为什么完成，它不关心。将上面的 <code>await</code> 替换成 <code>join</code> 后 </p>\n<pre><code class=\"tex\">1. kotlin.Unit\n</code></pre>\n<p>异常信息被吞掉了，用 <code>launch</code> 替换 <code>async</code> ，<code>join</code> 处仍然不会有任何响应。</p>\n<p><code>launch</code> 中未捕获的异常与 <code>aysync</code> 的处理方式不同， <code>launch</code> 会直接抛出异常给父协程，如果没有父协程或者处于 <code>supervisorScope</code> 中父协程不响应，那么就会交给上下文中执行的 <code>CoroutineExceptionHandler</code> 处理，如果没有指定，那就传给全局的 <code>CoroutineExcetionHandler</code> 等等。而 <code>async</code>  则要等 <code>await</code> 来消费</p>"},{"title":"协程挂起","_content":"\n\n\n## Delay\n\n* 线程: `Thread.sleep()`\n\n  `sleep` 让线程进入休眠状态,直到指定的时间之后某种信号或者达到某个条件,线程就会尝试恢复执行\n\n* 协程: `delay` \n\n  `delay` 会让协程挂起,这个过程并不会阻塞 CPU,甚至可以说从硬件使用效率上讲是\"什么都不耽误\", 从这个意义上讲 `delay` 也可以要让协程休眠的一种手段\n<!-- more-->\n  ```kotlin\n  public suspend fun delay(timeMillis: Long) {\n      if(timeMillis <= 0) return\n      return suspendCancellableCoroutine sc@ {cont: CancellableContinuation<Unit> -> \n      \tcont.context.delay.scheduleResumeAfterDelay(timeMillis, cont)\n  \t}\n  }\n  ```\n\n   `cont.context.delay.scheduleResumeAfterDelay` 这个操作,可以类比 Android 的 `handler.postDealy` ,本质上就是设置了一个延时回调,时间一到就调用 `resume` 方法让协程继续执行\n\n  \n\n  \n\n\n\n## SuspendCancellableCoroutine\n\n```kotlin\n    public final override suspend fun join() {\n        if (!joinInternal()) { // fast-path no wait\n            coroutineContext.checkCompletion()\n            return // do not suspend\n        }\n        return joinSuspend() // slow-path wait\n    }\n\n    private suspend fun joinSuspend() = suspendCancellableCoroutine<Unit> { cont ->\n        // We have to invoke join() handler only on cancellation, on completion we will be resumed regularly without handlers\n        cont.disposeOnCancellation(invokeOnCompletion(handler = ResumeOnCompletion(this, cont).asHandler))\n    }\n```\n\n`Job.join()` 这个方法会先检查调用者 `Job` 的状态是否已经完成，如果试，就直接返回并继续执行后面的代码而不再挂起，否则就走 `joinSuspend` 。这里只注册了一个完成时的回调\n\n\n\n```kotlin\npublic suspend inline fun <T> suspendCancellableCoroutine(crossinline block: (CancellableContinuation<T>)-> Unit):T = suspendCoroutineUninterceptedOrReturn{ uCont->\n    val cancelable = CancellableContinuationImpl(uCont.intercepted(), resumeMode = MODE_CANCELLABLE)\n    block(cancellable)\n    cancellable.getResult()\n}\n```\n\n`suspendCoroutineUninterceptedOrReturn` 这个方法帮助我们拿到 `Continuation` 实例，`suspendCoroutineUninterceptedOrReturn` 的返回值类型是 T, 而传入的 lambda  的返回值类型是 Any?,也就是 `cancellable.getResult()` 的类型。\n\n```kotlin\ninternal fun getResult() :Any? {\n    if(trySuspend()) return COROUTINE_SUSPEND // 触发挂起逻辑\n    \n    if(state is CompletedExceptionally) // 异常立即抛出\n    \tthrow recoverStackTrce(state.cause, this)\n    return getSuccessfulResult(state) // 正常结果立即返回\n}\n```\n\n`trySuspend()` 就是挂起逻辑，表示这个时候目标协程还没有执行完，需要等待结果。\n\n然后判断条件是协程已经执行完，可以直接拿到异常和正常结果的两种情况。\n\n```kotlin\npublic vla COROUTINE_SUSPEND: Any get() = CoroutineSingletons.COROUTINE_SUSPEND\n\ninternal enum class CoroutineSingletons {CONTINE_SUSPEND, UNDECIDED, RESUMED}\n```\n\n而 `trySuspend()` 返回的就是一个单例，任何时间协程见到它，就直到自己该挂起了。\n\n## 深入挂起操作\n\n真正的挂起是什么？\n\n```kotlin\nsuspend fun hello() = suspendCoroutineUninterceptedOrReturn<Int> {\n    continuation ->\n    log(1)\n    thread {\n        Thread.sleep(1000)\n        log(2)\n        continuation.resume(1024)\n    }\n    log(3)\n    CONTROUTINE_SUSPEND\n}\n```\n\n上面这一个 `suspend` 函数，在 `suspendCoroutineUninterceptedOrReturn` 当中直接返回这个 `COROUTINE_SUSPEND`\n\n## 协程的状态转移\n\n```java\npublic class ContinuationImpl implements Continuation<Object> {\n    private int label = 0;\n    private final Continuation<Unit> completion;\n    \n    public ContinuationImpl(Continuation<Unit> completion) {\n        this.completion = completion;\n    }\n    \n    @Override\n    public CoroutineContext getContext() {\n        return EmptyCoroutineContext.INSTANCE;\n    }\n    \n    @Override\n    public void resumeWith(@NotNull Object o) {\n        try {\n            Object resume = o;\n            switch(label) {\n                case 0: \n                    LogKt.log(1)\n                    result = SuspendFunctionsKt.returnSuspended(this);\n                    label++;\n                    if(isSuspended(result)) return;\n\t\t\t   case 1:\n                    LogKt.log(result);\n                    LogKt.log(2)\n                    result = DelayKt.delay(1000, this);\n                    label++;\n                    if(isSuspended(result)) return;\n                case 2:\n                    LogKt.log(3)\n                        result = SuspendedFunctionsKt.returnImmediately(this);\n                    label++;\n                    if(isSuspended(result)) return;\n                case 3:\n                    LogKt.log(result);\n                    LogKt.log(4)\n            }\n        }\n        completion.resumeWith(Unit.INSTACNE);\n    } catch (Exception e){\n        completion.resumeWith(e)\n    }\n}\n\nprivate boolean isSuspended(Object result) {\n    return result == IntrinsicsKt.getCOROUTINE_SUSPENDED();\n}\n```\n\n> 实际上，在 Kotlin 的标准库中，有一个 `ContinuationImpl` 的累，只不过，它的 `resumeWith` 最终调用到了 `invokeSuspend` 而这个 `invokeSuspend` 实际上就是我们的协程体，通常也就是要给 Lamdba 表达式，我们通过 `launch` 启动协程，传入的 Lambda 表达式，实际上会被编译成一个 `SuspendLambda`  的子类，而它又是 `ContinuationImpl` 的子类。\n\n仿照 `runSuspend` 类，我们实现一个 completion \n\n```java\npublic class RunSuspend implements Continuation<Unit> {\n    private Object result;\n    \n    @Override\n    public CoroutineContext getContext(){\n        return EmptyCoroutineContext.INSTANCE;\n    }\n    \n    @Override\n    public void resumeWith(@NotNull Object result) {\n        synchronized(this) {\n            this.result = result;\n            notifyAll();// 协程已结束，通知下面的 wait() 方法停止阻塞\n        }\n    }\n    \n    public void await() throws Throwable {\n        synchronized(this) {\n            while(true) {\n                Object result = this.result;\n                if(result == null) wait();// 调用了 Object。wait() ，阻塞当前线程，在 notify 或者 notifyAll 调用时返回\n                else if(result instanceof Throwable) {\n                    throw (Throwable) result;\n                } else return;\n            }\n        }\n    }\n}\n```\n\n```java\npublic static void main(String...args) throws Throwable {\n    RunSuspend runSuspend = new RunSuspend();\n    ContinationImpl table = new ContinuationImpl(runSuspend);\n    table.resumeWith(Unit.INSTANCE);\n    runSuspend.await();\n}\n```\n\n> 这种写法，简直就是 `suspend main` 的真是面目。\n\n`completion` 传入的 `runSuspend` 实例的 `resumeWith` 实际上是在 `ContinuationImpl` 的 `resumeWith` 的最后才被调用，因为它的 `await()` 一旦进入阻塞状态，直到 `ContinuationImpl` 的整体状态流转完毕才会停止阻塞，此时进程也就运行完毕，可以退出了。\n\n","source":"_posts/Kotlin/协程/协程-挂起.md","raw":"---\ntitle: 协程挂起\ntag: Kotlin\n\n---\n\n\n\n## Delay\n\n* 线程: `Thread.sleep()`\n\n  `sleep` 让线程进入休眠状态,直到指定的时间之后某种信号或者达到某个条件,线程就会尝试恢复执行\n\n* 协程: `delay` \n\n  `delay` 会让协程挂起,这个过程并不会阻塞 CPU,甚至可以说从硬件使用效率上讲是\"什么都不耽误\", 从这个意义上讲 `delay` 也可以要让协程休眠的一种手段\n<!-- more-->\n  ```kotlin\n  public suspend fun delay(timeMillis: Long) {\n      if(timeMillis <= 0) return\n      return suspendCancellableCoroutine sc@ {cont: CancellableContinuation<Unit> -> \n      \tcont.context.delay.scheduleResumeAfterDelay(timeMillis, cont)\n  \t}\n  }\n  ```\n\n   `cont.context.delay.scheduleResumeAfterDelay` 这个操作,可以类比 Android 的 `handler.postDealy` ,本质上就是设置了一个延时回调,时间一到就调用 `resume` 方法让协程继续执行\n\n  \n\n  \n\n\n\n## SuspendCancellableCoroutine\n\n```kotlin\n    public final override suspend fun join() {\n        if (!joinInternal()) { // fast-path no wait\n            coroutineContext.checkCompletion()\n            return // do not suspend\n        }\n        return joinSuspend() // slow-path wait\n    }\n\n    private suspend fun joinSuspend() = suspendCancellableCoroutine<Unit> { cont ->\n        // We have to invoke join() handler only on cancellation, on completion we will be resumed regularly without handlers\n        cont.disposeOnCancellation(invokeOnCompletion(handler = ResumeOnCompletion(this, cont).asHandler))\n    }\n```\n\n`Job.join()` 这个方法会先检查调用者 `Job` 的状态是否已经完成，如果试，就直接返回并继续执行后面的代码而不再挂起，否则就走 `joinSuspend` 。这里只注册了一个完成时的回调\n\n\n\n```kotlin\npublic suspend inline fun <T> suspendCancellableCoroutine(crossinline block: (CancellableContinuation<T>)-> Unit):T = suspendCoroutineUninterceptedOrReturn{ uCont->\n    val cancelable = CancellableContinuationImpl(uCont.intercepted(), resumeMode = MODE_CANCELLABLE)\n    block(cancellable)\n    cancellable.getResult()\n}\n```\n\n`suspendCoroutineUninterceptedOrReturn` 这个方法帮助我们拿到 `Continuation` 实例，`suspendCoroutineUninterceptedOrReturn` 的返回值类型是 T, 而传入的 lambda  的返回值类型是 Any?,也就是 `cancellable.getResult()` 的类型。\n\n```kotlin\ninternal fun getResult() :Any? {\n    if(trySuspend()) return COROUTINE_SUSPEND // 触发挂起逻辑\n    \n    if(state is CompletedExceptionally) // 异常立即抛出\n    \tthrow recoverStackTrce(state.cause, this)\n    return getSuccessfulResult(state) // 正常结果立即返回\n}\n```\n\n`trySuspend()` 就是挂起逻辑，表示这个时候目标协程还没有执行完，需要等待结果。\n\n然后判断条件是协程已经执行完，可以直接拿到异常和正常结果的两种情况。\n\n```kotlin\npublic vla COROUTINE_SUSPEND: Any get() = CoroutineSingletons.COROUTINE_SUSPEND\n\ninternal enum class CoroutineSingletons {CONTINE_SUSPEND, UNDECIDED, RESUMED}\n```\n\n而 `trySuspend()` 返回的就是一个单例，任何时间协程见到它，就直到自己该挂起了。\n\n## 深入挂起操作\n\n真正的挂起是什么？\n\n```kotlin\nsuspend fun hello() = suspendCoroutineUninterceptedOrReturn<Int> {\n    continuation ->\n    log(1)\n    thread {\n        Thread.sleep(1000)\n        log(2)\n        continuation.resume(1024)\n    }\n    log(3)\n    CONTROUTINE_SUSPEND\n}\n```\n\n上面这一个 `suspend` 函数，在 `suspendCoroutineUninterceptedOrReturn` 当中直接返回这个 `COROUTINE_SUSPEND`\n\n## 协程的状态转移\n\n```java\npublic class ContinuationImpl implements Continuation<Object> {\n    private int label = 0;\n    private final Continuation<Unit> completion;\n    \n    public ContinuationImpl(Continuation<Unit> completion) {\n        this.completion = completion;\n    }\n    \n    @Override\n    public CoroutineContext getContext() {\n        return EmptyCoroutineContext.INSTANCE;\n    }\n    \n    @Override\n    public void resumeWith(@NotNull Object o) {\n        try {\n            Object resume = o;\n            switch(label) {\n                case 0: \n                    LogKt.log(1)\n                    result = SuspendFunctionsKt.returnSuspended(this);\n                    label++;\n                    if(isSuspended(result)) return;\n\t\t\t   case 1:\n                    LogKt.log(result);\n                    LogKt.log(2)\n                    result = DelayKt.delay(1000, this);\n                    label++;\n                    if(isSuspended(result)) return;\n                case 2:\n                    LogKt.log(3)\n                        result = SuspendedFunctionsKt.returnImmediately(this);\n                    label++;\n                    if(isSuspended(result)) return;\n                case 3:\n                    LogKt.log(result);\n                    LogKt.log(4)\n            }\n        }\n        completion.resumeWith(Unit.INSTACNE);\n    } catch (Exception e){\n        completion.resumeWith(e)\n    }\n}\n\nprivate boolean isSuspended(Object result) {\n    return result == IntrinsicsKt.getCOROUTINE_SUSPENDED();\n}\n```\n\n> 实际上，在 Kotlin 的标准库中，有一个 `ContinuationImpl` 的累，只不过，它的 `resumeWith` 最终调用到了 `invokeSuspend` 而这个 `invokeSuspend` 实际上就是我们的协程体，通常也就是要给 Lamdba 表达式，我们通过 `launch` 启动协程，传入的 Lambda 表达式，实际上会被编译成一个 `SuspendLambda`  的子类，而它又是 `ContinuationImpl` 的子类。\n\n仿照 `runSuspend` 类，我们实现一个 completion \n\n```java\npublic class RunSuspend implements Continuation<Unit> {\n    private Object result;\n    \n    @Override\n    public CoroutineContext getContext(){\n        return EmptyCoroutineContext.INSTANCE;\n    }\n    \n    @Override\n    public void resumeWith(@NotNull Object result) {\n        synchronized(this) {\n            this.result = result;\n            notifyAll();// 协程已结束，通知下面的 wait() 方法停止阻塞\n        }\n    }\n    \n    public void await() throws Throwable {\n        synchronized(this) {\n            while(true) {\n                Object result = this.result;\n                if(result == null) wait();// 调用了 Object。wait() ，阻塞当前线程，在 notify 或者 notifyAll 调用时返回\n                else if(result instanceof Throwable) {\n                    throw (Throwable) result;\n                } else return;\n            }\n        }\n    }\n}\n```\n\n```java\npublic static void main(String...args) throws Throwable {\n    RunSuspend runSuspend = new RunSuspend();\n    ContinationImpl table = new ContinuationImpl(runSuspend);\n    table.resumeWith(Unit.INSTANCE);\n    runSuspend.await();\n}\n```\n\n> 这种写法，简直就是 `suspend main` 的真是面目。\n\n`completion` 传入的 `runSuspend` 实例的 `resumeWith` 实际上是在 `ContinuationImpl` 的 `resumeWith` 的最后才被调用，因为它的 `await()` 一旦进入阻塞状态，直到 `ContinuationImpl` 的整体状态流转完毕才会停止阻塞，此时进程也就运行完毕，可以退出了。\n\n","slug":"Kotlin/协程/协程-挂起","published":1,"date":"2021-01-29T15:54:28.318Z","updated":"2021-01-29T16:16:05.224Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8lc003vsz5q6ipixond","content":"<h2 id=\"Delay\"><a href=\"#Delay\" class=\"headerlink\" title=\"Delay\"></a>Delay</h2><ul>\n<li><p>线程: <code>Thread.sleep()</code></p>\n<p><code>sleep</code> 让线程进入休眠状态,直到指定的时间之后某种信号或者达到某个条件,线程就会尝试恢复执行</p>\n</li>\n<li><p>协程: <code>delay</code> </p>\n<p><code>delay</code> 会让协程挂起,这个过程并不会阻塞 CPU,甚至可以说从硬件使用效率上讲是”什么都不耽误”, 从这个意义上讲 <code>delay</code> 也可以要让协程休眠的一种手段</p>\n<a id=\"more\"></a>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">public</span> suspend <span class=\"token keyword\">fun</span> <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span>timeMillis<span class=\"token operator\">:</span> Long<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>timeMillis <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span>\n    <span class=\"token keyword\">return</span> suspendCancellableCoroutine <span class=\"token label symbol\">sc@</span> <span class=\"token punctuation\">{</span>cont<span class=\"token operator\">:</span> CancellableContinuation<span class=\"token operator\">&lt;</span>Unit<span class=\"token operator\">></span> <span class=\"token operator\">-></span> \n        cont<span class=\"token punctuation\">.</span>context<span class=\"token punctuation\">.</span>delay<span class=\"token punctuation\">.</span><span class=\"token function\">scheduleResumeAfterDelay</span><span class=\"token punctuation\">(</span>timeMillis<span class=\"token punctuation\">,</span> cont<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p> <code>cont.context.delay.scheduleResumeAfterDelay</code> 这个操作,可以类比 Android 的 <code>handler.postDealy</code> ,本质上就是设置了一个延时回调,时间一到就调用 <code>resume</code> 方法让协程继续执行</p>\n</li>\n</ul>\n<h2 id=\"SuspendCancellableCoroutine\"><a href=\"#SuspendCancellableCoroutine\" class=\"headerlink\" title=\"SuspendCancellableCoroutine\"></a>SuspendCancellableCoroutine</h2><pre class=\" language-kotlin\"><code class=\"language-kotlin\">    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">override</span> suspend <span class=\"token keyword\">fun</span> <span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">joinInternal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// fast-path no wait</span>\n            coroutineContext<span class=\"token punctuation\">.</span><span class=\"token function\">checkCompletion</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token comment\" spellcheck=\"true\">// do not suspend</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">joinSuspend</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// slow-path wait</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> suspend <span class=\"token keyword\">fun</span> <span class=\"token function\">joinSuspend</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> suspendCancellableCoroutine<span class=\"token operator\">&lt;</span>Unit<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> cont <span class=\"token operator\">-></span>\n        <span class=\"token comment\" spellcheck=\"true\">// We have to invoke join() handler only on cancellation, on completion we will be resumed regularly without handlers</span>\n        cont<span class=\"token punctuation\">.</span><span class=\"token function\">disposeOnCancellation</span><span class=\"token punctuation\">(</span><span class=\"token function\">invokeOnCompletion</span><span class=\"token punctuation\">(</span>handler <span class=\"token operator\">=</span> <span class=\"token function\">ResumeOnCompletion</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> cont<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>asHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p><code>Job.join()</code> 这个方法会先检查调用者 <code>Job</code> 的状态是否已经完成，如果试，就直接返回并继续执行后面的代码而不再挂起，否则就走 <code>joinSuspend</code> 。这里只注册了一个完成时的回调</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">public</span> suspend <span class=\"token keyword\">inline</span> <span class=\"token keyword\">fun</span> <span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">suspendCancellableCoroutine</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">crossinline</span> block<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>CancellableContinuation<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span> Unit<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>T <span class=\"token operator\">=</span> suspendCoroutineUninterceptedOrReturn<span class=\"token punctuation\">{</span> uCont<span class=\"token operator\">-></span>\n    <span class=\"token keyword\">val</span> cancelable <span class=\"token operator\">=</span> <span class=\"token function\">CancellableContinuationImpl</span><span class=\"token punctuation\">(</span>uCont<span class=\"token punctuation\">.</span><span class=\"token function\">intercepted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> resumeMode <span class=\"token operator\">=</span> MODE_CANCELLABLE<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">block</span><span class=\"token punctuation\">(</span>cancellable<span class=\"token punctuation\">)</span>\n    cancellable<span class=\"token punctuation\">.</span><span class=\"token function\">getResult</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><code>suspendCoroutineUninterceptedOrReturn</code> 这个方法帮助我们拿到 <code>Continuation</code> 实例，<code>suspendCoroutineUninterceptedOrReturn</code> 的返回值类型是 T, 而传入的 lambda  的返回值类型是 Any?,也就是 <code>cancellable.getResult()</code> 的类型。</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">internal</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">getResult</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span>Any<span class=\"token operator\">?</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">trySuspend</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> COROUTINE_SUSPEND <span class=\"token comment\" spellcheck=\"true\">// 触发挂起逻辑</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>state <span class=\"token keyword\">is</span> CompletedExceptionally<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 异常立即抛出</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token function\">recoverStackTrce</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">.</span>cause<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">getSuccessfulResult</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 正常结果立即返回</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><code>trySuspend()</code> 就是挂起逻辑，表示这个时候目标协程还没有执行完，需要等待结果。</p>\n<p>然后判断条件是协程已经执行完，可以直接拿到异常和正常结果的两种情况。</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">public</span> vla COROUTINE_SUSPEND<span class=\"token operator\">:</span> Any <span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> CoroutineSingletons<span class=\"token punctuation\">.</span>COROUTINE_SUSPEND\n\n<span class=\"token keyword\">internal</span> <span class=\"token keyword\">enum</span> <span class=\"token keyword\">class</span> CoroutineSingletons <span class=\"token punctuation\">{</span>CONTINE_SUSPEND<span class=\"token punctuation\">,</span> UNDECIDED<span class=\"token punctuation\">,</span> RESUMED<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>而 <code>trySuspend()</code> 返回的就是一个单例，任何时间协程见到它，就直到自己该挂起了。</p>\n<h2 id=\"深入挂起操作\"><a href=\"#深入挂起操作\" class=\"headerlink\" title=\"深入挂起操作\"></a>深入挂起操作</h2><p>真正的挂起是什么？</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\">suspend <span class=\"token keyword\">fun</span> <span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> suspendCoroutineUninterceptedOrReturn<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    continuation <span class=\"token operator\">-></span>\n    <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    thread <span class=\"token punctuation\">{</span>\n        Thread<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n        continuation<span class=\"token punctuation\">.</span><span class=\"token function\">resume</span><span class=\"token punctuation\">(</span><span class=\"token number\">1024</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n    CONTROUTINE_SUSPEND\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>上面这一个 <code>suspend</code> 函数，在 <code>suspendCoroutineUninterceptedOrReturn</code> 当中直接返回这个 <code>COROUTINE_SUSPEND</code></p>\n<h2 id=\"协程的状态转移\"><a href=\"#协程的状态转移\" class=\"headerlink\" title=\"协程的状态转移\"></a>协程的状态转移</h2><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ContinuationImpl</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Continuation</span><span class=\"token operator\">&lt;</span>Object<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> label <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> Continuation<span class=\"token operator\">&lt;</span>Unit<span class=\"token operator\">></span> completion<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">ContinuationImpl</span><span class=\"token punctuation\">(</span>Continuation<span class=\"token operator\">&lt;</span>Unit<span class=\"token operator\">></span> completion<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>completion <span class=\"token operator\">=</span> completion<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> CoroutineContext <span class=\"token function\">getContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> EmptyCoroutineContext<span class=\"token punctuation\">.</span>INSTANCE<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">resumeWith</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@NotNull</span> Object o<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            Object resume <span class=\"token operator\">=</span> o<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">switch</span><span class=\"token punctuation\">(</span>label<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">case</span> <span class=\"token number\">0</span><span class=\"token operator\">:</span> \n                    LogKt<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n                    result <span class=\"token operator\">=</span> SuspendFunctionsKt<span class=\"token punctuation\">.</span><span class=\"token function\">returnSuspended</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    label<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">isSuspended</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n               <span class=\"token keyword\">case</span> <span class=\"token number\">1</span><span class=\"token operator\">:</span>\n                    LogKt<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    LogKt<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n                    result <span class=\"token operator\">=</span> DelayKt<span class=\"token punctuation\">.</span><span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    label<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">isSuspended</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">case</span> <span class=\"token number\">2</span><span class=\"token operator\">:</span>\n                    LogKt<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n                        result <span class=\"token operator\">=</span> SuspendedFunctionsKt<span class=\"token punctuation\">.</span><span class=\"token function\">returnImmediately</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    label<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">isSuspended</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">case</span> <span class=\"token number\">3</span><span class=\"token operator\">:</span>\n                    LogKt<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    LogKt<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        completion<span class=\"token punctuation\">.</span><span class=\"token function\">resumeWith</span><span class=\"token punctuation\">(</span>Unit<span class=\"token punctuation\">.</span>INSTACNE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        completion<span class=\"token punctuation\">.</span><span class=\"token function\">resumeWith</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isSuspended</span><span class=\"token punctuation\">(</span>Object result<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> result <span class=\"token operator\">==</span> IntrinsicsKt<span class=\"token punctuation\">.</span><span class=\"token function\">getCOROUTINE_SUSPENDED</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<blockquote>\n<p>实际上，在 Kotlin 的标准库中，有一个 <code>ContinuationImpl</code> 的累，只不过，它的 <code>resumeWith</code> 最终调用到了 <code>invokeSuspend</code> 而这个 <code>invokeSuspend</code> 实际上就是我们的协程体，通常也就是要给 Lamdba 表达式，我们通过 <code>launch</code> 启动协程，传入的 Lambda 表达式，实际上会被编译成一个 <code>SuspendLambda</code>  的子类，而它又是 <code>ContinuationImpl</code> 的子类。</p>\n</blockquote>\n<p>仿照 <code>runSuspend</code> 类，我们实现一个 completion </p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RunSuspend</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Continuation</span><span class=\"token operator\">&lt;</span>Unit<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> Object result<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> CoroutineContext <span class=\"token function\">getContext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> EmptyCoroutineContext<span class=\"token punctuation\">.</span>INSTANCE<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">resumeWith</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@NotNull</span> Object result<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">synchronized</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>result <span class=\"token operator\">=</span> result<span class=\"token punctuation\">;</span>\n            <span class=\"token function\">notifyAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// 协程已结束，通知下面的 wait() 方法停止阻塞</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Throwable <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">synchronized</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                Object result <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>result<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>result <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// 调用了 Object。wait() ，阻塞当前线程，在 notify 或者 notifyAll 调用时返回</span>\n                <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>result <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Throwable</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">throw</span> <span class=\"token punctuation\">(</span>Throwable<span class=\"token punctuation\">)</span> result<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Throwable <span class=\"token punctuation\">{</span>\n    RunSuspend runSuspend <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RunSuspend</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ContinationImpl table <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ContinuationImpl</span><span class=\"token punctuation\">(</span>runSuspend<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    table<span class=\"token punctuation\">.</span><span class=\"token function\">resumeWith</span><span class=\"token punctuation\">(</span>Unit<span class=\"token punctuation\">.</span>INSTANCE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    runSuspend<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<blockquote>\n<p>这种写法，简直就是 <code>suspend main</code> 的真是面目。</p>\n</blockquote>\n<p><code>completion</code> 传入的 <code>runSuspend</code> 实例的 <code>resumeWith</code> 实际上是在 <code>ContinuationImpl</code> 的 <code>resumeWith</code> 的最后才被调用，因为它的 <code>await()</code> 一旦进入阻塞状态，直到 <code>ContinuationImpl</code> 的整体状态流转完毕才会停止阻塞，此时进程也就运行完毕，可以退出了。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Delay\"><a href=\"#Delay\" class=\"headerlink\" title=\"Delay\"></a>Delay</h2><ul>\n<li><p>线程: <code>Thread.sleep()</code></p>\n<p><code>sleep</code> 让线程进入休眠状态,直到指定的时间之后某种信号或者达到某个条件,线程就会尝试恢复执行</p>\n</li>\n<li><p>协程: <code>delay</code> </p>\n<p><code>delay</code> 会让协程挂起,这个过程并不会阻塞 CPU,甚至可以说从硬件使用效率上讲是”什么都不耽误”, 从这个意义上讲 <code>delay</code> 也可以要让协程休眠的一种手段</p>","more":"<pre><code class=\"kotlin\">public suspend fun delay(timeMillis: Long) {\n    if(timeMillis &lt;= 0) return\n    return suspendCancellableCoroutine sc@ {cont: CancellableContinuation&lt;Unit&gt; -&gt; \n        cont.context.delay.scheduleResumeAfterDelay(timeMillis, cont)\n    }\n}\n</code></pre>\n<p> <code>cont.context.delay.scheduleResumeAfterDelay</code> 这个操作,可以类比 Android 的 <code>handler.postDealy</code> ,本质上就是设置了一个延时回调,时间一到就调用 <code>resume</code> 方法让协程继续执行</p>\n</li>\n</ul>\n<h2 id=\"SuspendCancellableCoroutine\"><a href=\"#SuspendCancellableCoroutine\" class=\"headerlink\" title=\"SuspendCancellableCoroutine\"></a>SuspendCancellableCoroutine</h2><pre><code class=\"kotlin\">    public final override suspend fun join() {\n        if (!joinInternal()) { // fast-path no wait\n            coroutineContext.checkCompletion()\n            return // do not suspend\n        }\n        return joinSuspend() // slow-path wait\n    }\n\n    private suspend fun joinSuspend() = suspendCancellableCoroutine&lt;Unit&gt; { cont -&gt;\n        // We have to invoke join() handler only on cancellation, on completion we will be resumed regularly without handlers\n        cont.disposeOnCancellation(invokeOnCompletion(handler = ResumeOnCompletion(this, cont).asHandler))\n    }\n</code></pre>\n<p><code>Job.join()</code> 这个方法会先检查调用者 <code>Job</code> 的状态是否已经完成，如果试，就直接返回并继续执行后面的代码而不再挂起，否则就走 <code>joinSuspend</code> 。这里只注册了一个完成时的回调</p>\n<pre><code class=\"kotlin\">public suspend inline fun &lt;T&gt; suspendCancellableCoroutine(crossinline block: (CancellableContinuation&lt;T&gt;)-&gt; Unit):T = suspendCoroutineUninterceptedOrReturn{ uCont-&gt;\n    val cancelable = CancellableContinuationImpl(uCont.intercepted(), resumeMode = MODE_CANCELLABLE)\n    block(cancellable)\n    cancellable.getResult()\n}\n</code></pre>\n<p><code>suspendCoroutineUninterceptedOrReturn</code> 这个方法帮助我们拿到 <code>Continuation</code> 实例，<code>suspendCoroutineUninterceptedOrReturn</code> 的返回值类型是 T, 而传入的 lambda  的返回值类型是 Any?,也就是 <code>cancellable.getResult()</code> 的类型。</p>\n<pre><code class=\"kotlin\">internal fun getResult() :Any? {\n    if(trySuspend()) return COROUTINE_SUSPEND // 触发挂起逻辑\n\n    if(state is CompletedExceptionally) // 异常立即抛出\n        throw recoverStackTrce(state.cause, this)\n    return getSuccessfulResult(state) // 正常结果立即返回\n}\n</code></pre>\n<p><code>trySuspend()</code> 就是挂起逻辑，表示这个时候目标协程还没有执行完，需要等待结果。</p>\n<p>然后判断条件是协程已经执行完，可以直接拿到异常和正常结果的两种情况。</p>\n<pre><code class=\"kotlin\">public vla COROUTINE_SUSPEND: Any get() = CoroutineSingletons.COROUTINE_SUSPEND\n\ninternal enum class CoroutineSingletons {CONTINE_SUSPEND, UNDECIDED, RESUMED}\n</code></pre>\n<p>而 <code>trySuspend()</code> 返回的就是一个单例，任何时间协程见到它，就直到自己该挂起了。</p>\n<h2 id=\"深入挂起操作\"><a href=\"#深入挂起操作\" class=\"headerlink\" title=\"深入挂起操作\"></a>深入挂起操作</h2><p>真正的挂起是什么？</p>\n<pre><code class=\"kotlin\">suspend fun hello() = suspendCoroutineUninterceptedOrReturn&lt;Int&gt; {\n    continuation -&gt;\n    log(1)\n    thread {\n        Thread.sleep(1000)\n        log(2)\n        continuation.resume(1024)\n    }\n    log(3)\n    CONTROUTINE_SUSPEND\n}\n</code></pre>\n<p>上面这一个 <code>suspend</code> 函数，在 <code>suspendCoroutineUninterceptedOrReturn</code> 当中直接返回这个 <code>COROUTINE_SUSPEND</code></p>\n<h2 id=\"协程的状态转移\"><a href=\"#协程的状态转移\" class=\"headerlink\" title=\"协程的状态转移\"></a>协程的状态转移</h2><pre><code class=\"java\">public class ContinuationImpl implements Continuation&lt;Object&gt; {\n    private int label = 0;\n    private final Continuation&lt;Unit&gt; completion;\n\n    public ContinuationImpl(Continuation&lt;Unit&gt; completion) {\n        this.completion = completion;\n    }\n\n    @Override\n    public CoroutineContext getContext() {\n        return EmptyCoroutineContext.INSTANCE;\n    }\n\n    @Override\n    public void resumeWith(@NotNull Object o) {\n        try {\n            Object resume = o;\n            switch(label) {\n                case 0: \n                    LogKt.log(1)\n                    result = SuspendFunctionsKt.returnSuspended(this);\n                    label++;\n                    if(isSuspended(result)) return;\n               case 1:\n                    LogKt.log(result);\n                    LogKt.log(2)\n                    result = DelayKt.delay(1000, this);\n                    label++;\n                    if(isSuspended(result)) return;\n                case 2:\n                    LogKt.log(3)\n                        result = SuspendedFunctionsKt.returnImmediately(this);\n                    label++;\n                    if(isSuspended(result)) return;\n                case 3:\n                    LogKt.log(result);\n                    LogKt.log(4)\n            }\n        }\n        completion.resumeWith(Unit.INSTACNE);\n    } catch (Exception e){\n        completion.resumeWith(e)\n    }\n}\n\nprivate boolean isSuspended(Object result) {\n    return result == IntrinsicsKt.getCOROUTINE_SUSPENDED();\n}\n</code></pre>\n<blockquote>\n<p>实际上，在 Kotlin 的标准库中，有一个 <code>ContinuationImpl</code> 的累，只不过，它的 <code>resumeWith</code> 最终调用到了 <code>invokeSuspend</code> 而这个 <code>invokeSuspend</code> 实际上就是我们的协程体，通常也就是要给 Lamdba 表达式，我们通过 <code>launch</code> 启动协程，传入的 Lambda 表达式，实际上会被编译成一个 <code>SuspendLambda</code>  的子类，而它又是 <code>ContinuationImpl</code> 的子类。</p>\n</blockquote>\n<p>仿照 <code>runSuspend</code> 类，我们实现一个 completion </p>\n<pre><code class=\"java\">public class RunSuspend implements Continuation&lt;Unit&gt; {\n    private Object result;\n\n    @Override\n    public CoroutineContext getContext(){\n        return EmptyCoroutineContext.INSTANCE;\n    }\n\n    @Override\n    public void resumeWith(@NotNull Object result) {\n        synchronized(this) {\n            this.result = result;\n            notifyAll();// 协程已结束，通知下面的 wait() 方法停止阻塞\n        }\n    }\n\n    public void await() throws Throwable {\n        synchronized(this) {\n            while(true) {\n                Object result = this.result;\n                if(result == null) wait();// 调用了 Object。wait() ，阻塞当前线程，在 notify 或者 notifyAll 调用时返回\n                else if(result instanceof Throwable) {\n                    throw (Throwable) result;\n                } else return;\n            }\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"java\">public static void main(String...args) throws Throwable {\n    RunSuspend runSuspend = new RunSuspend();\n    ContinationImpl table = new ContinuationImpl(runSuspend);\n    table.resumeWith(Unit.INSTANCE);\n    runSuspend.await();\n}\n</code></pre>\n<blockquote>\n<p>这种写法，简直就是 <code>suspend main</code> 的真是面目。</p>\n</blockquote>\n<p><code>completion</code> 传入的 <code>runSuspend</code> 实例的 <code>resumeWith</code> 实际上是在 <code>ContinuationImpl</code> 的 <code>resumeWith</code> 的最后才被调用，因为它的 <code>await()</code> 一旦进入阻塞状态，直到 <code>ContinuationImpl</code> 的整体状态流转完毕才会停止阻塞，此时进程也就运行完毕，可以退出了。</p>"},{"title":"代理模式","_content":"\n代理模式给某一个对象提供了一个代理对象，并由代理对象控制对原对象的引用。通俗的讲，代理模式就是生活中的中介。\n\n## 静态代理\n\n**目的**：\n\n1. 通过引入代理对象的访问来间接访问目标对象，防止直接访问目标对象给系统带来不必要的复杂性和风向\n2. 通过代理对象对原有业务的增强。\n\n代理模式一般会有三个角色：\n\n**抽象角色：** 指代理角色和真是角色对外提供的公共方法，一般为一个接口\n\n**真实角色：** 需要实现抽象角色接口，定义了真是角色所要实现的业务逻辑，方便供代理角色调用。是真正的业务逻辑执行者\n<!-- more-->\n**代理角色：** 需要实现抽象角色接口，是真是角色的代理，通过真是角色的业务方法来实现抽象方法，并可以附自己的操作。将统一的流程控制放到代理角色中处理。\n\n静态代理在使用时，需要定义接口或父类，被代理对象与代理对象一起实现相同的接口或者父类。一般来说，被代理对象和代理对象时一对一的关系，当然一个代理对象对应多个被代理对象也时可以的。\n\n静态代理，一对一则会出现静态代理对象量多、代码量大，从而导致代码复杂，可维护性差等问题。一对多则代理对象会出现扩展能力差。\n\n## 动态代理\n\n动态代理是指在使用时再创建代理类和实例\n\n**有点：**\n\n只需要一个动态代理类就可以解决创建多个代理问题，避免重复、多余代码；更加灵活\n\n**缺点：**\n\n效率低，相比静态代理中，直接调用目标对象方法，动态代理则需要先通过 Java 反射机制，从而间接调用目标对象方法。\n\n应用场景局限，因为 Java 的单继承特性，即只能针对接口创建代理类，不能针对类创建代理类。\n\n## 动态代理的实现原理\n\n`InvocationHandler` 和 `Proxy` 一个接口，一个类，再动态代理中时一定会用到的\n\n`InvocationHandler` 接口是给动态代理类实现的，负责处理被代理对象的操作\n\n`Proxy` 是用来创建动态代理类实例对象的，只有得到对象，我们才能调用哪些需要代理的方法\n\n```java\nProxy.newProxyInstance(MyClass.class.getClassLoader, new Class[]{A.class, B.class}, new InvocationHandler(){\n    @Override\n    public Object invoke(Object o, Method method, Object[] objects) throws Throwable {\n        return method.invoke(a, objects);\n    }\n})\n```\n\n","source":"_posts/Java/设计模式/代理模式‘.md","raw":"---\ntitle: 代理模式\ntag: 设计模式\n---\n\n代理模式给某一个对象提供了一个代理对象，并由代理对象控制对原对象的引用。通俗的讲，代理模式就是生活中的中介。\n\n## 静态代理\n\n**目的**：\n\n1. 通过引入代理对象的访问来间接访问目标对象，防止直接访问目标对象给系统带来不必要的复杂性和风向\n2. 通过代理对象对原有业务的增强。\n\n代理模式一般会有三个角色：\n\n**抽象角色：** 指代理角色和真是角色对外提供的公共方法，一般为一个接口\n\n**真实角色：** 需要实现抽象角色接口，定义了真是角色所要实现的业务逻辑，方便供代理角色调用。是真正的业务逻辑执行者\n<!-- more-->\n**代理角色：** 需要实现抽象角色接口，是真是角色的代理，通过真是角色的业务方法来实现抽象方法，并可以附自己的操作。将统一的流程控制放到代理角色中处理。\n\n静态代理在使用时，需要定义接口或父类，被代理对象与代理对象一起实现相同的接口或者父类。一般来说，被代理对象和代理对象时一对一的关系，当然一个代理对象对应多个被代理对象也时可以的。\n\n静态代理，一对一则会出现静态代理对象量多、代码量大，从而导致代码复杂，可维护性差等问题。一对多则代理对象会出现扩展能力差。\n\n## 动态代理\n\n动态代理是指在使用时再创建代理类和实例\n\n**有点：**\n\n只需要一个动态代理类就可以解决创建多个代理问题，避免重复、多余代码；更加灵活\n\n**缺点：**\n\n效率低，相比静态代理中，直接调用目标对象方法，动态代理则需要先通过 Java 反射机制，从而间接调用目标对象方法。\n\n应用场景局限，因为 Java 的单继承特性，即只能针对接口创建代理类，不能针对类创建代理类。\n\n## 动态代理的实现原理\n\n`InvocationHandler` 和 `Proxy` 一个接口，一个类，再动态代理中时一定会用到的\n\n`InvocationHandler` 接口是给动态代理类实现的，负责处理被代理对象的操作\n\n`Proxy` 是用来创建动态代理类实例对象的，只有得到对象，我们才能调用哪些需要代理的方法\n\n```java\nProxy.newProxyInstance(MyClass.class.getClassLoader, new Class[]{A.class, B.class}, new InvocationHandler(){\n    @Override\n    public Object invoke(Object o, Method method, Object[] objects) throws Throwable {\n        return method.invoke(a, objects);\n    }\n})\n```\n\n","slug":"Java/设计模式/代理模式‘","published":1,"date":"2021-01-29T15:54:28.311Z","updated":"2021-01-29T16:16:44.804Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8ld003ysz5qb8394jhk","content":"<p>代理模式给某一个对象提供了一个代理对象，并由代理对象控制对原对象的引用。通俗的讲，代理模式就是生活中的中介。</p>\n<h2 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h2><p><strong>目的</strong>：</p>\n<ol>\n<li>通过引入代理对象的访问来间接访问目标对象，防止直接访问目标对象给系统带来不必要的复杂性和风向</li>\n<li>通过代理对象对原有业务的增强。</li>\n</ol>\n<p>代理模式一般会有三个角色：</p>\n<p><strong>抽象角色：</strong> 指代理角色和真是角色对外提供的公共方法，一般为一个接口</p>\n<p><strong>真实角色：</strong> 需要实现抽象角色接口，定义了真是角色所要实现的业务逻辑，方便供代理角色调用。是真正的业务逻辑执行者<br><a id=\"more\"></a><br><strong>代理角色：</strong> 需要实现抽象角色接口，是真是角色的代理，通过真是角色的业务方法来实现抽象方法，并可以附自己的操作。将统一的流程控制放到代理角色中处理。</p>\n<p>静态代理在使用时，需要定义接口或父类，被代理对象与代理对象一起实现相同的接口或者父类。一般来说，被代理对象和代理对象时一对一的关系，当然一个代理对象对应多个被代理对象也时可以的。</p>\n<p>静态代理，一对一则会出现静态代理对象量多、代码量大，从而导致代码复杂，可维护性差等问题。一对多则代理对象会出现扩展能力差。</p>\n<h2 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h2><p>动态代理是指在使用时再创建代理类和实例</p>\n<p><strong>有点：</strong></p>\n<p>只需要一个动态代理类就可以解决创建多个代理问题，避免重复、多余代码；更加灵活</p>\n<p><strong>缺点：</strong></p>\n<p>效率低，相比静态代理中，直接调用目标对象方法，动态代理则需要先通过 Java 反射机制，从而间接调用目标对象方法。</p>\n<p>应用场景局限，因为 Java 的单继承特性，即只能针对接口创建代理类，不能针对类创建代理类。</p>\n<h2 id=\"动态代理的实现原理\"><a href=\"#动态代理的实现原理\" class=\"headerlink\" title=\"动态代理的实现原理\"></a>动态代理的实现原理</h2><p><code>InvocationHandler</code> 和 <code>Proxy</code> 一个接口，一个类，再动态代理中时一定会用到的</p>\n<p><code>InvocationHandler</code> 接口是给动态代理类实现的，负责处理被代理对象的操作</p>\n<p><code>Proxy</code> 是用来创建动态代理类实例对象的，只有得到对象，我们才能调用哪些需要代理的方法</p>\n<pre class=\" language-java\"><code class=\"language-java\">Proxy<span class=\"token punctuation\">.</span><span class=\"token function\">newProxyInstance</span><span class=\"token punctuation\">(</span>MyClass<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">.</span>getClassLoader<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Class</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">{</span>A<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> B<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">InvocationHandler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> Object <span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span>Object o<span class=\"token punctuation\">,</span> Method method<span class=\"token punctuation\">,</span> Object<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> objects<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Throwable <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> method<span class=\"token punctuation\">.</span><span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> objects<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre>\n","site":{"data":{}},"excerpt":"<p>代理模式给某一个对象提供了一个代理对象，并由代理对象控制对原对象的引用。通俗的讲，代理模式就是生活中的中介。</p>\n<h2 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h2><p><strong>目的</strong>：</p>\n<ol>\n<li>通过引入代理对象的访问来间接访问目标对象，防止直接访问目标对象给系统带来不必要的复杂性和风向</li>\n<li>通过代理对象对原有业务的增强。</li>\n</ol>\n<p>代理模式一般会有三个角色：</p>\n<p><strong>抽象角色：</strong> 指代理角色和真是角色对外提供的公共方法，一般为一个接口</p>\n<p><strong>真实角色：</strong> 需要实现抽象角色接口，定义了真是角色所要实现的业务逻辑，方便供代理角色调用。是真正的业务逻辑执行者<br>","more":"<br><strong>代理角色：</strong> 需要实现抽象角色接口，是真是角色的代理，通过真是角色的业务方法来实现抽象方法，并可以附自己的操作。将统一的流程控制放到代理角色中处理。</p>\n<p>静态代理在使用时，需要定义接口或父类，被代理对象与代理对象一起实现相同的接口或者父类。一般来说，被代理对象和代理对象时一对一的关系，当然一个代理对象对应多个被代理对象也时可以的。</p>\n<p>静态代理，一对一则会出现静态代理对象量多、代码量大，从而导致代码复杂，可维护性差等问题。一对多则代理对象会出现扩展能力差。</p>\n<h2 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h2><p>动态代理是指在使用时再创建代理类和实例</p>\n<p><strong>有点：</strong></p>\n<p>只需要一个动态代理类就可以解决创建多个代理问题，避免重复、多余代码；更加灵活</p>\n<p><strong>缺点：</strong></p>\n<p>效率低，相比静态代理中，直接调用目标对象方法，动态代理则需要先通过 Java 反射机制，从而间接调用目标对象方法。</p>\n<p>应用场景局限，因为 Java 的单继承特性，即只能针对接口创建代理类，不能针对类创建代理类。</p>\n<h2 id=\"动态代理的实现原理\"><a href=\"#动态代理的实现原理\" class=\"headerlink\" title=\"动态代理的实现原理\"></a>动态代理的实现原理</h2><p><code>InvocationHandler</code> 和 <code>Proxy</code> 一个接口，一个类，再动态代理中时一定会用到的</p>\n<p><code>InvocationHandler</code> 接口是给动态代理类实现的，负责处理被代理对象的操作</p>\n<p><code>Proxy</code> 是用来创建动态代理类实例对象的，只有得到对象，我们才能调用哪些需要代理的方法</p>\n<pre><code class=\"java\">Proxy.newProxyInstance(MyClass.class.getClassLoader, new Class[]{A.class, B.class}, new InvocationHandler(){\n    @Override\n    public Object invoke(Object o, Method method, Object[] objects) throws Throwable {\n        return method.invoke(a, objects);\n    }\n})\n</code></pre>"},{"title":"协程调度器","_content":"\n![img](https://upload-images.jianshu.io/upload_images/18062676-f99f572eee860a04.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/730/format/webp)\n\n* 调度器本质上就是协程上下文的实现\n* 调度器的作用是用来实现线程的切换\n* 过度使用线程，同样会造成线程安全问题\n* suspendMain 是有一个空的上下文，因此不会产生线程的调度\n* 系统提供的调度器实现，Default, Main, Unconfined, IO\n<!-- more-->\n## 协程上下文（CoroutineContext）\n\n调度器本质上就是协程上下文的实现\n\n```kotlin\npublic interface CoroutineContext {\n    public operator fun <E: Element> get(key: Key<E>):E?\n    public fun <R> fold(initial:  R, operation:(R, Element) -> R):R\n    public operator fun plus(context: CoroutineContext): CorountineContext = ...\n    public fun minusKey(key: Key<*>): CoroutineContext\n    \n    public interface Key<E: Element>\n    \n    public interface Element : CoroutineContext {\n        public val key: Key<*>\n    }\n    ...\n}\n```\n\n本质上，上下文就是一个以 `key` 为索引的  `List` \n\n\n\n`CoroutineContext` 作为一个集合，它的元素就是源码中看到的 `Element` ， 每一个 `Element` 都有一个 `Key` ，因此它可以作为元素出现，同时它也是 `CoroutineContext`  的子接口，因此也可以作为集合出现。\n\n```kotlin\ninternal class CombinedContext (\nprivate val left: CoroutineContext,\nprivate val element: Element) : CoroutineContext, Serializable {\n    \n}\n```\n\n`CombinedContext` 前面是一个集合，后面是一个单独的元素。我们在协程体里面访问到的`coroutineContext` 大多是这个 `CombinedContext` 类型，表示有多个具体的上下文实现的集合，我们如果想要找到某一个特别的上下文，就需要用对应的 `key` 来查找\n\n```kotlin\nsuspend fun main() {\n    GlobalScope.launch{\n        println(coroutineContext[Job]) // “coroutine#1: StandaloneCoroutine{Active}@1ff5025\n    }\n    \n    println(coroutineContext[Job]) // null， suspend main 虽然也是协程体，但它是更底层的逻辑，因此没有 Job 实例\n}\n```\n\n这里的`Job` 实际上是对它的 `companion object` 的引用\n\n```kotlin\npublic interface Job: CoroutineContext.Element {\n    /**\n    * Key for [job] instance in the coroutine context.\n    */\n    public companion object Key: CoroutineContext.Key<Job> {}\n}\n```\n\n仿照`Thread.currentThread()` 来获取当前 `Job` 的方法 \n\n```kotlin\nsuspend inline fun Job.Key.currentJob() = coroutineContext[Job]\n\nsuspend fun coroutineJob() {\n    GlobalScope.launch {\n        log(Job.currentJob())\n    }\n    \n    log(Job.currentJob())\n}\n```\n\n**获取协程名字**\n\n```kotlin\nGlobalScope.launch(CoroutineName(\"Hello\")) {}\n```\n\n如果有多个上下文，需要添加 `+ ` 就可以了\n\n```kotlin\nGlobalScope.launch(Dispatcher.Main + CoroutineName(\"Hello\")) {}\n```\n\n## 协程拦截器\n\n```kotlin\npublic interface ContinuationInterception: CoroutineContext.Element {\n    companion object Key: CoroutineContext.Key<ContinuationInterceptor>\n    \n    public fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T>\n}\n```\n\n拦截器也是一个上下文的实现方向，拦截器可以左右协程的执行，同时为了保证它功能的正确性，协程上下文集合永远将他放在最后面，\n\n协程的拦截方法也很简单，因为协程的本质就是回调+黑魔法，而这个回调就是被拦截的`Continuation`，调度器就是基于拦截器实现的，换句话说，调度器就是拦截器的一种。\n\n我们可以自己定义一个拦截器放到我们协程的上下问中。\n\n```kotlin\nclass MyContinuationInterceptor: ContinuationInterceptor {\n    override val key = ContinuationInterceptor\n    override fun <T> interceptContinuation(continuation:Continuation<T>) = MyContinuation(continuation)\n}\n\n\nclass MyCOntinuation<T> (val continuation: Continuation<T>): Continuation<T> {\n    override val context = continuation.context\n    override fun resumeWith(result:Result<T>) {\n        log(\"<MyContinuation>$result\")\n        continuation.resumeWith(result)\n    }\n}\n```\n\n```kotlin\nsuspend fun main(){\n    GlobalScope.launch(MyContinuationInterceptor()) {\n        log(1)\n        val job = async {\n            log(2)\n            delay(1000)\n            log(3)\n            \"Hello\"\n        }\n        log(4)\n        val result = job.await()\n        log(\"5.$result\")\n    }.join()\n    log(6)\n}\n```\n\n通过 `launch` 启动了一个协程，为他指定了我们的拦截器上下文，紧接着在其内部用`async` 启动了一个协程，`async` 和 `launch`从功能上是同等类型的函数，不同之处在于 `async` 启动的 `Job` 也就是实际上的 `Deferred` 可以有返回结果。可以通过 `await` 方法获取。\n\n```txt\n[main] <MyContinuation> Success(kotlin.Unit)\n[main] 1\n[main] <MyContinuation> Success(kotlin.Unit)\n[main] 2\n[main] 4\n[kotlinx.coroutines.DefaultExecutor] <MyContinuation> Success(kotlin.Unit)\n[kotlinx.coroutines.DefaultExecutor] 3\n[kotlinx.coroutines.DefaultExecutor] <MyContinuation> Success(Hello)\n[kotlinx.coroutines.DefaultExecutor] 5.Hello\n[kotlinx.coroutines.DefaultExecutor] 6\n```\n\n首先，所有协程启动的时候，都会有一次`Continuation.resumeWith` 的操作，这一次操作对于调度器来说就是一次调度的机会，我们的协程有机会调度到其他线程的关键之处就在于这里。\n\n其次 `delay` 是挂起点， 1000ms 之后需要继续调度执行该协程，因此就有了 3 的日志。\n\n最后，正是我们需要的结果。\n\n而协程真正切换线程的逻辑源自于 `delay`  在 JVM 上，`delay` 实际上是一个 `ScheduledExcecutor` 里面添加了一个延时任务，因此会发生线程切换\n\n\n\n## 调度器\n\n```kotlin\npublic abstract class CoroutineDispatcher : AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {\n    public abstract fun dispatch(context: CoroutineContext, block: Runnable)\n}\n```\n\n调度器本身也是协程上下文的子类，同时实现了拦截器的接口， `dispatch` 方法会在拦截器的方法 `interceptContinuation` 中调用，进而实现协程的调用。所以如果我们香要自己实现自己的调度器，继承这个类`AbstracoroutineContextElement` 就可以\n\n* Default: 线程池\n* Main： UI 线程\n* Unconfined：直接执行\n* IO：线程池\n\n### UI  相关程序\n\nKotlin 的用户绝大部分是 Android 开发者，举一些常见的场景，点击一个按钮做异步任务回调刷新 UI \n\n```kotlin\ngetUserBtn.setOnClickListener {\n    getUser{user-> {\n        handler.post{\n            userNameView.text = user.name\n        }\n    }}\n}\n```\n\n```kotlin\ntypealias Callback = (User) -> Unit\n\nfun getUser(callback: Callback) {\n    \n}\n```\n\n因为 `getUser` 需要切换到其他线程执行，因此回调通常也会在这个非 UI 线程中使用，确保 UI 可以刷新，需要 `handler.post` 切换到 UI 线程。\n\n过度到协程的写法；\n\n```kotlin\nsuspend fun getUserCoroutine()= suspendCoroutine<User> {\n    continuation -> \n    getUser {\n        continuation.resume(it)\n    }\n}\n\ngetUserBtn.setOnClickListener {\n    GlobalScope.launch(Dispathcer.Main) {\n        userNameVite.text = getUserCoroutine().name\n    }\n}\n```\n\n**suspendCoroutine**\n\n它运行在协程当中，并且帮助我们获取当前协程的 `Continuation` 实例，也就是拿到回调，方柏霓我们调用它的 `resume` 和 `resumeWithException` 来返回结果或者抛出异常\n\n**Dispatchers.Main**\n\n```kotlin\ninternal object MainDispatcherLoader {\n    @JvmField\n    val dispatcher:MainCoroutineDispatcher = loadMainDispatcher()\n    \n    private fun loadMainDispatcher() :MainCoroutineDispatcher {\n        return try {\n            val factories = MainDispatcherFactory::class.java.let {cle -> \n\t\t\t\tServiceLoader.load(clz, clz.classLoader).toList()\n\t\t   }\n            factories.maxBy{it.loadPriority}?.tryCreateDispatcher(factories) ?: MissingMainCoroutineDispatcher(null)\n        } catch (e: Throwable) {\n            MissingMainCoroutineDispatcher(e)\n        }\n    }\n}\n```\n\n在 Android 当中，协程框架通过注册 `AndroidDispatcherFactory` 是的 `Main` 最终被赋值为 `HandlerDispatcher` 的实例。\n\n### 线程安全问题\n\n","source":"_posts/Kotlin/协程/协程-调度器.md","raw":"---\ntitle: 协程调度器\ntag: Kotlin\n\n\n---\n\n![img](https://upload-images.jianshu.io/upload_images/18062676-f99f572eee860a04.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/730/format/webp)\n\n* 调度器本质上就是协程上下文的实现\n* 调度器的作用是用来实现线程的切换\n* 过度使用线程，同样会造成线程安全问题\n* suspendMain 是有一个空的上下文，因此不会产生线程的调度\n* 系统提供的调度器实现，Default, Main, Unconfined, IO\n<!-- more-->\n## 协程上下文（CoroutineContext）\n\n调度器本质上就是协程上下文的实现\n\n```kotlin\npublic interface CoroutineContext {\n    public operator fun <E: Element> get(key: Key<E>):E?\n    public fun <R> fold(initial:  R, operation:(R, Element) -> R):R\n    public operator fun plus(context: CoroutineContext): CorountineContext = ...\n    public fun minusKey(key: Key<*>): CoroutineContext\n    \n    public interface Key<E: Element>\n    \n    public interface Element : CoroutineContext {\n        public val key: Key<*>\n    }\n    ...\n}\n```\n\n本质上，上下文就是一个以 `key` 为索引的  `List` \n\n\n\n`CoroutineContext` 作为一个集合，它的元素就是源码中看到的 `Element` ， 每一个 `Element` 都有一个 `Key` ，因此它可以作为元素出现，同时它也是 `CoroutineContext`  的子接口，因此也可以作为集合出现。\n\n```kotlin\ninternal class CombinedContext (\nprivate val left: CoroutineContext,\nprivate val element: Element) : CoroutineContext, Serializable {\n    \n}\n```\n\n`CombinedContext` 前面是一个集合，后面是一个单独的元素。我们在协程体里面访问到的`coroutineContext` 大多是这个 `CombinedContext` 类型，表示有多个具体的上下文实现的集合，我们如果想要找到某一个特别的上下文，就需要用对应的 `key` 来查找\n\n```kotlin\nsuspend fun main() {\n    GlobalScope.launch{\n        println(coroutineContext[Job]) // “coroutine#1: StandaloneCoroutine{Active}@1ff5025\n    }\n    \n    println(coroutineContext[Job]) // null， suspend main 虽然也是协程体，但它是更底层的逻辑，因此没有 Job 实例\n}\n```\n\n这里的`Job` 实际上是对它的 `companion object` 的引用\n\n```kotlin\npublic interface Job: CoroutineContext.Element {\n    /**\n    * Key for [job] instance in the coroutine context.\n    */\n    public companion object Key: CoroutineContext.Key<Job> {}\n}\n```\n\n仿照`Thread.currentThread()` 来获取当前 `Job` 的方法 \n\n```kotlin\nsuspend inline fun Job.Key.currentJob() = coroutineContext[Job]\n\nsuspend fun coroutineJob() {\n    GlobalScope.launch {\n        log(Job.currentJob())\n    }\n    \n    log(Job.currentJob())\n}\n```\n\n**获取协程名字**\n\n```kotlin\nGlobalScope.launch(CoroutineName(\"Hello\")) {}\n```\n\n如果有多个上下文，需要添加 `+ ` 就可以了\n\n```kotlin\nGlobalScope.launch(Dispatcher.Main + CoroutineName(\"Hello\")) {}\n```\n\n## 协程拦截器\n\n```kotlin\npublic interface ContinuationInterception: CoroutineContext.Element {\n    companion object Key: CoroutineContext.Key<ContinuationInterceptor>\n    \n    public fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T>\n}\n```\n\n拦截器也是一个上下文的实现方向，拦截器可以左右协程的执行，同时为了保证它功能的正确性，协程上下文集合永远将他放在最后面，\n\n协程的拦截方法也很简单，因为协程的本质就是回调+黑魔法，而这个回调就是被拦截的`Continuation`，调度器就是基于拦截器实现的，换句话说，调度器就是拦截器的一种。\n\n我们可以自己定义一个拦截器放到我们协程的上下问中。\n\n```kotlin\nclass MyContinuationInterceptor: ContinuationInterceptor {\n    override val key = ContinuationInterceptor\n    override fun <T> interceptContinuation(continuation:Continuation<T>) = MyContinuation(continuation)\n}\n\n\nclass MyCOntinuation<T> (val continuation: Continuation<T>): Continuation<T> {\n    override val context = continuation.context\n    override fun resumeWith(result:Result<T>) {\n        log(\"<MyContinuation>$result\")\n        continuation.resumeWith(result)\n    }\n}\n```\n\n```kotlin\nsuspend fun main(){\n    GlobalScope.launch(MyContinuationInterceptor()) {\n        log(1)\n        val job = async {\n            log(2)\n            delay(1000)\n            log(3)\n            \"Hello\"\n        }\n        log(4)\n        val result = job.await()\n        log(\"5.$result\")\n    }.join()\n    log(6)\n}\n```\n\n通过 `launch` 启动了一个协程，为他指定了我们的拦截器上下文，紧接着在其内部用`async` 启动了一个协程，`async` 和 `launch`从功能上是同等类型的函数，不同之处在于 `async` 启动的 `Job` 也就是实际上的 `Deferred` 可以有返回结果。可以通过 `await` 方法获取。\n\n```txt\n[main] <MyContinuation> Success(kotlin.Unit)\n[main] 1\n[main] <MyContinuation> Success(kotlin.Unit)\n[main] 2\n[main] 4\n[kotlinx.coroutines.DefaultExecutor] <MyContinuation> Success(kotlin.Unit)\n[kotlinx.coroutines.DefaultExecutor] 3\n[kotlinx.coroutines.DefaultExecutor] <MyContinuation> Success(Hello)\n[kotlinx.coroutines.DefaultExecutor] 5.Hello\n[kotlinx.coroutines.DefaultExecutor] 6\n```\n\n首先，所有协程启动的时候，都会有一次`Continuation.resumeWith` 的操作，这一次操作对于调度器来说就是一次调度的机会，我们的协程有机会调度到其他线程的关键之处就在于这里。\n\n其次 `delay` 是挂起点， 1000ms 之后需要继续调度执行该协程，因此就有了 3 的日志。\n\n最后，正是我们需要的结果。\n\n而协程真正切换线程的逻辑源自于 `delay`  在 JVM 上，`delay` 实际上是一个 `ScheduledExcecutor` 里面添加了一个延时任务，因此会发生线程切换\n\n\n\n## 调度器\n\n```kotlin\npublic abstract class CoroutineDispatcher : AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {\n    public abstract fun dispatch(context: CoroutineContext, block: Runnable)\n}\n```\n\n调度器本身也是协程上下文的子类，同时实现了拦截器的接口， `dispatch` 方法会在拦截器的方法 `interceptContinuation` 中调用，进而实现协程的调用。所以如果我们香要自己实现自己的调度器，继承这个类`AbstracoroutineContextElement` 就可以\n\n* Default: 线程池\n* Main： UI 线程\n* Unconfined：直接执行\n* IO：线程池\n\n### UI  相关程序\n\nKotlin 的用户绝大部分是 Android 开发者，举一些常见的场景，点击一个按钮做异步任务回调刷新 UI \n\n```kotlin\ngetUserBtn.setOnClickListener {\n    getUser{user-> {\n        handler.post{\n            userNameView.text = user.name\n        }\n    }}\n}\n```\n\n```kotlin\ntypealias Callback = (User) -> Unit\n\nfun getUser(callback: Callback) {\n    \n}\n```\n\n因为 `getUser` 需要切换到其他线程执行，因此回调通常也会在这个非 UI 线程中使用，确保 UI 可以刷新，需要 `handler.post` 切换到 UI 线程。\n\n过度到协程的写法；\n\n```kotlin\nsuspend fun getUserCoroutine()= suspendCoroutine<User> {\n    continuation -> \n    getUser {\n        continuation.resume(it)\n    }\n}\n\ngetUserBtn.setOnClickListener {\n    GlobalScope.launch(Dispathcer.Main) {\n        userNameVite.text = getUserCoroutine().name\n    }\n}\n```\n\n**suspendCoroutine**\n\n它运行在协程当中，并且帮助我们获取当前协程的 `Continuation` 实例，也就是拿到回调，方柏霓我们调用它的 `resume` 和 `resumeWithException` 来返回结果或者抛出异常\n\n**Dispatchers.Main**\n\n```kotlin\ninternal object MainDispatcherLoader {\n    @JvmField\n    val dispatcher:MainCoroutineDispatcher = loadMainDispatcher()\n    \n    private fun loadMainDispatcher() :MainCoroutineDispatcher {\n        return try {\n            val factories = MainDispatcherFactory::class.java.let {cle -> \n\t\t\t\tServiceLoader.load(clz, clz.classLoader).toList()\n\t\t   }\n            factories.maxBy{it.loadPriority}?.tryCreateDispatcher(factories) ?: MissingMainCoroutineDispatcher(null)\n        } catch (e: Throwable) {\n            MissingMainCoroutineDispatcher(e)\n        }\n    }\n}\n```\n\n在 Android 当中，协程框架通过注册 `AndroidDispatcherFactory` 是的 `Main` 最终被赋值为 `HandlerDispatcher` 的实例。\n\n### 线程安全问题\n\n","slug":"Kotlin/协程/协程-调度器","published":1,"date":"2021-01-29T15:54:28.319Z","updated":"2021-01-29T16:16:02.061Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8lf0040sz5quaix5b0p","content":"<p><img src=\"https://upload-images.jianshu.io/upload_images/18062676-f99f572eee860a04.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/730/format/webp\" alt=\"img\"></p>\n<ul>\n<li>调度器本质上就是协程上下文的实现</li>\n<li>调度器的作用是用来实现线程的切换</li>\n<li>过度使用线程，同样会造成线程安全问题</li>\n<li>suspendMain 是有一个空的上下文，因此不会产生线程的调度</li>\n<li>系统提供的调度器实现，Default, Main, Unconfined, IO<a id=\"more\"></a>\n<h2 id=\"协程上下文（CoroutineContext）\"><a href=\"#协程上下文（CoroutineContext）\" class=\"headerlink\" title=\"协程上下文（CoroutineContext）\"></a>协程上下文（CoroutineContext）</h2></li>\n</ul>\n<p>调度器本质上就是协程上下文的实现</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> CoroutineContext <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> operator <span class=\"token keyword\">fun</span> <span class=\"token operator\">&lt;</span>E<span class=\"token operator\">:</span> Element<span class=\"token operator\">></span> <span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token operator\">:</span> Key<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>E<span class=\"token operator\">?</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">fun</span> <span class=\"token operator\">&lt;</span>R<span class=\"token operator\">></span> <span class=\"token function\">fold</span><span class=\"token punctuation\">(</span>initial<span class=\"token operator\">:</span>  R<span class=\"token punctuation\">,</span> operation<span class=\"token operator\">:</span><span class=\"token punctuation\">(</span>R<span class=\"token punctuation\">,</span> Element<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> R<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>R\n    <span class=\"token keyword\">public</span> operator <span class=\"token keyword\">fun</span> <span class=\"token function\">plus</span><span class=\"token punctuation\">(</span>context<span class=\"token operator\">:</span> CoroutineContext<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> CorountineContext <span class=\"token operator\">=</span> <span class=\"token operator\">..</span><span class=\"token punctuation\">.</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">minusKey</span><span class=\"token punctuation\">(</span>key<span class=\"token operator\">:</span> Key<span class=\"token operator\">&lt;</span><span class=\"token operator\">*</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> CoroutineContext\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> Key<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">:</span> Element<span class=\"token operator\">></span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> Element <span class=\"token operator\">:</span> CoroutineContext <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">val</span> key<span class=\"token operator\">:</span> Key<span class=\"token operator\">&lt;</span><span class=\"token operator\">*</span><span class=\"token operator\">></span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">..</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>本质上，上下文就是一个以 <code>key</code> 为索引的  <code>List</code> </p>\n<p><code>CoroutineContext</code> 作为一个集合，它的元素就是源码中看到的 <code>Element</code> ， 每一个 <code>Element</code> 都有一个 <code>Key</code> ，因此它可以作为元素出现，同时它也是 <code>CoroutineContext</code>  的子接口，因此也可以作为集合出现。</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">internal</span> <span class=\"token keyword\">class</span> <span class=\"token function\">CombinedContext</span> <span class=\"token punctuation\">(</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">val</span> left<span class=\"token operator\">:</span> CoroutineContext<span class=\"token punctuation\">,</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">val</span> element<span class=\"token operator\">:</span> Element<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> CoroutineContext<span class=\"token punctuation\">,</span> Serializable <span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><code>CombinedContext</code> 前面是一个集合，后面是一个单独的元素。我们在协程体里面访问到的<code>coroutineContext</code> 大多是这个 <code>CombinedContext</code> 类型，表示有多个具体的上下文实现的集合，我们如果想要找到某一个特别的上下文，就需要用对应的 <code>key</code> 来查找</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\">suspend <span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>coroutineContext<span class=\"token punctuation\">[</span>Job<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// “coroutine#1: StandaloneCoroutine{Active}@1ff5025</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>coroutineContext<span class=\"token punctuation\">[</span>Job<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// null， suspend main 虽然也是协程体，但它是更底层的逻辑，因此没有 Job 实例</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>这里的<code>Job</code> 实际上是对它的 <code>companion object</code> 的引用</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> Job<span class=\"token operator\">:</span> CoroutineContext<span class=\"token punctuation\">.</span><span class=\"token function\">Element</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">/**\n    * Key for [job] instance in the coroutine context.\n    */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">companion</span> <span class=\"token keyword\">object</span> Key<span class=\"token operator\">:</span> CoroutineContext<span class=\"token punctuation\">.</span>Key<span class=\"token operator\">&lt;</span>Job<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>仿照<code>Thread.currentThread()</code> 来获取当前 <code>Job</code> 的方法 </p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\">suspend <span class=\"token keyword\">inline</span> <span class=\"token keyword\">fun</span> Job<span class=\"token punctuation\">.</span>Key<span class=\"token punctuation\">.</span><span class=\"token function\">currentJob</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> coroutineContext<span class=\"token punctuation\">[</span>Job<span class=\"token punctuation\">]</span>\n\nsuspend <span class=\"token keyword\">fun</span> <span class=\"token function\">coroutineJob</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Job<span class=\"token punctuation\">.</span><span class=\"token function\">currentJob</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Job<span class=\"token punctuation\">.</span><span class=\"token function\">currentJob</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>获取协程名字</strong></p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\">GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span><span class=\"token punctuation\">(</span><span class=\"token function\">CoroutineName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n</code></pre>\n<p>如果有多个上下文，需要添加 <code>+</code> 就可以了</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\">GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span><span class=\"token punctuation\">(</span>Dispatcher<span class=\"token punctuation\">.</span>Main <span class=\"token operator\">+</span> <span class=\"token function\">CoroutineName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"协程拦截器\"><a href=\"#协程拦截器\" class=\"headerlink\" title=\"协程拦截器\"></a>协程拦截器</h2><pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> ContinuationInterception<span class=\"token operator\">:</span> CoroutineContext<span class=\"token punctuation\">.</span><span class=\"token function\">Element</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">companion</span> <span class=\"token keyword\">object</span> Key<span class=\"token operator\">:</span> CoroutineContext<span class=\"token punctuation\">.</span>Key<span class=\"token operator\">&lt;</span>ContinuationInterceptor<span class=\"token operator\">></span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">fun</span> <span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">interceptContinuation</span><span class=\"token punctuation\">(</span>continuation<span class=\"token operator\">:</span> Continuation<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Continuation<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>拦截器也是一个上下文的实现方向，拦截器可以左右协程的执行，同时为了保证它功能的正确性，协程上下文集合永远将他放在最后面，</p>\n<p>协程的拦截方法也很简单，因为协程的本质就是回调+黑魔法，而这个回调就是被拦截的<code>Continuation</code>，调度器就是基于拦截器实现的，换句话说，调度器就是拦截器的一种。</p>\n<p>我们可以自己定义一个拦截器放到我们协程的上下问中。</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">class</span> MyContinuationInterceptor<span class=\"token operator\">:</span> ContinuationInterceptor <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">val</span> key <span class=\"token operator\">=</span> ContinuationInterceptor\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">interceptContinuation</span><span class=\"token punctuation\">(</span>continuation<span class=\"token operator\">:</span>Continuation<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token function\">MyContinuation</span><span class=\"token punctuation\">(</span>continuation<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token keyword\">class</span> MyCOntinuation<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">val</span> continuation<span class=\"token operator\">:</span> Continuation<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Continuation<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">val</span> context <span class=\"token operator\">=</span> continuation<span class=\"token punctuation\">.</span>context\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">resumeWith</span><span class=\"token punctuation\">(</span>result<span class=\"token operator\">:</span>Result<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"&lt;MyContinuation><span class=\"token interpolation variable\">$result</span>\"</span><span class=\"token punctuation\">)</span>\n        continuation<span class=\"token punctuation\">.</span><span class=\"token function\">resumeWith</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\">suspend <span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span><span class=\"token punctuation\">(</span><span class=\"token function\">MyContinuationInterceptor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">val</span> job <span class=\"token operator\">=</span> async <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n            <span class=\"token string\">\"Hello\"</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">val</span> result <span class=\"token operator\">=</span> job<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"5.<span class=\"token interpolation variable\">$result</span>\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>通过 <code>launch</code> 启动了一个协程，为他指定了我们的拦截器上下文，紧接着在其内部用<code>async</code> 启动了一个协程，<code>async</code> 和 <code>launch</code>从功能上是同等类型的函数，不同之处在于 <code>async</code> 启动的 <code>Job</code> 也就是实际上的 <code>Deferred</code> 可以有返回结果。可以通过 <code>await</code> 方法获取。</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">[main] <MyContinuation> Success(kotlin.Unit)\n[main] 1\n[main] <MyContinuation> Success(kotlin.Unit)\n[main] 2\n[main] 4\n[kotlinx.coroutines.DefaultExecutor] <MyContinuation> Success(kotlin.Unit)\n[kotlinx.coroutines.DefaultExecutor] 3\n[kotlinx.coroutines.DefaultExecutor] <MyContinuation> Success(Hello)\n[kotlinx.coroutines.DefaultExecutor] 5.Hello\n[kotlinx.coroutines.DefaultExecutor] 6\n</code></pre>\n<p>首先，所有协程启动的时候，都会有一次<code>Continuation.resumeWith</code> 的操作，这一次操作对于调度器来说就是一次调度的机会，我们的协程有机会调度到其他线程的关键之处就在于这里。</p>\n<p>其次 <code>delay</code> 是挂起点， 1000ms 之后需要继续调度执行该协程，因此就有了 3 的日志。</p>\n<p>最后，正是我们需要的结果。</p>\n<p>而协程真正切换线程的逻辑源自于 <code>delay</code>  在 JVM 上，<code>delay</code> 实际上是一个 <code>ScheduledExcecutor</code> 里面添加了一个延时任务，因此会发生线程切换</p>\n<h2 id=\"调度器\"><a href=\"#调度器\" class=\"headerlink\" title=\"调度器\"></a>调度器</h2><pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> CoroutineDispatcher <span class=\"token operator\">:</span> <span class=\"token function\">AbstractCoroutineContextElement</span><span class=\"token punctuation\">(</span>ContinuationInterceptor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> ContinuationInterceptor <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span>context<span class=\"token operator\">:</span> CoroutineContext<span class=\"token punctuation\">,</span> block<span class=\"token operator\">:</span> Runnable<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>调度器本身也是协程上下文的子类，同时实现了拦截器的接口， <code>dispatch</code> 方法会在拦截器的方法 <code>interceptContinuation</code> 中调用，进而实现协程的调用。所以如果我们香要自己实现自己的调度器，继承这个类<code>AbstracoroutineContextElement</code> 就可以</p>\n<ul>\n<li>Default: 线程池</li>\n<li>Main： UI 线程</li>\n<li>Unconfined：直接执行</li>\n<li>IO：线程池</li>\n</ul>\n<h3 id=\"UI-相关程序\"><a href=\"#UI-相关程序\" class=\"headerlink\" title=\"UI  相关程序\"></a>UI  相关程序</h3><p>Kotlin 的用户绝大部分是 Android 开发者，举一些常见的场景，点击一个按钮做异步任务回调刷新 UI </p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\">getUserBtn<span class=\"token punctuation\">.</span><span class=\"token function\">setOnClickListener</span> <span class=\"token punctuation\">{</span>\n    getUser<span class=\"token punctuation\">{</span>user<span class=\"token operator\">-></span> <span class=\"token punctuation\">{</span>\n        handler<span class=\"token punctuation\">.</span><span class=\"token function\">post</span><span class=\"token punctuation\">{</span>\n            userNameView<span class=\"token punctuation\">.</span>text <span class=\"token operator\">=</span> user<span class=\"token punctuation\">.</span>name\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\">typealias Callback <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>User<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> Unit\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">getUser</span><span class=\"token punctuation\">(</span>callback<span class=\"token operator\">:</span> Callback<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>因为 <code>getUser</code> 需要切换到其他线程执行，因此回调通常也会在这个非 UI 线程中使用，确保 UI 可以刷新，需要 <code>handler.post</code> 切换到 UI 线程。</p>\n<p>过度到协程的写法；</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\">suspend <span class=\"token keyword\">fun</span> <span class=\"token function\">getUserCoroutine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=</span> suspendCoroutine<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    continuation <span class=\"token operator\">-></span> \n    getUser <span class=\"token punctuation\">{</span>\n        continuation<span class=\"token punctuation\">.</span><span class=\"token function\">resume</span><span class=\"token punctuation\">(</span>it<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\ngetUserBtn<span class=\"token punctuation\">.</span><span class=\"token function\">setOnClickListener</span> <span class=\"token punctuation\">{</span>\n    GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span><span class=\"token punctuation\">(</span>Dispathcer<span class=\"token punctuation\">.</span>Main<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        userNameVite<span class=\"token punctuation\">.</span>text <span class=\"token operator\">=</span> <span class=\"token function\">getUserCoroutine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>name\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>suspendCoroutine</strong></p>\n<p>它运行在协程当中，并且帮助我们获取当前协程的 <code>Continuation</code> 实例，也就是拿到回调，方柏霓我们调用它的 <code>resume</code> 和 <code>resumeWithException</code> 来返回结果或者抛出异常</p>\n<p><strong>Dispatchers.Main</strong></p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">internal</span> <span class=\"token keyword\">object</span> MainDispatcherLoader <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation builtin\">@JvmField</span>\n    <span class=\"token keyword\">val</span> dispatcher<span class=\"token operator\">:</span>MainCoroutineDispatcher <span class=\"token operator\">=</span> <span class=\"token function\">loadMainDispatcher</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">loadMainDispatcher</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span>MainCoroutineDispatcher <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">val</span> factories <span class=\"token operator\">=</span> MainDispatcherFactory<span class=\"token operator\">::</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">.</span>java<span class=\"token punctuation\">.</span><span class=\"token function\">let</span> <span class=\"token punctuation\">{</span>cle <span class=\"token operator\">-></span> \n                ServiceLoader<span class=\"token punctuation\">.</span><span class=\"token function\">load</span><span class=\"token punctuation\">(</span>clz<span class=\"token punctuation\">,</span> clz<span class=\"token punctuation\">.</span>classLoader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n           <span class=\"token punctuation\">}</span>\n            factories<span class=\"token punctuation\">.</span><span class=\"token function\">maxBy</span><span class=\"token punctuation\">{</span>it<span class=\"token punctuation\">.</span>loadPriority<span class=\"token punctuation\">}</span><span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">tryCreateDispatcher</span><span class=\"token punctuation\">(</span>factories<span class=\"token punctuation\">)</span> <span class=\"token operator\">?:</span> <span class=\"token function\">MissingMainCoroutineDispatcher</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token operator\">:</span> Throwable<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">MissingMainCoroutineDispatcher</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>在 Android 当中，协程框架通过注册 <code>AndroidDispatcherFactory</code> 是的 <code>Main</code> 最终被赋值为 <code>HandlerDispatcher</code> 的实例。</p>\n<h3 id=\"线程安全问题\"><a href=\"#线程安全问题\" class=\"headerlink\" title=\"线程安全问题\"></a>线程安全问题</h3>","site":{"data":{}},"excerpt":"<p><img src=\"https://upload-images.jianshu.io/upload_images/18062676-f99f572eee860a04.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/730/format/webp\" alt=\"img\"></p>\n<ul>\n<li>调度器本质上就是协程上下文的实现</li>\n<li>调度器的作用是用来实现线程的切换</li>\n<li>过度使用线程，同样会造成线程安全问题</li>\n<li>suspendMain 是有一个空的上下文，因此不会产生线程的调度</li>\n<li>系统提供的调度器实现，Default, Main, Unconfined, IO","more":"<h2 id=\"协程上下文（CoroutineContext）\"><a href=\"#协程上下文（CoroutineContext）\" class=\"headerlink\" title=\"协程上下文（CoroutineContext）\"></a>协程上下文（CoroutineContext）</h2></li>\n</ul>\n<p>调度器本质上就是协程上下文的实现</p>\n<pre><code class=\"kotlin\">public interface CoroutineContext {\n    public operator fun &lt;E: Element&gt; get(key: Key&lt;E&gt;):E?\n    public fun &lt;R&gt; fold(initial:  R, operation:(R, Element) -&gt; R):R\n    public operator fun plus(context: CoroutineContext): CorountineContext = ...\n    public fun minusKey(key: Key&lt;*&gt;): CoroutineContext\n\n    public interface Key&lt;E: Element&gt;\n\n    public interface Element : CoroutineContext {\n        public val key: Key&lt;*&gt;\n    }\n    ...\n}\n</code></pre>\n<p>本质上，上下文就是一个以 <code>key</code> 为索引的  <code>List</code> </p>\n<p><code>CoroutineContext</code> 作为一个集合，它的元素就是源码中看到的 <code>Element</code> ， 每一个 <code>Element</code> 都有一个 <code>Key</code> ，因此它可以作为元素出现，同时它也是 <code>CoroutineContext</code>  的子接口，因此也可以作为集合出现。</p>\n<pre><code class=\"kotlin\">internal class CombinedContext (\nprivate val left: CoroutineContext,\nprivate val element: Element) : CoroutineContext, Serializable {\n\n}\n</code></pre>\n<p><code>CombinedContext</code> 前面是一个集合，后面是一个单独的元素。我们在协程体里面访问到的<code>coroutineContext</code> 大多是这个 <code>CombinedContext</code> 类型，表示有多个具体的上下文实现的集合，我们如果想要找到某一个特别的上下文，就需要用对应的 <code>key</code> 来查找</p>\n<pre><code class=\"kotlin\">suspend fun main() {\n    GlobalScope.launch{\n        println(coroutineContext[Job]) // “coroutine#1: StandaloneCoroutine{Active}@1ff5025\n    }\n\n    println(coroutineContext[Job]) // null， suspend main 虽然也是协程体，但它是更底层的逻辑，因此没有 Job 实例\n}\n</code></pre>\n<p>这里的<code>Job</code> 实际上是对它的 <code>companion object</code> 的引用</p>\n<pre><code class=\"kotlin\">public interface Job: CoroutineContext.Element {\n    /**\n    * Key for [job] instance in the coroutine context.\n    */\n    public companion object Key: CoroutineContext.Key&lt;Job&gt; {}\n}\n</code></pre>\n<p>仿照<code>Thread.currentThread()</code> 来获取当前 <code>Job</code> 的方法 </p>\n<pre><code class=\"kotlin\">suspend inline fun Job.Key.currentJob() = coroutineContext[Job]\n\nsuspend fun coroutineJob() {\n    GlobalScope.launch {\n        log(Job.currentJob())\n    }\n\n    log(Job.currentJob())\n}\n</code></pre>\n<p><strong>获取协程名字</strong></p>\n<pre><code class=\"kotlin\">GlobalScope.launch(CoroutineName(&quot;Hello&quot;)) {}\n</code></pre>\n<p>如果有多个上下文，需要添加 <code>+</code> 就可以了</p>\n<pre><code class=\"kotlin\">GlobalScope.launch(Dispatcher.Main + CoroutineName(&quot;Hello&quot;)) {}\n</code></pre>\n<h2 id=\"协程拦截器\"><a href=\"#协程拦截器\" class=\"headerlink\" title=\"协程拦截器\"></a>协程拦截器</h2><pre><code class=\"kotlin\">public interface ContinuationInterception: CoroutineContext.Element {\n    companion object Key: CoroutineContext.Key&lt;ContinuationInterceptor&gt;\n\n    public fun &lt;T&gt; interceptContinuation(continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt;\n}\n</code></pre>\n<p>拦截器也是一个上下文的实现方向，拦截器可以左右协程的执行，同时为了保证它功能的正确性，协程上下文集合永远将他放在最后面，</p>\n<p>协程的拦截方法也很简单，因为协程的本质就是回调+黑魔法，而这个回调就是被拦截的<code>Continuation</code>，调度器就是基于拦截器实现的，换句话说，调度器就是拦截器的一种。</p>\n<p>我们可以自己定义一个拦截器放到我们协程的上下问中。</p>\n<pre><code class=\"kotlin\">class MyContinuationInterceptor: ContinuationInterceptor {\n    override val key = ContinuationInterceptor\n    override fun &lt;T&gt; interceptContinuation(continuation:Continuation&lt;T&gt;) = MyContinuation(continuation)\n}\n\n\nclass MyCOntinuation&lt;T&gt; (val continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt; {\n    override val context = continuation.context\n    override fun resumeWith(result:Result&lt;T&gt;) {\n        log(&quot;&lt;MyContinuation&gt;$result&quot;)\n        continuation.resumeWith(result)\n    }\n}\n</code></pre>\n<pre><code class=\"kotlin\">suspend fun main(){\n    GlobalScope.launch(MyContinuationInterceptor()) {\n        log(1)\n        val job = async {\n            log(2)\n            delay(1000)\n            log(3)\n            &quot;Hello&quot;\n        }\n        log(4)\n        val result = job.await()\n        log(&quot;5.$result&quot;)\n    }.join()\n    log(6)\n}\n</code></pre>\n<p>通过 <code>launch</code> 启动了一个协程，为他指定了我们的拦截器上下文，紧接着在其内部用<code>async</code> 启动了一个协程，<code>async</code> 和 <code>launch</code>从功能上是同等类型的函数，不同之处在于 <code>async</code> 启动的 <code>Job</code> 也就是实际上的 <code>Deferred</code> 可以有返回结果。可以通过 <code>await</code> 方法获取。</p>\n<pre><code class=\"txt\">[main] &lt;MyContinuation&gt; Success(kotlin.Unit)\n[main] 1\n[main] &lt;MyContinuation&gt; Success(kotlin.Unit)\n[main] 2\n[main] 4\n[kotlinx.coroutines.DefaultExecutor] &lt;MyContinuation&gt; Success(kotlin.Unit)\n[kotlinx.coroutines.DefaultExecutor] 3\n[kotlinx.coroutines.DefaultExecutor] &lt;MyContinuation&gt; Success(Hello)\n[kotlinx.coroutines.DefaultExecutor] 5.Hello\n[kotlinx.coroutines.DefaultExecutor] 6\n</code></pre>\n<p>首先，所有协程启动的时候，都会有一次<code>Continuation.resumeWith</code> 的操作，这一次操作对于调度器来说就是一次调度的机会，我们的协程有机会调度到其他线程的关键之处就在于这里。</p>\n<p>其次 <code>delay</code> 是挂起点， 1000ms 之后需要继续调度执行该协程，因此就有了 3 的日志。</p>\n<p>最后，正是我们需要的结果。</p>\n<p>而协程真正切换线程的逻辑源自于 <code>delay</code>  在 JVM 上，<code>delay</code> 实际上是一个 <code>ScheduledExcecutor</code> 里面添加了一个延时任务，因此会发生线程切换</p>\n<h2 id=\"调度器\"><a href=\"#调度器\" class=\"headerlink\" title=\"调度器\"></a>调度器</h2><pre><code class=\"kotlin\">public abstract class CoroutineDispatcher : AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {\n    public abstract fun dispatch(context: CoroutineContext, block: Runnable)\n}\n</code></pre>\n<p>调度器本身也是协程上下文的子类，同时实现了拦截器的接口， <code>dispatch</code> 方法会在拦截器的方法 <code>interceptContinuation</code> 中调用，进而实现协程的调用。所以如果我们香要自己实现自己的调度器，继承这个类<code>AbstracoroutineContextElement</code> 就可以</p>\n<ul>\n<li>Default: 线程池</li>\n<li>Main： UI 线程</li>\n<li>Unconfined：直接执行</li>\n<li>IO：线程池</li>\n</ul>\n<h3 id=\"UI-相关程序\"><a href=\"#UI-相关程序\" class=\"headerlink\" title=\"UI  相关程序\"></a>UI  相关程序</h3><p>Kotlin 的用户绝大部分是 Android 开发者，举一些常见的场景，点击一个按钮做异步任务回调刷新 UI </p>\n<pre><code class=\"kotlin\">getUserBtn.setOnClickListener {\n    getUser{user-&gt; {\n        handler.post{\n            userNameView.text = user.name\n        }\n    }}\n}\n</code></pre>\n<pre><code class=\"kotlin\">typealias Callback = (User) -&gt; Unit\n\nfun getUser(callback: Callback) {\n\n}\n</code></pre>\n<p>因为 <code>getUser</code> 需要切换到其他线程执行，因此回调通常也会在这个非 UI 线程中使用，确保 UI 可以刷新，需要 <code>handler.post</code> 切换到 UI 线程。</p>\n<p>过度到协程的写法；</p>\n<pre><code class=\"kotlin\">suspend fun getUserCoroutine()= suspendCoroutine&lt;User&gt; {\n    continuation -&gt; \n    getUser {\n        continuation.resume(it)\n    }\n}\n\ngetUserBtn.setOnClickListener {\n    GlobalScope.launch(Dispathcer.Main) {\n        userNameVite.text = getUserCoroutine().name\n    }\n}\n</code></pre>\n<p><strong>suspendCoroutine</strong></p>\n<p>它运行在协程当中，并且帮助我们获取当前协程的 <code>Continuation</code> 实例，也就是拿到回调，方柏霓我们调用它的 <code>resume</code> 和 <code>resumeWithException</code> 来返回结果或者抛出异常</p>\n<p><strong>Dispatchers.Main</strong></p>\n<pre><code class=\"kotlin\">internal object MainDispatcherLoader {\n    @JvmField\n    val dispatcher:MainCoroutineDispatcher = loadMainDispatcher()\n\n    private fun loadMainDispatcher() :MainCoroutineDispatcher {\n        return try {\n            val factories = MainDispatcherFactory::class.java.let {cle -&gt; \n                ServiceLoader.load(clz, clz.classLoader).toList()\n           }\n            factories.maxBy{it.loadPriority}?.tryCreateDispatcher(factories) ?: MissingMainCoroutineDispatcher(null)\n        } catch (e: Throwable) {\n            MissingMainCoroutineDispatcher(e)\n        }\n    }\n}\n</code></pre>\n<p>在 Android 当中，协程框架通过注册 <code>AndroidDispatcherFactory</code> 是的 <code>Main</code> 最终被赋值为 <code>HandlerDispatcher</code> 的实例。</p>\n<h3 id=\"线程安全问题\"><a href=\"#线程安全问题\" class=\"headerlink\" title=\"线程安全问题\"></a>线程安全问题</h3>"},{"_content":"# 协程\n\n```kotlin\nfun main() {\n    GlobalScope.launch {// 后台启动一个新的协程并继续， launch 协程的构建器\n        delay(1000L) // 非阻塞的等待1s，\n        println(\"World!\") // 延时后，输出 \n    }\n    println(\"Hello\") // 协程已再等待时，主线程还在继续\n    Thread.sleep(2000L) // 阻塞主线程 2s 保证， JVM 存活\n}\n```\n<!-- more-->\n协程是轻量级的线程。 `CoroutineScope` 通常与 `launch` 协程构建器一起启动。\n\n**GlobalScope**： 意味着新协程的生命周期与应用程序的生命周期一致\n\n`delay` 是一个特殊的挂起函数，不会造成线程阻塞，但是会挂起协程，并且只能再协程中使用。\n\n\n\n## 桥接阻塞与非阻塞的世界\n\n使用`runBlocking` 协程构建器来阻塞，使用非阻塞函数`delay` 方便，不易与 `Thread.sleep()` 阻塞函数混淆\n\n```kotlin\nfun main() {\n    GlobalScope.launch { //\n        delay(1000L)\n        println(\"world!\")\n    }\n    println(\"hello \")\n    runBlocking{ // 这个表达式阻塞了主线程\n        delay(2000L) \n    }\n}\n```\n\n上例，只使用了非阻塞函数 `delay`, 调用 `runBlocking` 的主线程会一直阻塞，直到 `runBlocking` 内部的协程执行完毕\n\n还可以使用 `runBlocking` 包裹 main 函数来执行：\n\n```kotlin\nfun main() = runBlocking<Unit> {\n    GlobalScope.launch {\n        delay(1000L)\n        println(\"world\")\n    }\n    println(\"Hello \")\n    delay(2000L)\n}\n```\n\n`runBlicking<Unit> {}` 作为用来启动顶层主协程的适配器。显式指定了返回类型 Unit， 因为在 Kotlin 中 main 函数必须返回 Unit 类型\n\n## 等待一个作业\n\n延迟一段时间来等待另一个协程运行并不是好选择，我们显式（非阻塞方式）等待所启动的后台 Job 执行结束\n\n```kotlin\nval job = GlobalScope.launch { // 启动一个新协程并持有这个作业的引用\n    delay(1000L)\n    println(\"world\")\n}\nprintln(\"hello \")\njob.join()// 等待直到子协程执行结束\n```\n\n这里主协程与后台作业的持续时间没有任何关系了。\n\n\n\n## 结构化的并发\n\n当我们使用 `GlobalScope.launch` 时，我们会创建一个顶层协程。虽然很轻，但运行时会消耗一些内存资源。如果忘记保持对新启动的协程的引用，它还会继续运行。如果协程中的代码挂起了会怎么样。如果我们启动了太多的协程并导致内存不足。必须手动保持对所有已启动协程的引用并 `join` 很容易出错\n\n结构化并发是解决这个问题的最佳方案。我们可以在执行操作所在的指定作用域内启动协程，而不是像通常使用线程（线程总是全局的）那样在 `GlobalScope` 中启动。\n\n我们使用`runBlocking` 协程构建器将 `main` 函数转化为协程，包括 `runBlocking` 在内的每个协程构建器都将 `CoroutineScope` 的实例添加到其代码块所在的作用域中。可以在这个作用域中启动这个线程而不需要显式 `join` 中，因为外部协程（示例中的 runBlocking) 直到在其他作用域中启动的所有协程都执行完毕后才会结束。\n\n```kotlin\nfun main() = runBlocking { // this: CoroutineScope\n    launch { // 在 runBlocking 作用域中启动一个新的协程\n        delay(1000L)\n        println(\"world\")\n    }\n    println(\"Hello, \")\n}\n```\n\n## 作用域构建\n\n除了由不同的构建器提供协程作用域之外，还可以使用 `coroutineScope` 构建器生命自己的作用域，它会主动创建一个协程作用域并且在所有已启动子协程执行完毕之前不会结束\n\n`runBlocking` 与 `coroutineScope`  可能看起来很类似，因为他们都会等待其协程体以及所有子协程结束。主要区别在于 `runBlocking` 方法会**阻塞**当前线程来等待，而 `coroutineScope` 只会挂起，会释放底层线程用于其他用途。\n\n```kotlin\nfun main = runBlocking { // coroutine scope\n    launch {\n        delay(200L)\n        println(\"Task from runBlocking\")\n    }\n    \n    coroutineScope {// 创建一个作用域协程\n        launch {\n            delay(500L)\n            println(\"Task from nested launch\")\n        }\n        delay(100L)\n\t\tprintln(\"Task from coroutine scope\") // 这一行会在内嵌 launch 之前输出\n    }\n    println(\"Coroutine scope is over\")    // 这一行在内嵌 launch 执行完毕后输出\n}\n```\n\n\n\n## 提取函数重构\n\n当将 `launch{}` 内部代码块提取到独立的函数体中时，需要 `suspend`  修饰新函数。这是一个挂起函数。\n\n```kotlin\nfun main() = runBlocking {\n    launch {doWorld()}\n    println(\"hello \")\n}\n\nsuspend fun doWorld() {\n    delay(1000L)\n    println(\"world!\")\n}\n```\n\n## 协程很轻量\n\n```kotlin\nfun main = runBlocking {\n    repeat(100_000) {\n        launch {\n            delay(5000L)\n            println(\".\")\n        }\n    }\n}\n```\n\n10w 个协程，每个都输出一个点，如果尝试使用线程，会发生内存不足的情况\n\n## 全局协程像守护线程\n\n```kotlin\nGlobalScope.launch {\n    repeat(1000) { i -> \n\t\tprintln(\"I`m sleeping $i ...\")\n                  delay(500L)\n\t    \t\t\t}\n}\ndelay(1399L)\n```\n\n","source":"_posts/Kotlin/协程/协程.md","raw":"# 协程\n\n```kotlin\nfun main() {\n    GlobalScope.launch {// 后台启动一个新的协程并继续， launch 协程的构建器\n        delay(1000L) // 非阻塞的等待1s，\n        println(\"World!\") // 延时后，输出 \n    }\n    println(\"Hello\") // 协程已再等待时，主线程还在继续\n    Thread.sleep(2000L) // 阻塞主线程 2s 保证， JVM 存活\n}\n```\n<!-- more-->\n协程是轻量级的线程。 `CoroutineScope` 通常与 `launch` 协程构建器一起启动。\n\n**GlobalScope**： 意味着新协程的生命周期与应用程序的生命周期一致\n\n`delay` 是一个特殊的挂起函数，不会造成线程阻塞，但是会挂起协程，并且只能再协程中使用。\n\n\n\n## 桥接阻塞与非阻塞的世界\n\n使用`runBlocking` 协程构建器来阻塞，使用非阻塞函数`delay` 方便，不易与 `Thread.sleep()` 阻塞函数混淆\n\n```kotlin\nfun main() {\n    GlobalScope.launch { //\n        delay(1000L)\n        println(\"world!\")\n    }\n    println(\"hello \")\n    runBlocking{ // 这个表达式阻塞了主线程\n        delay(2000L) \n    }\n}\n```\n\n上例，只使用了非阻塞函数 `delay`, 调用 `runBlocking` 的主线程会一直阻塞，直到 `runBlocking` 内部的协程执行完毕\n\n还可以使用 `runBlocking` 包裹 main 函数来执行：\n\n```kotlin\nfun main() = runBlocking<Unit> {\n    GlobalScope.launch {\n        delay(1000L)\n        println(\"world\")\n    }\n    println(\"Hello \")\n    delay(2000L)\n}\n```\n\n`runBlicking<Unit> {}` 作为用来启动顶层主协程的适配器。显式指定了返回类型 Unit， 因为在 Kotlin 中 main 函数必须返回 Unit 类型\n\n## 等待一个作业\n\n延迟一段时间来等待另一个协程运行并不是好选择，我们显式（非阻塞方式）等待所启动的后台 Job 执行结束\n\n```kotlin\nval job = GlobalScope.launch { // 启动一个新协程并持有这个作业的引用\n    delay(1000L)\n    println(\"world\")\n}\nprintln(\"hello \")\njob.join()// 等待直到子协程执行结束\n```\n\n这里主协程与后台作业的持续时间没有任何关系了。\n\n\n\n## 结构化的并发\n\n当我们使用 `GlobalScope.launch` 时，我们会创建一个顶层协程。虽然很轻，但运行时会消耗一些内存资源。如果忘记保持对新启动的协程的引用，它还会继续运行。如果协程中的代码挂起了会怎么样。如果我们启动了太多的协程并导致内存不足。必须手动保持对所有已启动协程的引用并 `join` 很容易出错\n\n结构化并发是解决这个问题的最佳方案。我们可以在执行操作所在的指定作用域内启动协程，而不是像通常使用线程（线程总是全局的）那样在 `GlobalScope` 中启动。\n\n我们使用`runBlocking` 协程构建器将 `main` 函数转化为协程，包括 `runBlocking` 在内的每个协程构建器都将 `CoroutineScope` 的实例添加到其代码块所在的作用域中。可以在这个作用域中启动这个线程而不需要显式 `join` 中，因为外部协程（示例中的 runBlocking) 直到在其他作用域中启动的所有协程都执行完毕后才会结束。\n\n```kotlin\nfun main() = runBlocking { // this: CoroutineScope\n    launch { // 在 runBlocking 作用域中启动一个新的协程\n        delay(1000L)\n        println(\"world\")\n    }\n    println(\"Hello, \")\n}\n```\n\n## 作用域构建\n\n除了由不同的构建器提供协程作用域之外，还可以使用 `coroutineScope` 构建器生命自己的作用域，它会主动创建一个协程作用域并且在所有已启动子协程执行完毕之前不会结束\n\n`runBlocking` 与 `coroutineScope`  可能看起来很类似，因为他们都会等待其协程体以及所有子协程结束。主要区别在于 `runBlocking` 方法会**阻塞**当前线程来等待，而 `coroutineScope` 只会挂起，会释放底层线程用于其他用途。\n\n```kotlin\nfun main = runBlocking { // coroutine scope\n    launch {\n        delay(200L)\n        println(\"Task from runBlocking\")\n    }\n    \n    coroutineScope {// 创建一个作用域协程\n        launch {\n            delay(500L)\n            println(\"Task from nested launch\")\n        }\n        delay(100L)\n\t\tprintln(\"Task from coroutine scope\") // 这一行会在内嵌 launch 之前输出\n    }\n    println(\"Coroutine scope is over\")    // 这一行在内嵌 launch 执行完毕后输出\n}\n```\n\n\n\n## 提取函数重构\n\n当将 `launch{}` 内部代码块提取到独立的函数体中时，需要 `suspend`  修饰新函数。这是一个挂起函数。\n\n```kotlin\nfun main() = runBlocking {\n    launch {doWorld()}\n    println(\"hello \")\n}\n\nsuspend fun doWorld() {\n    delay(1000L)\n    println(\"world!\")\n}\n```\n\n## 协程很轻量\n\n```kotlin\nfun main = runBlocking {\n    repeat(100_000) {\n        launch {\n            delay(5000L)\n            println(\".\")\n        }\n    }\n}\n```\n\n10w 个协程，每个都输出一个点，如果尝试使用线程，会发生内存不足的情况\n\n## 全局协程像守护线程\n\n```kotlin\nGlobalScope.launch {\n    repeat(1000) { i -> \n\t\tprintln(\"I`m sleeping $i ...\")\n                  delay(500L)\n\t    \t\t\t}\n}\ndelay(1399L)\n```\n\n","slug":"Kotlin/协程/协程","published":1,"date":"2021-01-29T15:54:28.319Z","updated":"2021-01-29T16:15:57.661Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8lh0043sz5qj74ojxoj","content":"<h1 id=\"协程\"><a href=\"#协程\" class=\"headerlink\" title=\"协程\"></a>协程</h1><pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span><span class=\"token comment\" spellcheck=\"true\">// 后台启动一个新的协程并继续， launch 协程的构建器</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 非阻塞的等待1s，</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"World!\"</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 延时后，输出 </span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 协程已再等待时，主线程还在继续</span>\n    Thread<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">2000L</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 阻塞主线程 2s 保证， JVM 存活</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<a id=\"more\"></a>\n<p>协程是轻量级的线程。 <code>CoroutineScope</code> 通常与 <code>launch</code> 协程构建器一起启动。</p>\n<p><strong>GlobalScope</strong>： 意味着新协程的生命周期与应用程序的生命周期一致</p>\n<p><code>delay</code> 是一个特殊的挂起函数，不会造成线程阻塞，但是会挂起协程，并且只能再协程中使用。</p>\n<h2 id=\"桥接阻塞与非阻塞的世界\"><a href=\"#桥接阻塞与非阻塞的世界\" class=\"headerlink\" title=\"桥接阻塞与非阻塞的世界\"></a>桥接阻塞与非阻塞的世界</h2><p>使用<code>runBlocking</code> 协程构建器来阻塞，使用非阻塞函数<code>delay</code> 方便，不易与 <code>Thread.sleep()</code> 阻塞函数混淆</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">//</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"world!\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello \"</span><span class=\"token punctuation\">)</span>\n    runBlocking<span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 这个表达式阻塞了主线程</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">2000L</span><span class=\"token punctuation\">)</span> \n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>上例，只使用了非阻塞函数 <code>delay</code>, 调用 <code>runBlocking</code> 的主线程会一直阻塞，直到 <code>runBlocking</code> 内部的协程执行完毕</p>\n<p>还可以使用 <code>runBlocking</code> 包裹 main 函数来执行：</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> runBlocking<span class=\"token operator\">&lt;</span>Unit<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"world\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello \"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">2000L</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><code>runBlicking&lt;Unit&gt; {}</code> 作为用来启动顶层主协程的适配器。显式指定了返回类型 Unit， 因为在 Kotlin 中 main 函数必须返回 Unit 类型</p>\n<h2 id=\"等待一个作业\"><a href=\"#等待一个作业\" class=\"headerlink\" title=\"等待一个作业\"></a>等待一个作业</h2><p>延迟一段时间来等待另一个协程运行并不是好选择，我们显式（非阻塞方式）等待所启动的后台 Job 执行结束</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> job <span class=\"token operator\">=</span> GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 启动一个新协程并持有这个作业的引用</span>\n    <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"world\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello \"</span><span class=\"token punctuation\">)</span>\njob<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token comment\" spellcheck=\"true\">// 等待直到子协程执行结束</span>\n</code></pre>\n<p>这里主协程与后台作业的持续时间没有任何关系了。</p>\n<h2 id=\"结构化的并发\"><a href=\"#结构化的并发\" class=\"headerlink\" title=\"结构化的并发\"></a>结构化的并发</h2><p>当我们使用 <code>GlobalScope.launch</code> 时，我们会创建一个顶层协程。虽然很轻，但运行时会消耗一些内存资源。如果忘记保持对新启动的协程的引用，它还会继续运行。如果协程中的代码挂起了会怎么样。如果我们启动了太多的协程并导致内存不足。必须手动保持对所有已启动协程的引用并 <code>join</code> 很容易出错</p>\n<p>结构化并发是解决这个问题的最佳方案。我们可以在执行操作所在的指定作用域内启动协程，而不是像通常使用线程（线程总是全局的）那样在 <code>GlobalScope</code> 中启动。</p>\n<p>我们使用<code>runBlocking</code> 协程构建器将 <code>main</code> 函数转化为协程，包括 <code>runBlocking</code> 在内的每个协程构建器都将 <code>CoroutineScope</code> 的实例添加到其代码块所在的作用域中。可以在这个作用域中启动这个线程而不需要显式 <code>join</code> 中，因为外部协程（示例中的 runBlocking) 直到在其他作用域中启动的所有协程都执行完毕后才会结束。</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> runBlocking <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// this: CoroutineScope</span>\n    launch <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 在 runBlocking 作用域中启动一个新的协程</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"world\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, \"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"作用域构建\"><a href=\"#作用域构建\" class=\"headerlink\" title=\"作用域构建\"></a>作用域构建</h2><p>除了由不同的构建器提供协程作用域之外，还可以使用 <code>coroutineScope</code> 构建器生命自己的作用域，它会主动创建一个协程作用域并且在所有已启动子协程执行完毕之前不会结束</p>\n<p><code>runBlocking</code> 与 <code>coroutineScope</code>  可能看起来很类似，因为他们都会等待其协程体以及所有子协程结束。主要区别在于 <code>runBlocking</code> 方法会<strong>阻塞</strong>当前线程来等待，而 <code>coroutineScope</code> 只会挂起，会释放底层线程用于其他用途。</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> main <span class=\"token operator\">=</span> runBlocking <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// coroutine scope</span>\n    launch <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">200L</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Task from runBlocking\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    coroutineScope <span class=\"token punctuation\">{</span><span class=\"token comment\" spellcheck=\"true\">// 创建一个作用域协程</span>\n        launch <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">500L</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Task from nested launch\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">100L</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Task from coroutine scope\"</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 这一行会在内嵌 launch 之前输出</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Coroutine scope is over\"</span><span class=\"token punctuation\">)</span>    <span class=\"token comment\" spellcheck=\"true\">// 这一行在内嵌 launch 执行完毕后输出</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"提取函数重构\"><a href=\"#提取函数重构\" class=\"headerlink\" title=\"提取函数重构\"></a>提取函数重构</h2><p>当将 <code>launch{}</code> 内部代码块提取到独立的函数体中时，需要 <code>suspend</code>  修饰新函数。这是一个挂起函数。</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> runBlocking <span class=\"token punctuation\">{</span>\n    launch <span class=\"token punctuation\">{</span><span class=\"token function\">doWorld</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello \"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\nsuspend <span class=\"token keyword\">fun</span> <span class=\"token function\">doWorld</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"world!\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"协程很轻量\"><a href=\"#协程很轻量\" class=\"headerlink\" title=\"协程很轻量\"></a>协程很轻量</h2><pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> main <span class=\"token operator\">=</span> runBlocking <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">repeat</span><span class=\"token punctuation\">(</span>100_000<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        launch <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">5000L</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\".\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>10w 个协程，每个都输出一个点，如果尝试使用线程，会发生内存不足的情况</p>\n<h2 id=\"全局协程像守护线程\"><a href=\"#全局协程像守护线程\" class=\"headerlink\" title=\"全局协程像守护线程\"></a>全局协程像守护线程</h2><pre class=\" language-kotlin\"><code class=\"language-kotlin\">GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">repeat</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> i <span class=\"token operator\">-></span> \n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"I`m sleeping <span class=\"token interpolation variable\">$i</span> ...\"</span><span class=\"token punctuation\">)</span>\n                  <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">500L</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1399L</span><span class=\"token punctuation\">)</span>\n</code></pre>\n","site":{"data":{}},"excerpt":"<h1 id=\"协程\"><a href=\"#协程\" class=\"headerlink\" title=\"协程\"></a>协程</h1><pre><code class=\"kotlin\">fun main() {\n    GlobalScope.launch {// 后台启动一个新的协程并继续， launch 协程的构建器\n        delay(1000L) // 非阻塞的等待1s，\n        println(&quot;World!&quot;) // 延时后，输出 \n    }\n    println(&quot;Hello&quot;) // 协程已再等待时，主线程还在继续\n    Thread.sleep(2000L) // 阻塞主线程 2s 保证， JVM 存活\n}\n</code></pre>","more":"<p>协程是轻量级的线程。 <code>CoroutineScope</code> 通常与 <code>launch</code> 协程构建器一起启动。</p>\n<p><strong>GlobalScope</strong>： 意味着新协程的生命周期与应用程序的生命周期一致</p>\n<p><code>delay</code> 是一个特殊的挂起函数，不会造成线程阻塞，但是会挂起协程，并且只能再协程中使用。</p>\n<h2 id=\"桥接阻塞与非阻塞的世界\"><a href=\"#桥接阻塞与非阻塞的世界\" class=\"headerlink\" title=\"桥接阻塞与非阻塞的世界\"></a>桥接阻塞与非阻塞的世界</h2><p>使用<code>runBlocking</code> 协程构建器来阻塞，使用非阻塞函数<code>delay</code> 方便，不易与 <code>Thread.sleep()</code> 阻塞函数混淆</p>\n<pre><code class=\"kotlin\">fun main() {\n    GlobalScope.launch { //\n        delay(1000L)\n        println(&quot;world!&quot;)\n    }\n    println(&quot;hello &quot;)\n    runBlocking{ // 这个表达式阻塞了主线程\n        delay(2000L) \n    }\n}\n</code></pre>\n<p>上例，只使用了非阻塞函数 <code>delay</code>, 调用 <code>runBlocking</code> 的主线程会一直阻塞，直到 <code>runBlocking</code> 内部的协程执行完毕</p>\n<p>还可以使用 <code>runBlocking</code> 包裹 main 函数来执行：</p>\n<pre><code class=\"kotlin\">fun main() = runBlocking&lt;Unit&gt; {\n    GlobalScope.launch {\n        delay(1000L)\n        println(&quot;world&quot;)\n    }\n    println(&quot;Hello &quot;)\n    delay(2000L)\n}\n</code></pre>\n<p><code>runBlicking&lt;Unit&gt; {}</code> 作为用来启动顶层主协程的适配器。显式指定了返回类型 Unit， 因为在 Kotlin 中 main 函数必须返回 Unit 类型</p>\n<h2 id=\"等待一个作业\"><a href=\"#等待一个作业\" class=\"headerlink\" title=\"等待一个作业\"></a>等待一个作业</h2><p>延迟一段时间来等待另一个协程运行并不是好选择，我们显式（非阻塞方式）等待所启动的后台 Job 执行结束</p>\n<pre><code class=\"kotlin\">val job = GlobalScope.launch { // 启动一个新协程并持有这个作业的引用\n    delay(1000L)\n    println(&quot;world&quot;)\n}\nprintln(&quot;hello &quot;)\njob.join()// 等待直到子协程执行结束\n</code></pre>\n<p>这里主协程与后台作业的持续时间没有任何关系了。</p>\n<h2 id=\"结构化的并发\"><a href=\"#结构化的并发\" class=\"headerlink\" title=\"结构化的并发\"></a>结构化的并发</h2><p>当我们使用 <code>GlobalScope.launch</code> 时，我们会创建一个顶层协程。虽然很轻，但运行时会消耗一些内存资源。如果忘记保持对新启动的协程的引用，它还会继续运行。如果协程中的代码挂起了会怎么样。如果我们启动了太多的协程并导致内存不足。必须手动保持对所有已启动协程的引用并 <code>join</code> 很容易出错</p>\n<p>结构化并发是解决这个问题的最佳方案。我们可以在执行操作所在的指定作用域内启动协程，而不是像通常使用线程（线程总是全局的）那样在 <code>GlobalScope</code> 中启动。</p>\n<p>我们使用<code>runBlocking</code> 协程构建器将 <code>main</code> 函数转化为协程，包括 <code>runBlocking</code> 在内的每个协程构建器都将 <code>CoroutineScope</code> 的实例添加到其代码块所在的作用域中。可以在这个作用域中启动这个线程而不需要显式 <code>join</code> 中，因为外部协程（示例中的 runBlocking) 直到在其他作用域中启动的所有协程都执行完毕后才会结束。</p>\n<pre><code class=\"kotlin\">fun main() = runBlocking { // this: CoroutineScope\n    launch { // 在 runBlocking 作用域中启动一个新的协程\n        delay(1000L)\n        println(&quot;world&quot;)\n    }\n    println(&quot;Hello, &quot;)\n}\n</code></pre>\n<h2 id=\"作用域构建\"><a href=\"#作用域构建\" class=\"headerlink\" title=\"作用域构建\"></a>作用域构建</h2><p>除了由不同的构建器提供协程作用域之外，还可以使用 <code>coroutineScope</code> 构建器生命自己的作用域，它会主动创建一个协程作用域并且在所有已启动子协程执行完毕之前不会结束</p>\n<p><code>runBlocking</code> 与 <code>coroutineScope</code>  可能看起来很类似，因为他们都会等待其协程体以及所有子协程结束。主要区别在于 <code>runBlocking</code> 方法会<strong>阻塞</strong>当前线程来等待，而 <code>coroutineScope</code> 只会挂起，会释放底层线程用于其他用途。</p>\n<pre><code class=\"kotlin\">fun main = runBlocking { // coroutine scope\n    launch {\n        delay(200L)\n        println(&quot;Task from runBlocking&quot;)\n    }\n\n    coroutineScope {// 创建一个作用域协程\n        launch {\n            delay(500L)\n            println(&quot;Task from nested launch&quot;)\n        }\n        delay(100L)\n        println(&quot;Task from coroutine scope&quot;) // 这一行会在内嵌 launch 之前输出\n    }\n    println(&quot;Coroutine scope is over&quot;)    // 这一行在内嵌 launch 执行完毕后输出\n}\n</code></pre>\n<h2 id=\"提取函数重构\"><a href=\"#提取函数重构\" class=\"headerlink\" title=\"提取函数重构\"></a>提取函数重构</h2><p>当将 <code>launch{}</code> 内部代码块提取到独立的函数体中时，需要 <code>suspend</code>  修饰新函数。这是一个挂起函数。</p>\n<pre><code class=\"kotlin\">fun main() = runBlocking {\n    launch {doWorld()}\n    println(&quot;hello &quot;)\n}\n\nsuspend fun doWorld() {\n    delay(1000L)\n    println(&quot;world!&quot;)\n}\n</code></pre>\n<h2 id=\"协程很轻量\"><a href=\"#协程很轻量\" class=\"headerlink\" title=\"协程很轻量\"></a>协程很轻量</h2><pre><code class=\"kotlin\">fun main = runBlocking {\n    repeat(100_000) {\n        launch {\n            delay(5000L)\n            println(&quot;.&quot;)\n        }\n    }\n}\n</code></pre>\n<p>10w 个协程，每个都输出一个点，如果尝试使用线程，会发生内存不足的情况</p>\n<h2 id=\"全局协程像守护线程\"><a href=\"#全局协程像守护线程\" class=\"headerlink\" title=\"全局协程像守护线程\"></a>全局协程像守护线程</h2><pre><code class=\"kotlin\">GlobalScope.launch {\n    repeat(1000) { i -&gt; \n        println(&quot;I`m sleeping $i ...&quot;)\n                  delay(500L)\n                    }\n}\ndelay(1399L)\n</code></pre>"},{"title":"协程知识点","_content":"\n## 什么是协程\n\n1. **轻量级的线程**，并不完全是线程\n2. 可以**顺序的写异步代码**， 降低异步编程带来的负担\n3. **更高效**，**多个协程可以公用一个线程**。一个 APP 可以使用的线程数量是有限的，但可以使用的协程是几乎无限的\n4. **运行在协程中的可中断的方法不会阻塞当前线程**\n<!-- more-->\n## 可中断的方法（suspending functions）\n\n**可中断的方法有能力中断协程的执行**， 当可中断的方法执行完毕后，结者就可以使用它们返回的结果\n\n```kotlin\nval user = suspend { userService.doLogin(username, password)}\nval currentFriends = suspend { userService.requestCurrentFriends(user) }\n```\n\n* 可中断方法可以运行在相同或不同的线程，取决于使用方式*\n* 可中断的方法只能运行在协程中或其它可中断的方法中\n\n```kotlin\nsuspend fun suspendingFunction(): Int {\n    // do long things\n    return 0\n}\n```\n\n## 协程上下文（Coroutine Context）\n\n*协程上下文是一系列规则和配置的集合，它决定了协程的运行方式*， 其内部结构是一个列表容器\n\n## withContext\n\n**在协程内部**，这个方法可以轻易的改变代码运行时所在的上下文。它是一个可中断的方法，所以调用它会中断协程的执行，直到执行完成。\n\n```kotlin\nsuspend fun suspendLogin(username: String, password: String):String = \nwithContext(Dispatchers.Main) {\n    userService.doLogin(username, password)\n}\n```\n\n### 调度器(dispatcher)\n\n* **Default**： 未指定 `dispathcer ` 的时候会默认使用。一般用于 CPU 密集型任务，特别是计算。可以使用和 CPU 核数一样多的线程\n* **IO**：用于输入、输出场景。通常涉及会阻塞线程，需要等待另一个系统响应的任务，比如：网络请求、数据库操作、读写文件。它不使用CPU，可以同一时间运行多个线程，默认数量是 64 的线程池。\n* **UnConfined**： 如果不在乎启动多少个新城，那么可以使用。它使用的线程是不可控制的，除非你特别清楚你在做什么，否则不建议\n* **Main**: 这个是 UI 相关的\n\n## 协程构造器（Coroutine Builders）\n\n根据实际情况，我们可以选择不同的协程构造器，也可以自己创建\n\n### runBlocking\n\n这个构造器会阻塞当前线程，直到协程内的所有任务执行完毕。\n\n`runBolcking` 对于测试可中断的方法非常有用。在测试的时候，将可中断的方法运行在 `runBlocking` 构建的协程内部，这样可以保证，在这些可中断的方法返回结果前，当前测试线程不会结束。\n\n```kotlin\nfun testSuspendedFunction() = runBlocking {\n    val res = suspendingTask1()\n    assertEquals(0, res)\n}\n```\n\n除了这个场景意外，几乎永不到\n\n### launch\n\n这个构造器狠重要，因为它可以 **很轻易的创建一个协程**，经常使用。\n\n`launch` 不会阻塞当前线程（前期是我们使用了合适的 `dispatcher`）\n\n这个构造器需要一个作用域（`scope`）\n\n```kotlin\nGlobalScope.launch(Dispatchers.Main){\n    ....\n}\n```\n\n`launch` 方法返回一个 `Job` ，`Job`  继承了协程上下文(`CoroutineContext`)\n\n`Job` 提供了很多有用的方法，一个 `Job` 可以有一个父 `Job`，父 `Job` 可以控制子 `Job`\n\n#### job.join\n\n这个方法可以中断与当前 `Job` 关联的协程，直到所有子 `Job` 执行完成。协程内所有可中断的方法与当前 `Job` 关联。直到子 `Job` 全部执行完成，与当前 `Job` 关联的协程才能继续执行。\n\n```kotlin\nval job = GlobalScope.launch(Dispatchers.Main) {\n    doCoroutineTask()\n    val res1 = suspendingTask1()\n    val res2 = suspendingTask2()\n    process(res1, res2)\n}\n\njob.join()\n```\n\n`job.join()` 是一个可中断的方法，所以它应该在协程内部被调用。\n\n#### job.cancel()\n\n取消所有与其关联的子 `Job` ，加入 `suspendingTask1()` 正在执行的时候 `Job` 调用了取消，这个时候 `res1` 不会再返回， 而且 `suspendingTask2()` 也不会再执行\n\n```kotlin\nval job = GlobalScope.launch(Dispatchers.Main) {\n    doCoroutineTask()\n    val res1 = suspendingTask1()\n    val res2 = suspendingTask2()\n    process(res1, res2)\n}\n\njob.cancel()\n```\n\n`job.cancel` 是一个普通方法，不必运行再协程内部\n\n### async\n\n`async` **允许并行地运行多个子线程任务**， 它不是一个可中断方法，当调用 `async` 启动子协程的同事，后面的代码也会立即执行。 `async` 通常需要运行再另外一个协程内部，它会返回一个特殊的 `Job` -> `Deferred`\n\n#### Deferred \n\n`Deferred` 有一个 `await()` 函数，它是一个可终端的方法，当需要获取 `async` 的结果是，需要调用 `await()` 方法等待。调用后，会中断当前线程，直到其返回结果\n\n```kotlin\nGlobalScope.launch(Dispatchers.Main) {\n    val user = withContext(Dispathcers.IO) {userService.doLogin(username, password)}\n    val currendFriend = async(Dispatchers.IO) {userService.requestCurrentFriends(user) }\n    val suggestedFriends = async(Dispatchers.IO) { userService.requestSuggestedFriends(user)}\n    \n    val finalUser = user.copy(friends = currenFriends.await() + suggestedFriends.await())\n}\n```\n\n\n\n## 作用域(Scope)\n\n### GlobalScope\n\n全局的作用域，如果协程的运行周期和 App 的生命周期一样长的滑，创建协程的时候可以使用它。不应该和任何可以销毁的组件绑定使用\n\n```kotlin\nGlobalScope.launch(Dispatchers.Main) {\n    \n}\n```\n\n* 是否伴随 APP 整个生命周期\n* 没有界面和组件绑定\n\n### 自定义协程作用域\n\n任何类都可以继承 `CoroutineScope` 作为一个作用域，唯一需要做的事儿就是去重写 `coroutineContext` 属性\n\n需要先明白两个概念 `dispathcer` 和 `Job`\n\n* dispathcer： 用于指定协程默认使用的 dispatcher\n* Job: 用在任何需要的时候取消协程\n\n```kotlin\nclass MainActivity:AppCompatActivity(), CoroutineScope {\n    override val coroutineContext: CoroutineContext\n    \tget() = Dispatchers.Main + job\n    \n    private lateinit var job: Job\n}\n```\n\n\n\n \n\n","source":"_posts/Kotlin/协程/协程知识点.md","raw":"---\ntitle: 协程知识点\ntag: Kotlin\n---\n\n## 什么是协程\n\n1. **轻量级的线程**，并不完全是线程\n2. 可以**顺序的写异步代码**， 降低异步编程带来的负担\n3. **更高效**，**多个协程可以公用一个线程**。一个 APP 可以使用的线程数量是有限的，但可以使用的协程是几乎无限的\n4. **运行在协程中的可中断的方法不会阻塞当前线程**\n<!-- more-->\n## 可中断的方法（suspending functions）\n\n**可中断的方法有能力中断协程的执行**， 当可中断的方法执行完毕后，结者就可以使用它们返回的结果\n\n```kotlin\nval user = suspend { userService.doLogin(username, password)}\nval currentFriends = suspend { userService.requestCurrentFriends(user) }\n```\n\n* 可中断方法可以运行在相同或不同的线程，取决于使用方式*\n* 可中断的方法只能运行在协程中或其它可中断的方法中\n\n```kotlin\nsuspend fun suspendingFunction(): Int {\n    // do long things\n    return 0\n}\n```\n\n## 协程上下文（Coroutine Context）\n\n*协程上下文是一系列规则和配置的集合，它决定了协程的运行方式*， 其内部结构是一个列表容器\n\n## withContext\n\n**在协程内部**，这个方法可以轻易的改变代码运行时所在的上下文。它是一个可中断的方法，所以调用它会中断协程的执行，直到执行完成。\n\n```kotlin\nsuspend fun suspendLogin(username: String, password: String):String = \nwithContext(Dispatchers.Main) {\n    userService.doLogin(username, password)\n}\n```\n\n### 调度器(dispatcher)\n\n* **Default**： 未指定 `dispathcer ` 的时候会默认使用。一般用于 CPU 密集型任务，特别是计算。可以使用和 CPU 核数一样多的线程\n* **IO**：用于输入、输出场景。通常涉及会阻塞线程，需要等待另一个系统响应的任务，比如：网络请求、数据库操作、读写文件。它不使用CPU，可以同一时间运行多个线程，默认数量是 64 的线程池。\n* **UnConfined**： 如果不在乎启动多少个新城，那么可以使用。它使用的线程是不可控制的，除非你特别清楚你在做什么，否则不建议\n* **Main**: 这个是 UI 相关的\n\n## 协程构造器（Coroutine Builders）\n\n根据实际情况，我们可以选择不同的协程构造器，也可以自己创建\n\n### runBlocking\n\n这个构造器会阻塞当前线程，直到协程内的所有任务执行完毕。\n\n`runBolcking` 对于测试可中断的方法非常有用。在测试的时候，将可中断的方法运行在 `runBlocking` 构建的协程内部，这样可以保证，在这些可中断的方法返回结果前，当前测试线程不会结束。\n\n```kotlin\nfun testSuspendedFunction() = runBlocking {\n    val res = suspendingTask1()\n    assertEquals(0, res)\n}\n```\n\n除了这个场景意外，几乎永不到\n\n### launch\n\n这个构造器狠重要，因为它可以 **很轻易的创建一个协程**，经常使用。\n\n`launch` 不会阻塞当前线程（前期是我们使用了合适的 `dispatcher`）\n\n这个构造器需要一个作用域（`scope`）\n\n```kotlin\nGlobalScope.launch(Dispatchers.Main){\n    ....\n}\n```\n\n`launch` 方法返回一个 `Job` ，`Job`  继承了协程上下文(`CoroutineContext`)\n\n`Job` 提供了很多有用的方法，一个 `Job` 可以有一个父 `Job`，父 `Job` 可以控制子 `Job`\n\n#### job.join\n\n这个方法可以中断与当前 `Job` 关联的协程，直到所有子 `Job` 执行完成。协程内所有可中断的方法与当前 `Job` 关联。直到子 `Job` 全部执行完成，与当前 `Job` 关联的协程才能继续执行。\n\n```kotlin\nval job = GlobalScope.launch(Dispatchers.Main) {\n    doCoroutineTask()\n    val res1 = suspendingTask1()\n    val res2 = suspendingTask2()\n    process(res1, res2)\n}\n\njob.join()\n```\n\n`job.join()` 是一个可中断的方法，所以它应该在协程内部被调用。\n\n#### job.cancel()\n\n取消所有与其关联的子 `Job` ，加入 `suspendingTask1()` 正在执行的时候 `Job` 调用了取消，这个时候 `res1` 不会再返回， 而且 `suspendingTask2()` 也不会再执行\n\n```kotlin\nval job = GlobalScope.launch(Dispatchers.Main) {\n    doCoroutineTask()\n    val res1 = suspendingTask1()\n    val res2 = suspendingTask2()\n    process(res1, res2)\n}\n\njob.cancel()\n```\n\n`job.cancel` 是一个普通方法，不必运行再协程内部\n\n### async\n\n`async` **允许并行地运行多个子线程任务**， 它不是一个可中断方法，当调用 `async` 启动子协程的同事，后面的代码也会立即执行。 `async` 通常需要运行再另外一个协程内部，它会返回一个特殊的 `Job` -> `Deferred`\n\n#### Deferred \n\n`Deferred` 有一个 `await()` 函数，它是一个可终端的方法，当需要获取 `async` 的结果是，需要调用 `await()` 方法等待。调用后，会中断当前线程，直到其返回结果\n\n```kotlin\nGlobalScope.launch(Dispatchers.Main) {\n    val user = withContext(Dispathcers.IO) {userService.doLogin(username, password)}\n    val currendFriend = async(Dispatchers.IO) {userService.requestCurrentFriends(user) }\n    val suggestedFriends = async(Dispatchers.IO) { userService.requestSuggestedFriends(user)}\n    \n    val finalUser = user.copy(friends = currenFriends.await() + suggestedFriends.await())\n}\n```\n\n\n\n## 作用域(Scope)\n\n### GlobalScope\n\n全局的作用域，如果协程的运行周期和 App 的生命周期一样长的滑，创建协程的时候可以使用它。不应该和任何可以销毁的组件绑定使用\n\n```kotlin\nGlobalScope.launch(Dispatchers.Main) {\n    \n}\n```\n\n* 是否伴随 APP 整个生命周期\n* 没有界面和组件绑定\n\n### 自定义协程作用域\n\n任何类都可以继承 `CoroutineScope` 作为一个作用域，唯一需要做的事儿就是去重写 `coroutineContext` 属性\n\n需要先明白两个概念 `dispathcer` 和 `Job`\n\n* dispathcer： 用于指定协程默认使用的 dispatcher\n* Job: 用在任何需要的时候取消协程\n\n```kotlin\nclass MainActivity:AppCompatActivity(), CoroutineScope {\n    override val coroutineContext: CoroutineContext\n    \tget() = Dispatchers.Main + job\n    \n    private lateinit var job: Job\n}\n```\n\n\n\n \n\n","slug":"Kotlin/协程/协程知识点","published":1,"date":"2021-01-29T15:54:28.320Z","updated":"2021-01-29T16:15:36.741Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkjhb8lj0045sz5qof650p3a","content":"<h2 id=\"什么是协程\"><a href=\"#什么是协程\" class=\"headerlink\" title=\"什么是协程\"></a>什么是协程</h2><ol>\n<li><strong>轻量级的线程</strong>，并不完全是线程</li>\n<li>可以<strong>顺序的写异步代码</strong>， 降低异步编程带来的负担</li>\n<li><strong>更高效</strong>，<strong>多个协程可以公用一个线程</strong>。一个 APP 可以使用的线程数量是有限的，但可以使用的协程是几乎无限的</li>\n<li><strong>运行在协程中的可中断的方法不会阻塞当前线程</strong><a id=\"more\"></a>\n<h2 id=\"可中断的方法（suspending-functions）\"><a href=\"#可中断的方法（suspending-functions）\" class=\"headerlink\" title=\"可中断的方法（suspending functions）\"></a>可中断的方法（suspending functions）</h2></li>\n</ol>\n<p><strong>可中断的方法有能力中断协程的执行</strong>， 当可中断的方法执行完毕后，结者就可以使用它们返回的结果</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> user <span class=\"token operator\">=</span> suspend <span class=\"token punctuation\">{</span> userService<span class=\"token punctuation\">.</span><span class=\"token function\">doLogin</span><span class=\"token punctuation\">(</span>username<span class=\"token punctuation\">,</span> password<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">val</span> currentFriends <span class=\"token operator\">=</span> suspend <span class=\"token punctuation\">{</span> userService<span class=\"token punctuation\">.</span><span class=\"token function\">requestCurrentFriends</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n</code></pre>\n<ul>\n<li>可中断方法可以运行在相同或不同的线程，取决于使用方式*</li>\n<li>可中断的方法只能运行在协程中或其它可中断的方法中</li>\n</ul>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\">suspend <span class=\"token keyword\">fun</span> <span class=\"token function\">suspendingFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Int <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// do long things</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"协程上下文（Coroutine-Context）\"><a href=\"#协程上下文（Coroutine-Context）\" class=\"headerlink\" title=\"协程上下文（Coroutine Context）\"></a>协程上下文（Coroutine Context）</h2><p><em>协程上下文是一系列规则和配置的集合，它决定了协程的运行方式</em>， 其内部结构是一个列表容器</p>\n<h2 id=\"withContext\"><a href=\"#withContext\" class=\"headerlink\" title=\"withContext\"></a>withContext</h2><p><strong>在协程内部</strong>，这个方法可以轻易的改变代码运行时所在的上下文。它是一个可中断的方法，所以调用它会中断协程的执行，直到执行完成。</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\">suspend <span class=\"token keyword\">fun</span> <span class=\"token function\">suspendLogin</span><span class=\"token punctuation\">(</span>username<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span> password<span class=\"token operator\">:</span> String<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>String <span class=\"token operator\">=</span> \n<span class=\"token function\">withContext</span><span class=\"token punctuation\">(</span>Dispatchers<span class=\"token punctuation\">.</span>Main<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    userService<span class=\"token punctuation\">.</span><span class=\"token function\">doLogin</span><span class=\"token punctuation\">(</span>username<span class=\"token punctuation\">,</span> password<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"调度器-dispatcher\"><a href=\"#调度器-dispatcher\" class=\"headerlink\" title=\"调度器(dispatcher)\"></a>调度器(dispatcher)</h3><ul>\n<li><strong>Default</strong>： 未指定 <code>dispathcer</code> 的时候会默认使用。一般用于 CPU 密集型任务，特别是计算。可以使用和 CPU 核数一样多的线程</li>\n<li><strong>IO</strong>：用于输入、输出场景。通常涉及会阻塞线程，需要等待另一个系统响应的任务，比如：网络请求、数据库操作、读写文件。它不使用CPU，可以同一时间运行多个线程，默认数量是 64 的线程池。</li>\n<li><strong>UnConfined</strong>： 如果不在乎启动多少个新城，那么可以使用。它使用的线程是不可控制的，除非你特别清楚你在做什么，否则不建议</li>\n<li><strong>Main</strong>: 这个是 UI 相关的</li>\n</ul>\n<h2 id=\"协程构造器（Coroutine-Builders）\"><a href=\"#协程构造器（Coroutine-Builders）\" class=\"headerlink\" title=\"协程构造器（Coroutine Builders）\"></a>协程构造器（Coroutine Builders）</h2><p>根据实际情况，我们可以选择不同的协程构造器，也可以自己创建</p>\n<h3 id=\"runBlocking\"><a href=\"#runBlocking\" class=\"headerlink\" title=\"runBlocking\"></a>runBlocking</h3><p>这个构造器会阻塞当前线程，直到协程内的所有任务执行完毕。</p>\n<p><code>runBolcking</code> 对于测试可中断的方法非常有用。在测试的时候，将可中断的方法运行在 <code>runBlocking</code> 构建的协程内部，这样可以保证，在这些可中断的方法返回结果前，当前测试线程不会结束。</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">testSuspendedFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> runBlocking <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> res <span class=\"token operator\">=</span> <span class=\"token function\">suspendingTask1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">assertEquals</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>除了这个场景意外，几乎永不到</p>\n<h3 id=\"launch\"><a href=\"#launch\" class=\"headerlink\" title=\"launch\"></a>launch</h3><p>这个构造器狠重要，因为它可以 <strong>很轻易的创建一个协程</strong>，经常使用。</p>\n<p><code>launch</code> 不会阻塞当前线程（前期是我们使用了合适的 <code>dispatcher</code>）</p>\n<p>这个构造器需要一个作用域（<code>scope</code>）</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\">GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span><span class=\"token punctuation\">(</span>Dispatchers<span class=\"token punctuation\">.</span>Main<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">..</span><span class=\"token operator\">..</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><code>launch</code> 方法返回一个 <code>Job</code> ，<code>Job</code>  继承了协程上下文(<code>CoroutineContext</code>)</p>\n<p><code>Job</code> 提供了很多有用的方法，一个 <code>Job</code> 可以有一个父 <code>Job</code>，父 <code>Job</code> 可以控制子 <code>Job</code></p>\n<h4 id=\"job-join\"><a href=\"#job-join\" class=\"headerlink\" title=\"job.join\"></a>job.join</h4><p>这个方法可以中断与当前 <code>Job</code> 关联的协程，直到所有子 <code>Job</code> 执行完成。协程内所有可中断的方法与当前 <code>Job</code> 关联。直到子 <code>Job</code> 全部执行完成，与当前 <code>Job</code> 关联的协程才能继续执行。</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> job <span class=\"token operator\">=</span> GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span><span class=\"token punctuation\">(</span>Dispatchers<span class=\"token punctuation\">.</span>Main<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">doCoroutineTask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">val</span> res1 <span class=\"token operator\">=</span> <span class=\"token function\">suspendingTask1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">val</span> res2 <span class=\"token operator\">=</span> <span class=\"token function\">suspendingTask2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">process</span><span class=\"token punctuation\">(</span>res1<span class=\"token punctuation\">,</span> res2<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\njob<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p><code>job.join()</code> 是一个可中断的方法，所以它应该在协程内部被调用。</p>\n<h4 id=\"job-cancel\"><a href=\"#job-cancel\" class=\"headerlink\" title=\"job.cancel()\"></a>job.cancel()</h4><p>取消所有与其关联的子 <code>Job</code> ，加入 <code>suspendingTask1()</code> 正在执行的时候 <code>Job</code> 调用了取消，这个时候 <code>res1</code> 不会再返回， 而且 <code>suspendingTask2()</code> 也不会再执行</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> job <span class=\"token operator\">=</span> GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span><span class=\"token punctuation\">(</span>Dispatchers<span class=\"token punctuation\">.</span>Main<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">doCoroutineTask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">val</span> res1 <span class=\"token operator\">=</span> <span class=\"token function\">suspendingTask1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">val</span> res2 <span class=\"token operator\">=</span> <span class=\"token function\">suspendingTask2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">process</span><span class=\"token punctuation\">(</span>res1<span class=\"token punctuation\">,</span> res2<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\njob<span class=\"token punctuation\">.</span><span class=\"token function\">cancel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p><code>job.cancel</code> 是一个普通方法，不必运行再协程内部</p>\n<h3 id=\"async\"><a href=\"#async\" class=\"headerlink\" title=\"async\"></a>async</h3><p><code>async</code> <strong>允许并行地运行多个子线程任务</strong>， 它不是一个可中断方法，当调用 <code>async</code> 启动子协程的同事，后面的代码也会立即执行。 <code>async</code> 通常需要运行再另外一个协程内部，它会返回一个特殊的 <code>Job</code> -&gt; <code>Deferred</code></p>\n<h4 id=\"Deferred\"><a href=\"#Deferred\" class=\"headerlink\" title=\"Deferred\"></a>Deferred</h4><p><code>Deferred</code> 有一个 <code>await()</code> 函数，它是一个可终端的方法，当需要获取 <code>async</code> 的结果是，需要调用 <code>await()</code> 方法等待。调用后，会中断当前线程，直到其返回结果</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\">GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span><span class=\"token punctuation\">(</span>Dispatchers<span class=\"token punctuation\">.</span>Main<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> user <span class=\"token operator\">=</span> <span class=\"token function\">withContext</span><span class=\"token punctuation\">(</span>Dispathcers<span class=\"token punctuation\">.</span>IO<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>userService<span class=\"token punctuation\">.</span><span class=\"token function\">doLogin</span><span class=\"token punctuation\">(</span>username<span class=\"token punctuation\">,</span> password<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">val</span> currendFriend <span class=\"token operator\">=</span> <span class=\"token function\">async</span><span class=\"token punctuation\">(</span>Dispatchers<span class=\"token punctuation\">.</span>IO<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>userService<span class=\"token punctuation\">.</span><span class=\"token function\">requestCurrentFriends</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">val</span> suggestedFriends <span class=\"token operator\">=</span> <span class=\"token function\">async</span><span class=\"token punctuation\">(</span>Dispatchers<span class=\"token punctuation\">.</span>IO<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> userService<span class=\"token punctuation\">.</span><span class=\"token function\">requestSuggestedFriends</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">val</span> finalUser <span class=\"token operator\">=</span> user<span class=\"token punctuation\">.</span><span class=\"token function\">copy</span><span class=\"token punctuation\">(</span>friends <span class=\"token operator\">=</span> currenFriends<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> suggestedFriends<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"作用域-Scope\"><a href=\"#作用域-Scope\" class=\"headerlink\" title=\"作用域(Scope)\"></a>作用域(Scope)</h2><h3 id=\"GlobalScope\"><a href=\"#GlobalScope\" class=\"headerlink\" title=\"GlobalScope\"></a>GlobalScope</h3><p>全局的作用域，如果协程的运行周期和 App 的生命周期一样长的滑，创建协程的时候可以使用它。不应该和任何可以销毁的组件绑定使用</p>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\">GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span><span class=\"token punctuation\">(</span>Dispatchers<span class=\"token punctuation\">.</span>Main<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<ul>\n<li>是否伴随 APP 整个生命周期</li>\n<li>没有界面和组件绑定</li>\n</ul>\n<h3 id=\"自定义协程作用域\"><a href=\"#自定义协程作用域\" class=\"headerlink\" title=\"自定义协程作用域\"></a>自定义协程作用域</h3><p>任何类都可以继承 <code>CoroutineScope</code> 作为一个作用域，唯一需要做的事儿就是去重写 <code>coroutineContext</code> 属性</p>\n<p>需要先明白两个概念 <code>dispathcer</code> 和 <code>Job</code></p>\n<ul>\n<li>dispathcer： 用于指定协程默认使用的 dispatcher</li>\n<li>Job: 用在任何需要的时候取消协程</li>\n</ul>\n<pre class=\" language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">class</span> MainActivity<span class=\"token operator\">:</span><span class=\"token function\">AppCompatActivity</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> CoroutineScope <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">val</span> coroutineContext<span class=\"token operator\">:</span> CoroutineContext\n        <span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> Dispatchers<span class=\"token punctuation\">.</span>Main <span class=\"token operator\">+</span> job\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">lateinit</span> <span class=\"token keyword\">var</span> job<span class=\"token operator\">:</span> Job\n<span class=\"token punctuation\">}</span>\n</code></pre>\n","site":{"data":{}},"excerpt":"<h2 id=\"什么是协程\"><a href=\"#什么是协程\" class=\"headerlink\" title=\"什么是协程\"></a>什么是协程</h2><ol>\n<li><strong>轻量级的线程</strong>，并不完全是线程</li>\n<li>可以<strong>顺序的写异步代码</strong>， 降低异步编程带来的负担</li>\n<li><strong>更高效</strong>，<strong>多个协程可以公用一个线程</strong>。一个 APP 可以使用的线程数量是有限的，但可以使用的协程是几乎无限的</li>\n<li><strong>运行在协程中的可中断的方法不会阻塞当前线程</strong>","more":"<h2 id=\"可中断的方法（suspending-functions）\"><a href=\"#可中断的方法（suspending-functions）\" class=\"headerlink\" title=\"可中断的方法（suspending functions）\"></a>可中断的方法（suspending functions）</h2></li>\n</ol>\n<p><strong>可中断的方法有能力中断协程的执行</strong>， 当可中断的方法执行完毕后，结者就可以使用它们返回的结果</p>\n<pre><code class=\"kotlin\">val user = suspend { userService.doLogin(username, password)}\nval currentFriends = suspend { userService.requestCurrentFriends(user) }\n</code></pre>\n<ul>\n<li>可中断方法可以运行在相同或不同的线程，取决于使用方式*</li>\n<li>可中断的方法只能运行在协程中或其它可中断的方法中</li>\n</ul>\n<pre><code class=\"kotlin\">suspend fun suspendingFunction(): Int {\n    // do long things\n    return 0\n}\n</code></pre>\n<h2 id=\"协程上下文（Coroutine-Context）\"><a href=\"#协程上下文（Coroutine-Context）\" class=\"headerlink\" title=\"协程上下文（Coroutine Context）\"></a>协程上下文（Coroutine Context）</h2><p><em>协程上下文是一系列规则和配置的集合，它决定了协程的运行方式</em>， 其内部结构是一个列表容器</p>\n<h2 id=\"withContext\"><a href=\"#withContext\" class=\"headerlink\" title=\"withContext\"></a>withContext</h2><p><strong>在协程内部</strong>，这个方法可以轻易的改变代码运行时所在的上下文。它是一个可中断的方法，所以调用它会中断协程的执行，直到执行完成。</p>\n<pre><code class=\"kotlin\">suspend fun suspendLogin(username: String, password: String):String = \nwithContext(Dispatchers.Main) {\n    userService.doLogin(username, password)\n}\n</code></pre>\n<h3 id=\"调度器-dispatcher\"><a href=\"#调度器-dispatcher\" class=\"headerlink\" title=\"调度器(dispatcher)\"></a>调度器(dispatcher)</h3><ul>\n<li><strong>Default</strong>： 未指定 <code>dispathcer</code> 的时候会默认使用。一般用于 CPU 密集型任务，特别是计算。可以使用和 CPU 核数一样多的线程</li>\n<li><strong>IO</strong>：用于输入、输出场景。通常涉及会阻塞线程，需要等待另一个系统响应的任务，比如：网络请求、数据库操作、读写文件。它不使用CPU，可以同一时间运行多个线程，默认数量是 64 的线程池。</li>\n<li><strong>UnConfined</strong>： 如果不在乎启动多少个新城，那么可以使用。它使用的线程是不可控制的，除非你特别清楚你在做什么，否则不建议</li>\n<li><strong>Main</strong>: 这个是 UI 相关的</li>\n</ul>\n<h2 id=\"协程构造器（Coroutine-Builders）\"><a href=\"#协程构造器（Coroutine-Builders）\" class=\"headerlink\" title=\"协程构造器（Coroutine Builders）\"></a>协程构造器（Coroutine Builders）</h2><p>根据实际情况，我们可以选择不同的协程构造器，也可以自己创建</p>\n<h3 id=\"runBlocking\"><a href=\"#runBlocking\" class=\"headerlink\" title=\"runBlocking\"></a>runBlocking</h3><p>这个构造器会阻塞当前线程，直到协程内的所有任务执行完毕。</p>\n<p><code>runBolcking</code> 对于测试可中断的方法非常有用。在测试的时候，将可中断的方法运行在 <code>runBlocking</code> 构建的协程内部，这样可以保证，在这些可中断的方法返回结果前，当前测试线程不会结束。</p>\n<pre><code class=\"kotlin\">fun testSuspendedFunction() = runBlocking {\n    val res = suspendingTask1()\n    assertEquals(0, res)\n}\n</code></pre>\n<p>除了这个场景意外，几乎永不到</p>\n<h3 id=\"launch\"><a href=\"#launch\" class=\"headerlink\" title=\"launch\"></a>launch</h3><p>这个构造器狠重要，因为它可以 <strong>很轻易的创建一个协程</strong>，经常使用。</p>\n<p><code>launch</code> 不会阻塞当前线程（前期是我们使用了合适的 <code>dispatcher</code>）</p>\n<p>这个构造器需要一个作用域（<code>scope</code>）</p>\n<pre><code class=\"kotlin\">GlobalScope.launch(Dispatchers.Main){\n    ....\n}\n</code></pre>\n<p><code>launch</code> 方法返回一个 <code>Job</code> ，<code>Job</code>  继承了协程上下文(<code>CoroutineContext</code>)</p>\n<p><code>Job</code> 提供了很多有用的方法，一个 <code>Job</code> 可以有一个父 <code>Job</code>，父 <code>Job</code> 可以控制子 <code>Job</code></p>\n<h4 id=\"job-join\"><a href=\"#job-join\" class=\"headerlink\" title=\"job.join\"></a>job.join</h4><p>这个方法可以中断与当前 <code>Job</code> 关联的协程，直到所有子 <code>Job</code> 执行完成。协程内所有可中断的方法与当前 <code>Job</code> 关联。直到子 <code>Job</code> 全部执行完成，与当前 <code>Job</code> 关联的协程才能继续执行。</p>\n<pre><code class=\"kotlin\">val job = GlobalScope.launch(Dispatchers.Main) {\n    doCoroutineTask()\n    val res1 = suspendingTask1()\n    val res2 = suspendingTask2()\n    process(res1, res2)\n}\n\njob.join()\n</code></pre>\n<p><code>job.join()</code> 是一个可中断的方法，所以它应该在协程内部被调用。</p>\n<h4 id=\"job-cancel\"><a href=\"#job-cancel\" class=\"headerlink\" title=\"job.cancel()\"></a>job.cancel()</h4><p>取消所有与其关联的子 <code>Job</code> ，加入 <code>suspendingTask1()</code> 正在执行的时候 <code>Job</code> 调用了取消，这个时候 <code>res1</code> 不会再返回， 而且 <code>suspendingTask2()</code> 也不会再执行</p>\n<pre><code class=\"kotlin\">val job = GlobalScope.launch(Dispatchers.Main) {\n    doCoroutineTask()\n    val res1 = suspendingTask1()\n    val res2 = suspendingTask2()\n    process(res1, res2)\n}\n\njob.cancel()\n</code></pre>\n<p><code>job.cancel</code> 是一个普通方法，不必运行再协程内部</p>\n<h3 id=\"async\"><a href=\"#async\" class=\"headerlink\" title=\"async\"></a>async</h3><p><code>async</code> <strong>允许并行地运行多个子线程任务</strong>， 它不是一个可中断方法，当调用 <code>async</code> 启动子协程的同事，后面的代码也会立即执行。 <code>async</code> 通常需要运行再另外一个协程内部，它会返回一个特殊的 <code>Job</code> -&gt; <code>Deferred</code></p>\n<h4 id=\"Deferred\"><a href=\"#Deferred\" class=\"headerlink\" title=\"Deferred\"></a>Deferred</h4><p><code>Deferred</code> 有一个 <code>await()</code> 函数，它是一个可终端的方法，当需要获取 <code>async</code> 的结果是，需要调用 <code>await()</code> 方法等待。调用后，会中断当前线程，直到其返回结果</p>\n<pre><code class=\"kotlin\">GlobalScope.launch(Dispatchers.Main) {\n    val user = withContext(Dispathcers.IO) {userService.doLogin(username, password)}\n    val currendFriend = async(Dispatchers.IO) {userService.requestCurrentFriends(user) }\n    val suggestedFriends = async(Dispatchers.IO) { userService.requestSuggestedFriends(user)}\n\n    val finalUser = user.copy(friends = currenFriends.await() + suggestedFriends.await())\n}\n</code></pre>\n<h2 id=\"作用域-Scope\"><a href=\"#作用域-Scope\" class=\"headerlink\" title=\"作用域(Scope)\"></a>作用域(Scope)</h2><h3 id=\"GlobalScope\"><a href=\"#GlobalScope\" class=\"headerlink\" title=\"GlobalScope\"></a>GlobalScope</h3><p>全局的作用域，如果协程的运行周期和 App 的生命周期一样长的滑，创建协程的时候可以使用它。不应该和任何可以销毁的组件绑定使用</p>\n<pre><code class=\"kotlin\">GlobalScope.launch(Dispatchers.Main) {\n\n}\n</code></pre>\n<ul>\n<li>是否伴随 APP 整个生命周期</li>\n<li>没有界面和组件绑定</li>\n</ul>\n<h3 id=\"自定义协程作用域\"><a href=\"#自定义协程作用域\" class=\"headerlink\" title=\"自定义协程作用域\"></a>自定义协程作用域</h3><p>任何类都可以继承 <code>CoroutineScope</code> 作为一个作用域，唯一需要做的事儿就是去重写 <code>coroutineContext</code> 属性</p>\n<p>需要先明白两个概念 <code>dispathcer</code> 和 <code>Job</code></p>\n<ul>\n<li>dispathcer： 用于指定协程默认使用的 dispatcher</li>\n<li>Job: 用在任何需要的时候取消协程</li>\n</ul>\n<pre><code class=\"kotlin\">class MainActivity:AppCompatActivity(), CoroutineScope {\n    override val coroutineContext: CoroutineContext\n        get() = Dispatchers.Main + job\n\n    private lateinit var job: Job\n}\n</code></pre>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckkjhb8760002sz5qzefgcfhz","category_id":"ckkjhb87h0006sz5qsto9wm7d","_id":"ckkjhb88g000fsz5qxev3yldw"},{"post_id":"ckkjhb8eq001fsz5qqqckxrwg","category_id":"ckkjhb8et001hsz5qbpeddo4x","_id":"ckkjhb8f8001tsz5qi2949j49"},{"post_id":"ckkjhb8fq002isz5qflofot3x","category_id":"ckkjhb8fw002msz5qz7me836l","_id":"ckkjhb8fz002rsz5qs8bpj8nk"}],"PostTag":[{"post_id":"ckkjhb8760002sz5qzefgcfhz","tag_id":"ckkjhb87j0007sz5qaewgnxoi","_id":"ckkjhb88d000csz5q679limy9"},{"post_id":"ckkjhb87d0004sz5qqrrm8sug","tag_id":"ckkjhb88c000bsz5qtkiingcq","_id":"ckkjhb88l000isz5qsapb64dy"},{"post_id":"ckkjhb87j0008sz5q7mhg41dy","tag_id":"ckkjhb88c000bsz5qtkiingcq","_id":"ckkjhb88p000msz5q29iwihur"},{"post_id":"ckkjhb88d000dsz5qwolvxf2k","tag_id":"ckkjhb88n000ksz5qk6f7ftxx","_id":"ckkjhb88t000qsz5q2g0qkd7z"},{"post_id":"ckkjhb88f000esz5qgij9tkel","tag_id":"ckkjhb88n000ksz5qk6f7ftxx","_id":"ckkjhb88u000ssz5qdpavct1b"},{"post_id":"ckkjhb88k000hsz5qtdw7y9a9","tag_id":"ckkjhb88u000rsz5q4jdg2rf7","_id":"ckkjhb88v000usz5qhu59sqg0"},{"post_id":"ckkjhb88m000jsz5q9dfpqo3r","tag_id":"ckkjhb88v000tsz5qq1l8w06g","_id":"ckkjhb88x000wsz5qdx3m28z4"},{"post_id":"ckkjhb88o000lsz5qlob7jxu4","tag_id":"ckkjhb88v000tsz5qq1l8w06g","_id":"ckkjhb88z000ysz5qc1m56r3e"},{"post_id":"ckkjhb88q000nsz5qsqln0c20","tag_id":"ckkjhb88v000tsz5qq1l8w06g","_id":"ckkjhb890000zsz5qwy9atz1m"},{"post_id":"ckkjhb8e80012sz5qolm14yb6","tag_id":"ckkjhb88c000bsz5qtkiingcq","_id":"ckkjhb8el0017sz5q16e4rm13"},{"post_id":"ckkjhb8ej0015sz5qnd102lof","tag_id":"ckkjhb88c000bsz5qtkiingcq","_id":"ckkjhb8en001asz5qea4w2qdm"},{"post_id":"ckkjhb8e60010sz5qmcy2w9cx","tag_id":"ckkjhb8ej0014sz5q5mlu8kpy","_id":"ckkjhb8eq001esz5q0mf945h8"},{"post_id":"ckkjhb8es001gsz5qbxx4ydsp","tag_id":"ckkjhb8eq001dsz5qqv0ew18w","_id":"ckkjhb8ev001ksz5qgurgf447"},{"post_id":"ckkjhb8el0018sz5qa7fucnxm","tag_id":"ckkjhb8eq001dsz5qqv0ew18w","_id":"ckkjhb8ex001msz5qmzd5dweo"},{"post_id":"ckkjhb8et001isz5q4ubmbre3","tag_id":"ckkjhb8eq001dsz5qqv0ew18w","_id":"ckkjhb8ez001psz5qros5z8jl"},{"post_id":"ckkjhb8ev001lsz5qg1r7o1uu","tag_id":"ckkjhb8eq001dsz5qqv0ew18w","_id":"ckkjhb8f6001rsz5qk9vq1lkc"},{"post_id":"ckkjhb8en001bsz5qij1w0rlw","tag_id":"ckkjhb8eq001dsz5qqv0ew18w","_id":"ckkjhb8f8001usz5qj41aabs8"},{"post_id":"ckkjhb8ey001nsz5qk2q8rde6","tag_id":"ckkjhb8eq001dsz5qqv0ew18w","_id":"ckkjhb8f9001wsz5qc1hf7isn"},{"post_id":"ckkjhb8ez001qsz5q15ozfm8z","tag_id":"ckkjhb88c000bsz5qtkiingcq","_id":"ckkjhb8fb001ysz5qj4jxowtw"},{"post_id":"ckkjhb8eq001fsz5qqqckxrwg","tag_id":"ckkjhb8eq001dsz5qqv0ew18w","_id":"ckkjhb8fd0020sz5qrkplb7ai"},{"post_id":"ckkjhb8f7001ssz5quh6h2vqj","tag_id":"ckkjhb88c000bsz5qtkiingcq","_id":"ckkjhb8ff0023sz5qkbf7xrk3"},{"post_id":"ckkjhb8f8001vsz5qruif60o6","tag_id":"ckkjhb88c000bsz5qtkiingcq","_id":"ckkjhb8fg0025sz5qeo727xn0"},{"post_id":"ckkjhb8fa001xsz5q5dzf05il","tag_id":"ckkjhb88c000bsz5qtkiingcq","_id":"ckkjhb8fi0027sz5qtcdkauac"},{"post_id":"ckkjhb8fh0026sz5qegkae1kr","tag_id":"ckkjhb88c000bsz5qtkiingcq","_id":"ckkjhb8fk002asz5q963f6hj6"},{"post_id":"ckkjhb8fc001zsz5qhpzc15fe","tag_id":"ckkjhb8ff0022sz5q6s63rzf7","_id":"ckkjhb8fl002csz5qo4ozd8zl"},{"post_id":"ckkjhb8fi0028sz5q4peid6fx","tag_id":"ckkjhb88n000ksz5qk6f7ftxx","_id":"ckkjhb8fn002fsz5q1ajipzb0"},{"post_id":"ckkjhb8fe0021sz5q1h8lfa8c","tag_id":"ckkjhb8ff0022sz5q6s63rzf7","_id":"ckkjhb8fq002hsz5qxoifugfh"},{"post_id":"ckkjhb8ff0024sz5qc8hf93rx","tag_id":"ckkjhb8ff0022sz5q6s63rzf7","_id":"ckkjhb8fv002ksz5qhkb2ip1k"},{"post_id":"ckkjhb8fk002bsz5q8p0jykz5","tag_id":"ckkjhb8fv002jsz5qd64j0ys9","_id":"ckkjhb8fx002osz5q92zk3fgz"},{"post_id":"ckkjhb8fm002dsz5q7qyxdbli","tag_id":"ckkjhb8fv002jsz5qd64j0ys9","_id":"ckkjhb8fy002qsz5qnfdeozpf"},{"post_id":"ckkjhb8fn002gsz5q7rmyrisx","tag_id":"ckkjhb8fv002jsz5qd64j0ys9","_id":"ckkjhb8g0002tsz5qf0znmvi3"},{"post_id":"ckkjhb8fq002isz5qflofot3x","tag_id":"ckkjhb8fz002ssz5qg1z9k2za","_id":"ckkjhb8g2002vsz5qwrvob9jy"},{"post_id":"ckkjhb8fv002lsz5qd7965tae","tag_id":"ckkjhb8fz002ssz5qg1z9k2za","_id":"ckkjhb8g3002wsz5quv0k6eef"},{"post_id":"ckkjhb8jm002xsz5qia04mgnq","tag_id":"ckkjhb8ej0014sz5q5mlu8kpy","_id":"ckkjhb8jq002zsz5q9ersaalv"},{"post_id":"ckkjhb8jn002ysz5q53dba459","tag_id":"ckkjhb8ej0014sz5q5mlu8kpy","_id":"ckkjhb8jr0031sz5qi51ki048"},{"post_id":"ckkjhb8jq0030sz5qctj6lpko","tag_id":"ckkjhb8ej0014sz5q5mlu8kpy","_id":"ckkjhb8jz0033sz5qmwojbz0k"},{"post_id":"ckkjhb8js0032sz5qm8o24jqy","tag_id":"ckkjhb8ej0014sz5q5mlu8kpy","_id":"ckkjhb8kg0035sz5ql2bnpq3r"},{"post_id":"ckkjhb8k00034sz5qe8oqtlxu","tag_id":"ckkjhb88c000bsz5qtkiingcq","_id":"ckkjhb8kh0037sz5qqhpm3jnf"},{"post_id":"ckkjhb8kg0036sz5qq6qghm0l","tag_id":"ckkjhb8ki0039sz5q6kid09ac","_id":"ckkjhb8kp003esz5qu5sfrsak"},{"post_id":"ckkjhb8ko003csz5qrzg7v2aq","tag_id":"ckkjhb8eq001dsz5qqv0ew18w","_id":"ckkjhb8kq003gsz5qhkks48ry"},{"post_id":"ckkjhb8kp003fsz5q8pttr0ew","tag_id":"ckkjhb8eq001dsz5qqv0ew18w","_id":"ckkjhb8kw003jsz5qvepp2jz9"},{"post_id":"ckkjhb8kh0038sz5qyric5vxb","tag_id":"ckkjhb8kp003dsz5q6hctrsyq","_id":"ckkjhb8l3003lsz5qx7k28s4m"},{"post_id":"ckkjhb8kq003hsz5qwiuqdc4p","tag_id":"ckkjhb8eq001dsz5qqv0ew18w","_id":"ckkjhb8l4003nsz5qc4f7ejri"},{"post_id":"ckkjhb8kj003asz5qnxf4je0l","tag_id":"ckkjhb8kp003dsz5q6hctrsyq","_id":"ckkjhb8l5003psz5qb1l59443"},{"post_id":"ckkjhb8l3003msz5qi3tccnj9","tag_id":"ckkjhb8eq001dsz5qqv0ew18w","_id":"ckkjhb8l7003ssz5q5e8q7yhk"},{"post_id":"ckkjhb8l9003usz5qluu5u01i","tag_id":"ckkjhb8l6003rsz5qg4g05ul5","_id":"ckkjhb8ld003xsz5qmaadnqp4"},{"post_id":"ckkjhb8l4003osz5q9jump8g2","tag_id":"ckkjhb8l6003rsz5qg4g05ul5","_id":"ckkjhb8lf003zsz5qm12cicgx"},{"post_id":"ckkjhb8lc003vsz5q6ipixond","tag_id":"ckkjhb8l6003rsz5qg4g05ul5","_id":"ckkjhb8lh0042sz5qs25c1a89"},{"post_id":"ckkjhb8l5003qsz5qgovs8qje","tag_id":"ckkjhb8l6003rsz5qg4g05ul5","_id":"ckkjhb8lj0044sz5qcp3e2mds"},{"post_id":"ckkjhb8lf0040sz5quaix5b0p","tag_id":"ckkjhb8l6003rsz5qg4g05ul5","_id":"ckkjhb8ll0047sz5qg6q612q5"},{"post_id":"ckkjhb8l7003tsz5qsk8mkiiv","tag_id":"ckkjhb8l6003rsz5qg4g05ul5","_id":"ckkjhb8ll0048sz5qres49pwk"},{"post_id":"ckkjhb8lj0045sz5qof650p3a","tag_id":"ckkjhb8l6003rsz5qg4g05ul5","_id":"ckkjhb8ll0049sz5q34kqrj4g"},{"post_id":"ckkjhb8ld003ysz5qb8394jhk","tag_id":"ckkjhb8lk0046sz5qpaltmxsx","_id":"ckkjhb8lm004asz5qbbpm0jj5"}],"Tag":[{"name":"Jetpack","_id":"ckkjhb87j0007sz5qaewgnxoi"},{"name":"Android","_id":"ckkjhb88c000bsz5qtkiingcq"},{"name":"Git","_id":"ckkjhb88n000ksz5qk6f7ftxx"},{"name":"Android Things","_id":"ckkjhb88u000rsz5q4jdg2rf7"},{"name":"绿植","_id":"ckkjhb88v000tsz5qq1l8w06g"},{"name":"Android View","_id":"ckkjhb8ej0014sz5q5mlu8kpy"},{"name":"Java","_id":"ckkjhb8eq001dsz5qqv0ew18w"},{"name":"Tools","_id":"ckkjhb8ff0022sz5q6s63rzf7"},{"name":"三方框架","_id":"ckkjhb8fv002jsz5qd64j0ys9"},{"name":"数据结构和算法","_id":"ckkjhb8fz002ssz5qg1z9k2za"},{"name":"Handler","_id":"ckkjhb8ki0039sz5q6kid09ac"},{"name":"Android 适配","_id":"ckkjhb8kp003dsz5q6hctrsyq"},{"name":"Kotlin","_id":"ckkjhb8l6003rsz5qg4g05ul5"},{"name":"设计模式","_id":"ckkjhb8lk0046sz5qpaltmxsx"}]}}