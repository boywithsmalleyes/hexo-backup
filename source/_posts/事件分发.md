# 事件分发


**事件分发的三个方法**

1. dispatchTouchEvent(MotionEvent event) 

    判断当前 View 是否要消费此事件，消费，则不再向下传递，反之传递，以此来分发事件；
2. onInterceptTouchEvent(MotionEvent event) 

    通过 dispatchTouchEvent 调用， 返回值用来判断当前 View 是否要消费事件；
3. onTouchEvent(MotionEvent event) 

    当 View 决定消费事件，则将进行该方法的调用，依据具体的事件，及具体业务，实现不同的事件。

<!--more-->
**关于事件分发的一些结论：**

1. 同一个事件序列是指从手指接触屏幕的那一刻起，到手指离开屏幕的那一刻结束，在这个过程中所产生的一系列事件，这个事件系列以 down 事件开始， 中间含有若干个 move 事件， 最终以 up 事件结束；
2. 正常情况下，一个事件序列只能被一个 View 拦截且消耗。这一套哦的原因可以参考 3， 因为一旦一个元素拦截了某个事件，那么同一个事件序列内的所有事件都会直接交给它处理，因此同一个事件序列中的事件不能分别由两个 View 同时处理，但是通过特殊手段可以做到，比如一个 View 将本该自己处理的事件，通过 onTouchEvent强行传递给其他 View 处理；
3. 某个 View 一旦决定拦截，那么这一个事件序列都只能由它来处理（如果能传递到他的话），并且它的 onInterceptTouchEvent 不会再被调用。
4. 某个 View 一旦开始处理事件，如果它不消耗 ACTION_DOWN 事件（onTouchEvent 返回 false）， 那么同一事件序列中的其他事件都不会再交给它来处理，并且事件将会重新交由它的父元素去处理，即父元素的 onTouchEvent 会被调用，意思就是事件一旦交由一个 View 处理，那么它就必须消耗掉，否则同一事件序列中的剩下的事件就不在交给他来处理了。
5. 如果 View 不消耗除 ACTION_DOWN 以外的其他事件， 那么这个点击事件会消失，此时父元素的 onTouchEvent 并不会被调用，并且当前 View 可以持续受到后续的事件，最终这些消失的点击事件会传递给 Activity 处理。
6. ViewGroup 默认不拦截任何事件，Android 源码中 ViewGroup 的 onInterceptTouchEvent 方法默认返回 false。
7. View 没有 onInterceptTouchEvent 方法，一旦有点击事件传递给他，那么他的 onTouchEvent 方法就会被调用。
8. View 的 onTouchEvent 方法默认会消耗掉事件（返回 true），除非他是不可点击的（clickable 和 longClickable 同时为 false）。View 的 longClickable 属性默认都是 false，clickable 属性要分情况，比如 Button 的 clickable 属性默认是 true，而 TextView 的 clickable 默认未 false。
9. View 的 enable 属性不影响 onTouchEvent 的默认返回值，哪怕一个 View 是 disable 状态，只要他的 clickable 或者 longClickable 有一个为 true， 那么他的 onTouchEvent 就返回true。
10. onClick 会发生的前提是 View 是可点击的，并且它收到了 down 和 up 事件。
11. 事件传递过程是有外向内的，即事件总是先传递给父元素，然后在由父元素分发给子 View，通过 requestDisallowInterceptTouchEvent 方法可以在子元素中干预父元素的事件分发过程，但是 ACTION_DOWN 事件除外（*解决滑动冲突，内部拦截法*）。
12. 事件的传递过程：Activity -> Window(PhoneWindow) -> View -> dispatchTouchEvent -> onInterceptTouchEvent -> onTouchEvent。
13. 当一个 View 需要处理事件时，如果它设置了 onTouchListener，那么 onTouchListener 中的 onTouch 方法会被回调。这时事件如何处理要看 onTouch 的返回值，返回 false，则当前 View 的 onTouchEvent 被调用，true， 则不调用。View 的 onTouchListener 方法优先级高于 onTouchEvent；onClickListener（需要完成有 up 操作） 方法在 onTouchEvent 中被调用，因此，onClickListener 处于事件传递的尾端。

